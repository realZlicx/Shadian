import {
  defu,
  dirname,
  isAbsolute,
  join,
  normalize,
  normalizeWindowsPath,
  relative,
  require_assert,
  require_crypto,
  require_events,
  require_fs,
  require_node_fs,
  require_node_os,
  require_node_stream,
  require_node_util,
  require_path,
  require_process,
  require_promises,
  require_stream,
  require_url,
  require_util,
  require_yallist,
  resolve
} from "./chunk-MFZSQRQ2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DFKQJ226.js";

// browser-external:node:perf_hooks
var require_node_perf_hooks = __commonJS({
  "browser-external:node:perf_hooks"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:perf_hooks" has been externalized for browser compatibility. Cannot access "node:perf_hooks.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/semver/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/semver/node_modules/lru-cache/index.js"(exports2, module3) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value2, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value2, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value2;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value2, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value2);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value2, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff2 = Date.now() - hit.now;
      return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value2, length, now, maxAge) {
        this.key = key;
        this.value = value2;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module3.exports = LRUCache;
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module3) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module3.exports = parseOptions;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module3) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module3.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module3) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module3.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module3) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module3.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value2) => {
      for (const [token, max] of safeRegexReplacements) {
        value2 = value2.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value2;
    };
    var createToken = (name, value2, isGlobal) => {
      const safe = makeSafeRegex(value2);
      const index2 = R++;
      debug(name, index2, value2);
      t[name] = index2;
      src[index2] = value2;
      re[index2] = new RegExp(value2, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module3) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module3.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module3) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m2 = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module3.exports = SemVer;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module3) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module3.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module3) {
    var compare = require_compare();
    var eq2 = (a, b, loose) => compare(a, b, loose) === 0;
    module3.exports = eq2;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module3) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module3.exports = neq;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module3) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module3.exports = gt;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module3) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module3.exports = gte;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module3) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module3.exports = lt;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module3) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module3.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module3) {
    var eq2 = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq2(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module3.exports = cmp;
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module3) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r2 = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m2 = comp.match(r2);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module3.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module3) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module3.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r2 = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r2, (_, M, m2, p, pr) => {
        debug("tilde", comp, _, M, m2, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r2 = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r2, (_, M, m2, p, pr) => {
        debug("caret", comp, _, M, m2, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r2 = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r2, (ret, gtlt, M, m2, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m2, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m2);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p = 0;
            } else {
              m2 = +m2 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m2}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module3) {
    var Range = require_range();
    var satisfies2 = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module3.exports = satisfies2;
  }
});

// browser-external:node:url
var require_node_url = __commonJS({
  "browser-external:node:url"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:url" has been externalized for browser compatibility. Cannot access "node:url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:module
var require_node_module = __commonJS({
  "browser-external:node:module"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:module" has been externalized for browser compatibility. Cannot access "node:module.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:assert
var require_node_assert = __commonJS({
  "browser-external:node:assert"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:assert" has been externalized for browser compatibility. Cannot access "node:assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:process
var require_node_process = __commonJS({
  "browser-external:node:process"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:process" has been externalized for browser compatibility. Cannot access "node:process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:path
var require_node_path = __commonJS({
  "browser-external:node:path"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:path" has been externalized for browser compatibility. Cannot access "node:path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:v8
var require_node_v8 = __commonJS({
  "browser-external:node:v8"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:v8" has been externalized for browser compatibility. Cannot access "node:v8.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:perf_hooks
var require_perf_hooks = __commonJS({
  "browser-external:perf_hooks"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "perf_hooks" has been externalized for browser compatibility. Cannot access "perf_hooks.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:vm
var require_vm = __commonJS({
  "browser-external:vm"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "vm" has been externalized for browser compatibility. Cannot access "vm.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:v8
var require_v8 = __commonJS({
  "browser-external:v8"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "v8" has been externalized for browser compatibility. Cannot access "v8.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jiti/dist/jiti.js
var require_jiti = __commonJS({
  "node_modules/jiti/dist/jiti.js"(exports2, module3) {
    (() => {
      var __webpack_modules__ = { "./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const nativeModule = __webpack_require__2("module"), path3 = __webpack_require__2("path"), fs4 = __webpack_require__2("fs");
        module4.exports = function(filename) {
          return filename || (filename = process.cwd()), function(path4) {
            try {
              return fs4.lstatSync(path4).isDirectory();
            } catch (e) {
              return false;
            }
          }(filename) && (filename = path3.join(filename, "index.js")), nativeModule.createRequire ? nativeModule.createRequire(filename) : nativeModule.createRequireFromPath ? nativeModule.createRequireFromPath(filename) : function(filename2) {
            const mod = new nativeModule.Module(filename2, null);
            return mod.filename = filename2, mod.paths = nativeModule.Module._nodeModulePaths(path3.dirname(filename2)), mod._compile("module.exports = require;", filename2), mod.exports;
          }(filename);
        };
      }, "./node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        const Yallist = __webpack_require__2("./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"), MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1;
        const get = (self2, key, doUse) => {
          const node = self2[CACHE].get(key);
          if (node) {
            const hit = node.value;
            if (isStale(self2, hit)) {
              if (del(self2, node), !self2[ALLOW_STALE])
                return;
            } else
              doUse && (self2[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self2[LRU_LIST].unshiftNode(node));
            return hit.value;
          }
        }, isStale = (self2, hit) => {
          if (!hit || !hit.maxAge && !self2[MAX_AGE])
            return false;
          const diff2 = Date.now() - hit.now;
          return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
        }, trim = (self2) => {
          if (self2[LENGTH] > self2[MAX])
            for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && null !== walker; ) {
              const prev = walker.prev;
              del(self2, walker), walker = prev;
            }
        }, del = (self2, node) => {
          if (node) {
            const hit = node.value;
            self2[DISPOSE] && self2[DISPOSE](hit.key, hit.value), self2[LENGTH] -= hit.length, self2[CACHE].delete(hit.key), self2[LRU_LIST].removeNode(node);
          }
        };
        class Entry {
          constructor(key, value2, length, now, maxAge) {
            this.key = key, this.value = value2, this.length = length, this.now = now, this.maxAge = maxAge || 0;
          }
        }
        const forEachStep = (self2, fn, node, thisp) => {
          let hit = node.value;
          isStale(self2, hit) && (del(self2, node), self2[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self2);
        };
        module4.exports = class {
          constructor(options) {
            if ("number" == typeof options && (options = { max: options }), options || (options = {}), options.max && ("number" != typeof options.max || options.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[MAX] = options.max || 1 / 0;
            const lc = options.length || naiveLength;
            if (this[LENGTH_CALCULATOR] = "function" != typeof lc ? naiveLength : lc, this[ALLOW_STALE] = options.stale || false, options.maxAge && "number" != typeof options.maxAge)
              throw new TypeError("maxAge must be a number");
            this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false, this.reset();
          }
          set max(mL) {
            if ("number" != typeof mL || mL < 0)
              throw new TypeError("max must be a non-negative number");
            this[MAX] = mL || 1 / 0, trim(this);
          }
          get max() {
            return this[MAX];
          }
          set allowStale(allowStale) {
            this[ALLOW_STALE] = !!allowStale;
          }
          get allowStale() {
            return this[ALLOW_STALE];
          }
          set maxAge(mA) {
            if ("number" != typeof mA)
              throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = mA, trim(this);
          }
          get maxAge() {
            return this[MAX_AGE];
          }
          set lengthCalculator(lC) {
            "function" != typeof lC && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
            })), trim(this);
          }
          get lengthCalculator() {
            return this[LENGTH_CALCULATOR];
          }
          get length() {
            return this[LENGTH];
          }
          get itemCount() {
            return this[LRU_LIST].length;
          }
          rforEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].tail; null !== walker; ) {
              const prev = walker.prev;
              forEachStep(this, fn, walker, thisp), walker = prev;
            }
          }
          forEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].head; null !== walker; ) {
              const next = walker.next;
              forEachStep(this, fn, walker, thisp), walker = next;
            }
          }
          keys() {
            return this[LRU_LIST].toArray().map((k) => k.key);
          }
          values() {
            return this[LRU_LIST].toArray().map((k) => k.value);
          }
          reset() {
            this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value)), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
          }
          dump() {
            return this[LRU_LIST].map((hit) => !isStale(this, hit) && { k: hit.key, v: hit.value, e: hit.now + (hit.maxAge || 0) }).toArray().filter((h) => h);
          }
          dumpLru() {
            return this[LRU_LIST];
          }
          set(key, value2, maxAge) {
            if ((maxAge = maxAge || this[MAX_AGE]) && "number" != typeof maxAge)
              throw new TypeError("maxAge must be a number");
            const now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value2, key);
            if (this[CACHE].has(key)) {
              if (len > this[MAX])
                return del(this, this[CACHE].get(key)), false;
              const item = this[CACHE].get(key).value;
              return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value2, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), true;
            }
            const hit = new Entry(key, value2, len, now, maxAge);
            return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value2), false) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), true);
          }
          has(key) {
            if (!this[CACHE].has(key))
              return false;
            const hit = this[CACHE].get(key).value;
            return !isStale(this, hit);
          }
          get(key) {
            return get(this, key, true);
          }
          peek(key) {
            return get(this, key, false);
          }
          pop() {
            const node = this[LRU_LIST].tail;
            return node ? (del(this, node), node.value) : null;
          }
          del(key) {
            del(this, this[CACHE].get(key));
          }
          load(arr) {
            this.reset();
            const now = Date.now();
            for (let l = arr.length - 1; l >= 0; l--) {
              const hit = arr[l], expiresAt = hit.e || 0;
              if (0 === expiresAt)
                this.set(hit.k, hit.v);
              else {
                const maxAge = expiresAt - now;
                maxAge > 0 && this.set(hit.k, hit.v, maxAge);
              }
            }
          }
          prune() {
            this[CACHE].forEach((value2, key) => get(this, key, false));
          }
        };
      }, "./node_modules/.pnpm/mlly@1.4.0/node_modules/mlly/dist lazy recursive": (module4) => {
        function webpackEmptyAsyncContext(req) {
          return Promise.resolve().then(() => {
            var e = new Error("Cannot find module '" + req + "'");
            throw e.code = "MODULE_NOT_FOUND", e;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/.pnpm/mlly@1.4.0/node_modules/mlly/dist lazy recursive", module4.exports = webpackEmptyAsyncContext;
      }, "./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js": (module4, exports3, __webpack_require__2) => {
        "use strict";
        var crypto = __webpack_require__2("crypto");
        function objectHash(object, options) {
          return function(object2, options2) {
            var hashingStream;
            hashingStream = "passthrough" !== options2.algorithm ? crypto.createHash(options2.algorithm) : new PassThrough();
            void 0 === hashingStream.write && (hashingStream.write = hashingStream.update, hashingStream.end = hashingStream.update);
            var hasher = typeHasher(options2, hashingStream);
            hasher.dispatch(object2), hashingStream.update || hashingStream.end("");
            if (hashingStream.digest)
              return hashingStream.digest("buffer" === options2.encoding ? void 0 : options2.encoding);
            var buf = hashingStream.read();
            if ("buffer" === options2.encoding)
              return buf;
            return buf.toString(options2.encoding);
          }(object, options = applyDefaults2(object, options));
        }
        (exports3 = module4.exports = objectHash).sha1 = function(object) {
          return objectHash(object);
        }, exports3.keys = function(object) {
          return objectHash(object, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, exports3.MD5 = function(object) {
          return objectHash(object, { algorithm: "md5", encoding: "hex" });
        }, exports3.keysMD5 = function(object) {
          return objectHash(object, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var hashes = crypto.getHashes ? crypto.getHashes().slice() : ["sha1", "md5"];
        hashes.push("passthrough");
        var encodings = ["buffer", "hex", "binary", "base64"];
        function applyDefaults2(object, sourceOptions) {
          sourceOptions = sourceOptions || {};
          var options = {};
          if (options.algorithm = sourceOptions.algorithm || "sha1", options.encoding = sourceOptions.encoding || "hex", options.excludeValues = !!sourceOptions.excludeValues, options.algorithm = options.algorithm.toLowerCase(), options.encoding = options.encoding.toLowerCase(), options.ignoreUnknown = true === sourceOptions.ignoreUnknown, options.respectType = false !== sourceOptions.respectType, options.respectFunctionNames = false !== sourceOptions.respectFunctionNames, options.respectFunctionProperties = false !== sourceOptions.respectFunctionProperties, options.unorderedArrays = true === sourceOptions.unorderedArrays, options.unorderedSets = false !== sourceOptions.unorderedSets, options.unorderedObjects = false !== sourceOptions.unorderedObjects, options.replacer = sourceOptions.replacer || void 0, options.excludeKeys = sourceOptions.excludeKeys || void 0, void 0 === object)
            throw new Error("Object argument required.");
          for (var i = 0; i < hashes.length; ++i)
            hashes[i].toLowerCase() === options.algorithm.toLowerCase() && (options.algorithm = hashes[i]);
          if (-1 === hashes.indexOf(options.algorithm))
            throw new Error('Algorithm "' + options.algorithm + '"  not supported. supported values: ' + hashes.join(", "));
          if (-1 === encodings.indexOf(options.encoding) && "passthrough" !== options.algorithm)
            throw new Error('Encoding "' + options.encoding + '"  not supported. supported values: ' + encodings.join(", "));
          return options;
        }
        function isNativeFunction(f) {
          if ("function" != typeof f)
            return false;
          return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(f));
        }
        function typeHasher(options, writeTo, context) {
          context = context || [];
          var write = function(str) {
            return writeTo.update ? writeTo.update(str, "utf8") : writeTo.write(str, "utf8");
          };
          return { dispatch: function(value2) {
            options.replacer && (value2 = options.replacer(value2));
            var type = typeof value2;
            return null === value2 && (type = "null"), this["_" + type](value2);
          }, _object: function(object) {
            var objString = Object.prototype.toString.call(object), objType = /\[object (.*)\]/i.exec(objString);
            objType = (objType = objType ? objType[1] : "unknown:[" + objString + "]").toLowerCase();
            var objectNumber;
            if ((objectNumber = context.indexOf(object)) >= 0)
              return this.dispatch("[CIRCULAR:" + objectNumber + "]");
            if (context.push(object), "undefined" != typeof Buffer && Buffer.isBuffer && Buffer.isBuffer(object))
              return write("buffer:"), write(object);
            if ("object" === objType || "function" === objType || "asyncfunction" === objType) {
              var keys2 = Object.keys(object);
              options.unorderedObjects && (keys2 = keys2.sort()), false === options.respectType || isNativeFunction(object) || keys2.splice(0, 0, "prototype", "__proto__", "constructor"), options.excludeKeys && (keys2 = keys2.filter(function(key) {
                return !options.excludeKeys(key);
              })), write("object:" + keys2.length + ":");
              var self2 = this;
              return keys2.forEach(function(key) {
                self2.dispatch(key), write(":"), options.excludeValues || self2.dispatch(object[key]), write(",");
              });
            }
            if (!this["_" + objType]) {
              if (options.ignoreUnknown)
                return write("[" + objType + "]");
              throw new Error('Unknown object type "' + objType + '"');
            }
            this["_" + objType](object);
          }, _array: function(arr, unordered) {
            unordered = void 0 !== unordered ? unordered : false !== options.unorderedArrays;
            var self2 = this;
            if (write("array:" + arr.length + ":"), !unordered || arr.length <= 1)
              return arr.forEach(function(entry) {
                return self2.dispatch(entry);
              });
            var contextAdditions = [], entries = arr.map(function(entry) {
              var strm = new PassThrough(), localContext = context.slice();
              return typeHasher(options, strm, localContext).dispatch(entry), contextAdditions = contextAdditions.concat(localContext.slice(context.length)), strm.read().toString();
            });
            return context = context.concat(contextAdditions), entries.sort(), this._array(entries, false);
          }, _date: function(date) {
            return write("date:" + date.toJSON());
          }, _symbol: function(sym) {
            return write("symbol:" + sym.toString());
          }, _error: function(err) {
            return write("error:" + err.toString());
          }, _boolean: function(bool) {
            return write("bool:" + bool.toString());
          }, _string: function(string) {
            write("string:" + string.length + ":"), write(string.toString());
          }, _function: function(fn) {
            write("fn:"), isNativeFunction(fn) ? this.dispatch("[native]") : this.dispatch(fn.toString()), false !== options.respectFunctionNames && this.dispatch("function-name:" + String(fn.name)), options.respectFunctionProperties && this._object(fn);
          }, _number: function(number) {
            return write("number:" + number.toString());
          }, _xml: function(xml) {
            return write("xml:" + xml.toString());
          }, _null: function() {
            return write("Null");
          }, _undefined: function() {
            return write("Undefined");
          }, _regexp: function(regex) {
            return write("regex:" + regex.toString());
          }, _uint8array: function(arr) {
            return write("uint8array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _uint8clampedarray: function(arr) {
            return write("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _int8array: function(arr) {
            return write("int8array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _uint16array: function(arr) {
            return write("uint16array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _int16array: function(arr) {
            return write("int16array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _uint32array: function(arr) {
            return write("uint32array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _int32array: function(arr) {
            return write("int32array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _float32array: function(arr) {
            return write("float32array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _float64array: function(arr) {
            return write("float64array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _arraybuffer: function(arr) {
            return write("arraybuffer:"), this.dispatch(new Uint8Array(arr));
          }, _url: function(url) {
            return write("url:" + url.toString());
          }, _map: function(map) {
            write("map:");
            var arr = Array.from(map);
            return this._array(arr, false !== options.unorderedSets);
          }, _set: function(set) {
            write("set:");
            var arr = Array.from(set);
            return this._array(arr, false !== options.unorderedSets);
          }, _file: function(file) {
            return write("file:"), this.dispatch([file.name, file.size, file.type, file.lastModfied]);
          }, _blob: function() {
            if (options.ignoreUnknown)
              return write("[blob]");
            throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
          }, _domwindow: function() {
            return write("domwindow");
          }, _bigint: function(number) {
            return write("bigint:" + number.toString());
          }, _process: function() {
            return write("process");
          }, _timer: function() {
            return write("timer");
          }, _pipe: function() {
            return write("pipe");
          }, _tcp: function() {
            return write("tcp");
          }, _udp: function() {
            return write("udp");
          }, _tty: function() {
            return write("tty");
          }, _statwatcher: function() {
            return write("statwatcher");
          }, _securecontext: function() {
            return write("securecontext");
          }, _connection: function() {
            return write("connection");
          }, _zlib: function() {
            return write("zlib");
          }, _context: function() {
            return write("context");
          }, _nodescript: function() {
            return write("nodescript");
          }, _httpparser: function() {
            return write("httpparser");
          }, _dataview: function() {
            return write("dataview");
          }, _signal: function() {
            return write("signal");
          }, _fsevent: function() {
            return write("fsevent");
          }, _tlswrap: function() {
            return write("tlswrap");
          } };
        }
        function PassThrough() {
          return { buf: "", write: function(b) {
            this.buf += b;
          }, end: function(b) {
            this.buf += b;
          }, read: function() {
            return this.buf;
          } };
        }
        exports3.writeToStream = function(object, options, stream) {
          return void 0 === stream && (stream = options, options = {}), typeHasher(options = applyDefaults2(object, options), stream).dispatch(object);
        };
      }, "./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js": (module4, exports3, __webpack_require__2) => {
        "use strict";
        module4 = __webpack_require__2.nmd(module4), Object.defineProperty(exports3, "__esModule", { value: true }), exports3.addHook = function(hook, opts = {}) {
          let reverted = false;
          const loaders = [], oldLoaders = [];
          let exts;
          const originalJSLoader = Module._extensions[".js"], matcher = opts.matcher || null, ignoreNodeModules = false !== opts.ignoreNodeModules;
          exts = opts.extensions || opts.exts || opts.extension || opts.ext || [".js"], Array.isArray(exts) || (exts = [exts]);
          return exts.forEach((ext) => {
            if ("string" != typeof ext)
              throw new TypeError(`Invalid Extension: ${ext}`);
            const oldLoader = Module._extensions[ext] || originalJSLoader;
            oldLoaders[ext] = Module._extensions[ext], loaders[ext] = Module._extensions[ext] = function(mod, filename) {
              let compile;
              reverted || function(filename2, exts2, matcher2, ignoreNodeModules2) {
                if ("string" != typeof filename2)
                  return false;
                if (-1 === exts2.indexOf(_path.default.extname(filename2)))
                  return false;
                const resolvedFilename = _path.default.resolve(filename2);
                if (ignoreNodeModules2 && nodeModulesRegex.test(resolvedFilename))
                  return false;
                if (matcher2 && "function" == typeof matcher2)
                  return !!matcher2(resolvedFilename);
                return true;
              }(filename, exts, matcher, ignoreNodeModules) && (compile = mod._compile, mod._compile = function(code) {
                mod._compile = compile;
                const newCode = hook(code, filename);
                if ("string" != typeof newCode)
                  throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
                return mod._compile(newCode, filename);
              }), oldLoader(mod, filename);
            };
          }), function() {
            reverted || (reverted = true, exts.forEach((ext) => {
              Module._extensions[ext] === loaders[ext] && (oldLoaders[ext] ? Module._extensions[ext] = oldLoaders[ext] : delete Module._extensions[ext]);
            }));
          };
        };
        var _module = _interopRequireDefault(__webpack_require__2("module")), _path = _interopRequireDefault(__webpack_require__2("path"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const nodeModulesRegex = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/, Module = module4.constructor.length > 1 ? module4.constructor : _module.default, HOOK_RETURNED_NOTHING_ERROR_MESSAGE = "[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!\n--------------------\nIf you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.";
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/comparator.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const ANY = Symbol("SemVer ANY");
        class Comparator {
          static get ANY() {
            return ANY;
          }
          constructor(comp, options) {
            if (options = parseOptions(options), comp instanceof Comparator) {
              if (comp.loose === !!options.loose)
                return comp;
              comp = comp.value;
            }
            comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
          }
          parse(comp) {
            const r2 = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m2 = comp.match(r2);
            if (!m2)
              throw new TypeError(`Invalid comparator: ${comp}`);
            this.operator = void 0 !== m2[1] ? m2[1] : "", "=" === this.operator && (this.operator = ""), m2[2] ? this.semver = new SemVer(m2[2], this.options.loose) : this.semver = ANY;
          }
          toString() {
            return this.value;
          }
          test(version2) {
            if (debug("Comparator.test", version2, this.options.loose), this.semver === ANY || version2 === ANY)
              return true;
            if ("string" == typeof version2)
              try {
                version2 = new SemVer(version2, this.options);
              } catch (er) {
                return false;
              }
            return cmp(version2, this.operator, this.semver, this.options);
          }
          intersects(comp, options) {
            if (!(comp instanceof Comparator))
              throw new TypeError("a Comparator is required");
            return "" === this.operator ? "" === this.value || new Range(comp.value, options).test(this.value) : "" === comp.operator ? "" === comp.value || new Range(this.value, options).test(comp.semver) : (!(options = parseOptions(options)).includePrerelease || "<0.0.0-0" !== this.value && "<0.0.0-0" !== comp.value) && (!(!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !comp.operator.startsWith(">")) || (!(!this.operator.startsWith("<") || !comp.operator.startsWith("<")) || (!(this.semver.version !== comp.semver.version || !this.operator.includes("=") || !comp.operator.includes("=")) || (!!(cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) || !!(cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")))))));
          }
        }
        module4.exports = Comparator;
        const parseOptions = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/parse-options.js"), { safeRe: re, t } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/re.js"), cmp = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/cmp.js"), debug = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/debug.js"), SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js");
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        class Range {
          constructor(range, options) {
            if (options = parseOptions(options), range instanceof Range)
              return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
            if (range instanceof Comparator)
              return this.raw = range.value, this.set = [[range]], this.format(), this;
            if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((r2) => this.parseRange(r2)).filter((c) => c.length), !this.set.length)
              throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
              const first = this.set[0];
              if (this.set = this.set.filter((c) => !isNullSet(c[0])), 0 === this.set.length)
                this.set = [first];
              else if (this.set.length > 1) {
                for (const c of this.set)
                  if (1 === c.length && isAny(c[0])) {
                    this.set = [c];
                    break;
                  }
              }
            }
            this.format();
          }
          format() {
            return this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim(), this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(range) {
            const memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range, cached = cache.get(memoKey);
            if (cached)
              return cached;
            const loose = this.options.loose, hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
            range = range.replace(hr, hyphenReplace(this.options.includePrerelease)), debug("hyphen replace", range), range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range), range = range.replace(re[t.TILDETRIM], tildeTrimReplace), debug("tilde trim", range), range = range.replace(re[t.CARETTRIM], caretTrimReplace), debug("caret trim", range);
            let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
            loose && (rangeList = rangeList.filter((comp) => (debug("loose invalid filter", comp, this.options), !!comp.match(re[t.COMPARATORLOOSE])))), debug("range list", rangeList);
            const rangeMap = /* @__PURE__ */ new Map(), comparators = rangeList.map((comp) => new Comparator(comp, this.options));
            for (const comp of comparators) {
              if (isNullSet(comp))
                return [comp];
              rangeMap.set(comp.value, comp);
            }
            rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
            const result = [...rangeMap.values()];
            return cache.set(memoKey, result), result;
          }
          intersects(range, options) {
            if (!(range instanceof Range))
              throw new TypeError("a Range is required");
            return this.set.some((thisComparators) => isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => rangeComparators.every((rangeComparator) => thisComparator.intersects(rangeComparator, options)))));
          }
          test(version2) {
            if (!version2)
              return false;
            if ("string" == typeof version2)
              try {
                version2 = new SemVer(version2, this.options);
              } catch (er) {
                return false;
              }
            for (let i = 0; i < this.set.length; i++)
              if (testSet(this.set[i], version2, this.options))
                return true;
            return false;
          }
        }
        module4.exports = Range;
        const cache = new (__webpack_require__2("./node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"))({ max: 1e3 }), parseOptions = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/parse-options.js"), Comparator = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/comparator.js"), debug = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/debug.js"), SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/re.js"), { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/constants.js"), isNullSet = (c) => "<0.0.0-0" === c.value, isAny = (c) => "" === c.value, isSatisfiable = (comparators, options) => {
          let result = true;
          const remainingComparators = comparators.slice();
          let testComparator = remainingComparators.pop();
          for (; result && remainingComparators.length; )
            result = remainingComparators.every((otherComparator) => testComparator.intersects(otherComparator, options)), testComparator = remainingComparators.pop();
          return result;
        }, parseComparator = (comp, options) => (debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp), isX = (id) => !id || "x" === id.toLowerCase() || "*" === id, replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" "), replaceTilde = (comp, options) => {
          const r2 = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
          return comp.replace(r2, (_, M, m2, p, pr) => {
            let ret;
            return debug("tilde", comp, _, M, m2, p, pr), isX(M) ? ret = "" : isX(m2) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0` : pr ? (debug("replaceTilde pr", pr), ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`) : ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`, debug("tilde return", ret), ret;
          });
        }, replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" "), replaceCaret = (comp, options) => {
          debug("caret", comp, options);
          const r2 = options.loose ? re[t.CARETLOOSE] : re[t.CARET], z = options.includePrerelease ? "-0" : "";
          return comp.replace(r2, (_, M, m2, p, pr) => {
            let ret;
            return debug("caret", comp, _, M, m2, p, pr), isX(M) ? ret = "" : isX(m2) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? ret = "0" === M ? `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0` : `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0` : pr ? (debug("replaceCaret pr", pr), ret = "0" === M ? "0" === m2 ? `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0` : `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0` : `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug("no pr"), ret = "0" === M ? "0" === m2 ? `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0` : `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0` : `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`), debug("caret return", ret), ret;
          });
        }, replaceXRanges = (comp, options) => (debug("replaceXRanges", comp, options), comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ")), replaceXRange = (comp, options) => {
          comp = comp.trim();
          const r2 = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
          return comp.replace(r2, (ret, gtlt, M, m2, p, pr) => {
            debug("xRange", comp, ret, gtlt, M, m2, p, pr);
            const xM = isX(M), xm = xM || isX(m2), xp = xm || isX(p), anyX = xp;
            return "=" === gtlt && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m2 = 0), p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m2 = 0, p = 0) : (m2 = +m2 + 1, p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m2 = +m2 + 1), "<" === gtlt && (pr = "-0"), ret = `${gtlt + M}.${m2}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`), debug("xRange return", ret), ret;
          });
        }, replaceStars = (comp, options) => (debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "")), replaceGTE0 = (comp, options) => (debug("replaceGTE0", comp, options), comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "")), hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => `${from = isX(fM) ? "" : isX(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`} ${to = isX(tM) ? "" : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`}`.trim(), testSet = (set, version2, options) => {
          for (let i = 0; i < set.length; i++)
            if (!set[i].test(version2))
              return false;
          if (version2.prerelease.length && !options.includePrerelease) {
            for (let i = 0; i < set.length; i++)
              if (debug(set[i].semver), set[i].semver !== Comparator.ANY && set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch)
                  return true;
              }
            return false;
          }
          return true;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const debug = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/debug.js"), { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/constants.js"), { safeRe: re, t } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/re.js"), parseOptions = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/parse-options.js"), { compareIdentifiers } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/identifiers.js");
        class SemVer {
          constructor(version2, options) {
            if (options = parseOptions(options), version2 instanceof SemVer) {
              if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease)
                return version2;
              version2 = version2.version;
            } else if ("string" != typeof version2)
              throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
            if (version2.length > MAX_LENGTH)
              throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
            debug("SemVer", version2, options), this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease;
            const m2 = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
            if (!m2)
              throw new TypeError(`Invalid Version: ${version2}`);
            if (this.raw = version2, this.major = +m2[1], this.minor = +m2[2], this.patch = +m2[3], this.major > MAX_SAFE_INTEGER2 || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0)
              throw new TypeError("Invalid patch version");
            m2[4] ? this.prerelease = m2[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER2)
                  return num;
              }
              return id;
            }) : this.prerelease = [], this.build = m2[5] ? m2[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(other) {
            if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer)) {
              if ("string" == typeof other && other === this.version)
                return 0;
              other = new SemVer(other, this.options);
            }
            return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
          }
          compareMain(other) {
            return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
          }
          comparePre(other) {
            if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
              return -1;
            if (!this.prerelease.length && other.prerelease.length)
              return 1;
            if (!this.prerelease.length && !other.prerelease.length)
              return 0;
            let i = 0;
            do {
              const a = this.prerelease[i], b = other.prerelease[i];
              if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b)
                return 0;
              if (void 0 === b)
                return 1;
              if (void 0 === a)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          compareBuild(other) {
            other instanceof SemVer || (other = new SemVer(other, this.options));
            let i = 0;
            do {
              const a = this.build[i], b = other.build[i];
              if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b)
                return 0;
              if (void 0 === b)
                return 1;
              if (void 0 === a)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          inc(release, identifier, identifierBase) {
            switch (release) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier, identifierBase);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier, identifierBase);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
                break;
              case "prerelease":
                0 === this.prerelease.length && this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
                break;
              case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
              case "pre": {
                const base = Number(identifierBase) ? 1 : 0;
                if (!identifier && false === identifierBase)
                  throw new Error("invalid increment argument: identifier is empty");
                if (0 === this.prerelease.length)
                  this.prerelease = [base];
                else {
                  let i = this.prerelease.length;
                  for (; --i >= 0; )
                    "number" == typeof this.prerelease[i] && (this.prerelease[i]++, i = -2);
                  if (-1 === i) {
                    if (identifier === this.prerelease.join(".") && false === identifierBase)
                      throw new Error("invalid increment argument: identifier already exists");
                    this.prerelease.push(base);
                  }
                }
                if (identifier) {
                  let prerelease = [identifier, base];
                  false === identifierBase && (prerelease = [identifier]), 0 === compareIdentifiers(this.prerelease[0], identifier) ? isNaN(this.prerelease[1]) && (this.prerelease = prerelease) : this.prerelease = prerelease;
                }
                break;
              }
              default:
                throw new Error(`invalid increment argument: ${release}`);
            }
            return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
          }
        }
        module4.exports = SemVer;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/clean.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const parse5 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/parse.js");
        module4.exports = (version2, options) => {
          const s = parse5(version2.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/cmp.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const eq2 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/eq.js"), neq = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/neq.js"), gt = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gt.js"), gte = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gte.js"), lt = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lt.js"), lte = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lte.js");
        module4.exports = (a, op, b, loose) => {
          switch (op) {
            case "===":
              return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), a === b;
            case "!==":
              return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), a !== b;
            case "":
            case "=":
            case "==":
              return eq2(a, b, loose);
            case "!=":
              return neq(a, b, loose);
            case ">":
              return gt(a, b, loose);
            case ">=":
              return gte(a, b, loose);
            case "<":
              return lt(a, b, loose);
            case "<=":
              return lte(a, b, loose);
            default:
              throw new TypeError(`Invalid operator: ${op}`);
          }
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/coerce.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), parse5 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/parse.js"), { safeRe: re, t } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/re.js");
        module4.exports = (version2, options) => {
          if (version2 instanceof SemVer)
            return version2;
          if ("number" == typeof version2 && (version2 = String(version2)), "string" != typeof version2)
            return null;
          let match = null;
          if ((options = options || {}).rtl) {
            let next;
            for (; (next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length); )
              match && next.index + next[0].length === match.index + match[0].length || (match = next), re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            re[t.COERCERTL].lastIndex = -1;
          } else
            match = version2.match(re[t.COERCE]);
          return null === match ? null : parse5(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare-build.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js");
        module4.exports = (a, b, loose) => {
          const versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare-loose.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b) => compare(a, b, true);
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js");
        module4.exports = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/diff.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const parse5 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/parse.js");
        module4.exports = (version1, version2) => {
          const v1 = parse5(version1, null, true), v2 = parse5(version2, null, true), comparison = v1.compare(v2);
          if (0 === comparison)
            return null;
          const v1Higher = comparison > 0, highVersion = v1Higher ? v1 : v2, lowVersion = v1Higher ? v2 : v1, highHasPre = !!highVersion.prerelease.length;
          if (!!lowVersion.prerelease.length && !highHasPre)
            return lowVersion.patch || lowVersion.minor ? highVersion.patch ? "patch" : highVersion.minor ? "minor" : "major" : "major";
          const prefix = highHasPre ? "pre" : "";
          return v1.major !== v2.major ? prefix + "major" : v1.minor !== v2.minor ? prefix + "minor" : v1.patch !== v2.patch ? prefix + "patch" : "prerelease";
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/eq.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b, loose) => 0 === compare(a, b, loose);
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gt.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b, loose) => compare(a, b, loose) > 0;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gte.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b, loose) => compare(a, b, loose) >= 0;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/inc.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js");
        module4.exports = (version2, release, options, identifier, identifierBase) => {
          "string" == typeof options && (identifierBase = identifier, identifier = options, options = void 0);
          try {
            return new SemVer(version2 instanceof SemVer ? version2.version : version2, options).inc(release, identifier, identifierBase).version;
          } catch (er) {
            return null;
          }
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lt.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b, loose) => compare(a, b, loose) < 0;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lte.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b, loose) => compare(a, b, loose) <= 0;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/major.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js");
        module4.exports = (a, loose) => new SemVer(a, loose).major;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/minor.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js");
        module4.exports = (a, loose) => new SemVer(a, loose).minor;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/neq.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b, loose) => 0 !== compare(a, b, loose);
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/parse.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js");
        module4.exports = (version2, options, throwErrors = false) => {
          if (version2 instanceof SemVer)
            return version2;
          try {
            return new SemVer(version2, options);
          } catch (er) {
            if (!throwErrors)
              return null;
            throw er;
          }
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/patch.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js");
        module4.exports = (a, loose) => new SemVer(a, loose).patch;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/prerelease.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const parse5 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/parse.js");
        module4.exports = (version2, options) => {
          const parsed = parse5(version2, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/rcompare.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (a, b, loose) => compare(b, a, loose);
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/rsort.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compareBuild = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare-build.js");
        module4.exports = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/satisfies.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js");
        module4.exports = (version2, range, options) => {
          try {
            range = new Range(range, options);
          } catch (er) {
            return false;
          }
          return range.test(version2);
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/sort.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const compareBuild = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare-build.js");
        module4.exports = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/valid.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const parse5 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/parse.js");
        module4.exports = (version2, options) => {
          const v = parse5(version2, options);
          return v ? v.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/index.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const internalRe = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/re.js"), constants = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/constants.js"), SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), identifiers = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/identifiers.js"), parse5 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/parse.js"), valid = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/valid.js"), clean = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/clean.js"), inc = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/inc.js"), diff2 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/diff.js"), major = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/major.js"), minor = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/minor.js"), patch = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/patch.js"), prerelease = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/prerelease.js"), compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js"), rcompare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/rcompare.js"), compareLoose = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare-loose.js"), compareBuild = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare-build.js"), sort = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/sort.js"), rsort = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/rsort.js"), gt = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gt.js"), lt = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lt.js"), eq2 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/eq.js"), neq = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/neq.js"), gte = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gte.js"), lte = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lte.js"), cmp = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/cmp.js"), coerce = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/coerce.js"), Comparator = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/comparator.js"), Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js"), satisfies2 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/satisfies.js"), toComparators = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/to-comparators.js"), maxSatisfying = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/max-satisfying.js"), minSatisfying = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/min-satisfying.js"), minVersion = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/min-version.js"), validRange = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/valid.js"), outside = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/outside.js"), gtr = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/gtr.js"), ltr = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/ltr.js"), intersects = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/intersects.js"), simplifyRange = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/simplify.js"), subset = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/subset.js");
        module4.exports = { parse: parse5, valid, clean, inc, diff: diff2, major, minor, patch, prerelease, compare, rcompare, compareLoose, compareBuild, sort, rsort, gt, lt, eq: eq2, neq, gte, lte, cmp, coerce, Comparator, Range, satisfies: satisfies2, toComparators, maxSatisfying, minSatisfying, minVersion, validRange, outside, gtr, ltr, intersects, simplifyRange, subset, SemVer, re: internalRe.re, src: internalRe.src, tokens: internalRe.t, SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION, RELEASE_TYPES: constants.RELEASE_TYPES, compareIdentifiers: identifiers.compareIdentifiers, rcompareIdentifiers: identifiers.rcompareIdentifiers };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/constants.js": (module4) => {
        const MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
        module4.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/debug.js": (module4) => {
        const debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
        };
        module4.exports = debug;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/identifiers.js": (module4) => {
        const numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
          const anum = numeric.test(a), bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        module4.exports = { compareIdentifiers, rcompareIdentifiers: (a, b) => compareIdentifiers(b, a) };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/parse-options.js": (module4) => {
        const looseOption = Object.freeze({ loose: true }), emptyOpts = Object.freeze({});
        module4.exports = (options) => options ? "object" != typeof options ? looseOption : options : emptyOpts;
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/re.js": (module4, exports3, __webpack_require__2) => {
        const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH } = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/constants.js"), debug = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/internal/debug.js"), re = (exports3 = module4.exports = {}).re = [], safeRe = exports3.safeRe = [], src = exports3.src = [], t = exports3.t = {};
        let R = 0;
        const safeRegexReplacements = [["\\s", 1], ["\\d", MAX_SAFE_COMPONENT_LENGTH], ["[a-zA-Z0-9-]", MAX_SAFE_BUILD_LENGTH]], createToken = (name, value2, isGlobal) => {
          const safe = ((value3) => {
            for (const [token, max] of safeRegexReplacements)
              value3 = value3.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
            return value3;
          })(value2), index2 = R++;
          debug(name, index2, value2), t[name] = index2, src[index2] = value2, re[index2] = new RegExp(value2, isGlobal ? "g" : void 0), safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
        };
        createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "\\d+"), createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", "[a-zA-Z0-9-]+"), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), createToken("COERCERTL", src[t.COERCE], true), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true), exports3.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true), exports3.caretTrimReplace = "$1^", createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true), exports3.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/gtr.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const outside = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/outside.js");
        module4.exports = (version2, range, options) => outside(version2, range, ">", options);
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/intersects.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js");
        module4.exports = (r1, r2, options) => (r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2, options));
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/ltr.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const outside = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/outside.js");
        module4.exports = (version2, range, options) => outside(version2, range, "<", options);
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/max-satisfying.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js");
        module4.exports = (versions, range, options) => {
          let max = null, maxSV = null, rangeObj = null;
          try {
            rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (max = v, maxSV = new SemVer(max, options)));
          }), max;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/min-satisfying.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js");
        module4.exports = (versions, range, options) => {
          let min = null, minSV = null, rangeObj = null;
          try {
            rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (min = v, minSV = new SemVer(min, options)));
          }), min;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/min-version.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js"), gt = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gt.js");
        module4.exports = (range, loose) => {
          range = new Range(range, loose);
          let minver = new SemVer("0.0.0");
          if (range.test(minver))
            return minver;
          if (minver = new SemVer("0.0.0-0"), range.test(minver))
            return minver;
          minver = null;
          for (let i = 0; i < range.set.length; ++i) {
            const comparators = range.set[i];
            let setMin = null;
            comparators.forEach((comparator) => {
              const compver = new SemVer(comparator.semver.version);
              switch (comparator.operator) {
                case ">":
                  0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
                case "":
                case ">=":
                  setMin && !gt(compver, setMin) || (setMin = compver);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${comparator.operator}`);
              }
            }), !setMin || minver && !gt(minver, setMin) || (minver = setMin);
          }
          return minver && range.test(minver) ? minver : null;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/outside.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/semver.js"), Comparator = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/comparator.js"), { ANY } = Comparator, Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js"), satisfies2 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/satisfies.js"), gt = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gt.js"), lt = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lt.js"), lte = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/lte.js"), gte = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/gte.js");
        module4.exports = (version2, range, hilo, options) => {
          let gtfn, ltefn, ltfn, comp, ecomp;
          switch (version2 = new SemVer(version2, options), range = new Range(range, options), hilo) {
            case ">":
              gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
              break;
            case "<":
              gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies2(version2, range, options))
            return false;
          for (let i = 0; i < range.set.length; ++i) {
            const comparators = range.set[i];
            let high = null, low = null;
            if (comparators.forEach((comparator) => {
              comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
            }), high.operator === comp || high.operator === ecomp)
              return false;
            if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver))
              return false;
            if (low.operator === ecomp && ltfn(version2, low.semver))
              return false;
          }
          return true;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/simplify.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const satisfies2 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/satisfies.js"), compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js");
        module4.exports = (versions, range, options) => {
          const set = [];
          let first = null, prev = null;
          const v = versions.sort((a, b) => compare(a, b, options));
          for (const version2 of v) {
            satisfies2(version2, range, options) ? (prev = version2, first || (first = version2)) : (prev && set.push([first, prev]), prev = null, first = null);
          }
          first && set.push([first, null]);
          const ranges = [];
          for (const [min, max] of set)
            min === max ? ranges.push(min) : max || min !== v[0] ? max ? min === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min} - ${max}`) : ranges.push(`>=${min}`) : ranges.push("*");
          const simplified = ranges.join(" || "), original = "string" == typeof range.raw ? range.raw : String(range);
          return simplified.length < original.length ? simplified : range;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/subset.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js"), Comparator = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/comparator.js"), { ANY } = Comparator, satisfies2 = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/satisfies.js"), compare = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/functions/compare.js"), minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")], minimumVersion = [new Comparator(">=0.0.0")], simpleSubset = (sub, dom, options) => {
          if (sub === dom)
            return true;
          if (1 === sub.length && sub[0].semver === ANY) {
            if (1 === dom.length && dom[0].semver === ANY)
              return true;
            sub = options.includePrerelease ? minimumVersionWithPreRelease : minimumVersion;
          }
          if (1 === dom.length && dom[0].semver === ANY) {
            if (options.includePrerelease)
              return true;
            dom = minimumVersion;
          }
          const eqSet = /* @__PURE__ */ new Set();
          let gt, lt, gtltComp, higher, lower, hasDomLT, hasDomGT;
          for (const c of sub)
            ">" === c.operator || ">=" === c.operator ? gt = higherGT(gt, c, options) : "<" === c.operator || "<=" === c.operator ? lt = lowerLT(lt, c, options) : eqSet.add(c.semver);
          if (eqSet.size > 1)
            return null;
          if (gt && lt) {
            if (gtltComp = compare(gt.semver, lt.semver, options), gtltComp > 0)
              return null;
            if (0 === gtltComp && (">=" !== gt.operator || "<=" !== lt.operator))
              return null;
          }
          for (const eq2 of eqSet) {
            if (gt && !satisfies2(eq2, String(gt), options))
              return null;
            if (lt && !satisfies2(eq2, String(lt), options))
              return null;
            for (const c of dom)
              if (!satisfies2(eq2, String(c), options))
                return false;
            return true;
          }
          let needDomLTPre = !(!lt || options.includePrerelease || !lt.semver.prerelease.length) && lt.semver, needDomGTPre = !(!gt || options.includePrerelease || !gt.semver.prerelease.length) && gt.semver;
          needDomLTPre && 1 === needDomLTPre.prerelease.length && "<" === lt.operator && 0 === needDomLTPre.prerelease[0] && (needDomLTPre = false);
          for (const c of dom) {
            if (hasDomGT = hasDomGT || ">" === c.operator || ">=" === c.operator, hasDomLT = hasDomLT || "<" === c.operator || "<=" === c.operator, gt) {
              if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = false), ">" === c.operator || ">=" === c.operator) {
                if (higher = higherGT(gt, c, options), higher === c && higher !== gt)
                  return false;
              } else if (">=" === gt.operator && !satisfies2(gt.semver, String(c), options))
                return false;
            }
            if (lt) {
              if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = false), "<" === c.operator || "<=" === c.operator) {
                if (lower = lowerLT(lt, c, options), lower === c && lower !== lt)
                  return false;
              } else if ("<=" === lt.operator && !satisfies2(lt.semver, String(c), options))
                return false;
            }
            if (!c.operator && (lt || gt) && 0 !== gtltComp)
              return false;
          }
          return !(gt && hasDomLT && !lt && 0 !== gtltComp) && (!(lt && hasDomGT && !gt && 0 !== gtltComp) && (!needDomGTPre && !needDomLTPre));
        }, higherGT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare(a.semver, b.semver, options);
          return comp > 0 ? a : comp < 0 || ">" === b.operator && ">=" === a.operator ? b : a;
        }, lowerLT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare(a.semver, b.semver, options);
          return comp < 0 ? a : comp > 0 || "<" === b.operator && "<=" === a.operator ? b : a;
        };
        module4.exports = (sub, dom, options = {}) => {
          if (sub === dom)
            return true;
          sub = new Range(sub, options), dom = new Range(dom, options);
          let sawNonNull = false;
          OUTER:
            for (const simpleSub of sub.set) {
              for (const simpleDom of dom.set) {
                const isSub = simpleSubset(simpleSub, simpleDom, options);
                if (sawNonNull = sawNonNull || null !== isSub, isSub)
                  continue OUTER;
              }
              if (sawNonNull)
                return false;
            }
          return true;
        };
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/to-comparators.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js");
        module4.exports = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
      }, "./node_modules/.pnpm/semver@7.5.3/node_modules/semver/ranges/valid.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        const Range = __webpack_require__2("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/classes/range.js");
        module4.exports = (range, options) => {
          try {
            return new Range(range, options).range || "*";
          } catch (er) {
            return null;
          }
        };
      }, "./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js": (module4) => {
        "use strict";
        module4.exports = function(Yallist) {
          Yallist.prototype[Symbol.iterator] = function* () {
            for (let walker = this.head; walker; walker = walker.next)
              yield walker.value;
          };
        };
      }, "./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        function Yallist(list) {
          var self2 = this;
          if (self2 instanceof Yallist || (self2 = new Yallist()), self2.tail = null, self2.head = null, self2.length = 0, list && "function" == typeof list.forEach)
            list.forEach(function(item) {
              self2.push(item);
            });
          else if (arguments.length > 0)
            for (var i = 0, l = arguments.length; i < l; i++)
              self2.push(arguments[i]);
          return self2;
        }
        function insert(self2, node, value2) {
          var inserted = node === self2.head ? new Node3(value2, null, node, self2) : new Node3(value2, node, node.next, self2);
          return null === inserted.next && (self2.tail = inserted), null === inserted.prev && (self2.head = inserted), self2.length++, inserted;
        }
        function push(self2, item) {
          self2.tail = new Node3(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
        }
        function unshift(self2, item) {
          self2.head = new Node3(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
        }
        function Node3(value2, prev, next, list) {
          if (!(this instanceof Node3))
            return new Node3(value2, prev, next, list);
          this.list = list, this.value = value2, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
        }
        module4.exports = Yallist, Yallist.Node = Node3, Yallist.create = Yallist, Yallist.prototype.removeNode = function(node) {
          if (node.list !== this)
            throw new Error("removing node which does not belong to this list");
          var next = node.next, prev = node.prev;
          return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
        }, Yallist.prototype.unshiftNode = function(node) {
          if (node !== this.head) {
            node.list && node.list.removeNode(node);
            var head = this.head;
            node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
          }
        }, Yallist.prototype.pushNode = function(node) {
          if (node !== this.tail) {
            node.list && node.list.removeNode(node);
            var tail = this.tail;
            node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
          }
        }, Yallist.prototype.push = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            push(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.unshift = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            unshift(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.pop = function() {
          if (this.tail) {
            var res = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
          }
        }, Yallist.prototype.shift = function() {
          if (this.head) {
            var res = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
          }
        }, Yallist.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.head, i = 0; null !== walker; i++)
            fn.call(thisp, walker.value, i, this), walker = walker.next;
        }, Yallist.prototype.forEachReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.tail, i = this.length - 1; null !== walker; i--)
            fn.call(thisp, walker.value, i, this), walker = walker.prev;
        }, Yallist.prototype.get = function(n) {
          for (var i = 0, walker = this.head; null !== walker && i < n; i++)
            walker = walker.next;
          if (i === n && null !== walker)
            return walker.value;
        }, Yallist.prototype.getReverse = function(n) {
          for (var i = 0, walker = this.tail; null !== walker && i < n; i++)
            walker = walker.prev;
          if (i === n && null !== walker)
            return walker.value;
        }, Yallist.prototype.map = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.head; null !== walker; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
          return res;
        }, Yallist.prototype.mapReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.tail; null !== walker; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
          return res;
        }, Yallist.prototype.reduce = function(fn, initial) {
          var acc, walker = this.head;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.head.next, acc = this.head.value;
          }
          for (var i = 0; null !== walker; i++)
            acc = fn(acc, walker.value, i), walker = walker.next;
          return acc;
        }, Yallist.prototype.reduceReverse = function(fn, initial) {
          var acc, walker = this.tail;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.tail.prev, acc = this.tail.value;
          }
          for (var i = this.length - 1; null !== walker; i--)
            acc = fn(acc, walker.value, i), walker = walker.prev;
          return acc;
        }, Yallist.prototype.toArray = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.head; null !== walker; i++)
            arr[i] = walker.value, walker = walker.next;
          return arr;
        }, Yallist.prototype.toArrayReverse = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.tail; null !== walker; i++)
            arr[i] = walker.value, walker = walker.prev;
          return arr;
        }, Yallist.prototype.slice = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = 0, walker = this.head; null !== walker && i < from; i++)
            walker = walker.next;
          for (; null !== walker && i < to; i++, walker = walker.next)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.sliceReverse = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = this.length, walker = this.tail; null !== walker && i > to; i--)
            walker = walker.prev;
          for (; null !== walker && i > from; i--, walker = walker.prev)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
          start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
          for (var i = 0, walker = this.head; null !== walker && i < start; i++)
            walker = walker.next;
          var ret = [];
          for (i = 0; walker && i < deleteCount; i++)
            ret.push(walker.value), walker = this.removeNode(walker);
          null === walker && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
          for (i = 0; i < nodes.length; i++)
            walker = insert(this, walker, nodes[i]);
          return ret;
        }, Yallist.prototype.reverse = function() {
          for (var head = this.head, tail = this.tail, walker = head; null !== walker; walker = walker.prev) {
            var p = walker.prev;
            walker.prev = walker.next, walker.next = p;
          }
          return this.head = tail, this.tail = head, this;
        };
        try {
          __webpack_require__2("./node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js")(Yallist);
        } catch (er) {
        }
      }, crypto: (module4) => {
        "use strict";
        module4.exports = require_crypto();
      }, fs: (module4) => {
        "use strict";
        module4.exports = require_fs();
      }, module: (module4) => {
        "use strict";
        module4.exports = require_module();
      }, path: (module4) => {
        "use strict";
        module4.exports = require_path();
      } }, __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (void 0 !== cachedModule)
          return cachedModule.exports;
        var module4 = __webpack_module_cache__[moduleId] = { id: moduleId, loaded: false, exports: {} };
        return __webpack_modules__[moduleId](module4, module4.exports, __webpack_require__), module4.loaded = true, module4.exports;
      }
      __webpack_require__.n = (module4) => {
        var getter = module4 && module4.__esModule ? () => module4.default : () => module4;
        return __webpack_require__.d(getter, { a: getter }), getter;
      }, __webpack_require__.d = (exports3, definition) => {
        for (var key in definition)
          __webpack_require__.o(definition, key) && !__webpack_require__.o(exports3, key) && Object.defineProperty(exports3, key, { enumerable: true, get: definition[key] });
      }, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), __webpack_require__.nmd = (module4) => (module4.paths = [], module4.children || (module4.children = []), module4);
      var __webpack_exports__ = {};
      (() => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, { default: () => createJITI });
        var external_fs_ = __webpack_require__("fs"), external_module_ = __webpack_require__("module");
        const external_perf_hooks_namespaceObject = require_perf_hooks(), external_os_namespaceObject = require_os(), external_vm_namespaceObject = require_vm();
        var external_vm_default = __webpack_require__.n(external_vm_namespaceObject);
        const external_url_namespaceObject = require_url();
        function normalizeWindowsPath2(input = "") {
          return input && input.includes("\\") ? input.replace(/\\/g, "/") : input;
        }
        const _UNC_REGEX = /^[/\\]{2}/, _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, _DRIVE_LETTER_RE = /^[A-Za-z]:$/, pathe_92c04245_normalize = function(path3) {
          if (0 === path3.length)
            return ".";
          const isUNCPath = (path3 = normalizeWindowsPath2(path3)).match(_UNC_REGEX), isPathAbsolute = isAbsolute2(path3), trailingSeparator = "/" === path3[path3.length - 1];
          return 0 === (path3 = normalizeString(path3, !isPathAbsolute)).length ? isPathAbsolute ? "/" : trailingSeparator ? "./" : "." : (trailingSeparator && (path3 += "/"), _DRIVE_LETTER_RE.test(path3) && (path3 += "/"), isUNCPath ? isPathAbsolute ? `//${path3}` : `//./${path3}` : isPathAbsolute && !isAbsolute2(path3) ? `/${path3}` : path3);
        }, join2 = function(...arguments_) {
          if (0 === arguments_.length)
            return ".";
          let joined;
          for (const argument of arguments_)
            argument && argument.length > 0 && (void 0 === joined ? joined = argument : joined += `/${argument}`);
          return void 0 === joined ? "." : pathe_92c04245_normalize(joined.replace(/\/\/+/g, "/"));
        };
        function normalizeString(path3, allowAboveRoot) {
          let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, char = null;
          for (let index2 = 0; index2 <= path3.length; ++index2) {
            if (index2 < path3.length)
              char = path3[index2];
            else {
              if ("/" === char)
                break;
              char = "/";
            }
            if ("/" === char) {
              if (lastSlash === index2 - 1 || 1 === dots)
                ;
              else if (2 === dots) {
                if (res.length < 2 || 2 !== lastSegmentLength || "." !== res[res.length - 1] || "." !== res[res.length - 2]) {
                  if (res.length > 2) {
                    const lastSlashIndex = res.lastIndexOf("/");
                    -1 === lastSlashIndex ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = index2, dots = 0;
                    continue;
                  }
                  if (res.length > 0) {
                    res = "", lastSegmentLength = 0, lastSlash = index2, dots = 0;
                    continue;
                  }
                }
                allowAboveRoot && (res += res.length > 0 ? "/.." : "..", lastSegmentLength = 2);
              } else
                res.length > 0 ? res += `/${path3.slice(lastSlash + 1, index2)}` : res = path3.slice(lastSlash + 1, index2), lastSegmentLength = index2 - lastSlash - 1;
              lastSlash = index2, dots = 0;
            } else
              "." === char && -1 !== dots ? ++dots : dots = -1;
          }
          return res;
        }
        const isAbsolute2 = function(p) {
          return _IS_ABSOLUTE_RE.test(p);
        }, _EXTNAME_RE = /.(\.[^./]+)$/, extname3 = function(p) {
          const match = _EXTNAME_RE.exec(normalizeWindowsPath2(p));
          return match && match[1] || "";
        }, pathe_92c04245_dirname = function(p) {
          const segments = normalizeWindowsPath2(p).replace(/\/$/, "").split("/").slice(0, -1);
          return 1 === segments.length && _DRIVE_LETTER_RE.test(segments[0]) && (segments[0] += "/"), segments.join("/") || (isAbsolute2(p) ? "/" : ".");
        }, basename2 = function(p, extension) {
          const lastSegment = normalizeWindowsPath2(p).split("/").pop();
          return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
        }, suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^\s*["[{]|^\s*-?\d[\d.]{0,14}\s*$/;
        function jsonParseTransform(key, value2) {
          if (!("__proto__" === key || "constructor" === key && value2 && "object" == typeof value2 && "prototype" in value2))
            return value2;
          !function(key2) {
            console.warn(`[destr] Dropping "${key2}" key to prevent prototype pollution.`);
          }(key);
        }
        function destr2(value2, options = {}) {
          if ("string" != typeof value2)
            return value2;
          const _value = value2.trim();
          if ('"' === value2[0] && '"' === value2[value2.length - 1])
            return _value.slice(1, -1);
          const _lval = _value.toLowerCase();
          if ("true" === _lval)
            return true;
          if ("false" === _lval)
            return false;
          if ("undefined" !== _lval) {
            if ("null" === _lval)
              return null;
            if ("nan" === _lval)
              return Number.NaN;
            if ("infinity" === _lval)
              return Number.POSITIVE_INFINITY;
            if ("-infinity" === _lval)
              return Number.NEGATIVE_INFINITY;
            if (!JsonSigRx.test(value2)) {
              if (options.strict)
                throw new SyntaxError("[destr] Invalid JSON");
              return value2;
            }
            try {
              if (suspectProtoRx.test(value2) || suspectConstructorRx.test(value2)) {
                if (options.strict)
                  throw new Error("[destr] Possible prototype pollution");
                return JSON.parse(value2, jsonParseTransform);
              }
              return JSON.parse(value2);
            } catch (error) {
              if (options.strict)
                throw error;
              return value2;
            }
          }
        }
        function escapeStringRegexp(string) {
          if ("string" != typeof string)
            throw new TypeError("Expected a string");
          return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var create_require = __webpack_require__("./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js"), create_require_default = __webpack_require__.n(create_require), semver = __webpack_require__("./node_modules/.pnpm/semver@7.5.3/node_modules/semver/index.js");
        const pathSeparators2 = /* @__PURE__ */ new Set(["/", "\\", void 0]), normalizedAliasSymbol2 = Symbol.for("pathe:normalizedAlias");
        function normalizeAliases2(_aliases) {
          if (_aliases[normalizedAliasSymbol2])
            return _aliases;
          const aliases = Object.fromEntries(Object.entries(_aliases).sort(([a], [b]) => function(a2, b2) {
            return b2.split("/").length - a2.split("/").length;
          }(a, b)));
          for (const key in aliases)
            for (const alias in aliases)
              alias === key || key.startsWith(alias) || aliases[key].startsWith(alias) && pathSeparators2.has(aliases[key][alias.length]) && (aliases[key] = aliases[alias] + aliases[key].slice(alias.length));
          return Object.defineProperty(aliases, normalizedAliasSymbol2, { value: true, enumerable: false }), aliases;
        }
        var lib = __webpack_require__("./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js"), object_hash = __webpack_require__("./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js"), object_hash_default = __webpack_require__.n(object_hash), astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], nonASCIIidentifierStartChars2 = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", reservedWords2 = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", keywords$12 = { 5: ecma5AndLessKeywords2, "5module": ecma5AndLessKeywords2 + " export import", 6: ecma5AndLessKeywords2 + " const class extends export import super" }, keywordRelationalOperator2 = /^in(stanceof)?$/, nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]"), nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "-----------------------------------------------------------------------------------------------------------------------------------------------------]");
        function isInAstralSet2(code, set) {
          for (var pos = 65536, i2 = 0; i2 < set.length; i2 += 2) {
            if ((pos += set[i2]) > code)
              return false;
            if ((pos += set[i2 + 1]) >= code)
              return true;
          }
          return false;
        }
        function isIdentifierStart2(code, astral) {
          return code < 65 ? 36 === code : code < 91 || (code < 97 ? 95 === code : code < 123 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code)) : false !== astral && isInAstralSet2(code, astralIdentifierStartCodes2)));
        }
        function isIdentifierChar2(code, astral) {
          return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code < 91 || (code < 97 ? 95 === code : code < 123 || (code <= 65535 ? code >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code)) : false !== astral && (isInAstralSet2(code, astralIdentifierStartCodes2) || isInAstralSet2(code, astralIdentifierCodes2)))));
        }
        var TokenType3 = function(label, conf) {
          void 0 === conf && (conf = {}), this.label = label, this.keyword = conf.keyword, this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.isLoop = !!conf.isLoop, this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, this.postfix = !!conf.postfix, this.binop = conf.binop || null, this.updateContext = null;
        };
        function binop2(name, prec) {
          return new TokenType3(name, { beforeExpr: true, binop: prec });
        }
        var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true }, keywords2 = {};
        function kw2(name, options) {
          return void 0 === options && (options = {}), options.keyword = name, keywords2[name] = new TokenType3(name, options);
        }
        var types$12 = { num: new TokenType3("num", startsExpr2), regexp: new TokenType3("regexp", startsExpr2), string: new TokenType3("string", startsExpr2), name: new TokenType3("name", startsExpr2), privateId: new TokenType3("privateId", startsExpr2), eof: new TokenType3("eof"), bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }), bracketR: new TokenType3("]"), braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }), braceR: new TokenType3("}"), parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }), parenR: new TokenType3(")"), comma: new TokenType3(",", beforeExpr2), semi: new TokenType3(";", beforeExpr2), colon: new TokenType3(":", beforeExpr2), dot: new TokenType3("."), question: new TokenType3("?", beforeExpr2), questionDot: new TokenType3("?."), arrow: new TokenType3("=>", beforeExpr2), template: new TokenType3("template"), invalidTemplate: new TokenType3("invalidTemplate"), ellipsis: new TokenType3("...", beforeExpr2), backQuote: new TokenType3("`", startsExpr2), dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }), eq: new TokenType3("=", { beforeExpr: true, isAssign: true }), assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }), incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: binop2("||", 1), logicalAND: binop2("&&", 2), bitwiseOR: binop2("|", 3), bitwiseXOR: binop2("^", 4), bitwiseAND: binop2("&", 5), equality: binop2("==/!=/===/!==", 6), relational: binop2("</>/<=/>=", 7), bitShift: binop2("<</>>/>>>", 8), plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: binop2("%", 10), star: binop2("*", 10), slash: binop2("/", 10), starstar: new TokenType3("**", { beforeExpr: true }), coalesce: binop2("??", 1), _break: kw2("break"), _case: kw2("case", beforeExpr2), _catch: kw2("catch"), _continue: kw2("continue"), _debugger: kw2("debugger"), _default: kw2("default", beforeExpr2), _do: kw2("do", { isLoop: true, beforeExpr: true }), _else: kw2("else", beforeExpr2), _finally: kw2("finally"), _for: kw2("for", { isLoop: true }), _function: kw2("function", startsExpr2), _if: kw2("if"), _return: kw2("return", beforeExpr2), _switch: kw2("switch"), _throw: kw2("throw", beforeExpr2), _try: kw2("try"), _var: kw2("var"), _const: kw2("const"), _while: kw2("while", { isLoop: true }), _with: kw2("with"), _new: kw2("new", { beforeExpr: true, startsExpr: true }), _this: kw2("this", startsExpr2), _super: kw2("super", startsExpr2), _class: kw2("class", startsExpr2), _extends: kw2("extends", beforeExpr2), _export: kw2("export"), _import: kw2("import", startsExpr2), _null: kw2("null", startsExpr2), _true: kw2("true", startsExpr2), _false: kw2("false", startsExpr2), _in: kw2("in", { beforeExpr: true, binop: 7 }), _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }), _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, lineBreak2 = /\r\n?|\n|\u2028|\u2029/, lineBreakG2 = new RegExp(lineBreak2.source, "g");
        function isNewLine2(code) {
          return 10 === code || 13 === code || 8232 === code || 8233 === code;
        }
        function nextLineBreak2(code, from, end) {
          void 0 === end && (end = code.length);
          for (var i2 = from; i2 < end; i2++) {
            var next = code.charCodeAt(i2);
            if (isNewLine2(next))
              return i2 < end - 1 && 13 === next && 10 === code.charCodeAt(i2 + 1) ? i2 + 2 : i2 + 1;
          }
          return -1;
        }
        var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ref2 = Object.prototype, acorn_hasOwnProperty = ref2.hasOwnProperty, acorn_toString = ref2.toString, hasOwn2 = Object.hasOwn || function(obj, propName) {
          return acorn_hasOwnProperty.call(obj, propName);
        }, isArray3 = Array.isArray || function(obj) {
          return "[object Array]" === acorn_toString.call(obj);
        };
        function wordsRegexp2(words) {
          return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
        }
        function codePointToString2(code) {
          return code <= 65535 ? String.fromCharCode(code) : (code -= 65536, String.fromCharCode(55296 + (code >> 10), 56320 + (1023 & code)));
        }
        var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Position3 = function(line, col) {
          this.line = line, this.column = col;
        };
        Position3.prototype.offset = function(n) {
          return new Position3(this.line, this.column + n);
        };
        var SourceLocation3 = function(p, start, end) {
          this.start = start, this.end = end, null !== p.sourceFile && (this.source = p.sourceFile);
        };
        function getLineInfo2(input, offset2) {
          for (var line = 1, cur = 0; ; ) {
            var nextBreak = nextLineBreak2(input, cur, offset2);
            if (nextBreak < 0)
              return new Position3(line, offset2 - cur);
            ++line, cur = nextBreak;
          }
        }
        var defaultOptions2 = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false }, warnedAboutEcmaVersion2 = false;
        function getOptions2(opts) {
          var options = {};
          for (var opt in defaultOptions2)
            options[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions2[opt];
          if ("latest" === options.ecmaVersion ? options.ecmaVersion = 1e8 : null == options.ecmaVersion ? (!warnedAboutEcmaVersion2 && "object" == typeof console && console.warn && (warnedAboutEcmaVersion2 = true, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), options.ecmaVersion = 11) : options.ecmaVersion >= 2015 && (options.ecmaVersion -= 2009), null == options.allowReserved && (options.allowReserved = options.ecmaVersion < 5), opts && null != opts.allowHashBang || (options.allowHashBang = options.ecmaVersion >= 14), isArray3(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function(token) {
              return tokens.push(token);
            };
          }
          return isArray3(options.onComment) && (options.onComment = function(options2, array) {
            return function(block, text, start, end, startLoc, endLoc) {
              var comment = { type: block ? "Block" : "Line", value: text, start, end };
              options2.locations && (comment.loc = new SourceLocation3(this, startLoc, endLoc)), options2.ranges && (comment.range = [start, end]), array.push(comment);
            };
          }(options, options.onComment)), options;
        }
        function functionFlags2(async, generator) {
          return 2 | (async ? 4 : 0) | (generator ? 8 : 0);
        }
        var Parser3 = function(options, input, startPos) {
          this.options = options = getOptions2(options), this.sourceFile = options.sourceFile, this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : "module" === options.sourceType ? "5module" : 5]);
          var reserved = "";
          true !== options.allowReserved && (reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : 5 === options.ecmaVersion ? 5 : 3], "module" === options.sourceType && (reserved += " await")), this.reservedWords = wordsRegexp2(reserved);
          var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
          this.reservedWordsStrict = wordsRegexp2(reservedStrict), this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind), this.input = String(input), this.containsEsc = false, startPos ? (this.pos = startPos, this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = types$12.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = "module" === options.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), 0 === this.pos && options.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
        }, prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
        Parser3.prototype.parse = function() {
          var node = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(node);
        }, prototypeAccessors2.inFunction.get = function() {
          return (2 & this.currentVarScope().flags) > 0;
        }, prototypeAccessors2.inGenerator.get = function() {
          return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, prototypeAccessors2.inAsync.get = function() {
          return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, prototypeAccessors2.canAwait.get = function() {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
            var scope = this.scopeStack[i2];
            if (scope.inClassFieldInit || 256 & scope.flags)
              return false;
            if (2 & scope.flags)
              return (4 & scope.flags) > 0;
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        }, prototypeAccessors2.allowSuper.get = function() {
          var ref3 = this.currentThisScope(), flags = ref3.flags, inClassFieldInit = ref3.inClassFieldInit;
          return (64 & flags) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
        }, prototypeAccessors2.allowDirectSuper.get = function() {
          return (128 & this.currentThisScope().flags) > 0;
        }, prototypeAccessors2.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }, prototypeAccessors2.allowNewDotTarget.get = function() {
          var ref3 = this.currentThisScope(), flags = ref3.flags, inClassFieldInit = ref3.inClassFieldInit;
          return (258 & flags) > 0 || inClassFieldInit;
        }, prototypeAccessors2.inClassStaticBlock.get = function() {
          return (256 & this.currentVarScope().flags) > 0;
        }, Parser3.extend = function() {
          for (var plugins = [], len = arguments.length; len--; )
            plugins[len] = arguments[len];
          for (var cls = this, i2 = 0; i2 < plugins.length; i2++)
            cls = plugins[i2](cls);
          return cls;
        }, Parser3.parse = function(input, options) {
          return new this(options, input).parse();
        }, Parser3.parseExpressionAt = function(input, pos, options) {
          var parser = new this(options, input, pos);
          return parser.nextToken(), parser.parseExpression();
        }, Parser3.tokenizer = function(input, options) {
          return new this(options, input);
        }, Object.defineProperties(Parser3.prototype, prototypeAccessors2);
        var pp$92 = Parser3.prototype, literal2 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
        pp$92.strictDirective = function(start) {
          if (this.options.ecmaVersion < 5)
            return false;
          for (; ; ) {
            skipWhiteSpace2.lastIndex = start, start += skipWhiteSpace2.exec(this.input)[0].length;
            var match = literal2.exec(this.input.slice(start));
            if (!match)
              return false;
            if ("use strict" === (match[1] || match[2])) {
              skipWhiteSpace2.lastIndex = start + match[0].length;
              var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length, next = this.input.charAt(end);
              return ";" === next || "}" === next || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || "!" === next && "=" === this.input.charAt(end + 1));
            }
            start += match[0].length, skipWhiteSpace2.lastIndex = start, start += skipWhiteSpace2.exec(this.input)[0].length, ";" === this.input[start] && start++;
          }
        }, pp$92.eat = function(type) {
          return this.type === type && (this.next(), true);
        }, pp$92.isContextual = function(name) {
          return this.type === types$12.name && this.value === name && !this.containsEsc;
        }, pp$92.eatContextual = function(name) {
          return !!this.isContextual(name) && (this.next(), true);
        }, pp$92.expectContextual = function(name) {
          this.eatContextual(name) || this.unexpected();
        }, pp$92.canInsertSemicolon = function() {
          return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        }, pp$92.insertSemicolon = function() {
          if (this.canInsertSemicolon())
            return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
        }, pp$92.semicolon = function() {
          this.eat(types$12.semi) || this.insertSemicolon() || this.unexpected();
        }, pp$92.afterTrailingComma = function(tokType, notNext) {
          if (this.type === tokType)
            return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), notNext || this.next(), true;
        }, pp$92.expect = function(type) {
          this.eat(type) || this.unexpected();
        }, pp$92.unexpected = function(pos) {
          this.raise(null != pos ? pos : this.start, "Unexpected token");
        };
        var DestructuringErrors3 = function() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
          if (refDestructuringErrors) {
            refDestructuringErrors.trailingComma > -1 && this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
            var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
            parens > -1 && this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        }, pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
          if (!refDestructuringErrors)
            return false;
          var shorthandAssign = refDestructuringErrors.shorthandAssign, doubleProto = refDestructuringErrors.doubleProto;
          if (!andThrow)
            return shorthandAssign >= 0 || doubleProto >= 0;
          shorthandAssign >= 0 && this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"), doubleProto >= 0 && this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }, pp$92.checkYieldAwaitInDefaultParams = function() {
          this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
        }, pp$92.isSimpleAssignTarget = function(expr) {
          return "ParenthesizedExpression" === expr.type ? this.isSimpleAssignTarget(expr.expression) : "Identifier" === expr.type || "MemberExpression" === expr.type;
        };
        var pp$82 = Parser3.prototype;
        pp$82.parseTopLevel = function(node) {
          var exports3 = /* @__PURE__ */ Object.create(null);
          for (node.body || (node.body = []); this.type !== types$12.eof; ) {
            var stmt = this.parseStatement(null, true, exports3);
            node.body.push(stmt);
          }
          if (this.inModule)
            for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
              var name = list2[i2];
              this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
            }
          return this.adaptDirectivePrologue(node.body), this.next(), node.sourceType = this.options.sourceType, this.finishNode(node, "Program");
        };
        var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
        pp$82.isLet = function(context) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
            return false;
          skipWhiteSpace2.lastIndex = this.pos;
          var skip = skipWhiteSpace2.exec(this.input), next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (91 === nextCh || 92 === nextCh)
            return true;
          if (context)
            return false;
          if (123 === nextCh || nextCh > 55295 && nextCh < 56320)
            return true;
          if (isIdentifierStart2(nextCh, true)) {
            for (var pos = next + 1; isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true); )
              ++pos;
            if (92 === nextCh || nextCh > 55295 && nextCh < 56320)
              return true;
            var ident = this.input.slice(next, pos);
            if (!keywordRelationalOperator2.test(ident))
              return true;
          }
          return false;
        }, pp$82.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
            return false;
          skipWhiteSpace2.lastIndex = this.pos;
          var after, skip = skipWhiteSpace2.exec(this.input), next = this.pos + skip[0].length;
          return !(lineBreak2.test(this.input.slice(this.pos, next)) || "function" !== this.input.slice(next, next + 8) || next + 8 !== this.input.length && (isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
        }, pp$82.parseStatement = function(context, topLevel, exports3) {
          var kind, starttype = this.type, node = this.startNode();
          switch (this.isLet(context) && (starttype = types$12._var, kind = "let"), starttype) {
            case types$12._break:
            case types$12._continue:
              return this.parseBreakContinueStatement(node, starttype.keyword);
            case types$12._debugger:
              return this.parseDebuggerStatement(node);
            case types$12._do:
              return this.parseDoStatement(node);
            case types$12._for:
              return this.parseForStatement(node);
            case types$12._function:
              return context && (this.strict || "if" !== context && "label" !== context) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(node, false, !context);
            case types$12._class:
              return context && this.unexpected(), this.parseClass(node, true);
            case types$12._if:
              return this.parseIfStatement(node);
            case types$12._return:
              return this.parseReturnStatement(node);
            case types$12._switch:
              return this.parseSwitchStatement(node);
            case types$12._throw:
              return this.parseThrowStatement(node);
            case types$12._try:
              return this.parseTryStatement(node);
            case types$12._const:
            case types$12._var:
              return kind = kind || this.value, context && "var" !== kind && this.unexpected(), this.parseVarStatement(node, kind);
            case types$12._while:
              return this.parseWhileStatement(node);
            case types$12._with:
              return this.parseWithStatement(node);
            case types$12.braceL:
              return this.parseBlock(true, node);
            case types$12.semi:
              return this.parseEmptyStatement(node);
            case types$12._export:
            case types$12._import:
              if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
                skipWhiteSpace2.lastIndex = this.pos;
                var skip = skipWhiteSpace2.exec(this.input), next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                if (40 === nextCh || 46 === nextCh)
                  return this.parseExpressionStatement(node, this.parseExpression());
              }
              return this.options.allowImportExportEverywhere || (topLevel || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), starttype === types$12._import ? this.parseImport(node) : this.parseExport(node, exports3);
            default:
              if (this.isAsyncFunction())
                return context && this.unexpected(), this.next(), this.parseFunctionStatement(node, true, !context);
              var maybeName = this.value, expr = this.parseExpression();
              return starttype === types$12.name && "Identifier" === expr.type && this.eat(types$12.colon) ? this.parseLabeledStatement(node, maybeName, expr, context) : this.parseExpressionStatement(node, expr);
          }
        }, pp$82.parseBreakContinueStatement = function(node, keyword) {
          var isBreak = "break" === keyword;
          this.next(), this.eat(types$12.semi) || this.insertSemicolon() ? node.label = null : this.type !== types$12.name ? this.unexpected() : (node.label = this.parseIdent(), this.semicolon());
          for (var i2 = 0; i2 < this.labels.length; ++i2) {
            var lab = this.labels[i2];
            if (null == node.label || lab.name === node.label.name) {
              if (null != lab.kind && (isBreak || "loop" === lab.kind))
                break;
              if (node.label && isBreak)
                break;
            }
          }
          return i2 === this.labels.length && this.raise(node.start, "Unsyntactic " + keyword), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        }, pp$82.parseDebuggerStatement = function(node) {
          return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
        }, pp$82.parseDoStatement = function(node) {
          return this.next(), this.labels.push(loopLabel2), node.body = this.parseStatement("do"), this.labels.pop(), this.expect(types$12._while), node.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(types$12.semi) : this.semicolon(), this.finishNode(node, "DoWhileStatement");
        }, pp$82.parseForStatement = function(node) {
          this.next();
          var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          if (this.labels.push(loopLabel2), this.enterScope(0), this.expect(types$12.parenL), this.type === types$12.semi)
            return awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, null);
          var isLet = this.isLet();
          if (this.type === types$12._var || this.type === types$12._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
            return this.next(), this.parseVar(init$1, true, kind), this.finishNode(init$1, "VariableDeclaration"), (this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === init$1.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === types$12._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), this.parseForIn(node, init$1)) : (awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init$1));
          }
          var startsWithLet = this.isContextual("let"), isForOf = false, refDestructuringErrors = new DestructuringErrors3(), init = this.parseExpression(!(awaitAt > -1) || "await", refDestructuringErrors);
          return this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === types$12._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), startsWithLet && isForOf && this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(init, false, refDestructuringErrors), this.checkLValPattern(init), this.parseForIn(node, init)) : (this.checkExpressionErrors(refDestructuringErrors, true), awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init));
        }, pp$82.parseFunctionStatement = function(node, isAsync, declarationPosition) {
          return this.next(), this.parseFunction(node, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
        }, pp$82.parseIfStatement = function(node) {
          return this.next(), node.test = this.parseParenExpression(), node.consequent = this.parseStatement("if"), node.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null, this.finishNode(node, "IfStatement");
        }, pp$82.parseReturnStatement = function(node) {
          return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(types$12.semi) || this.insertSemicolon() ? node.argument = null : (node.argument = this.parseExpression(), this.semicolon()), this.finishNode(node, "ReturnStatement");
        }, pp$82.parseSwitchStatement = function(node) {
          var cur;
          this.next(), node.discriminant = this.parseParenExpression(), node.cases = [], this.expect(types$12.braceL), this.labels.push(switchLabel2), this.enterScope(0);
          for (var sawDefault = false; this.type !== types$12.braceR; )
            if (this.type === types$12._case || this.type === types$12._default) {
              var isCase = this.type === types$12._case;
              cur && this.finishNode(cur, "SwitchCase"), node.cases.push(cur = this.startNode()), cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), sawDefault = true, cur.test = null), this.expect(types$12.colon);
            } else
              cur || this.unexpected(), cur.consequent.push(this.parseStatement(null));
          return this.exitScope(), cur && this.finishNode(cur, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(node, "SwitchStatement");
        }, pp$82.parseThrowStatement = function(node) {
          return this.next(), lineBreak2.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
        };
        var empty$12 = [];
        pp$82.parseCatchClauseParam = function() {
          var param = this.parseBindingAtom(), simple = "Identifier" === param.type;
          return this.enterScope(simple ? 32 : 0), this.checkLValPattern(param, simple ? 4 : 2), this.expect(types$12.parenR), param;
        }, pp$82.parseTryStatement = function(node) {
          if (this.next(), node.block = this.parseBlock(), node.handler = null, this.type === types$12._catch) {
            var clause = this.startNode();
            this.next(), this.eat(types$12.parenL) ? clause.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), clause.param = null, this.enterScope(0)), clause.body = this.parseBlock(false), this.exitScope(), node.handler = this.finishNode(clause, "CatchClause");
          }
          return node.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null, node.handler || node.finalizer || this.raise(node.start, "Missing catch or finally clause"), this.finishNode(node, "TryStatement");
        }, pp$82.parseVarStatement = function(node, kind, allowMissingInitializer) {
          return this.next(), this.parseVar(node, false, kind, allowMissingInitializer), this.semicolon(), this.finishNode(node, "VariableDeclaration");
        }, pp$82.parseWhileStatement = function(node) {
          return this.next(), node.test = this.parseParenExpression(), this.labels.push(loopLabel2), node.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(node, "WhileStatement");
        }, pp$82.parseWithStatement = function(node) {
          return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), node.object = this.parseParenExpression(), node.body = this.parseStatement("with"), this.finishNode(node, "WithStatement");
        }, pp$82.parseEmptyStatement = function(node) {
          return this.next(), this.finishNode(node, "EmptyStatement");
        }, pp$82.parseLabeledStatement = function(node, maybeName, expr, context) {
          for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
            list2[i$1].name === maybeName && this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
          for (var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null, i2 = this.labels.length - 1; i2 >= 0; i2--) {
            var label$1 = this.labels[i2];
            if (label$1.statementStart !== node.start)
              break;
            label$1.statementStart = this.start, label$1.kind = kind;
          }
          return this.labels.push({ name: maybeName, kind, statementStart: this.start }), node.body = this.parseStatement(context ? -1 === context.indexOf("label") ? context + "label" : context : "label"), this.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
        }, pp$82.parseExpressionStatement = function(node, expr) {
          return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
        }, pp$82.parseBlock = function(createNewLexicalScope, node, exitStrict) {
          for (void 0 === createNewLexicalScope && (createNewLexicalScope = true), void 0 === node && (node = this.startNode()), node.body = [], this.expect(types$12.braceL), createNewLexicalScope && this.enterScope(0); this.type !== types$12.braceR; ) {
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
          }
          return exitStrict && (this.strict = false), this.next(), createNewLexicalScope && this.exitScope(), this.finishNode(node, "BlockStatement");
        }, pp$82.parseFor = function(node, init) {
          return node.init = init, this.expect(types$12.semi), node.test = this.type === types$12.semi ? null : this.parseExpression(), this.expect(types$12.semi), node.update = this.type === types$12.parenR ? null : this.parseExpression(), this.expect(types$12.parenR), node.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(node, "ForStatement");
        }, pp$82.parseForIn = function(node, init) {
          var isForIn = this.type === types$12._in;
          return this.next(), "VariableDeclaration" === init.type && null != init.declarations[0].init && (!isForIn || this.options.ecmaVersion < 8 || this.strict || "var" !== init.kind || "Identifier" !== init.declarations[0].id.type) && this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign(), this.expect(types$12.parenR), node.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        }, pp$82.parseVar = function(node, isFor, kind, allowMissingInitializer) {
          for (node.declarations = [], node.kind = kind; ; ) {
            var decl = this.startNode();
            if (this.parseVarId(decl, kind), this.eat(types$12.eq) ? decl.init = this.parseMaybeAssign(isFor) : allowMissingInitializer || "const" !== kind || this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? allowMissingInitializer || "Identifier" === decl.id.type || isFor && (this.type === types$12._in || this.isContextual("of")) ? decl.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), node.declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(types$12.comma))
              break;
          }
          return node;
        }, pp$82.parseVarId = function(decl, kind) {
          decl.id = this.parseBindingAtom(), this.checkLValPattern(decl.id, "var" === kind ? 1 : 2, false);
        };
        var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2;
        function isPrivateNameConflicted2(privateNameMap, element) {
          var name = element.key.name, curr = privateNameMap[name], next = "true";
          return "MethodDefinition" !== element.type || "get" !== element.kind && "set" !== element.kind || (next = (element.static ? "s" : "i") + element.kind), "iget" === curr && "iset" === next || "iset" === curr && "iget" === next || "sget" === curr && "sset" === next || "sset" === curr && "sget" === next ? (privateNameMap[name] = "true", false) : !!curr || (privateNameMap[name] = next, false);
        }
        function checkKeyName2(node, name) {
          var computed = node.computed, key = node.key;
          return !computed && ("Identifier" === key.type && key.name === name || "Literal" === key.type && key.value === name);
        }
        pp$82.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
          this.initFunction(node), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) && (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2 && this.unexpected(), node.generator = this.eat(types$12.star)), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), statement & FUNC_STATEMENT2 && (node.id = 4 & statement && this.type !== types$12.name ? null : this.parseIdent(), !node.id || statement & FUNC_HANGING_STATEMENT2 || this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags2(node.async, node.generator)), statement & FUNC_STATEMENT2 || (node.id = this.type === types$12.name ? this.parseIdent() : null), this.parseFunctionParams(node), this.parseFunctionBody(node, allowExpressionBody, false, forInit), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.finishNode(node, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
        }, pp$82.parseFunctionParams = function(node) {
          this.expect(types$12.parenL), node.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
        }, pp$82.parseClass = function(node, isStatement) {
          this.next();
          var oldStrict = this.strict;
          this.strict = true, this.parseClassId(node, isStatement), this.parseClassSuper(node);
          var privateNameMap = this.enterClassBody(), classBody = this.startNode(), hadConstructor = false;
          for (classBody.body = [], this.expect(types$12.braceL); this.type !== types$12.braceR; ) {
            var element = this.parseClassElement(null !== node.superClass);
            element && (classBody.body.push(element), "MethodDefinition" === element.type && "constructor" === element.kind ? (hadConstructor && this.raiseRecoverable(element.start, "Duplicate constructor in the same class"), hadConstructor = true) : element.key && "PrivateIdentifier" === element.key.type && isPrivateNameConflicted2(privateNameMap, element) && this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared"));
          }
          return this.strict = oldStrict, this.next(), node.body = this.finishNode(classBody, "ClassBody"), this.exitClassBody(), this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        }, pp$82.parseClassElement = function(constructorAllowsSuper) {
          if (this.eat(types$12.semi))
            return null;
          var ecmaVersion = this.options.ecmaVersion, node = this.startNode(), keyName = "", isGenerator = false, isAsync = false, kind = "method", isStatic = false;
          if (this.eatContextual("static")) {
            if (ecmaVersion >= 13 && this.eat(types$12.braceL))
              return this.parseClassStaticBlock(node), node;
            this.isClassElementNameStart() || this.type === types$12.star ? isStatic = true : keyName = "static";
          }
          if (node.static = isStatic, !keyName && ecmaVersion >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== types$12.star || this.canInsertSemicolon() ? keyName = "async" : isAsync = true), !keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$12.star) && (isGenerator = true), !keyName && !isAsync && !isGenerator) {
            var lastValue = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? kind = lastValue : keyName = lastValue);
          }
          if (keyName ? (node.computed = false, node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), node.key.name = keyName, this.finishNode(node.key, "Identifier")) : this.parseClassElementName(node), ecmaVersion < 13 || this.type === types$12.parenL || "method" !== kind || isGenerator || isAsync) {
            var isConstructor = !node.static && checkKeyName2(node, "constructor"), allowsDirectSuper = isConstructor && constructorAllowsSuper;
            isConstructor && "method" !== kind && this.raise(node.key.start, "Constructor can't have get/set modifier"), node.kind = isConstructor ? "constructor" : kind, this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
          } else
            this.parseClassField(node);
          return node;
        }, pp$82.isClassElementNameStart = function() {
          return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
        }, pp$82.parseClassElementName = function(element) {
          this.type === types$12.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), element.computed = false, element.key = this.parsePrivateIdent()) : this.parsePropertyName(element);
        }, pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
          var key = method.key;
          "constructor" === method.kind ? (isGenerator && this.raise(key.start, "Constructor can't be a generator"), isAsync && this.raise(key.start, "Constructor can't be an async method")) : method.static && checkKeyName2(method, "prototype") && this.raise(key.start, "Classes may not have a static property named prototype");
          var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
          return "get" === method.kind && 0 !== value2.params.length && this.raiseRecoverable(value2.start, "getter should have no params"), "set" === method.kind && 1 !== value2.params.length && this.raiseRecoverable(value2.start, "setter should have exactly one param"), "set" === method.kind && "RestElement" === value2.params[0].type && this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params"), this.finishNode(method, "MethodDefinition");
        }, pp$82.parseClassField = function(field) {
          if (checkKeyName2(field, "constructor") ? this.raise(field.key.start, "Classes can't have a field named 'constructor'") : field.static && checkKeyName2(field, "prototype") && this.raise(field.key.start, "Classes can't have a static field named 'prototype'"), this.eat(types$12.eq)) {
            var scope = this.currentThisScope(), inClassFieldInit = scope.inClassFieldInit;
            scope.inClassFieldInit = true, field.value = this.parseMaybeAssign(), scope.inClassFieldInit = inClassFieldInit;
          } else
            field.value = null;
          return this.semicolon(), this.finishNode(field, "PropertyDefinition");
        }, pp$82.parseClassStaticBlock = function(node) {
          node.body = [];
          var oldLabels = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== types$12.braceR; ) {
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
          }
          return this.next(), this.exitScope(), this.labels = oldLabels, this.finishNode(node, "StaticBlock");
        }, pp$82.parseClassId = function(node, isStatement) {
          this.type === types$12.name ? (node.id = this.parseIdent(), isStatement && this.checkLValSimple(node.id, 2, false)) : (true === isStatement && this.unexpected(), node.id = null);
        }, pp$82.parseClassSuper = function(node) {
          node.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
        }, pp$82.enterClassBody = function() {
          var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          return this.privateNameStack.push(element), element.declared;
        }, pp$82.exitClassBody = function() {
          for (var ref3 = this.privateNameStack.pop(), declared = ref3.declared, used = ref3.used, len = this.privateNameStack.length, parent = 0 === len ? null : this.privateNameStack[len - 1], i2 = 0; i2 < used.length; ++i2) {
            var id = used[i2];
            hasOwn2(declared, id.name) || (parent ? parent.used.push(id) : this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class"));
          }
        }, pp$82.parseExportAllDeclaration = function(node, exports3) {
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (node.exported = this.parseModuleExportName(), this.checkExport(exports3, node.exported, this.lastTokStart)) : node.exported = null), this.expectContextual("from"), this.type !== types$12.string && this.unexpected(), node.source = this.parseExprAtom(), this.semicolon(), this.finishNode(node, "ExportAllDeclaration");
        }, pp$82.parseExport = function(node, exports3) {
          if (this.next(), this.eat(types$12.star))
            return this.parseExportAllDeclaration(node, exports3);
          if (this.eat(types$12._default))
            return this.checkExport(exports3, "default", this.lastTokStart), node.declaration = this.parseExportDefaultDeclaration(), this.finishNode(node, "ExportDefaultDeclaration");
          if (this.shouldParseExportStatement())
            node.declaration = this.parseExportDeclaration(node), "VariableDeclaration" === node.declaration.type ? this.checkVariableExport(exports3, node.declaration.declarations) : this.checkExport(exports3, node.declaration.id, node.declaration.id.start), node.specifiers = [], node.source = null;
          else {
            if (node.declaration = null, node.specifiers = this.parseExportSpecifiers(exports3), this.eatContextual("from"))
              this.type !== types$12.string && this.unexpected(), node.source = this.parseExprAtom();
            else {
              for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
                var spec = list2[i2];
                this.checkUnreserved(spec.local), this.checkLocalExport(spec.local), "Literal" === spec.local.type && this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        }, pp$82.parseExportDeclaration = function(node) {
          return this.parseStatement(null);
        }, pp$82.parseExportDefaultDeclaration = function() {
          var isAsync;
          if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            return this.next(), isAsync && this.next(), this.parseFunction(fNode, 4 | FUNC_STATEMENT2, false, isAsync);
          }
          if (this.type === types$12._class) {
            var cNode = this.startNode();
            return this.parseClass(cNode, "nullableID");
          }
          var declaration = this.parseMaybeAssign();
          return this.semicolon(), declaration;
        }, pp$82.checkExport = function(exports3, name, pos) {
          exports3 && ("string" != typeof name && (name = "Identifier" === name.type ? name.name : name.value), hasOwn2(exports3, name) && this.raiseRecoverable(pos, "Duplicate export '" + name + "'"), exports3[name] = true);
        }, pp$82.checkPatternExport = function(exports3, pat) {
          var type = pat.type;
          if ("Identifier" === type)
            this.checkExport(exports3, pat, pat.start);
          else if ("ObjectPattern" === type)
            for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkPatternExport(exports3, prop);
            }
          else if ("ArrayPattern" === type)
            for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
              var elt = list$1[i$1];
              elt && this.checkPatternExport(exports3, elt);
            }
          else
            "Property" === type ? this.checkPatternExport(exports3, pat.value) : "AssignmentPattern" === type ? this.checkPatternExport(exports3, pat.left) : "RestElement" === type ? this.checkPatternExport(exports3, pat.argument) : "ParenthesizedExpression" === type && this.checkPatternExport(exports3, pat.expression);
        }, pp$82.checkVariableExport = function(exports3, decls) {
          if (exports3)
            for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
              var decl = list2[i2];
              this.checkPatternExport(exports3, decl.id);
            }
        }, pp$82.shouldParseExportStatement = function() {
          return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
        }, pp$82.parseExportSpecifier = function(exports3) {
          var node = this.startNode();
          return node.local = this.parseModuleExportName(), node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local, this.checkExport(exports3, node.exported, node.exported.start), this.finishNode(node, "ExportSpecifier");
        }, pp$82.parseExportSpecifiers = function(exports3) {
          var nodes = [], first = true;
          for (this.expect(types$12.braceL); !this.eat(types$12.braceR); ) {
            if (first)
              first = false;
            else if (this.expect(types$12.comma), this.afterTrailingComma(types$12.braceR))
              break;
            nodes.push(this.parseExportSpecifier(exports3));
          }
          return nodes;
        }, pp$82.parseImport = function(node) {
          return this.next(), this.type === types$12.string ? (node.specifiers = empty$12, node.source = this.parseExprAtom()) : (node.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), node.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(node, "ImportDeclaration");
        }, pp$82.parseImportSpecifier = function() {
          var node = this.startNode();
          return node.imported = this.parseModuleExportName(), this.eatContextual("as") ? node.local = this.parseIdent() : (this.checkUnreserved(node.imported), node.local = node.imported), this.checkLValSimple(node.local, 2), this.finishNode(node, "ImportSpecifier");
        }, pp$82.parseImportDefaultSpecifier = function() {
          var node = this.startNode();
          return node.local = this.parseIdent(), this.checkLValSimple(node.local, 2), this.finishNode(node, "ImportDefaultSpecifier");
        }, pp$82.parseImportNamespaceSpecifier = function() {
          var node = this.startNode();
          return this.next(), this.expectContextual("as"), node.local = this.parseIdent(), this.checkLValSimple(node.local, 2), this.finishNode(node, "ImportNamespaceSpecifier");
        }, pp$82.parseImportSpecifiers = function() {
          var nodes = [], first = true;
          if (this.type === types$12.name && (nodes.push(this.parseImportDefaultSpecifier()), !this.eat(types$12.comma)))
            return nodes;
          if (this.type === types$12.star)
            return nodes.push(this.parseImportNamespaceSpecifier()), nodes;
          for (this.expect(types$12.braceL); !this.eat(types$12.braceR); ) {
            if (first)
              first = false;
            else if (this.expect(types$12.comma), this.afterTrailingComma(types$12.braceR))
              break;
            nodes.push(this.parseImportSpecifier());
          }
          return nodes;
        }, pp$82.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
            var stringLiteral = this.parseLiteral(this.value);
            return loneSurrogate2.test(stringLiteral.value) && this.raise(stringLiteral.start, "An export name cannot include a lone surrogate."), stringLiteral;
          }
          return this.parseIdent(true);
        }, pp$82.adaptDirectivePrologue = function(statements) {
          for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2)
            statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }, pp$82.isDirectiveCandidate = function(statement) {
          return this.options.ecmaVersion >= 5 && "ExpressionStatement" === statement.type && "Literal" === statement.expression.type && "string" == typeof statement.expression.value && ('"' === this.input[statement.start] || "'" === this.input[statement.start]);
        };
        var pp$72 = Parser3.prototype;
        pp$72.toAssignable = function(node, isBinding, refDestructuringErrors) {
          if (this.options.ecmaVersion >= 6 && node)
            switch (node.type) {
              case "Identifier":
                this.inAsync && "await" === node.name && this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
                break;
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                node.type = "ObjectPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, true);
                for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                  var prop = list2[i2];
                  this.toAssignable(prop, isBinding), "RestElement" !== prop.type || "ArrayPattern" !== prop.argument.type && "ObjectPattern" !== prop.argument.type || this.raise(prop.argument.start, "Unexpected token");
                }
                break;
              case "Property":
                "init" !== node.kind && this.raise(node.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(node.value, isBinding);
                break;
              case "ArrayExpression":
                node.type = "ArrayPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, true), this.toAssignableList(node.elements, isBinding);
                break;
              case "SpreadElement":
                node.type = "RestElement", this.toAssignable(node.argument, isBinding), "AssignmentPattern" === node.argument.type && this.raise(node.argument.start, "Rest elements cannot have a default value");
                break;
              case "AssignmentExpression":
                "=" !== node.operator && this.raise(node.left.end, "Only '=' operator can be used for specifying default value."), node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isBinding);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(node.expression, isBinding, refDestructuringErrors);
                break;
              case "ChainExpression":
                this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
                break;
              case "MemberExpression":
                if (!isBinding)
                  break;
              default:
                this.raise(node.start, "Assigning to rvalue");
            }
          else
            refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, true);
          return node;
        }, pp$72.toAssignableList = function(exprList, isBinding) {
          for (var end = exprList.length, i2 = 0; i2 < end; i2++) {
            var elt = exprList[i2];
            elt && this.toAssignable(elt, isBinding);
          }
          if (end) {
            var last = exprList[end - 1];
            6 === this.options.ecmaVersion && isBinding && last && "RestElement" === last.type && "Identifier" !== last.argument.type && this.unexpected(last.argument.start);
          }
          return exprList;
        }, pp$72.parseSpread = function(refDestructuringErrors) {
          var node = this.startNode();
          return this.next(), node.argument = this.parseMaybeAssign(false, refDestructuringErrors), this.finishNode(node, "SpreadElement");
        }, pp$72.parseRestBinding = function() {
          var node = this.startNode();
          return this.next(), 6 === this.options.ecmaVersion && this.type !== types$12.name && this.unexpected(), node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
        }, pp$72.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6)
            switch (this.type) {
              case types$12.bracketL:
                var node = this.startNode();
                return this.next(), node.elements = this.parseBindingList(types$12.bracketR, true, true), this.finishNode(node, "ArrayPattern");
              case types$12.braceL:
                return this.parseObj(true);
            }
          return this.parseIdent();
        }, pp$72.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
          for (var elts = [], first = true; !this.eat(close); )
            if (first ? first = false : this.expect(types$12.comma), allowEmpty && this.type === types$12.comma)
              elts.push(null);
            else {
              if (allowTrailingComma && this.afterTrailingComma(close))
                break;
              if (this.type === types$12.ellipsis) {
                var rest = this.parseRestBinding();
                this.parseBindingListItem(rest), elts.push(rest), this.type === types$12.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(close);
                break;
              }
              elts.push(this.parseAssignableListItem(allowModifiers));
            }
          return elts;
        }, pp$72.parseAssignableListItem = function(allowModifiers) {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem(elem), elem;
        }, pp$72.parseBindingListItem = function(param) {
          return param;
        }, pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
          if (left = left || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(types$12.eq))
            return left;
          var node = this.startNodeAt(startPos, startLoc);
          return node.left = left, node.right = this.parseMaybeAssign(), this.finishNode(node, "AssignmentPattern");
        }, pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
          void 0 === bindingType && (bindingType = 0);
          var isBind = 0 !== bindingType;
          switch (expr.type) {
            case "Identifier":
              this.strict && this.reservedWordsStrictBind.test(expr.name) && this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"), isBind && (2 === bindingType && "let" === expr.name && this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"), checkClashes && (hasOwn2(checkClashes, expr.name) && this.raiseRecoverable(expr.start, "Argument name clash"), checkClashes[expr.name] = true), 5 !== bindingType && this.declareName(expr.name, bindingType, expr.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              isBind && this.raiseRecoverable(expr.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return isBind && this.raiseRecoverable(expr.start, "Binding parenthesized expression"), this.checkLValSimple(expr.expression, bindingType, checkClashes);
            default:
              this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
          }
        }, pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
          switch (void 0 === bindingType && (bindingType = 0), expr.type) {
            case "ObjectPattern":
              for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.checkLValInnerPattern(prop, bindingType, checkClashes);
              }
              break;
            case "ArrayPattern":
              for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
                var elem = list$1[i$1];
                elem && this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
              break;
            default:
              this.checkLValSimple(expr, bindingType, checkClashes);
          }
        }, pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
          switch (void 0 === bindingType && (bindingType = 0), expr.type) {
            case "Property":
              this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(expr.left, bindingType, checkClashes);
              break;
            case "RestElement":
              this.checkLValPattern(expr.argument, bindingType, checkClashes);
              break;
            default:
              this.checkLValPattern(expr, bindingType, checkClashes);
          }
        };
        var TokContext3 = function(token, isExpr, preserveSpace, override, generator) {
          this.token = token, this.isExpr = !!isExpr, this.preserveSpace = !!preserveSpace, this.override = override, this.generator = !!generator;
        }, types2 = { b_stat: new TokContext3("{", false), b_expr: new TokContext3("{", true), b_tmpl: new TokContext3("${", false), p_stat: new TokContext3("(", false), p_expr: new TokContext3("(", true), q_tmpl: new TokContext3("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }), f_stat: new TokContext3("function", false), f_expr: new TokContext3("function", true), f_expr_gen: new TokContext3("function", true, false, null, true), f_gen: new TokContext3("function", false, false, null, true) }, pp$62 = Parser3.prototype;
        pp$62.initialContext = function() {
          return [types2.b_stat];
        }, pp$62.curContext = function() {
          return this.context[this.context.length - 1];
        }, pp$62.braceIsBlock = function(prevType) {
          var parent = this.curContext();
          return parent === types2.f_expr || parent === types2.f_stat || (prevType !== types$12.colon || parent !== types2.b_stat && parent !== types2.b_expr ? prevType === types$12._return || prevType === types$12.name && this.exprAllowed ? lineBreak2.test(this.input.slice(this.lastTokEnd, this.start)) : prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow || (prevType === types$12.braceL ? parent === types2.b_stat : prevType !== types$12._var && prevType !== types$12._const && prevType !== types$12.name && !this.exprAllowed) : !parent.isExpr);
        }, pp$62.inGeneratorContext = function() {
          for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
            var context = this.context[i2];
            if ("function" === context.token)
              return context.generator;
          }
          return false;
        }, pp$62.updateContext = function(prevType) {
          var update, type = this.type;
          type.keyword && prevType === types$12.dot ? this.exprAllowed = false : (update = type.updateContext) ? update.call(this, prevType) : this.exprAllowed = type.beforeExpr;
        }, pp$62.overrideContext = function(tokenCtx) {
          this.curContext() !== tokenCtx && (this.context[this.context.length - 1] = tokenCtx);
        }, types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
          if (1 !== this.context.length) {
            var out = this.context.pop();
            out === types2.b_stat && "function" === this.curContext().token && (out = this.context.pop()), this.exprAllowed = !out.isExpr;
          } else
            this.exprAllowed = true;
        }, types$12.braceL.updateContext = function(prevType) {
          this.context.push(this.braceIsBlock(prevType) ? types2.b_stat : types2.b_expr), this.exprAllowed = true;
        }, types$12.dollarBraceL.updateContext = function() {
          this.context.push(types2.b_tmpl), this.exprAllowed = true;
        }, types$12.parenL.updateContext = function(prevType) {
          var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
          this.context.push(statementParens ? types2.p_stat : types2.p_expr), this.exprAllowed = true;
        }, types$12.incDec.updateContext = function() {
        }, types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
          !prevType.beforeExpr || prevType === types$12._else || prevType === types$12.semi && this.curContext() !== types2.p_stat || prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start)) || (prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types2.b_stat ? this.context.push(types2.f_stat) : this.context.push(types2.f_expr), this.exprAllowed = false;
        }, types$12.backQuote.updateContext = function() {
          this.curContext() === types2.q_tmpl ? this.context.pop() : this.context.push(types2.q_tmpl), this.exprAllowed = false;
        }, types$12.star.updateContext = function(prevType) {
          if (prevType === types$12._function) {
            var index2 = this.context.length - 1;
            this.context[index2] === types2.f_expr ? this.context[index2] = types2.f_expr_gen : this.context[index2] = types2.f_gen;
          }
          this.exprAllowed = true;
        }, types$12.name.updateContext = function(prevType) {
          var allowed = false;
          this.options.ecmaVersion >= 6 && prevType !== types$12.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (allowed = true), this.exprAllowed = allowed;
        };
        var pp$52 = Parser3.prototype;
        function isPrivateFieldAccess2(node) {
          return "MemberExpression" === node.type && "PrivateIdentifier" === node.property.type || "ChainExpression" === node.type && isPrivateFieldAccess2(node.expression);
        }
        pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
          if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === prop.type || this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))) {
            var name, key = prop.key;
            switch (key.type) {
              case "Identifier":
                name = key.name;
                break;
              case "Literal":
                name = String(key.value);
                break;
              default:
                return;
            }
            var kind = prop.kind;
            if (this.options.ecmaVersion >= 6)
              "__proto__" === name && "init" === kind && (propHash.proto && (refDestructuringErrors ? refDestructuringErrors.doubleProto < 0 && (refDestructuringErrors.doubleProto = key.start) : this.raiseRecoverable(key.start, "Redefinition of __proto__ property")), propHash.proto = true);
            else {
              var other = propHash[name = "$" + name];
              if (other)
                ("init" === kind ? this.strict && other.init || other.get || other.set : other.init || other[kind]) && this.raiseRecoverable(key.start, "Redefinition of property");
              else
                other = propHash[name] = { init: false, get: false, set: false };
              other[kind] = true;
            }
          }
        }, pp$52.parseExpression = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
          if (this.type === types$12.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            for (node.expressions = [expr]; this.eat(types$12.comma); )
              node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        }, pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
          if (this.isContextual("yield")) {
            if (this.inGenerator)
              return this.parseYield(forInit);
            this.exprAllowed = false;
          }
          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
          refDestructuringErrors ? (oldParenAssign = refDestructuringErrors.parenthesizedAssign, oldTrailingComma = refDestructuringErrors.trailingComma, oldDoubleProto = refDestructuringErrors.doubleProto, refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1) : (refDestructuringErrors = new DestructuringErrors3(), ownDestructuringErrors = true);
          var startPos = this.start, startLoc = this.startLoc;
          this.type !== types$12.parenL && this.type !== types$12.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === forInit);
          var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
          if (afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), this.type.isAssign) {
            var node = this.startNodeAt(startPos, startLoc);
            return node.operator = this.value, this.type === types$12.eq && (left = this.toAssignable(left, false, refDestructuringErrors)), ownDestructuringErrors || (refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1), refDestructuringErrors.shorthandAssign >= left.start && (refDestructuringErrors.shorthandAssign = -1), this.type === types$12.eq ? this.checkLValPattern(left) : this.checkLValSimple(left), node.left = left, this.next(), node.right = this.parseMaybeAssign(forInit), oldDoubleProto > -1 && (refDestructuringErrors.doubleProto = oldDoubleProto), this.finishNode(node, "AssignmentExpression");
          }
          return ownDestructuringErrors && this.checkExpressionErrors(refDestructuringErrors, true), oldParenAssign > -1 && (refDestructuringErrors.parenthesizedAssign = oldParenAssign), oldTrailingComma > -1 && (refDestructuringErrors.trailingComma = oldTrailingComma), left;
        }, pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprOps(forInit, refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors))
            return expr;
          if (this.eat(types$12.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            return node.test = expr, node.consequent = this.parseMaybeAssign(), this.expect(types$12.colon), node.alternate = this.parseMaybeAssign(forInit), this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        }, pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
          return this.checkExpressionErrors(refDestructuringErrors) || expr.start === startPos && "ArrowFunctionExpression" === expr.type ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
        }, pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
          var prec = this.type.binop;
          if (null != prec && (!forInit || this.type !== types$12._in) && prec > minPrec) {
            var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND, coalesce = this.type === types$12.coalesce;
            coalesce && (prec = types$12.logicalAND.binop);
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc, right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit), node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            return (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
          return left;
        }, pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
          "PrivateIdentifier" === right.type && this.raise(right.start, "Private identifier can only be left side of binary expression");
          var node = this.startNodeAt(startPos, startLoc);
          return node.left = left, node.operator = op, node.right = right, this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
        }, pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
          var expr, startPos = this.start, startLoc = this.startLoc;
          if (this.isContextual("await") && this.canAwait)
            expr = this.parseAwait(forInit), sawUnary = true;
          else if (this.type.prefix) {
            var node = this.startNode(), update = this.type === types$12.incDec;
            node.operator = this.value, node.prefix = true, this.next(), node.argument = this.parseMaybeUnary(null, true, update, forInit), this.checkExpressionErrors(refDestructuringErrors, true), update ? this.checkLValSimple(node.argument) : this.strict && "delete" === node.operator && "Identifier" === node.argument.type ? this.raiseRecoverable(node.start, "Deleting local variable in strict mode") : "delete" === node.operator && isPrivateFieldAccess2(node.argument) ? this.raiseRecoverable(node.start, "Private fields can not be deleted") : sawUnary = true, expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          } else if (sawUnary || this.type !== types$12.privateId) {
            if (expr = this.parseExprSubscripts(refDestructuringErrors, forInit), this.checkExpressionErrors(refDestructuringErrors))
              return expr;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var node$1 = this.startNodeAt(startPos, startLoc);
              node$1.operator = this.value, node$1.prefix = false, node$1.argument = expr, this.checkLValSimple(expr), this.next(), expr = this.finishNode(node$1, "UpdateExpression");
            }
          } else
            (forInit || 0 === this.privateNameStack.length) && this.unexpected(), expr = this.parsePrivateIdent(), this.type !== types$12._in && this.unexpected();
          return incDec || !this.eat(types$12.starstar) ? expr : sawUnary ? void this.unexpected(this.lastTokStart) : this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }, pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
          var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprAtom(refDestructuringErrors, forInit);
          if ("ArrowFunctionExpression" === expr.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd))
            return expr;
          var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
          return refDestructuringErrors && "MemberExpression" === result.type && (refDestructuringErrors.parenthesizedAssign >= result.start && (refDestructuringErrors.parenthesizedAssign = -1), refDestructuringErrors.parenthesizedBind >= result.start && (refDestructuringErrors.parenthesizedBind = -1), refDestructuringErrors.trailingComma >= result.start && (refDestructuringErrors.trailingComma = -1)), result;
        }, pp$52.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
          for (var maybeAsyncArrow = this.options.ecmaVersion >= 8 && "Identifier" === base.type && "async" === base.name && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start == 5 && this.potentialArrowAt === base.start, optionalChained = false; ; ) {
            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
            if (element.optional && (optionalChained = true), element === base || "ArrowFunctionExpression" === element.type) {
              if (optionalChained) {
                var chainNode = this.startNodeAt(startPos, startLoc);
                chainNode.expression = element, element = this.finishNode(chainNode, "ChainExpression");
              }
              return element;
            }
            base = element;
          }
        }, pp$52.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(types$12.arrow);
        }, pp$52.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        }, pp$52.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
          var optionalSupported = this.options.ecmaVersion >= 11, optional = optionalSupported && this.eat(types$12.questionDot);
          noCalls && optional && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          var computed = this.eat(types$12.bracketL);
          if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.object = base, computed ? (node.property = this.parseExpression(), this.expect(types$12.bracketR)) : this.type === types$12.privateId && "Super" !== base.type ? node.property = this.parsePrivateIdent() : node.property = this.parseIdent("never" !== this.options.allowReserved), node.computed = !!computed, optionalSupported && (node.optional = optional), base = this.finishNode(node, "MemberExpression");
          } else if (!noCalls && this.eat(types$12.parenL)) {
            var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
            var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow())
              return this.checkPatternErrors(refDestructuringErrors, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
            this.checkExpressionErrors(refDestructuringErrors, true), this.yieldPos = oldYieldPos || this.yieldPos, this.awaitPos = oldAwaitPos || this.awaitPos, this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base, node$1.arguments = exprList, optionalSupported && (node$1.optional = optional), base = this.finishNode(node$1, "CallExpression");
          } else if (this.type === types$12.backQuote) {
            (optional || optionalChained) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base, node$2.quasi = this.parseTemplate({ isTagged: true }), base = this.finishNode(node$2, "TaggedTemplateExpression");
          }
          return base;
        }, pp$52.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
          this.type === types$12.slash && this.readRegexp();
          var node, canBeArrow = this.potentialArrowAt === this.start;
          switch (this.type) {
            case types$12._super:
              return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), node = this.startNode(), this.next(), this.type !== types$12.parenL || this.allowDirectSuper || this.raise(node.start, "super() call outside constructor of a subclass"), this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL && this.unexpected(), this.finishNode(node, "Super");
            case types$12._this:
              return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");
            case types$12.name:
              var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc, id = this.parseIdent(false);
              if (this.options.ecmaVersion >= 8 && !containsEsc && "async" === id.name && !this.canInsertSemicolon() && this.eat(types$12._function))
                return this.overrideContext(types2.f_expr), this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
              if (canBeArrow && !this.canInsertSemicolon()) {
                if (this.eat(types$12.arrow))
                  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
                if (this.options.ecmaVersion >= 8 && "async" === id.name && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc))
                  return id = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(types$12.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
              return id;
            case types$12.regexp:
              var value2 = this.value;
              return (node = this.parseLiteral(value2.value)).regex = { pattern: value2.pattern, flags: value2.flags }, node;
            case types$12.num:
            case types$12.string:
              return this.parseLiteral(this.value);
            case types$12._null:
            case types$12._true:
            case types$12._false:
              return (node = this.startNode()).value = this.type === types$12._null ? null : this.type === types$12._true, node.raw = this.type.keyword, this.next(), this.finishNode(node, "Literal");
            case types$12.parenL:
              var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
              return refDestructuringErrors && (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr) && (refDestructuringErrors.parenthesizedAssign = start), refDestructuringErrors.parenthesizedBind < 0 && (refDestructuringErrors.parenthesizedBind = start)), expr;
            case types$12.bracketL:
              return node = this.startNode(), this.next(), node.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors), this.finishNode(node, "ArrayExpression");
            case types$12.braceL:
              return this.overrideContext(types2.b_expr), this.parseObj(false, refDestructuringErrors);
            case types$12._function:
              return node = this.startNode(), this.next(), this.parseFunction(node, 0);
            case types$12._class:
              return this.parseClass(this.startNode(), false);
            case types$12._new:
              return this.parseNew();
            case types$12.backQuote:
              return this.parseTemplate();
            case types$12._import:
              return this.options.ecmaVersion >= 11 ? this.parseExprImport(forNew) : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }, pp$52.parseExprAtomDefault = function() {
          this.unexpected();
        }, pp$52.parseExprImport = function(forNew) {
          var node = this.startNode();
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
          var meta = this.parseIdent(true);
          return this.type !== types$12.parenL || forNew ? this.type === types$12.dot ? (node.meta = meta, this.parseImportMeta(node)) : void this.unexpected() : this.parseDynamicImport(node);
        }, pp$52.parseDynamicImport = function(node) {
          if (this.next(), node.source = this.parseMaybeAssign(), !this.eat(types$12.parenR)) {
            var errorPos = this.start;
            this.eat(types$12.comma) && this.eat(types$12.parenR) ? this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()") : this.unexpected(errorPos);
          }
          return this.finishNode(node, "ImportExpression");
        }, pp$52.parseImportMeta = function(node) {
          this.next();
          var containsEsc = this.containsEsc;
          return node.property = this.parseIdent(true), "meta" !== node.property.name && this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"), containsEsc && this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"), "module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"), this.finishNode(node, "MetaProperty");
        }, pp$52.parseLiteral = function(value2) {
          var node = this.startNode();
          return node.value = value2, node.raw = this.input.slice(this.start, this.end), 110 === node.raw.charCodeAt(node.raw.length - 1) && (node.bigint = node.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(node, "Literal");
        }, pp$52.parseParenExpression = function() {
          this.expect(types$12.parenL);
          var val = this.parseExpression();
          return this.expect(types$12.parenR), val;
        }, pp$52.shouldParseArrow = function(exprList) {
          return !this.canInsertSemicolon();
        }, pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
          var val, startPos = this.start, startLoc = this.startLoc, allowTrailingComma = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var spreadStart, innerStartPos = this.start, innerStartLoc = this.startLoc, exprList = [], first = true, lastIsComma = false, refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== types$12.parenR; ) {
              if (first ? first = false : this.expect(types$12.comma), allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
                lastIsComma = true;
                break;
              }
              if (this.type === types$12.ellipsis) {
                spreadStart = this.start, exprList.push(this.parseParenItem(this.parseRestBinding())), this.type === types$12.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                break;
              }
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
            if (this.expect(types$12.parenR), canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$12.arrow))
              return this.checkPatternErrors(refDestructuringErrors, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.parseParenArrowList(startPos, startLoc, exprList, forInit);
            exprList.length && !lastIsComma || this.unexpected(this.lastTokStart), spreadStart && this.unexpected(spreadStart), this.checkExpressionErrors(refDestructuringErrors, true), this.yieldPos = oldYieldPos || this.yieldPos, this.awaitPos = oldAwaitPos || this.awaitPos, exprList.length > 1 ? ((val = this.startNodeAt(innerStartPos, innerStartLoc)).expressions = exprList, this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)) : val = exprList[0];
          } else
            val = this.parseParenExpression();
          if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            return par.expression = val, this.finishNode(par, "ParenthesizedExpression");
          }
          return val;
        }, pp$52.parseParenItem = function(item) {
          return item;
        }, pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
        };
        var empty2 = [];
        pp$52.parseNew = function() {
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var node = this.startNode(), meta = this.parseIdent(true);
          if (this.options.ecmaVersion >= 6 && this.eat(types$12.dot)) {
            node.meta = meta;
            var containsEsc = this.containsEsc;
            return node.property = this.parseIdent(true), "target" !== node.property.name && this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"), containsEsc && this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"), this.finishNode(node, "MetaProperty");
          }
          var startPos = this.start, startLoc = this.startLoc;
          return node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false), this.eat(types$12.parenL) ? node.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false) : node.arguments = empty2, this.finishNode(node, "NewExpression");
        }, pp$52.parseTemplateElement = function(ref3) {
          var isTagged = ref3.isTagged, elem = this.startNode();
          return this.type === types$12.invalidTemplate ? (isTagged || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), elem.value = { raw: this.value, cooked: null }) : elem.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), elem.tail = this.type === types$12.backQuote, this.finishNode(elem, "TemplateElement");
        }, pp$52.parseTemplate = function(ref3) {
          void 0 === ref3 && (ref3 = {});
          var isTagged = ref3.isTagged;
          void 0 === isTagged && (isTagged = false);
          var node = this.startNode();
          this.next(), node.expressions = [];
          var curElt = this.parseTemplateElement({ isTagged });
          for (node.quasis = [curElt]; !curElt.tail; )
            this.type === types$12.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(types$12.dollarBraceL), node.expressions.push(this.parseExpression()), this.expect(types$12.braceR), node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
          return this.next(), this.finishNode(node, "TemplateLiteral");
        }, pp$52.isAsyncProp = function(prop) {
          return !prop.computed && "Identifier" === prop.key.type && "async" === prop.key.name && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        }, pp$52.parseObj = function(isPattern, refDestructuringErrors) {
          var node = this.startNode(), first = true, propHash = {};
          for (node.properties = [], this.next(); !this.eat(types$12.braceR); ) {
            if (first)
              first = false;
            else if (this.expect(types$12.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR))
              break;
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            isPattern || this.checkPropClash(prop, propHash, refDestructuringErrors), node.properties.push(prop);
          }
          return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
        }, pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
          var isGenerator, isAsync, startPos, startLoc, prop = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis))
            return isPattern ? (prop.argument = this.parseIdent(false), this.type === types$12.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(prop, "RestElement")) : (prop.argument = this.parseMaybeAssign(false, refDestructuringErrors), this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start), this.finishNode(prop, "SpreadElement"));
          this.options.ecmaVersion >= 6 && (prop.method = false, prop.shorthand = false, (isPattern || refDestructuringErrors) && (startPos = this.start, startLoc = this.startLoc), isPattern || (isGenerator = this.eat(types$12.star)));
          var containsEsc = this.containsEsc;
          return this.parsePropertyName(prop), !isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop) ? (isAsync = true, isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star), this.parsePropertyName(prop)) : isAsync = false, this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc), this.finishNode(prop, "Property");
        }, pp$52.parseGetterSetter = function(prop) {
          prop.kind = prop.key.name, this.parsePropertyName(prop), prop.value = this.parseMethod(false);
          var paramCount = "get" === prop.kind ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            "get" === prop.kind ? this.raiseRecoverable(start, "getter should have no params") : this.raiseRecoverable(start, "setter should have exactly one param");
          } else
            "set" === prop.kind && "RestElement" === prop.value.params[0].type && this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
        }, pp$52.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
          (isGenerator || isAsync) && this.type === types$12.colon && this.unexpected(), this.eat(types$12.colon) ? (prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors), prop.kind = "init") : this.options.ecmaVersion >= 6 && this.type === types$12.parenL ? (isPattern && this.unexpected(), prop.kind = "init", prop.method = true, prop.value = this.parseMethod(isGenerator, isAsync)) : isPattern || containsEsc || !(this.options.ecmaVersion >= 5) || prop.computed || "Identifier" !== prop.key.type || "get" !== prop.key.name && "set" !== prop.key.name || this.type === types$12.comma || this.type === types$12.braceR || this.type === types$12.eq ? this.options.ecmaVersion >= 6 && !prop.computed && "Identifier" === prop.key.type ? ((isGenerator || isAsync) && this.unexpected(), this.checkUnreserved(prop.key), "await" !== prop.key.name || this.awaitIdentPos || (this.awaitIdentPos = startPos), prop.kind = "init", isPattern ? prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key)) : this.type === types$12.eq && refDestructuringErrors ? (refDestructuringErrors.shorthandAssign < 0 && (refDestructuringErrors.shorthandAssign = this.start), prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key))) : prop.value = this.copyNode(prop.key), prop.shorthand = true) : this.unexpected() : ((isGenerator || isAsync) && this.unexpected(), this.parseGetterSetter(prop));
        }, pp$52.parsePropertyName = function(prop) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(types$12.bracketL))
              return prop.computed = true, prop.key = this.parseMaybeAssign(), this.expect(types$12.bracketR), prop.key;
            prop.computed = false;
          }
          return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
        }, pp$52.initFunction = function(node) {
          node.id = null, this.options.ecmaVersion >= 6 && (node.generator = node.expression = false), this.options.ecmaVersion >= 8 && (node.async = false);
        }, pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
          var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          return this.initFunction(node), this.options.ecmaVersion >= 6 && (node.generator = isGenerator), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | functionFlags2(isAsync, node.generator) | (allowDirectSuper ? 128 : 0)), this.expect(types$12.parenL), node.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(node, false, true, false), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.finishNode(node, "FunctionExpression");
        }, pp$52.parseArrowExpression = function(node, params, isAsync, forInit) {
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          return this.enterScope(16 | functionFlags2(isAsync, false)), this.initFunction(node), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, node.params = this.toAssignableList(params, true), this.parseFunctionBody(node, true, false, forInit), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.finishNode(node, "ArrowFunctionExpression");
        }, pp$52.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
          var isExpression = isArrowFunction && this.type !== types$12.braceL, oldStrict = this.strict, useStrict = false;
          if (isExpression)
            node.body = this.parseMaybeAssign(forInit), node.expression = true, this.checkParams(node, false);
          else {
            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
            oldStrict && !nonSimple || (useStrict = this.strictDirective(this.end)) && nonSimple && this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            var oldLabels = this.labels;
            this.labels = [], useStrict && (this.strict = true), this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params)), this.strict && node.id && this.checkLValSimple(node.id, 5), node.body = this.parseBlock(false, void 0, useStrict && !oldStrict), node.expression = false, this.adaptDirectivePrologue(node.body.body), this.labels = oldLabels;
          }
          this.exitScope();
        }, pp$52.isSimpleParamList = function(params) {
          for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
            if ("Identifier" !== list2[i2].type)
              return false;
          }
          return true;
        }, pp$52.checkParams = function(node, allowDuplicates) {
          for (var nameHash = /* @__PURE__ */ Object.create(null), i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
            var param = list2[i2];
            this.checkLValInnerPattern(param, 1, allowDuplicates ? null : nameHash);
          }
        }, pp$52.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
          for (var elts = [], first = true; !this.eat(close); ) {
            if (first)
              first = false;
            else if (this.expect(types$12.comma), allowTrailingComma && this.afterTrailingComma(close))
              break;
            var elt = void 0;
            allowEmpty && this.type === types$12.comma ? elt = null : this.type === types$12.ellipsis ? (elt = this.parseSpread(refDestructuringErrors), refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start)) : elt = this.parseMaybeAssign(false, refDestructuringErrors), elts.push(elt);
          }
          return elts;
        }, pp$52.checkUnreserved = function(ref3) {
          var start = ref3.start, end = ref3.end, name = ref3.name;
          (this.inGenerator && "yield" === name && this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === name && this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && "arguments" === name && this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || "arguments" !== name && "await" !== name || this.raise(start, "Cannot use " + name + " in class static initialization block"), this.keywords.test(name) && this.raise(start, "Unexpected keyword '" + name + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(start, end).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(name) && (this.inAsync || "await" !== name || this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(start, "The keyword '" + name + "' is reserved"));
        }, pp$52.parseIdent = function(liberal) {
          var node = this.parseIdentNode();
          return this.next(!!liberal), this.finishNode(node, "Identifier"), liberal || (this.checkUnreserved(node), "await" !== node.name || this.awaitIdentPos || (this.awaitIdentPos = node.start)), node;
        }, pp$52.parseIdentNode = function() {
          var node = this.startNode();
          return this.type === types$12.name ? node.name = this.value : this.type.keyword ? (node.name = this.type.keyword, "class" !== node.name && "function" !== node.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop()) : this.unexpected(), node;
        }, pp$52.parsePrivateIdent = function() {
          var node = this.startNode();
          return this.type === types$12.privateId ? node.name = this.value : this.unexpected(), this.next(), this.finishNode(node, "PrivateIdentifier"), 0 === this.privateNameStack.length ? this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(node), node;
        }, pp$52.parseYield = function(forInit) {
          this.yieldPos || (this.yieldPos = this.start);
          var node = this.startNode();
          return this.next(), this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr ? (node.delegate = false, node.argument = null) : (node.delegate = this.eat(types$12.star), node.argument = this.parseMaybeAssign(forInit)), this.finishNode(node, "YieldExpression");
        }, pp$52.parseAwait = function(forInit) {
          this.awaitPos || (this.awaitPos = this.start);
          var node = this.startNode();
          return this.next(), node.argument = this.parseMaybeUnary(null, true, false, forInit), this.finishNode(node, "AwaitExpression");
        };
        var pp$42 = Parser3.prototype;
        pp$42.raise = function(pos, message) {
          var loc = getLineInfo2(this.input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          throw err.pos = pos, err.loc = loc, err.raisedAt = this.pos, err;
        }, pp$42.raiseRecoverable = pp$42.raise, pp$42.curPosition = function() {
          if (this.options.locations)
            return new Position3(this.curLine, this.pos - this.lineStart);
        };
        var pp$32 = Parser3.prototype, Scope3 = function(flags) {
          this.flags = flags, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = false;
        };
        pp$32.enterScope = function(flags) {
          this.scopeStack.push(new Scope3(flags));
        }, pp$32.exitScope = function() {
          this.scopeStack.pop();
        }, pp$32.treatFunctionsAsVarInScope = function(scope) {
          return 2 & scope.flags || !this.inModule && 1 & scope.flags;
        }, pp$32.declareName = function(name, bindingType, pos) {
          var redeclared = false;
          if (2 === bindingType) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1, scope.lexical.push(name), this.inModule && 1 & scope.flags && delete this.undefinedExports[name];
          } else if (4 === bindingType) {
            this.currentScope().lexical.push(name);
          } else if (3 === bindingType) {
            var scope$2 = this.currentScope();
            redeclared = this.treatFunctionsAsVar ? scope$2.lexical.indexOf(name) > -1 : scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1, scope$2.functions.push(name);
          } else
            for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
              var scope$3 = this.scopeStack[i2];
              if (scope$3.lexical.indexOf(name) > -1 && !(32 & scope$3.flags && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                redeclared = true;
                break;
              }
              if (scope$3.var.push(name), this.inModule && 1 & scope$3.flags && delete this.undefinedExports[name], 259 & scope$3.flags)
                break;
            }
          redeclared && this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }, pp$32.checkLocalExport = function(id) {
          -1 === this.scopeStack[0].lexical.indexOf(id.name) && -1 === this.scopeStack[0].var.indexOf(id.name) && (this.undefinedExports[id.name] = id);
        }, pp$32.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        }, pp$32.currentVarScope = function() {
          for (var i2 = this.scopeStack.length - 1; ; i2--) {
            var scope = this.scopeStack[i2];
            if (259 & scope.flags)
              return scope;
          }
        }, pp$32.currentThisScope = function() {
          for (var i2 = this.scopeStack.length - 1; ; i2--) {
            var scope = this.scopeStack[i2];
            if (259 & scope.flags && !(16 & scope.flags))
              return scope;
          }
        };
        var Node3 = function(parser, pos, loc) {
          this.type = "", this.start = pos, this.end = 0, parser.options.locations && (this.loc = new SourceLocation3(parser, loc)), parser.options.directSourceFile && (this.sourceFile = parser.options.directSourceFile), parser.options.ranges && (this.range = [pos, 0]);
        }, pp$22 = Parser3.prototype;
        function finishNodeAt2(node, type, pos, loc) {
          return node.type = type, node.end = pos, this.options.locations && (node.loc.end = loc), this.options.ranges && (node.range[1] = pos), node;
        }
        pp$22.startNode = function() {
          return new Node3(this, this.start, this.startLoc);
        }, pp$22.startNodeAt = function(pos, loc) {
          return new Node3(this, pos, loc);
        }, pp$22.finishNode = function(node, type) {
          return finishNodeAt2.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
        }, pp$22.finishNodeAt = function(node, type, pos, loc) {
          return finishNodeAt2.call(this, node, type, pos, loc);
        }, pp$22.copyNode = function(node) {
          var newNode = new Node3(this, node.start, this.startLoc);
          for (var prop in node)
            newNode[prop] = node[prop];
          return newNode;
        };
        var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic", ecma12BinaryProperties2 = ecma10BinaryProperties2 + " EBase EComp EMod EPres ExtPict", unicodeBinaryProperties2 = { 9: ecma9BinaryProperties2, 10: ecma10BinaryProperties2, 11: ecma10BinaryProperties2, 12: ecma12BinaryProperties2, 13: ecma12BinaryProperties2, 14: ecma12BinaryProperties2 }, unicodeBinaryPropertiesOfStrings2 = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji" }, unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", unicodeScriptValues2 = { 9: ecma9ScriptValues2, 10: ecma10ScriptValues2, 11: ecma11ScriptValues2, 12: ecma12ScriptValues2, 13: ecma13ScriptValues2, 14: ecma13ScriptValues2 + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz" }, data2 = {};
        function buildUnicodeData2(ecmaVersion) {
          var d = data2[ecmaVersion] = { binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion] + " " + unicodeGeneralCategoryValues2), binaryOfStrings: wordsRegexp2(unicodeBinaryPropertiesOfStrings2[ecmaVersion]), nonBinary: { General_Category: wordsRegexp2(unicodeGeneralCategoryValues2), Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion]) } };
          d.nonBinary.Script_Extensions = d.nonBinary.Script, d.nonBinary.gc = d.nonBinary.General_Category, d.nonBinary.sc = d.nonBinary.Script, d.nonBinary.scx = d.nonBinary.Script_Extensions;
        }
        for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
          buildUnicodeData2(list[i]);
        }
        var pp$12 = Parser3.prototype, RegExpValidationState3 = function(parser) {
          this.parser = parser, this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = data2[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchV = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
        };
        function isSyntaxCharacter2(ch) {
          return 36 === ch || ch >= 40 && ch <= 43 || 46 === ch || 63 === ch || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
        }
        function isControlLetter2(ch) {
          return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
        }
        RegExpValidationState3.prototype.reset = function(start, pattern, flags) {
          var unicodeSets = -1 !== flags.indexOf("v"), unicode = -1 !== flags.indexOf("u");
          this.start = 0 | start, this.source = pattern + "", this.flags = flags, unicodeSets && this.parser.options.ecmaVersion >= 15 ? (this.switchU = true, this.switchV = true, this.switchN = true) : (this.switchU = unicode && this.parser.options.ecmaVersion >= 6, this.switchV = false, this.switchN = unicode && this.parser.options.ecmaVersion >= 9);
        }, RegExpValidationState3.prototype.raise = function(message) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
        }, RegExpValidationState3.prototype.at = function(i2, forceU) {
          void 0 === forceU && (forceU = false);
          var s = this.source, l = s.length;
          if (i2 >= l)
            return -1;
          var c = s.charCodeAt(i2);
          if (!forceU && !this.switchU || c <= 55295 || c >= 57344 || i2 + 1 >= l)
            return c;
          var next = s.charCodeAt(i2 + 1);
          return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
        }, RegExpValidationState3.prototype.nextIndex = function(i2, forceU) {
          void 0 === forceU && (forceU = false);
          var s = this.source, l = s.length;
          if (i2 >= l)
            return l;
          var next, c = s.charCodeAt(i2);
          return !forceU && !this.switchU || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343 ? i2 + 1 : i2 + 2;
        }, RegExpValidationState3.prototype.current = function(forceU) {
          return void 0 === forceU && (forceU = false), this.at(this.pos, forceU);
        }, RegExpValidationState3.prototype.lookahead = function(forceU) {
          return void 0 === forceU && (forceU = false), this.at(this.nextIndex(this.pos, forceU), forceU);
        }, RegExpValidationState3.prototype.advance = function(forceU) {
          void 0 === forceU && (forceU = false), this.pos = this.nextIndex(this.pos, forceU);
        }, RegExpValidationState3.prototype.eat = function(ch, forceU) {
          return void 0 === forceU && (forceU = false), this.current(forceU) === ch && (this.advance(forceU), true);
        }, RegExpValidationState3.prototype.eatChars = function(chs, forceU) {
          void 0 === forceU && (forceU = false);
          for (var pos = this.pos, i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
            var ch = list2[i2], current2 = this.at(pos, forceU);
            if (-1 === current2 || current2 !== ch)
              return false;
            pos = this.nextIndex(pos, forceU);
          }
          return this.pos = pos, true;
        }, pp$12.validateRegExpFlags = function(state) {
          for (var validFlags = state.validFlags, flags = state.flags, u = false, v = false, i2 = 0; i2 < flags.length; i2++) {
            var flag = flags.charAt(i2);
            -1 === validFlags.indexOf(flag) && this.raise(state.start, "Invalid regular expression flag"), flags.indexOf(flag, i2 + 1) > -1 && this.raise(state.start, "Duplicate regular expression flag"), "u" === flag && (u = true), "v" === flag && (v = true);
          }
          this.options.ecmaVersion >= 15 && u && v && this.raise(state.start, "Invalid regular expression flag");
        }, pp$12.validateRegExpPattern = function(state) {
          this.regexp_pattern(state), !state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0 && (state.switchN = true, this.regexp_pattern(state));
        }, pp$12.regexp_pattern = function(state) {
          state.pos = 0, state.lastIntValue = 0, state.lastStringValue = "", state.lastAssertionIsQuantifiable = false, state.numCapturingParens = 0, state.maxBackReference = 0, state.groupNames.length = 0, state.backReferenceNames.length = 0, this.regexp_disjunction(state), state.pos !== state.source.length && (state.eat(41) && state.raise("Unmatched ')'"), (state.eat(93) || state.eat(125)) && state.raise("Lone quantifier brackets")), state.maxBackReference > state.numCapturingParens && state.raise("Invalid escape");
          for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            -1 === state.groupNames.indexOf(name) && state.raise("Invalid named capture referenced");
          }
        }, pp$12.regexp_disjunction = function(state) {
          for (this.regexp_alternative(state); state.eat(124); )
            this.regexp_alternative(state);
          this.regexp_eatQuantifier(state, true) && state.raise("Nothing to repeat"), state.eat(123) && state.raise("Lone quantifier brackets");
        }, pp$12.regexp_alternative = function(state) {
          for (; state.pos < state.source.length && this.regexp_eatTerm(state); )
            ;
        }, pp$12.regexp_eatTerm = function(state) {
          return this.regexp_eatAssertion(state) ? (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state) && state.switchU && state.raise("Invalid quantifier"), true) : !!(state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) && (this.regexp_eatQuantifier(state), true);
        }, pp$12.regexp_eatAssertion = function(state) {
          var start = state.pos;
          if (state.lastAssertionIsQuantifiable = false, state.eat(94) || state.eat(36))
            return true;
          if (state.eat(92)) {
            if (state.eat(66) || state.eat(98))
              return true;
            state.pos = start;
          }
          if (state.eat(40) && state.eat(63)) {
            var lookbehind = false;
            if (this.options.ecmaVersion >= 9 && (lookbehind = state.eat(60)), state.eat(61) || state.eat(33))
              return this.regexp_disjunction(state), state.eat(41) || state.raise("Unterminated group"), state.lastAssertionIsQuantifiable = !lookbehind, true;
          }
          return state.pos = start, false;
        }, pp$12.regexp_eatQuantifier = function(state, noError) {
          return void 0 === noError && (noError = false), !!this.regexp_eatQuantifierPrefix(state, noError) && (state.eat(63), true);
        }, pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
          return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
        }, pp$12.regexp_eatBracedQuantifier = function(state, noError) {
          var start = state.pos;
          if (state.eat(123)) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state) && (min = state.lastIntValue, state.eat(44) && this.regexp_eatDecimalDigits(state) && (max = state.lastIntValue), state.eat(125)))
              return -1 !== max && max < min && !noError && state.raise("numbers out of order in {} quantifier"), true;
            state.switchU && !noError && state.raise("Incomplete quantifier"), state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatAtom = function(state) {
          return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
        }, pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
          var start = state.pos;
          if (state.eat(92)) {
            if (this.regexp_eatAtomEscape(state))
              return true;
            state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatUncapturingGroup = function(state) {
          var start = state.pos;
          if (state.eat(40)) {
            if (state.eat(63) && state.eat(58)) {
              if (this.regexp_disjunction(state), state.eat(41))
                return true;
              state.raise("Unterminated group");
            }
            state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatCapturingGroup = function(state) {
          if (state.eat(40)) {
            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(state) : 63 === state.current() && state.raise("Invalid group"), this.regexp_disjunction(state), state.eat(41))
              return state.numCapturingParens += 1, true;
            state.raise("Unterminated group");
          }
          return false;
        }, pp$12.regexp_eatExtendedAtom = function(state) {
          return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
        }, pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
          return this.regexp_eatBracedQuantifier(state, true) && state.raise("Nothing to repeat"), false;
        }, pp$12.regexp_eatSyntaxCharacter = function(state) {
          var ch = state.current();
          return !!isSyntaxCharacter2(ch) && (state.lastIntValue = ch, state.advance(), true);
        }, pp$12.regexp_eatPatternCharacters = function(state) {
          for (var start = state.pos, ch = 0; -1 !== (ch = state.current()) && !isSyntaxCharacter2(ch); )
            state.advance();
          return state.pos !== start;
        }, pp$12.regexp_eatExtendedPatternCharacter = function(state) {
          var ch = state.current();
          return !(-1 === ch || 36 === ch || ch >= 40 && ch <= 43 || 46 === ch || 63 === ch || 91 === ch || 94 === ch || 124 === ch) && (state.advance(), true);
        }, pp$12.regexp_groupSpecifier = function(state) {
          if (state.eat(63)) {
            if (this.regexp_eatGroupName(state))
              return -1 !== state.groupNames.indexOf(state.lastStringValue) && state.raise("Duplicate capture group name"), void state.groupNames.push(state.lastStringValue);
            state.raise("Invalid group");
          }
        }, pp$12.regexp_eatGroupName = function(state) {
          if (state.lastStringValue = "", state.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62))
              return true;
            state.raise("Invalid capture group name");
          }
          return false;
        }, pp$12.regexp_eatRegExpIdentifierName = function(state) {
          if (state.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(state)) {
            for (state.lastStringValue += codePointToString2(state.lastIntValue); this.regexp_eatRegExpIdentifierPart(state); )
              state.lastStringValue += codePointToString2(state.lastIntValue);
            return true;
          }
          return false;
        }, pp$12.regexp_eatRegExpIdentifierStart = function(state) {
          var start = state.pos, forceU = this.options.ecmaVersion >= 11, ch = state.current(forceU);
          return state.advance(forceU), 92 === ch && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU) && (ch = state.lastIntValue), function(ch2) {
            return isIdentifierStart2(ch2, true) || 36 === ch2 || 95 === ch2;
          }(ch) ? (state.lastIntValue = ch, true) : (state.pos = start, false);
        }, pp$12.regexp_eatRegExpIdentifierPart = function(state) {
          var start = state.pos, forceU = this.options.ecmaVersion >= 11, ch = state.current(forceU);
          return state.advance(forceU), 92 === ch && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU) && (ch = state.lastIntValue), function(ch2) {
            return isIdentifierChar2(ch2, true) || 36 === ch2 || 95 === ch2 || 8204 === ch2 || 8205 === ch2;
          }(ch) ? (state.lastIntValue = ch, true) : (state.pos = start, false);
        }, pp$12.regexp_eatAtomEscape = function(state) {
          return !!(this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) || (state.switchU && (99 === state.current() && state.raise("Invalid unicode escape"), state.raise("Invalid escape")), false);
        }, pp$12.regexp_eatBackReference = function(state) {
          var start = state.pos;
          if (this.regexp_eatDecimalEscape(state)) {
            var n = state.lastIntValue;
            if (state.switchU)
              return n > state.maxBackReference && (state.maxBackReference = n), true;
            if (n <= state.numCapturingParens)
              return true;
            state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatKGroupName = function(state) {
          if (state.eat(107)) {
            if (this.regexp_eatGroupName(state))
              return state.backReferenceNames.push(state.lastStringValue), true;
            state.raise("Invalid named reference");
          }
          return false;
        }, pp$12.regexp_eatCharacterEscape = function(state) {
          return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
        }, pp$12.regexp_eatCControlLetter = function(state) {
          var start = state.pos;
          if (state.eat(99)) {
            if (this.regexp_eatControlLetter(state))
              return true;
            state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatZero = function(state) {
          return 48 === state.current() && !isDecimalDigit2(state.lookahead()) && (state.lastIntValue = 0, state.advance(), true);
        }, pp$12.regexp_eatControlEscape = function(state) {
          var ch = state.current();
          return 116 === ch ? (state.lastIntValue = 9, state.advance(), true) : 110 === ch ? (state.lastIntValue = 10, state.advance(), true) : 118 === ch ? (state.lastIntValue = 11, state.advance(), true) : 102 === ch ? (state.lastIntValue = 12, state.advance(), true) : 114 === ch && (state.lastIntValue = 13, state.advance(), true);
        }, pp$12.regexp_eatControlLetter = function(state) {
          var ch = state.current();
          return !!isControlLetter2(ch) && (state.lastIntValue = ch % 32, state.advance(), true);
        }, pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
          void 0 === forceU && (forceU = false);
          var ch, start = state.pos, switchU = forceU || state.switchU;
          if (state.eat(117)) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
              var lead = state.lastIntValue;
              if (switchU && lead >= 55296 && lead <= 56319) {
                var leadSurrogateEnd = state.pos;
                if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                  var trail = state.lastIntValue;
                  if (trail >= 56320 && trail <= 57343)
                    return state.lastIntValue = 1024 * (lead - 55296) + (trail - 56320) + 65536, true;
                }
                state.pos = leadSurrogateEnd, state.lastIntValue = lead;
              }
              return true;
            }
            if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && ((ch = state.lastIntValue) >= 0 && ch <= 1114111))
              return true;
            switchU && state.raise("Invalid unicode escape"), state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatIdentityEscape = function(state) {
          if (state.switchU)
            return !!this.regexp_eatSyntaxCharacter(state) || !!state.eat(47) && (state.lastIntValue = 47, true);
          var ch = state.current();
          return !(99 === ch || state.switchN && 107 === ch) && (state.lastIntValue = ch, state.advance(), true);
        }, pp$12.regexp_eatDecimalEscape = function(state) {
          state.lastIntValue = 0;
          var ch = state.current();
          if (ch >= 49 && ch <= 57) {
            do {
              state.lastIntValue = 10 * state.lastIntValue + (ch - 48), state.advance();
            } while ((ch = state.current()) >= 48 && ch <= 57);
            return true;
          }
          return false;
        };
        function isUnicodePropertyNameCharacter2(ch) {
          return isControlLetter2(ch) || 95 === ch;
        }
        function isUnicodePropertyValueCharacter2(ch) {
          return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
        }
        function isDecimalDigit2(ch) {
          return ch >= 48 && ch <= 57;
        }
        function isHexDigit2(ch) {
          return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
        }
        function hexToInt2(ch) {
          return ch >= 65 && ch <= 70 ? ch - 65 + 10 : ch >= 97 && ch <= 102 ? ch - 97 + 10 : ch - 48;
        }
        function isOctalDigit2(ch) {
          return ch >= 48 && ch <= 55;
        }
        pp$12.regexp_eatCharacterClassEscape = function(state) {
          var ch = state.current();
          if (function(ch2) {
            return 100 === ch2 || 68 === ch2 || 115 === ch2 || 83 === ch2 || 119 === ch2 || 87 === ch2;
          }(ch))
            return state.lastIntValue = -1, state.advance(), 1;
          var negate = false;
          if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = 80 === ch) || 112 === ch)) {
            var result;
            if (state.lastIntValue = -1, state.advance(), state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125))
              return negate && 2 === result && state.raise("Invalid property name"), result;
            state.raise("Invalid property name");
          }
          return 0;
        }, pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
          var start = state.pos;
          if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
            var name = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
              var value2 = state.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(state, name, value2), 1;
            }
          }
          if (state.pos = start, this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          }
          return 0;
        }, pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
          hasOwn2(state.unicodeProperties.nonBinary, name) || state.raise("Invalid property name"), state.unicodeProperties.nonBinary[name].test(value2) || state.raise("Invalid property value");
        }, pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
          return state.unicodeProperties.binary.test(nameOrValue) ? 1 : state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue) ? 2 : void state.raise("Invalid property name");
        }, pp$12.regexp_eatUnicodePropertyName = function(state) {
          var ch = 0;
          for (state.lastStringValue = ""; isUnicodePropertyNameCharacter2(ch = state.current()); )
            state.lastStringValue += codePointToString2(ch), state.advance();
          return "" !== state.lastStringValue;
        }, pp$12.regexp_eatUnicodePropertyValue = function(state) {
          var ch = 0;
          for (state.lastStringValue = ""; isUnicodePropertyValueCharacter2(ch = state.current()); )
            state.lastStringValue += codePointToString2(ch), state.advance();
          return "" !== state.lastStringValue;
        }, pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
          return this.regexp_eatUnicodePropertyValue(state);
        }, pp$12.regexp_eatCharacterClass = function(state) {
          if (state.eat(91)) {
            var negate = state.eat(94), result = this.regexp_classContents(state);
            return state.eat(93) || state.raise("Unterminated character class"), negate && 2 === result && state.raise("Negated character class may contain strings"), true;
          }
          return false;
        }, pp$12.regexp_classContents = function(state) {
          return 93 === state.current() ? 1 : state.switchV ? this.regexp_classSetExpression(state) : (this.regexp_nonEmptyClassRanges(state), 1);
        }, pp$12.regexp_nonEmptyClassRanges = function(state) {
          for (; this.regexp_eatClassAtom(state); ) {
            var left = state.lastIntValue;
            if (state.eat(45) && this.regexp_eatClassAtom(state)) {
              var right = state.lastIntValue;
              !state.switchU || -1 !== left && -1 !== right || state.raise("Invalid character class"), -1 !== left && -1 !== right && left > right && state.raise("Range out of order in character class");
            }
          }
        }, pp$12.regexp_eatClassAtom = function(state) {
          var start = state.pos;
          if (state.eat(92)) {
            if (this.regexp_eatClassEscape(state))
              return true;
            if (state.switchU) {
              var ch$1 = state.current();
              (99 === ch$1 || isOctalDigit2(ch$1)) && state.raise("Invalid class escape"), state.raise("Invalid escape");
            }
            state.pos = start;
          }
          var ch = state.current();
          return 93 !== ch && (state.lastIntValue = ch, state.advance(), true);
        }, pp$12.regexp_eatClassEscape = function(state) {
          var start = state.pos;
          if (state.eat(98))
            return state.lastIntValue = 8, true;
          if (state.switchU && state.eat(45))
            return state.lastIntValue = 45, true;
          if (!state.switchU && state.eat(99)) {
            if (this.regexp_eatClassControlLetter(state))
              return true;
            state.pos = start;
          }
          return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
        }, pp$12.regexp_classSetExpression = function(state) {
          var subResult, result = 1;
          if (this.regexp_eatClassSetRange(state))
            ;
          else if (subResult = this.regexp_eatClassSetOperand(state)) {
            2 === subResult && (result = 2);
            for (var start = state.pos; state.eatChars([38, 38]); )
              38 !== state.current() && (subResult = this.regexp_eatClassSetOperand(state)) ? 2 !== subResult && (result = 1) : state.raise("Invalid character in character class");
            if (start !== state.pos)
              return result;
            for (; state.eatChars([45, 45]); )
              this.regexp_eatClassSetOperand(state) || state.raise("Invalid character in character class");
            if (start !== state.pos)
              return result;
          } else
            state.raise("Invalid character in character class");
          for (; ; )
            if (!this.regexp_eatClassSetRange(state)) {
              if (!(subResult = this.regexp_eatClassSetOperand(state)))
                return result;
              2 === subResult && (result = 2);
            }
        }, pp$12.regexp_eatClassSetRange = function(state) {
          var start = state.pos;
          if (this.regexp_eatClassSetCharacter(state)) {
            var left = state.lastIntValue;
            if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
              var right = state.lastIntValue;
              return -1 !== left && -1 !== right && left > right && state.raise("Range out of order in character class"), true;
            }
            state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatClassSetOperand = function(state) {
          return this.regexp_eatClassSetCharacter(state) ? 1 : this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
        }, pp$12.regexp_eatNestedClass = function(state) {
          var start = state.pos;
          if (state.eat(91)) {
            var negate = state.eat(94), result = this.regexp_classContents(state);
            if (state.eat(93))
              return negate && 2 === result && state.raise("Negated character class may contain strings"), result;
            state.pos = start;
          }
          if (state.eat(92)) {
            var result$1 = this.regexp_eatCharacterClassEscape(state);
            if (result$1)
              return result$1;
            state.pos = start;
          }
          return null;
        }, pp$12.regexp_eatClassStringDisjunction = function(state) {
          var start = state.pos;
          if (state.eatChars([92, 113])) {
            if (state.eat(123)) {
              var result = this.regexp_classStringDisjunctionContents(state);
              if (state.eat(125))
                return result;
            } else
              state.raise("Invalid escape");
            state.pos = start;
          }
          return null;
        }, pp$12.regexp_classStringDisjunctionContents = function(state) {
          for (var result = this.regexp_classString(state); state.eat(124); )
            2 === this.regexp_classString(state) && (result = 2);
          return result;
        }, pp$12.regexp_classString = function(state) {
          for (var count = 0; this.regexp_eatClassSetCharacter(state); )
            count++;
          return 1 === count ? 1 : 2;
        }, pp$12.regexp_eatClassSetCharacter = function(state) {
          var start = state.pos;
          if (state.eat(92))
            return !(!this.regexp_eatCharacterEscape(state) && !this.regexp_eatClassSetReservedPunctuator(state)) || (state.eat(98) ? (state.lastIntValue = 8, true) : (state.pos = start, false));
          var ch = state.current();
          return !(ch < 0 || ch === state.lookahead() && function(ch2) {
            return 33 === ch2 || ch2 >= 35 && ch2 <= 38 || ch2 >= 42 && ch2 <= 44 || 46 === ch2 || ch2 >= 58 && ch2 <= 64 || 94 === ch2 || 96 === ch2 || 126 === ch2;
          }(ch)) && (!function(ch2) {
            return 40 === ch2 || 41 === ch2 || 45 === ch2 || 47 === ch2 || ch2 >= 91 && ch2 <= 93 || ch2 >= 123 && ch2 <= 125;
          }(ch) && (state.advance(), state.lastIntValue = ch, true));
        }, pp$12.regexp_eatClassSetReservedPunctuator = function(state) {
          var ch = state.current();
          return !!function(ch2) {
            return 33 === ch2 || 35 === ch2 || 37 === ch2 || 38 === ch2 || 44 === ch2 || 45 === ch2 || ch2 >= 58 && ch2 <= 62 || 64 === ch2 || 96 === ch2 || 126 === ch2;
          }(ch) && (state.lastIntValue = ch, state.advance(), true);
        }, pp$12.regexp_eatClassControlLetter = function(state) {
          var ch = state.current();
          return !(!isDecimalDigit2(ch) && 95 !== ch) && (state.lastIntValue = ch % 32, state.advance(), true);
        }, pp$12.regexp_eatHexEscapeSequence = function(state) {
          var start = state.pos;
          if (state.eat(120)) {
            if (this.regexp_eatFixedHexDigits(state, 2))
              return true;
            state.switchU && state.raise("Invalid escape"), state.pos = start;
          }
          return false;
        }, pp$12.regexp_eatDecimalDigits = function(state) {
          var start = state.pos, ch = 0;
          for (state.lastIntValue = 0; isDecimalDigit2(ch = state.current()); )
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48), state.advance();
          return state.pos !== start;
        }, pp$12.regexp_eatHexDigits = function(state) {
          var start = state.pos, ch = 0;
          for (state.lastIntValue = 0; isHexDigit2(ch = state.current()); )
            state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch), state.advance();
          return state.pos !== start;
        }, pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
          if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
              var n2 = state.lastIntValue;
              n1 <= 3 && this.regexp_eatOctalDigit(state) ? state.lastIntValue = 64 * n1 + 8 * n2 + state.lastIntValue : state.lastIntValue = 8 * n1 + n2;
            } else
              state.lastIntValue = n1;
            return true;
          }
          return false;
        }, pp$12.regexp_eatOctalDigit = function(state) {
          var ch = state.current();
          return isOctalDigit2(ch) ? (state.lastIntValue = ch - 48, state.advance(), true) : (state.lastIntValue = 0, false);
        }, pp$12.regexp_eatFixedHexDigits = function(state, length) {
          var start = state.pos;
          state.lastIntValue = 0;
          for (var i2 = 0; i2 < length; ++i2) {
            var ch = state.current();
            if (!isHexDigit2(ch))
              return state.pos = start, false;
            state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch), state.advance();
          }
          return true;
        };
        var Token3 = function(p) {
          this.type = p.type, this.value = p.value, this.start = p.start, this.end = p.end, p.options.locations && (this.loc = new SourceLocation3(p, p.startLoc, p.endLoc)), p.options.ranges && (this.range = [p.start, p.end]);
        }, pp2 = Parser3.prototype;
        function stringToBigInt2(str) {
          return "function" != typeof BigInt ? null : BigInt(str.replace(/_/g, ""));
        }
        pp2.next = function(ignoreEscapeSequenceInKeyword) {
          !ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Token3(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
        }, pp2.getToken = function() {
          return this.next(), new Token3(this);
        }, "undefined" != typeof Symbol && (pp2[Symbol.iterator] = function() {
          var this$1$1 = this;
          return { next: function() {
            var token = this$1$1.getToken();
            return { done: token.type === types$12.eof, value: token };
          } };
        }), pp2.nextToken = function() {
          var curContext = this.curContext();
          return curContext && curContext.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(types$12.eof) : curContext.override ? curContext.override(this) : void this.readToken(this.fullCharCodeAtPos());
        }, pp2.readToken = function(code) {
          return isIdentifierStart2(code, this.options.ecmaVersion >= 6) || 92 === code ? this.readWord() : this.getTokenFromCode(code);
        }, pp2.fullCharCodeAtPos = function() {
          var code = this.input.charCodeAt(this.pos);
          if (code <= 55295 || code >= 56320)
            return code;
          var next = this.input.charCodeAt(this.pos + 1);
          return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
        }, pp2.skipBlockComment = function() {
          var startLoc = this.options.onComment && this.curPosition(), start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
          if (-1 === end && this.raise(this.pos - 2, "Unterminated comment"), this.pos = end + 2, this.options.locations)
            for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; )
              ++this.curLine, pos = this.lineStart = nextBreak;
          this.options.onComment && this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }, pp2.skipLineComment = function(startSkip) {
          for (var start = this.pos, startLoc = this.options.onComment && this.curPosition(), ch = this.input.charCodeAt(this.pos += startSkip); this.pos < this.input.length && !isNewLine2(ch); )
            ch = this.input.charCodeAt(++this.pos);
          this.options.onComment && this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }, pp2.skipSpace = function() {
          loop:
            for (; this.pos < this.input.length; ) {
              var ch = this.input.charCodeAt(this.pos);
              switch (ch) {
                case 32:
                case 160:
                  ++this.pos;
                  break;
                case 13:
                  10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.pos + 1)) {
                    case 42:
                      this.skipBlockComment();
                      break;
                    case 47:
                      this.skipLineComment(2);
                      break;
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (!(ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))))
                    break loop;
                  ++this.pos;
              }
            }
        }, pp2.finishToken = function(type, val) {
          this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
          var prevType = this.type;
          this.type = type, this.value = val, this.updateContext(prevType);
        }, pp2.readToken_dot = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next >= 48 && next <= 57)
            return this.readNumber(true);
          var next2 = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && 46 === next && 46 === next2 ? (this.pos += 3, this.finishToken(types$12.ellipsis)) : (++this.pos, this.finishToken(types$12.dot));
        }, pp2.readToken_slash = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === next ? this.finishOp(types$12.assign, 2) : this.finishOp(types$12.slash, 1);
        }, pp2.readToken_mult_modulo_exp = function(code) {
          var next = this.input.charCodeAt(this.pos + 1), size = 1, tokentype = 42 === code ? types$12.star : types$12.modulo;
          return this.options.ecmaVersion >= 7 && 42 === code && 42 === next && (++size, tokentype = types$12.starstar, next = this.input.charCodeAt(this.pos + 2)), 61 === next ? this.finishOp(types$12.assign, size + 1) : this.finishOp(tokentype, size);
        }, pp2.readToken_pipe_amp = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code) {
            if (this.options.ecmaVersion >= 12) {
              if (61 === this.input.charCodeAt(this.pos + 2))
                return this.finishOp(types$12.assign, 3);
            }
            return this.finishOp(124 === code ? types$12.logicalOR : types$12.logicalAND, 2);
          }
          return 61 === next ? this.finishOp(types$12.assign, 2) : this.finishOp(124 === code ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
        }, pp2.readToken_caret = function() {
          return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(types$12.assign, 2) : this.finishOp(types$12.bitwiseXOR, 1);
        }, pp2.readToken_plus_min = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          return next === code ? 45 !== next || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(types$12.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === next ? this.finishOp(types$12.assign, 2) : this.finishOp(types$12.plusMin, 1);
        }, pp2.readToken_lt_gt = function(code) {
          var next = this.input.charCodeAt(this.pos + 1), size = 1;
          return next === code ? (size = 62 === code && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + size) ? this.finishOp(types$12.assign, size + 1) : this.finishOp(types$12.bitShift, size)) : 33 !== next || 60 !== code || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === next && (size = 2), this.finishOp(types$12.relational, size)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }, pp2.readToken_eq_excl = function(code) {
          var next = this.input.charCodeAt(this.pos + 1);
          return 61 === next ? this.finishOp(types$12.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === code && 62 === next && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(types$12.arrow)) : this.finishOp(61 === code ? types$12.eq : types$12.prefix, 1);
        }, pp2.readToken_question = function() {
          var ecmaVersion = this.options.ecmaVersion;
          if (ecmaVersion >= 11) {
            var next = this.input.charCodeAt(this.pos + 1);
            if (46 === next) {
              var next2 = this.input.charCodeAt(this.pos + 2);
              if (next2 < 48 || next2 > 57)
                return this.finishOp(types$12.questionDot, 2);
            }
            if (63 === next) {
              if (ecmaVersion >= 12) {
                if (61 === this.input.charCodeAt(this.pos + 2))
                  return this.finishOp(types$12.assign, 3);
              }
              return this.finishOp(types$12.coalesce, 2);
            }
          }
          return this.finishOp(types$12.question, 1);
        }, pp2.readToken_numberSign = function() {
          var code = 35;
          if (this.options.ecmaVersion >= 13 && (++this.pos, isIdentifierStart2(code = this.fullCharCodeAtPos(), true) || 92 === code))
            return this.finishToken(types$12.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + codePointToString2(code) + "'");
        }, pp2.getTokenFromCode = function(code) {
          switch (code) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(types$12.parenL);
            case 41:
              return ++this.pos, this.finishToken(types$12.parenR);
            case 59:
              return ++this.pos, this.finishToken(types$12.semi);
            case 44:
              return ++this.pos, this.finishToken(types$12.comma);
            case 91:
              return ++this.pos, this.finishToken(types$12.bracketL);
            case 93:
              return ++this.pos, this.finishToken(types$12.bracketR);
            case 123:
              return ++this.pos, this.finishToken(types$12.braceL);
            case 125:
              return ++this.pos, this.finishToken(types$12.braceR);
            case 58:
              return ++this.pos, this.finishToken(types$12.colon);
            case 96:
              if (this.options.ecmaVersion < 6)
                break;
              return ++this.pos, this.finishToken(types$12.backQuote);
            case 48:
              var next = this.input.charCodeAt(this.pos + 1);
              if (120 === next || 88 === next)
                return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if (111 === next || 79 === next)
                  return this.readRadixNumber(8);
                if (98 === next || 66 === next)
                  return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(false);
            case 34:
            case 39:
              return this.readString(code);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(code);
            case 124:
            case 38:
              return this.readToken_pipe_amp(code);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(code);
            case 60:
            case 62:
              return this.readToken_lt_gt(code);
            case 61:
            case 33:
              return this.readToken_eq_excl(code);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(types$12.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString2(code) + "'");
        }, pp2.finishOp = function(type, size) {
          var str = this.input.slice(this.pos, this.pos + size);
          return this.pos += size, this.finishToken(type, str);
        }, pp2.readRegexp = function() {
          for (var escaped, inClass, start = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(start, "Unterminated regular expression");
            var ch = this.input.charAt(this.pos);
            if (lineBreak2.test(ch) && this.raise(start, "Unterminated regular expression"), escaped)
              escaped = false;
            else {
              if ("[" === ch)
                inClass = true;
              else if ("]" === ch && inClass)
                inClass = false;
              else if ("/" === ch && !inClass)
                break;
              escaped = "\\" === ch;
            }
            ++this.pos;
          }
          var pattern = this.input.slice(start, this.pos);
          ++this.pos;
          var flagsStart = this.pos, flags = this.readWord1();
          this.containsEsc && this.unexpected(flagsStart);
          var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
          state.reset(start, pattern, flags), this.validateRegExpFlags(state), this.validateRegExpPattern(state);
          var value2 = null;
          try {
            value2 = new RegExp(pattern, flags);
          } catch (e) {
          }
          return this.finishToken(types$12.regexp, { pattern, flags, value: value2 });
        }, pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
          for (var allowSeparators = this.options.ecmaVersion >= 12 && void 0 === len, isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && 48 === this.input.charCodeAt(this.pos), start = this.pos, total = 0, lastCode = 0, i2 = 0, e = null == len ? 1 / 0 : len; i2 < e; ++i2, ++this.pos) {
            var code = this.input.charCodeAt(this.pos), val = void 0;
            if (allowSeparators && 95 === code)
              isLegacyOctalNumericLiteral && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 95 === lastCode && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 0 === i2 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), lastCode = code;
            else {
              if ((val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : code >= 48 && code <= 57 ? code - 48 : 1 / 0) >= radix)
                break;
              lastCode = code, total = total * radix + val;
            }
          }
          return allowSeparators && 95 === lastCode && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === start || null != len && this.pos - start !== len ? null : total;
        }, pp2.readRadixNumber = function(radix) {
          var start = this.pos;
          this.pos += 2;
          var val = this.readInt(radix);
          return null == val && this.raise(this.start + 2, "Expected number in radix " + radix), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (val = stringToBigInt2(this.input.slice(start, this.pos)), ++this.pos) : isIdentifierStart2(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(types$12.num, val);
        }, pp2.readNumber = function(startsWithDot) {
          var start = this.pos;
          startsWithDot || null !== this.readInt(10, void 0, true) || this.raise(start, "Invalid number");
          var octal = this.pos - start >= 2 && 48 === this.input.charCodeAt(start);
          octal && this.strict && this.raise(start, "Invalid number");
          var next = this.input.charCodeAt(this.pos);
          if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && 110 === next) {
            var val$1 = stringToBigInt2(this.input.slice(start, this.pos));
            return ++this.pos, isIdentifierStart2(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(types$12.num, val$1);
          }
          octal && /[89]/.test(this.input.slice(start, this.pos)) && (octal = false), 46 !== next || octal || (++this.pos, this.readInt(10), next = this.input.charCodeAt(this.pos)), 69 !== next && 101 !== next || octal || (43 !== (next = this.input.charCodeAt(++this.pos)) && 45 !== next || ++this.pos, null === this.readInt(10) && this.raise(start, "Invalid number")), isIdentifierStart2(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
          var str, val = (str = this.input.slice(start, this.pos), octal ? parseInt(str, 8) : parseFloat(str.replace(/_/g, "")));
          return this.finishToken(types$12.num, val);
        }, pp2.readCodePoint = function() {
          var code;
          if (123 === this.input.charCodeAt(this.pos)) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var codePos = ++this.pos;
            code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, code > 1114111 && this.invalidStringToken(codePos, "Code point out of bounds");
          } else
            code = this.readHexChar(4);
          return code;
        }, pp2.readString = function(quote) {
          for (var out = "", chunkStart = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var ch = this.input.charCodeAt(this.pos);
            if (ch === quote)
              break;
            92 === ch ? (out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(false), chunkStart = this.pos) : 8232 === ch || 8233 === ch ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (isNewLine2(ch) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
          }
          return out += this.input.slice(chunkStart, this.pos++), this.finishToken(types$12.string, out);
        };
        var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
        pp2.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (err) {
            if (err !== INVALID_TEMPLATE_ESCAPE_ERROR2)
              throw err;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = false;
        }, pp2.invalidStringToken = function(position, message) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9)
            throw INVALID_TEMPLATE_ESCAPE_ERROR2;
          this.raise(position, message);
        }, pp2.readTmplToken = function() {
          for (var out = "", chunkStart = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
            var ch = this.input.charCodeAt(this.pos);
            if (96 === ch || 36 === ch && 123 === this.input.charCodeAt(this.pos + 1))
              return this.pos !== this.start || this.type !== types$12.template && this.type !== types$12.invalidTemplate ? (out += this.input.slice(chunkStart, this.pos), this.finishToken(types$12.template, out)) : 36 === ch ? (this.pos += 2, this.finishToken(types$12.dollarBraceL)) : (++this.pos, this.finishToken(types$12.backQuote));
            if (92 === ch)
              out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(true), chunkStart = this.pos;
            else if (isNewLine2(ch)) {
              switch (out += this.input.slice(chunkStart, this.pos), ++this.pos, ch) {
                case 13:
                  10 === this.input.charCodeAt(this.pos) && ++this.pos;
                case 10:
                  out += "\n";
                  break;
                default:
                  out += String.fromCharCode(ch);
              }
              this.options.locations && (++this.curLine, this.lineStart = this.pos), chunkStart = this.pos;
            } else
              ++this.pos;
          }
        }, pp2.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++)
            switch (this.input[this.pos]) {
              case "\\":
                ++this.pos;
                break;
              case "$":
                if ("{" !== this.input[this.pos + 1])
                  break;
              case "`":
                return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
            }
          this.raise(this.start, "Unterminated template");
        }, pp2.readEscapedChar = function(inTemplate) {
          var ch = this.input.charCodeAt(++this.pos);
          switch (++this.pos, ch) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return codePointToString2(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              10 === this.input.charCodeAt(this.pos) && ++this.pos;
            case 10:
              return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
            case 56:
            case 57:
              if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), inTemplate) {
                var codePos = this.pos - 1;
                this.invalidStringToken(codePos, "Invalid escape sequence in template string");
              }
            default:
              if (ch >= 48 && ch <= 55) {
                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
                return octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), this.pos += octalStr.length - 1, ch = this.input.charCodeAt(this.pos), "0" === octalStr && 56 !== ch && 57 !== ch || !this.strict && !inTemplate || this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(octal);
              }
              return isNewLine2(ch) ? "" : String.fromCharCode(ch);
          }
        }, pp2.readHexChar = function(len) {
          var codePos = this.pos, n = this.readInt(16, len);
          return null === n && this.invalidStringToken(codePos, "Bad character escape sequence"), n;
        }, pp2.readWord1 = function() {
          this.containsEsc = false;
          for (var word = "", first = true, chunkStart = this.pos, astral = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
            var ch = this.fullCharCodeAtPos();
            if (isIdentifierChar2(ch, astral))
              this.pos += ch <= 65535 ? 1 : 2;
            else {
              if (92 !== ch)
                break;
              this.containsEsc = true, word += this.input.slice(chunkStart, this.pos);
              var escStart = this.pos;
              117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
              var esc = this.readCodePoint();
              (first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral) || this.invalidStringToken(escStart, "Invalid Unicode escape"), word += codePointToString2(esc), chunkStart = this.pos;
            }
            first = false;
          }
          return word + this.input.slice(chunkStart, this.pos);
        }, pp2.readWord = function() {
          var word = this.readWord1(), type = types$12.name;
          return this.keywords.test(word) && (type = keywords2[word]), this.finishToken(type, word);
        };
        Parser3.acorn = { Parser: Parser3, version: "8.9.0", defaultOptions: defaultOptions2, Position: Position3, SourceLocation: SourceLocation3, getLineInfo: getLineInfo2, Node: Node3, TokenType: TokenType3, tokTypes: types$12, keywordTypes: keywords2, TokContext: TokContext3, tokContexts: types2, isIdentifierChar: isIdentifierChar2, isIdentifierStart: isIdentifierStart2, Token: Token3, isNewLine: isNewLine2, lineBreak: lineBreak2, lineBreakG: lineBreakG2, nonASCIIwhitespace: nonASCIIwhitespace2 };
        const external_node_module_namespaceObject = require_module(), external_node_fs_namespaceObject = require_fs(), external_node_url_namespaceObject = require_url();
        Math.floor, String.fromCharCode;
        const TRAILING_SLASH_RE2 = /\/$|\/\?/;
        function hasTrailingSlash2(input = "", queryParameters = false) {
          return queryParameters ? TRAILING_SLASH_RE2.test(input) : input.endsWith("/");
        }
        function withTrailingSlash2(input = "", queryParameters = false) {
          if (!queryParameters)
            return input.endsWith("/") ? input : input + "/";
          if (hasTrailingSlash2(input, true))
            return input || "/";
          const [s0, ...s] = input.split("?");
          return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "");
        }
        function hasLeadingSlash2(input = "") {
          return input.startsWith("/");
        }
        function withoutLeadingSlash2(input = "") {
          return (hasLeadingSlash2(input) ? input.slice(1) : input) || "/";
        }
        function isNonEmptyURL2(url) {
          return url && "/" !== url;
        }
        function joinURL2(base, ...input) {
          let url = base || "";
          for (const index2 of input.filter((url2) => isNonEmptyURL2(url2)))
            url = url ? withTrailingSlash2(url) + withoutLeadingSlash2(index2) : index2;
          return url;
        }
        const external_node_assert_namespaceObject = require_assert(), external_node_process_namespaceObject = require_process(), external_node_path_namespaceObject = require_path(), external_node_v8_namespaceObject = require_v8(), external_node_util_namespaceObject = require_util(), BUILTIN_MODULES2 = new Set(external_node_module_namespaceObject.builtinModules);
        function normalizeSlash2(string_) {
          return string_.replace(/\\/g, "/");
        }
        const isWindows3 = "win32" === external_node_process_namespaceObject.platform, own$12 = {}.hasOwnProperty, classRegExp2 = /^([A-Z][a-z\d]*)+$/, kTypes2 = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), codes2 = {};
        function formatList2(array, type = "and") {
          return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
        }
        const messages2 = /* @__PURE__ */ new Map();
        let userStackTraceLimit2;
        function createError2(sym, value2, def) {
          return messages2.set(sym, value2), function(Base, key) {
            return NodeError;
            function NodeError(...args) {
              const limit = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable2() && (Error.stackTraceLimit = 0);
              const error = new Base();
              isErrorStackTraceLimitWritable2() && (Error.stackTraceLimit = limit);
              const message = function(key2, args2, self2) {
                const message2 = messages2.get(key2);
                if (external_node_assert_namespaceObject(void 0 !== message2, "expected `message` to be found"), "function" == typeof message2)
                  return external_node_assert_namespaceObject(message2.length <= args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${message2.length}).`), Reflect.apply(message2, self2, args2);
                const regex = /%[dfijoOs]/g;
                let expectedLength = 0;
                for (; null !== regex.exec(message2); )
                  expectedLength++;
                return external_node_assert_namespaceObject(expectedLength === args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${expectedLength}).`), 0 === args2.length ? message2 : (args2.unshift(message2), Reflect.apply(external_node_util_namespaceObject.format, null, args2));
              }(key, args, error);
              return Object.defineProperties(error, { message: { value: message, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${key}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), captureLargerStackTrace2(error), error.code = key, error;
            }
          }(def, sym);
        }
        function isErrorStackTraceLimitWritable2() {
          try {
            if (external_node_v8_namespaceObject.startupSnapshot.isBuildingSnapshot())
              return false;
          } catch {
          }
          const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return void 0 === desc ? Object.isExtensible(Error) : own$12.call(desc, "writable") && void 0 !== desc.writable ? desc.writable : void 0 !== desc.set;
        }
        codes2.ERR_INVALID_ARG_TYPE = createError2("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
          external_node_assert_namespaceObject("string" == typeof name, "'name' must be a string"), Array.isArray(expected) || (expected = [expected]);
          let message = "The ";
          if (name.endsWith(" argument"))
            message += `${name} `;
          else {
            const type = name.includes(".") ? "property" : "argument";
            message += `"${name}" ${type} `;
          }
          message += "must be ";
          const types3 = [], instances = [], other = [];
          for (const value2 of expected)
            external_node_assert_namespaceObject("string" == typeof value2, "All expected entries have to be of type string"), kTypes2.has(value2) ? types3.push(value2.toLowerCase()) : null === classRegExp2.exec(value2) ? (external_node_assert_namespaceObject("object" !== value2, 'The value "object" should be written as "Object"'), other.push(value2)) : instances.push(value2);
          if (instances.length > 0) {
            const pos = types3.indexOf("object");
            -1 !== pos && (types3.slice(pos, 1), instances.push("Object"));
          }
          return types3.length > 0 && (message += `${types3.length > 1 ? "one of type" : "of type"} ${formatList2(types3, "or")}`, (instances.length > 0 || other.length > 0) && (message += " or ")), instances.length > 0 && (message += `an instance of ${formatList2(instances, "or")}`, other.length > 0 && (message += " or ")), other.length > 0 && (other.length > 1 ? message += `one of ${formatList2(other, "or")}` : (other[0].toLowerCase() !== other[0] && (message += "an "), message += `${other[0]}`)), message += `. Received ${function(value2) {
            if (null == value2)
              return String(value2);
            if ("function" == typeof value2 && value2.name)
              return `function ${value2.name}`;
            if ("object" == typeof value2)
              return value2.constructor && value2.constructor.name ? `an instance of ${value2.constructor.name}` : `${(0, external_node_util_namespaceObject.inspect)(value2, { depth: -1 })}`;
            let inspected = (0, external_node_util_namespaceObject.inspect)(value2, { colors: false });
            inspected.length > 28 && (inspected = `${inspected.slice(0, 25)}...`);
            return `type ${typeof value2} (${inspected})`;
          }(actual)}`, message;
        }, TypeError), codes2.ERR_INVALID_MODULE_SPECIFIER = createError2("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base = void 0) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`, TypeError), codes2.ERR_INVALID_PACKAGE_CONFIG = createError2("ERR_INVALID_PACKAGE_CONFIG", (path3, base, message) => `Invalid package config ${path3}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`, Error), codes2.ERR_INVALID_PACKAGE_TARGET = createError2("ERR_INVALID_PACKAGE_TARGET", (pkgPath, key, target, isImport = false, base = void 0) => {
          const relError = "string" == typeof target && !isImport && target.length > 0 && !target.startsWith("./");
          return "." === key ? (external_node_assert_namespaceObject(false === isImport), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }, Error), codes2.ERR_MODULE_NOT_FOUND = createError2("ERR_MODULE_NOT_FOUND", (path3, base, type = "package") => `Cannot find ${type} '${path3}' imported from ${base}`, Error), codes2.ERR_NETWORK_IMPORT_DISALLOWED = createError2("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), codes2.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError2("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`, TypeError), codes2.ERR_PACKAGE_PATH_NOT_EXPORTED = createError2("ERR_PACKAGE_PATH_NOT_EXPORTED", (pkgPath, subpath, base = void 0) => "." === subpath ? `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`, Error), codes2.ERR_UNSUPPORTED_DIR_IMPORT = createError2("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), codes2.ERR_UNKNOWN_FILE_EXTENSION = createError2("ERR_UNKNOWN_FILE_EXTENSION", (ext, path3) => `Unknown file extension "${ext}" for ${path3}`, TypeError), codes2.ERR_INVALID_ARG_VALUE = createError2("ERR_INVALID_ARG_VALUE", (name, value2, reason = "is invalid") => {
          let inspected = (0, external_node_util_namespaceObject.inspect)(value2);
          inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`);
          return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
        }, TypeError), codes2.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError2("ERR_UNSUPPORTED_ESM_URL_SCHEME", (url, supported) => {
          let message = `Only URLs with a scheme in: ${formatList2(supported)} are supported by the default ESM loader`;
          return isWindows3 && 2 === url.protocol.length && (message += ". On Windows, absolute paths must be valid file:// URLs"), message += `. Received protocol '${url.protocol}'`, message;
        }, Error);
        const captureLargerStackTrace2 = function(fn) {
          const hidden = "__node_internal_" + fn.name;
          return Object.defineProperty(fn, "name", { value: hidden }), fn;
        }(function(error) {
          const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable2();
          return stackTraceLimitIsWritable && (userStackTraceLimit2 = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit2), error;
        });
        const packageJsonReader2 = { read: function(jsonPath) {
          try {
            return { string: external_node_fs_namespaceObject.readFileSync(external_node_path_namespaceObject.toNamespacedPath(external_node_path_namespaceObject.join(external_node_path_namespaceObject.dirname(jsonPath), "package.json")), "utf8") };
          } catch (error) {
            const exception = error;
            if ("ENOENT" === exception.code)
              return { string: void 0 };
            throw exception;
          }
        } };
        const { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$12 } = codes2, packageJsonCache2 = /* @__PURE__ */ new Map();
        function getPackageConfig2(path3, specifier, base) {
          const existing = packageJsonCache2.get(path3);
          if (void 0 !== existing)
            return existing;
          const source = packageJsonReader2.read(path3).string;
          if (void 0 === source) {
            const packageConfig2 = { pjsonPath: path3, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
            return packageJsonCache2.set(path3, packageConfig2), packageConfig2;
          }
          let packageJson;
          try {
            packageJson = JSON.parse(source);
          } catch (error) {
            const exception = error;
            throw new ERR_INVALID_PACKAGE_CONFIG$12(path3, (base ? `"${specifier}" from ` : "") + (0, external_node_url_namespaceObject.fileURLToPath)(base || specifier), exception.message);
          }
          const { exports: exports3, imports, main, name, type } = packageJson, packageConfig = { pjsonPath: path3, exists: true, main: "string" == typeof main ? main : void 0, name: "string" == typeof name ? name : void 0, type: "module" === type || "commonjs" === type ? type : "none", exports: exports3, imports: imports && "object" == typeof imports ? imports : void 0 };
          return packageJsonCache2.set(path3, packageConfig), packageConfig;
        }
        function getPackageScopeConfig2(resolved) {
          let packageJsonUrl = new external_node_url_namespaceObject.URL("package.json", resolved);
          for (; ; ) {
            if (packageJsonUrl.pathname.endsWith("node_modules/package.json"))
              break;
            const packageConfig2 = getPackageConfig2((0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl), resolved);
            if (packageConfig2.exists)
              return packageConfig2;
            const lastPackageJsonUrl = packageJsonUrl;
            if (packageJsonUrl = new external_node_url_namespaceObject.URL("../package.json", packageJsonUrl), packageJsonUrl.pathname === lastPackageJsonUrl.pathname)
              break;
          }
          const packageJsonPath = (0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl), packageConfig = { pjsonPath: packageJsonPath, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          return packageJsonCache2.set(packageJsonPath, packageConfig), packageConfig;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: ERR_UNKNOWN_FILE_EXTENSION2 } = codes2, dist_hasOwnProperty = {}.hasOwnProperty, extensionFormatMap2 = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" };
        const protocolHandlers2 = { __proto__: null, "data:": function(parsed) {
          const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
          return function(mime2) {
            return mime2 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime2) ? "module" : "application/json" === mime2 ? "json" : null;
          }(mime);
        }, "file:": function(url, _context, ignoreErrors) {
          const ext = function(url2) {
            const pathname = url2.pathname;
            let index2 = pathname.length;
            for (; index2--; ) {
              const code = pathname.codePointAt(index2);
              if (47 === code)
                return "";
              if (46 === code)
                return 47 === pathname.codePointAt(index2 - 1) ? "" : pathname.slice(index2);
            }
            return "";
          }(url);
          if (".js" === ext)
            return "module" === function(url2) {
              return getPackageScopeConfig2(url2).type;
            }(url) ? "module" : "commonjs";
          const format2 = extensionFormatMap2[ext];
          if (format2)
            return format2;
          if (ignoreErrors)
            return;
          const filepath = (0, external_node_url_namespaceObject.fileURLToPath)(url);
          throw new ERR_UNKNOWN_FILE_EXTENSION2(ext, filepath);
        }, "http:": getHttpProtocolModuleFormat2, "https:": getHttpProtocolModuleFormat2, "node:": () => "builtin" };
        function getHttpProtocolModuleFormat2() {
        }
        const RegExpPrototypeSymbolReplace2 = RegExp.prototype[Symbol.replace], { ERR_NETWORK_IMPORT_DISALLOWED: ERR_NETWORK_IMPORT_DISALLOWED2, ERR_INVALID_MODULE_SPECIFIER: ERR_INVALID_MODULE_SPECIFIER2, ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2, ERR_INVALID_PACKAGE_TARGET: ERR_INVALID_PACKAGE_TARGET2, ERR_MODULE_NOT_FOUND: ERR_MODULE_NOT_FOUND2, ERR_PACKAGE_IMPORT_NOT_DEFINED: ERR_PACKAGE_IMPORT_NOT_DEFINED2, ERR_PACKAGE_PATH_NOT_EXPORTED: ERR_PACKAGE_PATH_NOT_EXPORTED2, ERR_UNSUPPORTED_DIR_IMPORT: ERR_UNSUPPORTED_DIR_IMPORT2, ERR_UNSUPPORTED_ESM_URL_SCHEME: ERR_UNSUPPORTED_ESM_URL_SCHEME2 } = codes2, own2 = {}.hasOwnProperty, invalidSegmentRegEx2 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, deprecatedInvalidSegmentRegEx2 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, invalidPackageNameRegEx2 = /^\.|%|\\/, patternRegEx2 = /\*/g, encodedSepRegEx2 = /%2f|%5c/i, emittedPackageWarnings2 = /* @__PURE__ */ new Set(), doubleSlashRegEx2 = /[/\\]{2}/;
        function emitInvalidSegmentDeprecation2(target, request, match, packageJsonUrl, internal2, base, isTarget) {
          const pjsonPath = (0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl), double = null !== doubleSlashRegEx2.exec(isTarget ? target : request);
          external_node_process_namespaceObject.emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal2 ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, external_node_url_namespaceObject.fileURLToPath)(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function emitLegacyIndexDeprecation2(url, packageJsonUrl, base, main) {
          const format2 = function(url2, context) {
            return dist_hasOwnProperty.call(protocolHandlers2, url2.protocol) && protocolHandlers2[url2.protocol](url2, context, true) || null;
          }(url, { parentURL: base.href });
          if ("module" !== format2)
            return;
          const path3 = (0, external_node_url_namespaceObject.fileURLToPath)(url.href), pkgPath = (0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".", packageJsonUrl)), basePath = (0, external_node_url_namespaceObject.fileURLToPath)(base);
          main ? external_node_process_namespaceObject.emitWarning(`Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path3.slice(pkgPath.length)}", imported from ${basePath}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`, "DeprecationWarning", "DEP0151") : external_node_process_namespaceObject.emitWarning(`No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path3.slice(pkgPath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function tryStatSync2(path3) {
          try {
            return (0, external_node_fs_namespaceObject.statSync)(path3);
          } catch {
            return new external_node_fs_namespaceObject.Stats();
          }
        }
        function fileExists2(url) {
          const stats = (0, external_node_fs_namespaceObject.statSync)(url, { throwIfNoEntry: false }), isFile = stats ? stats.isFile() : void 0;
          return null != isFile && isFile;
        }
        function legacyMainResolve2(packageJsonUrl, packageConfig, base) {
          let guess;
          if (void 0 !== packageConfig.main) {
            if (guess = new external_node_url_namespaceObject.URL(packageConfig.main, packageJsonUrl), fileExists2(guess))
              return guess;
            const tries2 = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
            let i3 = -1;
            for (; ++i3 < tries2.length && (guess = new external_node_url_namespaceObject.URL(tries2[i3], packageJsonUrl), !fileExists2(guess)); )
              guess = void 0;
            if (guess)
              return emitLegacyIndexDeprecation2(guess, packageJsonUrl, base, packageConfig.main), guess;
          }
          const tries = ["./index.js", "./index.json", "./index.node"];
          let i2 = -1;
          for (; ++i2 < tries.length && (guess = new external_node_url_namespaceObject.URL(tries[i2], packageJsonUrl), !fileExists2(guess)); )
            guess = void 0;
          if (guess)
            return emitLegacyIndexDeprecation2(guess, packageJsonUrl, base, packageConfig.main), guess;
          throw new ERR_MODULE_NOT_FOUND2((0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".", packageJsonUrl)), (0, external_node_url_namespaceObject.fileURLToPath)(base));
        }
        function exportsNotFound2(subpath, packageJsonUrl, base) {
          return new ERR_PACKAGE_PATH_NOT_EXPORTED2((0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".", packageJsonUrl)), subpath, base && (0, external_node_url_namespaceObject.fileURLToPath)(base));
        }
        function invalidPackageTarget2(subpath, target, packageJsonUrl, internal2, base) {
          return target = "object" == typeof target && null !== target ? JSON.stringify(target, null, "") : `${target}`, new ERR_INVALID_PACKAGE_TARGET2((0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".", packageJsonUrl)), subpath, target, internal2, base && (0, external_node_url_namespaceObject.fileURLToPath)(base));
        }
        function resolvePackageTargetString2(target, subpath, match, packageJsonUrl, base, pattern, internal2, isPathMap, conditions) {
          if ("" !== subpath && !pattern && "/" !== target[target.length - 1])
            throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
          if (!target.startsWith("./")) {
            if (internal2 && !target.startsWith("../") && !target.startsWith("/")) {
              let isURL = false;
              try {
                new external_node_url_namespaceObject.URL(target), isURL = true;
              } catch {
              }
              if (!isURL) {
                return packageResolve2(pattern ? RegExpPrototypeSymbolReplace2.call(patternRegEx2, target, () => subpath) : target + subpath, packageJsonUrl, conditions);
              }
            }
            throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
          }
          if (null !== invalidSegmentRegEx2.exec(target.slice(2))) {
            if (null !== deprecatedInvalidSegmentRegEx2.exec(target.slice(2)))
              throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
            if (!isPathMap) {
              const request = pattern ? match.replace("*", () => subpath) : match + subpath;
              emitInvalidSegmentDeprecation2(pattern ? RegExpPrototypeSymbolReplace2.call(patternRegEx2, target, () => subpath) : target, request, match, packageJsonUrl, internal2, base, true);
            }
          }
          const resolved = new external_node_url_namespaceObject.URL(target, packageJsonUrl), resolvedPath = resolved.pathname, packagePath = new external_node_url_namespaceObject.URL(".", packageJsonUrl).pathname;
          if (!resolvedPath.startsWith(packagePath))
            throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
          if ("" === subpath)
            return resolved;
          if (null !== invalidSegmentRegEx2.exec(subpath)) {
            const request = pattern ? match.replace("*", () => subpath) : match + subpath;
            if (null === deprecatedInvalidSegmentRegEx2.exec(subpath)) {
              if (!isPathMap) {
                emitInvalidSegmentDeprecation2(pattern ? RegExpPrototypeSymbolReplace2.call(patternRegEx2, target, () => subpath) : target, request, match, packageJsonUrl, internal2, base, false);
              }
            } else
              !function(request2, match2, packageJsonUrl2, internal3, base2) {
                const reason = `request is not a valid match in pattern "${match2}" for the "${internal3 ? "imports" : "exports"}" resolution of ${(0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl2)}`;
                throw new ERR_INVALID_MODULE_SPECIFIER2(request2, reason, base2 && (0, external_node_url_namespaceObject.fileURLToPath)(base2));
              }(request, match, packageJsonUrl, internal2, base);
          }
          return pattern ? new external_node_url_namespaceObject.URL(RegExpPrototypeSymbolReplace2.call(patternRegEx2, resolved.href, () => subpath)) : new external_node_url_namespaceObject.URL(subpath, resolved);
        }
        function isArrayIndex2(key) {
          const keyNumber = Number(key);
          return `${keyNumber}` === key && (keyNumber >= 0 && keyNumber < 4294967295);
        }
        function resolvePackageTarget2(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal2, isPathMap, conditions) {
          if ("string" == typeof target)
            return resolvePackageTargetString2(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal2, isPathMap, conditions);
          if (Array.isArray(target)) {
            const targetList = target;
            if (0 === targetList.length)
              return null;
            let lastException, i2 = -1;
            for (; ++i2 < targetList.length; ) {
              const targetItem = targetList[i2];
              let resolveResult;
              try {
                resolveResult = resolvePackageTarget2(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal2, isPathMap, conditions);
              } catch (error) {
                if (lastException = error, "ERR_INVALID_PACKAGE_TARGET" === error.code)
                  continue;
                throw error;
              }
              if (void 0 !== resolveResult) {
                if (null !== resolveResult)
                  return resolveResult;
                lastException = null;
              }
            }
            if (null == lastException)
              return null;
            throw lastException;
          }
          if ("object" == typeof target && null !== target) {
            const keys2 = Object.getOwnPropertyNames(target);
            let i2 = -1;
            for (; ++i2 < keys2.length; ) {
              if (isArrayIndex2(keys2[i2]))
                throw new ERR_INVALID_PACKAGE_CONFIG2((0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
            }
            for (i2 = -1; ++i2 < keys2.length; ) {
              const key = keys2[i2];
              if ("default" === key || conditions && conditions.has(key)) {
                const resolveResult = resolvePackageTarget2(packageJsonUrl, target[key], subpath, packageSubpath, base, pattern, internal2, isPathMap, conditions);
                if (void 0 === resolveResult)
                  continue;
                return resolveResult;
              }
            }
            return null;
          }
          if (null === target)
            return null;
          throw invalidPackageTarget2(packageSubpath, target, packageJsonUrl, internal2, base);
        }
        function emitTrailingSlashPatternDeprecation2(match, pjsonUrl, base) {
          const pjsonPath = (0, external_node_url_namespaceObject.fileURLToPath)(pjsonUrl);
          emittedPackageWarnings2.has(pjsonPath + "|" + match) || (emittedPackageWarnings2.add(pjsonPath + "|" + match), external_node_process_namespaceObject.emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, external_node_url_namespaceObject.fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function packageExportsResolve2(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
          let exports3 = packageConfig.exports;
          if (function(exports4, packageJsonUrl2, base2) {
            if ("string" == typeof exports4 || Array.isArray(exports4))
              return true;
            if ("object" != typeof exports4 || null === exports4)
              return false;
            const keys3 = Object.getOwnPropertyNames(exports4);
            let isConditionalSugar = false, i3 = 0, j = -1;
            for (; ++j < keys3.length; ) {
              const key = keys3[j], curIsConditionalSugar = "" === key || "." !== key[0];
              if (0 == i3++)
                isConditionalSugar = curIsConditionalSugar;
              else if (isConditionalSugar !== curIsConditionalSugar)
                throw new ERR_INVALID_PACKAGE_CONFIG2((0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl2), base2, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return isConditionalSugar;
          }(exports3, packageJsonUrl, base) && (exports3 = { ".": exports3 }), own2.call(exports3, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
            const resolveResult = resolvePackageTarget2(packageJsonUrl, exports3[packageSubpath], "", packageSubpath, base, false, false, false, conditions);
            if (null == resolveResult)
              throw exportsNotFound2(packageSubpath, packageJsonUrl, base);
            return resolveResult;
          }
          let bestMatch = "", bestMatchSubpath = "";
          const keys2 = Object.getOwnPropertyNames(exports3);
          let i2 = -1;
          for (; ++i2 < keys2.length; ) {
            const key = keys2[i2], patternIndex = key.indexOf("*");
            if (-1 !== patternIndex && packageSubpath.startsWith(key.slice(0, patternIndex))) {
              packageSubpath.endsWith("/") && emitTrailingSlashPatternDeprecation2(packageSubpath, packageJsonUrl, base);
              const patternTrailer = key.slice(patternIndex + 1);
              packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && 1 === patternKeyCompare2(bestMatch, key) && key.lastIndexOf("*") === patternIndex && (bestMatch = key, bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length));
            }
          }
          if (bestMatch) {
            const resolveResult = resolvePackageTarget2(packageJsonUrl, exports3[bestMatch], bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
            if (null == resolveResult)
              throw exportsNotFound2(packageSubpath, packageJsonUrl, base);
            return resolveResult;
          }
          throw exportsNotFound2(packageSubpath, packageJsonUrl, base);
        }
        function patternKeyCompare2(a, b) {
          const aPatternIndex = a.indexOf("*"), bPatternIndex = b.indexOf("*"), baseLengthA = -1 === aPatternIndex ? a.length : aPatternIndex + 1, baseLengthB = -1 === bPatternIndex ? b.length : bPatternIndex + 1;
          return baseLengthA > baseLengthB ? -1 : baseLengthB > baseLengthA || -1 === aPatternIndex ? 1 : -1 === bPatternIndex || a.length > b.length ? -1 : b.length > a.length ? 1 : 0;
        }
        function packageImportsResolve2(name, base, conditions) {
          if ("#" === name || name.startsWith("#/") || name.endsWith("/")) {
            throw new ERR_INVALID_MODULE_SPECIFIER2(name, "is not a valid internal imports specifier name", (0, external_node_url_namespaceObject.fileURLToPath)(base));
          }
          let packageJsonUrl;
          const packageConfig = getPackageScopeConfig2(base);
          if (packageConfig.exists) {
            packageJsonUrl = (0, external_node_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);
            const imports = packageConfig.imports;
            if (imports)
              if (own2.call(imports, name) && !name.includes("*")) {
                const resolveResult = resolvePackageTarget2(packageJsonUrl, imports[name], "", name, base, false, true, false, conditions);
                if (null != resolveResult)
                  return resolveResult;
              } else {
                let bestMatch = "", bestMatchSubpath = "";
                const keys2 = Object.getOwnPropertyNames(imports);
                let i2 = -1;
                for (; ++i2 < keys2.length; ) {
                  const key = keys2[i2], patternIndex = key.indexOf("*");
                  if (-1 !== patternIndex && name.startsWith(key.slice(0, -1))) {
                    const patternTrailer = key.slice(patternIndex + 1);
                    name.length >= key.length && name.endsWith(patternTrailer) && 1 === patternKeyCompare2(bestMatch, key) && key.lastIndexOf("*") === patternIndex && (bestMatch = key, bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length));
                  }
                }
                if (bestMatch) {
                  const resolveResult = resolvePackageTarget2(packageJsonUrl, imports[bestMatch], bestMatchSubpath, bestMatch, base, true, true, false, conditions);
                  if (null != resolveResult)
                    return resolveResult;
                }
              }
          }
          throw function(specifier, packageJsonUrl2, base2) {
            return new ERR_PACKAGE_IMPORT_NOT_DEFINED2(specifier, packageJsonUrl2 && (0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".", packageJsonUrl2)), (0, external_node_url_namespaceObject.fileURLToPath)(base2));
          }(name, packageJsonUrl, base);
        }
        function packageResolve2(specifier, base, conditions) {
          if (external_node_module_namespaceObject.builtinModules.includes(specifier))
            return new external_node_url_namespaceObject.URL("node:" + specifier);
          const { packageName, packageSubpath, isScoped } = function(specifier2, base2) {
            let separatorIndex = specifier2.indexOf("/"), validPackageName = true, isScoped2 = false;
            "@" === specifier2[0] && (isScoped2 = true, -1 === separatorIndex || 0 === specifier2.length ? validPackageName = false : separatorIndex = specifier2.indexOf("/", separatorIndex + 1));
            const packageName2 = -1 === separatorIndex ? specifier2 : specifier2.slice(0, separatorIndex);
            if (null !== invalidPackageNameRegEx2.exec(packageName2) && (validPackageName = false), !validPackageName)
              throw new ERR_INVALID_MODULE_SPECIFIER2(specifier2, "is not a valid package name", (0, external_node_url_namespaceObject.fileURLToPath)(base2));
            return { packageName: packageName2, packageSubpath: "." + (-1 === separatorIndex ? "" : specifier2.slice(separatorIndex)), isScoped: isScoped2 };
          }(specifier, base), packageConfig = getPackageScopeConfig2(base);
          if (packageConfig.exists) {
            const packageJsonUrl2 = (0, external_node_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);
            if (packageConfig.name === packageName && void 0 !== packageConfig.exports && null !== packageConfig.exports)
              return packageExportsResolve2(packageJsonUrl2, packageSubpath, packageConfig, base, conditions);
          }
          let lastPath, packageJsonUrl = new external_node_url_namespaceObject.URL("./node_modules/" + packageName + "/package.json", base), packageJsonPath = (0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl);
          do {
            if (!tryStatSync2(packageJsonPath.slice(0, -13)).isDirectory()) {
              lastPath = packageJsonPath, packageJsonUrl = new external_node_url_namespaceObject.URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl), packageJsonPath = (0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl);
              continue;
            }
            const packageConfig2 = getPackageConfig2(packageJsonPath, specifier, base);
            return void 0 !== packageConfig2.exports && null !== packageConfig2.exports ? packageExportsResolve2(packageJsonUrl, packageSubpath, packageConfig2, base, conditions) : "." === packageSubpath ? legacyMainResolve2(packageJsonUrl, packageConfig2, base) : new external_node_url_namespaceObject.URL(packageSubpath, packageJsonUrl);
          } while (packageJsonPath.length !== lastPath.length);
          throw new ERR_MODULE_NOT_FOUND2(packageName, (0, external_node_url_namespaceObject.fileURLToPath)(base));
        }
        function moduleResolve2(specifier, base, conditions, preserveSymlinks) {
          const protocol = base.protocol, isRemote = "http:" === protocol || "https:" === protocol;
          let resolved;
          if (function(specifier2) {
            return "" !== specifier2 && ("/" === specifier2[0] || function(specifier3) {
              if ("." === specifier3[0]) {
                if (1 === specifier3.length || "/" === specifier3[1])
                  return true;
                if ("." === specifier3[1] && (2 === specifier3.length || "/" === specifier3[2]))
                  return true;
              }
              return false;
            }(specifier2));
          }(specifier))
            resolved = new external_node_url_namespaceObject.URL(specifier, base);
          else if (isRemote || "#" !== specifier[0])
            try {
              resolved = new external_node_url_namespaceObject.URL(specifier);
            } catch {
              isRemote || (resolved = packageResolve2(specifier, base, conditions));
            }
          else
            resolved = packageImportsResolve2(specifier, base, conditions);
          return external_node_assert_namespaceObject(void 0 !== resolved, "expected to be defined"), "file:" !== resolved.protocol ? resolved : function(resolved2, base2, preserveSymlinks2) {
            if (null !== encodedSepRegEx2.exec(resolved2.pathname))
              throw new ERR_INVALID_MODULE_SPECIFIER2(resolved2.pathname, 'must not include encoded "/" or "\\" characters', (0, external_node_url_namespaceObject.fileURLToPath)(base2));
            const filePath = (0, external_node_url_namespaceObject.fileURLToPath)(resolved2), stats = tryStatSync2(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
            if (stats.isDirectory()) {
              const error = new ERR_UNSUPPORTED_DIR_IMPORT2(filePath, (0, external_node_url_namespaceObject.fileURLToPath)(base2));
              throw error.url = String(resolved2), error;
            }
            if (!stats.isFile())
              throw new ERR_MODULE_NOT_FOUND2(filePath || resolved2.pathname, base2 && (0, external_node_url_namespaceObject.fileURLToPath)(base2), "module");
            if (!preserveSymlinks2) {
              const real = (0, external_node_fs_namespaceObject.realpathSync)(filePath), { search, hash: hash2 } = resolved2;
              (resolved2 = (0, external_node_url_namespaceObject.pathToFileURL)(real + (filePath.endsWith(external_node_path_namespaceObject.sep) ? "/" : ""))).search = search, resolved2.hash = hash2;
            }
            return resolved2;
          }(resolved, base, preserveSymlinks);
        }
        function fileURLToPath4(id) {
          return "string" != typeof id || id.startsWith("file://") ? normalizeSlash2((0, external_node_url_namespaceObject.fileURLToPath)(id)) : normalizeSlash2(id);
        }
        const DEFAULT_CONDITIONS_SET2 = /* @__PURE__ */ new Set(["node", "import"]), DEFAULT_URL2 = (0, external_node_url_namespaceObject.pathToFileURL)(process.cwd()), DEFAULT_EXTENSIONS2 = [".mjs", ".cjs", ".js", ".json"], NOT_FOUND_ERRORS2 = /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND", "ERR_PACKAGE_PATH_NOT_EXPORTED"]);
        function _tryModuleResolve2(id, url, conditions) {
          try {
            return moduleResolve2(id, url, conditions);
          } catch (error) {
            if (!NOT_FOUND_ERRORS2.has(error.code))
              throw error;
          }
        }
        function _resolve2(id, options = {}) {
          if (/(node|data|http|https):/.test(id))
            return id;
          if (BUILTIN_MODULES2.has(id))
            return "node:" + id;
          if (isAbsolute2(id) && (0, external_node_fs_namespaceObject.existsSync)(id)) {
            const realPath2 = (0, external_node_fs_namespaceObject.realpathSync)(fileURLToPath4(id));
            return (0, external_node_url_namespaceObject.pathToFileURL)(realPath2).toString();
          }
          const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET2, _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((u) => new URL(function(id2) {
            return "string" != typeof id2 && (id2 = id2.toString()), /(node|data|http|https|file):/.test(id2) ? id2 : BUILTIN_MODULES2.has(id2) ? "node:" + id2 : "file://" + encodeURI(normalizeSlash2(id2));
          }(u.toString())));
          0 === _urls.length && _urls.push(DEFAULT_URL2);
          const urls = [..._urls];
          for (const url of _urls)
            "file:" === url.protocol && urls.push(new URL("./", url), new URL(joinURL2(url.pathname, "_index.js"), url), new URL("node_modules", url));
          let resolved;
          for (const url of urls) {
            if (resolved = _tryModuleResolve2(id, url, conditionsSet), resolved)
              break;
            for (const prefix of ["", "/index"]) {
              for (const extension of options.extensions || DEFAULT_EXTENSIONS2)
                if (resolved = _tryModuleResolve2(id + prefix + extension, url, conditionsSet), resolved)
                  break;
              if (resolved)
                break;
            }
            if (resolved)
              break;
          }
          if (!resolved) {
            const error = new Error(`Cannot find module ${id} imported from ${urls.join(", ")}`);
            throw error.code = "ERR_MODULE_NOT_FOUND", error;
          }
          const realPath = (0, external_node_fs_namespaceObject.realpathSync)(fileURLToPath4(resolved));
          return (0, external_node_url_namespaceObject.pathToFileURL)(realPath).toString();
        }
        function resolveSync2(id, options) {
          return _resolve2(id, options);
        }
        function resolvePathSync2(id, options) {
          return fileURLToPath4(resolveSync2(id, options));
        }
        const ESM_RE = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
        function hasESMSyntax(code) {
          return ESM_RE.test(code);
        }
        var external_crypto_ = __webpack_require__("crypto");
        function md5(content, len = 8) {
          return (0, external_crypto_.createHash)("md5").update(content).digest("hex").slice(0, len);
        }
        const _EnvDebug = destr2(process.env.JITI_DEBUG), _EnvCache = destr2(process.env.JITI_CACHE), _EnvESMResolve = destr2(process.env.JITI_ESM_RESOLVE), _EnvRequireCache = destr2(process.env.JITI_REQUIRE_CACHE), _EnvSourceMaps = destr2(process.env.JITI_SOURCE_MAPS), _EnvAlias = destr2(process.env.JITI_ALIAS), _EnvTransform = destr2(process.env.JITI_TRANSFORM_MODULES), _EnvNative = destr2(process.env.JITI_NATIVE_MODULES), jiti_isWindows = "win32" === (0, external_os_namespaceObject.platform)(), defaults3 = { debug: _EnvDebug, cache: void 0 === _EnvCache || !!_EnvCache, requireCache: void 0 === _EnvRequireCache || !!_EnvRequireCache, sourceMaps: void 0 !== _EnvSourceMaps && !!_EnvSourceMaps, interopDefault: false, esmResolve: _EnvESMResolve || false, cacheVersion: "7", legacy: (0, semver.lt)(process.version || "0.0.0", "14.0.0"), extensions: [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts", ".json"], alias: _EnvAlias, nativeModules: _EnvNative || [], transformModules: _EnvTransform || [] }, JS_EXT_RE = /\.(c|m)?j(sx?)$/, TS_EXT_RE = /\.(c|m)?t(sx?)$/;
        function createJITI(_filename, opts = {}, parentModule, parentCache) {
          (opts = Object.assign(Object.assign({}, defaults3), opts)).legacy && (opts.cacheVersion += "-legacy"), opts.transformOptions && (opts.cacheVersion += "-" + object_hash_default()(opts.transformOptions));
          const alias = opts.alias && Object.keys(opts.alias).length > 0 ? normalizeAliases2(opts.alias || {}) : null, nativeModules = ["typescript", "jiti", ...opts.nativeModules || []], transformModules = [...opts.transformModules || []], isNativeRe = new RegExp(`node_modules/(${nativeModules.map((m2) => escapeStringRegexp(m2)).join("|")})/`), isTransformRe = new RegExp(`node_modules/(${transformModules.map((m2) => escapeStringRegexp(m2)).join("|")})/`);
          function debug(...args) {
            opts.debug && console.log("[jiti]", ...args);
          }
          if (_filename || (_filename = process.cwd()), function(filename) {
            try {
              return (0, external_fs_.lstatSync)(filename).isDirectory();
            } catch (_a) {
              return false;
            }
          }(_filename) && (_filename = join2(_filename, "index.js")), true === opts.cache && (opts.cache = function() {
            let _tmpDir = (0, external_os_namespaceObject.tmpdir)();
            if (process.env.TMPDIR && _tmpDir === process.cwd() && !process.env.JITI_RESPECT_TMPDIR_ENV) {
              const _env = process.env.TMPDIR;
              delete process.env.TMPDIR, _tmpDir = (0, external_os_namespaceObject.tmpdir)(), process.env.TMPDIR = _env;
            }
            return join2(_tmpDir, "node-jiti");
          }()), opts.cache)
            try {
              if ((0, external_fs_.mkdirSync)(opts.cache, { recursive: true }), !function(filename) {
                try {
                  return (0, external_fs_.accessSync)(filename, external_fs_.constants.W_OK), true;
                } catch (_a) {
                  return false;
                }
              }(opts.cache))
                throw new Error("directory is not writable");
            } catch (error) {
              debug("Error creating cache directory at ", opts.cache, error), opts.cache = false;
            }
          const nativeRequire = create_require_default()(jiti_isWindows ? _filename.replace(/\//g, "\\") : _filename), tryResolve = (id, options) => {
            try {
              return nativeRequire.resolve(id, options);
            } catch (_a) {
            }
          }, _url = (0, external_url_namespaceObject.pathToFileURL)(_filename), _additionalExts = [...opts.extensions].filter((ext) => ".js" !== ext), _resolve3 = (id, options) => {
            let resolved, err;
            if (alias && (id = function(path3, aliases) {
              const _path = normalizeWindowsPath2(path3);
              aliases = normalizeAliases2(aliases);
              for (const alias2 in aliases)
                if (_path.startsWith(alias2) && pathSeparators2.has(_path[alias2.length]))
                  return join2(aliases[alias2], _path.slice(alias2.length));
              return _path;
            }(id, alias)), opts.esmResolve) {
              const conditionSets = [["node", "require"], ["node", "import"]];
              for (const conditions of conditionSets) {
                try {
                  resolved = resolvePathSync2(id, { url: _url, conditions });
                } catch (error) {
                  err = error;
                }
                if (resolved)
                  return resolved;
              }
            }
            try {
              return nativeRequire.resolve(id, options);
            } catch (error) {
              err = error;
            }
            for (const ext of _additionalExts) {
              if (resolved = tryResolve(id + ext, options) || tryResolve(id + "/index" + ext, options), resolved)
                return resolved;
              if (TS_EXT_RE.test((null == parentModule ? void 0 : parentModule.filename) || "") && (resolved = tryResolve(id.replace(JS_EXT_RE, ".$1t$2"), options), resolved))
                return resolved;
            }
            throw err;
          };
          function transform(topts) {
            let code = function(filename, source, get) {
              if (!opts.cache || !filename)
                return get();
              const sourceHash = ` /* v${opts.cacheVersion}-${md5(source, 16)} */`, filebase = basename2(pathe_92c04245_dirname(filename)) + "-" + basename2(filename), cacheFile = join2(opts.cache, filebase + "." + md5(filename) + ".js");
              if ((0, external_fs_.existsSync)(cacheFile)) {
                const cacheSource = (0, external_fs_.readFileSync)(cacheFile, "utf8");
                if (cacheSource.endsWith(sourceHash))
                  return debug("[cache hit]", filename, "~>", cacheFile), cacheSource;
              }
              debug("[cache miss]", filename);
              const result = get();
              return result.includes("__JITI_ERROR__") || (0, external_fs_.writeFileSync)(cacheFile, result + sourceHash, "utf8"), result;
            }(topts.filename, topts.source, () => {
              var _a;
              const res = opts.transform(Object.assign(Object.assign(Object.assign({ legacy: opts.legacy }, opts.transformOptions), { babel: Object.assign(Object.assign({}, opts.sourceMaps ? { sourceFileName: topts.filename, sourceMaps: "inline" } : {}), null === (_a = opts.transformOptions) || void 0 === _a ? void 0 : _a.babel) }), topts));
              return res.error && opts.debug && debug(res.error), res.code;
            });
            return code.startsWith("#!") && (code = "// " + code), code;
          }
          function _interopDefault(mod) {
            return opts.interopDefault ? function(sourceModule) {
              if (null === (value2 = sourceModule) || "object" != typeof value2 || !("default" in sourceModule))
                return sourceModule;
              var value2;
              const newModule = sourceModule.default;
              for (const key in sourceModule)
                if ("default" === key)
                  try {
                    key in newModule || Object.defineProperty(newModule, key, { enumerable: false, configurable: false, get: () => newModule });
                  } catch {
                  }
                else
                  try {
                    key in newModule || Object.defineProperty(newModule, key, { enumerable: true, configurable: true, get: () => sourceModule[key] });
                  } catch {
                  }
              return newModule;
            }(mod) : mod;
          }
          function jiti2(id) {
            var _a, _b;
            const cache = parentCache || {};
            if (id.startsWith("node:") ? id = id.slice(5) : id.startsWith("file:") && (id = (0, external_url_namespaceObject.fileURLToPath)(id)), external_module_.builtinModules.includes(id) || ".pnp.js" === id)
              return nativeRequire(id);
            const filename = _resolve3(id), ext = extname3(filename);
            if (".json" === ext) {
              debug("[json]", filename);
              const jsonModule = nativeRequire(id);
              return Object.defineProperty(jsonModule, "default", { value: jsonModule }), jsonModule;
            }
            if (ext && !opts.extensions.includes(ext))
              return debug("[unknown]", filename), nativeRequire(id);
            if (isNativeRe.test(filename))
              return debug("[native]", filename), nativeRequire(id);
            if (cache[filename])
              return _interopDefault(null === (_a = cache[filename]) || void 0 === _a ? void 0 : _a.exports);
            if (opts.requireCache && nativeRequire.cache[filename])
              return _interopDefault(null === (_b = nativeRequire.cache[filename]) || void 0 === _b ? void 0 : _b.exports);
            return evalModule((0, external_fs_.readFileSync)(filename, "utf8"), { id, filename, ext, cache });
          }
          function evalModule(source, evalOptions = {}) {
            var _a;
            const id = evalOptions.id || (evalOptions.filename ? basename2(evalOptions.filename) : `_jitiEval.${evalOptions.ext || ".js"}`), filename = evalOptions.filename || _resolve3(id), ext = evalOptions.ext || extname3(filename), cache = evalOptions.cache || parentCache || {}, isTypescript = ".ts" === ext || ".mts" === ext || ".cts" === ext, isNativeModule = ".mjs" === ext || ".js" === ext && "module" === (null === (_a = function(path3) {
              for (; path3 && "." !== path3 && "/" !== path3; ) {
                path3 = join2(path3, "..");
                try {
                  const pkg = (0, external_fs_.readFileSync)(join2(path3, "package.json"), "utf8");
                  try {
                    return JSON.parse(pkg);
                  } catch (_a2) {
                  }
                  break;
                } catch (_b) {
                }
              }
            }(filename)) || void 0 === _a ? void 0 : _a.type), needsTranspile = !(".cjs" === ext) && (isTypescript || isNativeModule || isTransformRe.test(filename) || hasESMSyntax(source) || opts.legacy && source.match(/\?\.|\?\?/));
            const start = external_perf_hooks_namespaceObject.performance.now();
            if (needsTranspile) {
              source = transform({ filename, source, ts: isTypescript });
              debug("[transpile]" + (isNativeModule ? " [esm]" : ""), filename, `(${Math.round(1e3 * (external_perf_hooks_namespaceObject.performance.now() - start)) / 1e3}ms)`);
            } else
              try {
                return debug("[native]", filename), _interopDefault(nativeRequire(id));
              } catch (error) {
                debug("Native require error:", error), debug("[fallback]", filename), source = transform({ filename, source, ts: isTypescript });
              }
            const mod = new external_module_.Module(filename);
            let compiled;
            mod.filename = filename, parentModule && (mod.parent = parentModule, Array.isArray(parentModule.children) && !parentModule.children.includes(mod) && parentModule.children.push(mod)), mod.require = createJITI(filename, opts, mod, cache), mod.path = pathe_92c04245_dirname(filename), mod.paths = external_module_.Module._nodeModulePaths(mod.path), cache[filename] = mod, opts.requireCache && (nativeRequire.cache[filename] = mod);
            try {
              compiled = external_vm_default().runInThisContext(external_module_.Module.wrap(source), { filename, lineOffset: 0, displayErrors: false });
            } catch (error) {
              opts.requireCache && delete nativeRequire.cache[filename], opts.onError(error);
            }
            try {
              compiled(mod.exports, mod.require, mod, mod.filename, pathe_92c04245_dirname(mod.filename));
            } catch (error) {
              opts.requireCache && delete nativeRequire.cache[filename], opts.onError(error);
            }
            if (mod.exports && mod.exports.__JITI_ERROR__) {
              const { filename: filename2, line, column, code, message } = mod.exports.__JITI_ERROR__, err = new Error(`${code}: ${message} 
 ${`${filename2}:${line}:${column}`}`);
              Error.captureStackTrace(err, jiti2), opts.onError(err);
            }
            mod.loaded = true;
            return _interopDefault(mod.exports);
          }
          return _resolve3.paths = nativeRequire.resolve.paths, jiti2.resolve = _resolve3, jiti2.cache = opts.requireCache ? nativeRequire.cache : {}, jiti2.extensions = nativeRequire.extensions, jiti2.main = nativeRequire.main, jiti2.transform = transform, jiti2.register = function() {
            return (0, lib.addHook)((source, filename) => jiti2.transform({ source, filename, ts: !!/\.[cm]?ts$/.test(filename) }), { exts: opts.extensions });
          }, jiti2.evalModule = evalModule, jiti2;
        }
      })(), module3.exports = __webpack_exports__.default;
    })();
  }
});

// browser-external:tty
var require_tty = __commonJS({
  "browser-external:tty"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tty" has been externalized for browser compatibility. Cannot access "tty.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jiti/dist/babel.js
var require_babel = __commonJS({
  "node_modules/jiti/dist/babel.js"(exports2, module3) {
    (() => {
      var __webpack_modules__ = { "./node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js": function(module4, __unused_webpack_exports, __webpack_require__2) {
        module4.exports = function(traceMapping, genMapping) {
          "use strict";
          const SOURCELESS_MAPPING = SegmentObject("", -1, -1, "", null), EMPTY_SOURCES = [];
          function SegmentObject(source, line, column, name, content) {
            return { source, line, column, name, content };
          }
          function Source(map, sources, source, content) {
            return { map, sources, source, content };
          }
          function MapSource(map, sources) {
            return Source(map, sources, "", null);
          }
          function OriginalSource(source, content) {
            return Source(null, EMPTY_SOURCES, source, content);
          }
          function traceMappings(tree) {
            const gen = new genMapping.GenMapping({ file: tree.map.file }), { sources: rootSources, map } = tree, rootNames = map.names, rootMappings = traceMapping.decodedMappings(map);
            for (let i = 0; i < rootMappings.length; i++) {
              const segments = rootMappings[i];
              for (let j = 0; j < segments.length; j++) {
                const segment = segments[j], genCol = segment[0];
                let traced = SOURCELESS_MAPPING;
                if (1 !== segment.length && (traced = originalPositionFor(rootSources[segment[1]], segment[2], segment[3], 5 === segment.length ? rootNames[segment[4]] : ""), null == traced))
                  continue;
                const { column, line, name, content, source } = traced;
                genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name), source && null != content && genMapping.setSourceContent(gen, source, content);
              }
            }
            return gen;
          }
          function originalPositionFor(source, line, column, name) {
            if (!source.map)
              return SegmentObject(source.source, line, column, name, source.content);
            const segment = traceMapping.traceSegment(source.map, line, column);
            return null == segment ? null : 1 === segment.length ? SOURCELESS_MAPPING : originalPositionFor(source.sources[segment[1]], segment[2], segment[3], 5 === segment.length ? source.map.names[segment[4]] : name);
          }
          function asArray(value2) {
            return Array.isArray(value2) ? value2 : [value2];
          }
          function buildSourceMapTree(input, loader) {
            const maps = asArray(input).map((m2) => new traceMapping.TraceMap(m2, "")), map = maps.pop();
            for (let i = 0; i < maps.length; i++)
              if (maps[i].sources.length > 1)
                throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
            let tree = build2(map, loader, "", 0);
            for (let i = maps.length - 1; i >= 0; i--)
              tree = MapSource(maps[i], [tree]);
            return tree;
          }
          function build2(map, loader, importer, importerDepth) {
            const { resolvedSources, sourcesContent } = map, depth = importerDepth + 1;
            return MapSource(map, resolvedSources.map((sourceFile, i) => {
              const ctx = { importer, depth, source: sourceFile || "", content: void 0 }, sourceMap = loader(ctx.source, ctx), { source, content } = ctx;
              return sourceMap ? build2(new traceMapping.TraceMap(sourceMap, source), loader, source, depth) : OriginalSource(source, void 0 !== content ? content : sourcesContent ? sourcesContent[i] : null);
            }));
          }
          class SourceMap {
            constructor(map, options) {
              const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
              this.version = out.version, this.file = out.file, this.mappings = out.mappings, this.names = out.names, this.sourceRoot = out.sourceRoot, this.sources = out.sources, options.excludeContent || (this.sourcesContent = out.sourcesContent);
            }
            toString() {
              return JSON.stringify(this);
            }
          }
          function remapping(input, loader, options) {
            const opts = "object" == typeof options ? options : { excludeContent: !!options, decodedMappings: false }, tree = buildSourceMapTree(input, loader);
            return new SourceMap(traceMappings(tree), opts);
          }
          return remapping;
        }(__webpack_require__2("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.18/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"), __webpack_require__2("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"));
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files lazy recursive": (module4) => {
        function webpackEmptyAsyncContext(req) {
          return Promise.resolve().then(() => {
            var e = new Error("Cannot find module '" + req + "'");
            throw e.code = "MODULE_NOT_FOUND", e;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files lazy recursive", module4.exports = webpackEmptyAsyncContext;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive": (module4) => {
        function webpackEmptyContext(req) {
          var e = new Error("Cannot find module '" + req + "'");
          throw e.code = "MODULE_NOT_FOUND", e;
        }
        webpackEmptyContext.keys = () => [], webpackEmptyContext.resolve = webpackEmptyContext, webpackEmptyContext.id = "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive", module4.exports = webpackEmptyContext;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-class-properties/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-class-properties", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-export-namespace-from@7.8.3_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-export-namespace-from/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-export-namespace-from", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("exportNamespaceFrom");
        } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-nullish-coalescing-operator@7.8.3_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-nullish-coalescing-operator", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("nullishCoalescingOperator");
        } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-optional-chaining@7.8.3_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-optional-chaining", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalChaining");
        } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js": function(__unused_webpack_module, exports3, __webpack_require__2) {
        !function(exports4, setArray, sourcemapCodec, traceMapping) {
          "use strict";
          const COLUMN = 0, SOURCES_INDEX = 1, SOURCE_LINE = 2, SOURCE_COLUMN = 3, NAMES_INDEX = 4, NO_NAME = -1;
          let addSegmentInternal;
          exports4.addSegment = void 0, exports4.addMapping = void 0, exports4.maybeAddSegment = void 0, exports4.maybeAddMapping = void 0, exports4.setSourceContent = void 0, exports4.toDecodedMap = void 0, exports4.toEncodedMap = void 0, exports4.fromMap = void 0, exports4.allMappings = void 0;
          class GenMapping {
            constructor({ file, sourceRoot } = {}) {
              this._names = new setArray.SetArray(), this._sources = new setArray.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = file, this.sourceRoot = sourceRoot;
            }
          }
          function getLine(mappings, index2) {
            for (let i = mappings.length; i <= index2; i++)
              mappings[i] = [];
            return mappings[index2];
          }
          function getColumnIndex(line, genColumn) {
            let index2 = line.length;
            for (let i = index2 - 1; i >= 0 && !(genColumn >= line[i][COLUMN]); index2 = i--)
              ;
            return index2;
          }
          function insert(array, index2, value2) {
            for (let i = array.length; i > index2; i--)
              array[i] = array[i - 1];
            array[index2] = value2;
          }
          function removeEmptyFinalLines(mappings) {
            const { length } = mappings;
            let len = length;
            for (let i = len - 1; i >= 0 && !(mappings[i].length > 0); len = i, i--)
              ;
            len < length && (mappings.length = len);
          }
          function putAll(strarr, array) {
            for (let i = 0; i < array.length; i++)
              setArray.put(strarr, array[i]);
          }
          function skipSourceless(line, index2) {
            return 0 === index2 || 1 === line[index2 - 1].length;
          }
          function skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
            if (0 === index2)
              return false;
            const prev = line[index2 - 1];
            return 1 !== prev.length && sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (5 === prev.length ? prev[NAMES_INDEX] : NO_NAME);
          }
          function addMappingInternal(skipable, map, mapping) {
            const { generated, source, original, name, content } = mapping;
            if (!source)
              return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
            const s = source;
            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);
          }
          exports4.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content), exports4.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content), exports4.addMapping = (map, mapping) => addMappingInternal(false, map, mapping), exports4.maybeAddMapping = (map, mapping) => addMappingInternal(true, map, mapping), exports4.setSourceContent = (map, source, content) => {
            const { _sources: sources, _sourcesContent: sourcesContent } = map;
            sourcesContent[setArray.put(sources, source)] = content;
          }, exports4.toDecodedMap = (map) => {
            const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
            return removeEmptyFinalLines(mappings), { version: 3, file: file || void 0, names: names.array, sourceRoot: sourceRoot || void 0, sources: sources.array, sourcesContent, mappings };
          }, exports4.toEncodedMap = (map) => {
            const decoded = exports4.toDecodedMap(map);
            return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
          }, exports4.allMappings = (map) => {
            const out = [], { _mappings: mappings, _sources: sources, _names: names } = map;
            for (let i = 0; i < mappings.length; i++) {
              const line = mappings[i];
              for (let j = 0; j < line.length; j++) {
                const seg = line[j], generated = { line: i + 1, column: seg[COLUMN] };
                let source, original, name;
                1 !== seg.length && (source = sources.array[seg[SOURCES_INDEX]], original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] }, 5 === seg.length && (name = names.array[seg[NAMES_INDEX]])), out.push({ generated, source, original, name });
              }
            }
            return out;
          }, exports4.fromMap = (input) => {
            const map = new traceMapping.TraceMap(input), gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
            return putAll(gen._names, map.names), putAll(gen._sources, map.sources), gen._sourcesContent = map.sourcesContent || map.sources.map(() => null), gen._mappings = traceMapping.decodedMappings(map), gen;
          }, addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map, line = getLine(mappings, genLine), index2 = getColumnIndex(line, genColumn);
            if (!source) {
              if (skipable && skipSourceless(line, index2))
                return;
              return insert(line, index2, [genColumn]);
            }
            const sourcesIndex = setArray.put(sources, source), namesIndex = name ? setArray.put(names, name) : NO_NAME;
            if (sourcesIndex === sourcesContent.length && (sourcesContent[sourcesIndex] = null != content ? content : null), !skipable || !skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex))
              return insert(line, index2, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
          }, exports4.GenMapping = GenMapping, Object.defineProperty(exports4, "__esModule", { value: true });
        }(exports3, __webpack_require__2("./node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js"), __webpack_require__2("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), __webpack_require__2("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.18/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"));
      }, "./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.0/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js": function(module4) {
        module4.exports = function() {
          "use strict";
          const schemeRegex = /^[\w+.-]+:\/\//, urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
          var UrlType;
          function isAbsoluteUrl(input) {
            return schemeRegex.test(input);
          }
          function isSchemeRelativeUrl(input) {
            return input.startsWith("//");
          }
          function isAbsolutePath(input) {
            return input.startsWith("/");
          }
          function isFileUrl(input) {
            return input.startsWith("file:");
          }
          function isRelative(input) {
            return /^[.?#]/.test(input);
          }
          function parseAbsoluteUrl(input) {
            const match = urlRegex.exec(input);
            return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
          }
          function parseFileUrl(input) {
            const match = fileRegex.exec(input), path3 = match[2];
            return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path3) ? path3 : "/" + path3, match[3] || "", match[4] || "");
          }
          function makeUrl(scheme, user, host, port, path3, query, hash2) {
            return { scheme, user, host, port, path: path3, query, hash: hash2, type: UrlType.Absolute };
          }
          function parseUrl(input) {
            if (isSchemeRelativeUrl(input)) {
              const url2 = parseAbsoluteUrl("http:" + input);
              return url2.scheme = "", url2.type = UrlType.SchemeRelative, url2;
            }
            if (isAbsolutePath(input)) {
              const url2 = parseAbsoluteUrl("http://foo.com" + input);
              return url2.scheme = "", url2.host = "", url2.type = UrlType.AbsolutePath, url2;
            }
            if (isFileUrl(input))
              return parseFileUrl(input);
            if (isAbsoluteUrl(input))
              return parseAbsoluteUrl(input);
            const url = parseAbsoluteUrl("http://foo.com/" + input);
            return url.scheme = "", url.host = "", url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty, url;
          }
          function stripPathFilename(path3) {
            if (path3.endsWith("/.."))
              return path3;
            const index2 = path3.lastIndexOf("/");
            return path3.slice(0, index2 + 1);
          }
          function mergePaths(url, base) {
            normalizePath(base, base.type), "/" === url.path ? url.path = base.path : url.path = stripPathFilename(base.path) + url.path;
          }
          function normalizePath(url, type) {
            const rel = type <= UrlType.RelativePath, pieces = url.path.split("/");
            let pointer = 1, positive = 0, addTrailingSlash = false;
            for (let i = 1; i < pieces.length; i++) {
              const piece = pieces[i];
              piece ? (addTrailingSlash = false, "." !== piece && (".." !== piece ? (pieces[pointer++] = piece, positive++) : positive ? (addTrailingSlash = true, positive--, pointer--) : rel && (pieces[pointer++] = piece))) : addTrailingSlash = true;
            }
            let path3 = "";
            for (let i = 1; i < pointer; i++)
              path3 += "/" + pieces[i];
            (!path3 || addTrailingSlash && !path3.endsWith("/..")) && (path3 += "/"), url.path = path3;
          }
          function resolve3(input, base) {
            if (!input && !base)
              return "";
            const url = parseUrl(input);
            let inputType = url.type;
            if (base && inputType !== UrlType.Absolute) {
              const baseUrl = parseUrl(base), baseType = baseUrl.type;
              switch (inputType) {
                case UrlType.Empty:
                  url.hash = baseUrl.hash;
                case UrlType.Hash:
                  url.query = baseUrl.query;
                case UrlType.Query:
                case UrlType.RelativePath:
                  mergePaths(url, baseUrl);
                case UrlType.AbsolutePath:
                  url.user = baseUrl.user, url.host = baseUrl.host, url.port = baseUrl.port;
                case UrlType.SchemeRelative:
                  url.scheme = baseUrl.scheme;
              }
              baseType > inputType && (inputType = baseType);
            }
            normalizePath(url, inputType);
            const queryHash = url.query + url.hash;
            switch (inputType) {
              case UrlType.Hash:
              case UrlType.Query:
                return queryHash;
              case UrlType.RelativePath: {
                const path3 = url.path.slice(1);
                return path3 ? isRelative(base || input) && !isRelative(path3) ? "./" + path3 + queryHash : path3 + queryHash : queryHash || ".";
              }
              case UrlType.AbsolutePath:
                return url.path + queryHash;
              default:
                return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
            }
          }
          return function(UrlType2) {
            UrlType2[UrlType2.Empty = 1] = "Empty", UrlType2[UrlType2.Hash = 2] = "Hash", UrlType2[UrlType2.Query = 3] = "Query", UrlType2[UrlType2.RelativePath = 4] = "RelativePath", UrlType2[UrlType2.AbsolutePath = 5] = "AbsolutePath", UrlType2[UrlType2.SchemeRelative = 6] = "SchemeRelative", UrlType2[UrlType2.Absolute = 7] = "Absolute";
          }(UrlType || (UrlType = {})), resolve3;
        }();
      }, "./node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js": function(__unused_webpack_module, exports3) {
        !function(exports4) {
          "use strict";
          exports4.get = void 0, exports4.put = void 0, exports4.pop = void 0;
          class SetArray {
            constructor() {
              this._indexes = { __proto__: null }, this.array = [];
            }
          }
          exports4.get = (strarr, key) => strarr._indexes[key], exports4.put = (strarr, key) => {
            const index2 = exports4.get(strarr, key);
            if (void 0 !== index2)
              return index2;
            const { array, _indexes: indexes } = strarr;
            return indexes[key] = array.push(key) - 1;
          }, exports4.pop = (strarr) => {
            const { array, _indexes: indexes } = strarr;
            0 !== array.length && (indexes[array.pop()] = void 0);
          }, exports4.SetArray = SetArray, Object.defineProperty(exports4, "__esModule", { value: true });
        }(exports3);
      }, "./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.14/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js": function(__unused_webpack_module, exports3) {
        !function(exports4) {
          "use strict";
          const comma = ",".charCodeAt(0), semicolon = ";".charCodeAt(0), chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar = new Uint8Array(64), charToInt = new Uint8Array(128);
          for (let i = 0; i < chars.length; i++) {
            const c = chars.charCodeAt(i);
            intToChar[i] = c, charToInt[c] = i;
          }
          const td = "undefined" != typeof TextDecoder ? new TextDecoder() : "undefined" != typeof Buffer ? { decode: (buf) => Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString() } : { decode(buf) {
            let out = "";
            for (let i = 0; i < buf.length; i++)
              out += String.fromCharCode(buf[i]);
            return out;
          } };
          function decode(mappings) {
            const state = new Int32Array(5), decoded = [];
            let index2 = 0;
            do {
              const semi = indexOf(mappings, index2), line = [];
              let sorted = true, lastCol = 0;
              state[0] = 0;
              for (let i = index2; i < semi; i++) {
                let seg;
                i = decodeInteger(mappings, i, state, 0);
                const col = state[0];
                col < lastCol && (sorted = false), lastCol = col, hasMoreVlq(mappings, i, semi) ? (i = decodeInteger(mappings, i, state, 1), i = decodeInteger(mappings, i, state, 2), i = decodeInteger(mappings, i, state, 3), hasMoreVlq(mappings, i, semi) ? (i = decodeInteger(mappings, i, state, 4), seg = [col, state[1], state[2], state[3], state[4]]) : seg = [col, state[1], state[2], state[3]]) : seg = [col], line.push(seg);
              }
              sorted || sort(line), decoded.push(line), index2 = semi + 1;
            } while (index2 <= mappings.length);
            return decoded;
          }
          function indexOf(mappings, index2) {
            const idx = mappings.indexOf(";", index2);
            return -1 === idx ? mappings.length : idx;
          }
          function decodeInteger(mappings, pos, state, j) {
            let value2 = 0, shift = 0, integer = 0;
            do {
              const c = mappings.charCodeAt(pos++);
              integer = charToInt[c], value2 |= (31 & integer) << shift, shift += 5;
            } while (32 & integer);
            const shouldNegate = 1 & value2;
            return value2 >>>= 1, shouldNegate && (value2 = -2147483648 | -value2), state[j] += value2, pos;
          }
          function hasMoreVlq(mappings, i, length) {
            return !(i >= length) && mappings.charCodeAt(i) !== comma;
          }
          function sort(line) {
            line.sort(sortComparator);
          }
          function sortComparator(a, b) {
            return a[0] - b[0];
          }
          function encode(decoded) {
            const state = new Int32Array(5), bufLength = 16384, subLength = bufLength - 36, buf = new Uint8Array(bufLength), sub = buf.subarray(0, subLength);
            let pos = 0, out = "";
            for (let i = 0; i < decoded.length; i++) {
              const line = decoded[i];
              if (i > 0 && (pos === bufLength && (out += td.decode(buf), pos = 0), buf[pos++] = semicolon), 0 !== line.length) {
                state[0] = 0;
                for (let j = 0; j < line.length; j++) {
                  const segment = line[j];
                  pos > subLength && (out += td.decode(sub), buf.copyWithin(0, subLength, pos), pos -= subLength), j > 0 && (buf[pos++] = comma), pos = encodeInteger(buf, pos, state, segment, 0), 1 !== segment.length && (pos = encodeInteger(buf, pos, state, segment, 1), pos = encodeInteger(buf, pos, state, segment, 2), pos = encodeInteger(buf, pos, state, segment, 3), 4 !== segment.length && (pos = encodeInteger(buf, pos, state, segment, 4)));
                }
              }
            }
            return out + td.decode(buf.subarray(0, pos));
          }
          function encodeInteger(buf, pos, state, segment, j) {
            const next = segment[j];
            let num = next - state[j];
            state[j] = next, num = num < 0 ? -num << 1 | 1 : num << 1;
            do {
              let clamped = 31 & num;
              num >>>= 5, num > 0 && (clamped |= 32), buf[pos++] = intToChar[clamped];
            } while (num > 0);
            return pos;
          }
          exports4.decode = decode, exports4.encode = encode, Object.defineProperty(exports4, "__esModule", { value: true });
        }(exports3);
      }, "./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js": function(__unused_webpack_module, exports3) {
        !function(exports4) {
          "use strict";
          const comma = ",".charCodeAt(0), semicolon = ";".charCodeAt(0), chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar = new Uint8Array(64), charToInt = new Uint8Array(128);
          for (let i = 0; i < chars.length; i++) {
            const c = chars.charCodeAt(i);
            intToChar[i] = c, charToInt[c] = i;
          }
          const td = "undefined" != typeof TextDecoder ? new TextDecoder() : "undefined" != typeof Buffer ? { decode: (buf) => Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString() } : { decode(buf) {
            let out = "";
            for (let i = 0; i < buf.length; i++)
              out += String.fromCharCode(buf[i]);
            return out;
          } };
          function decode(mappings) {
            const state = new Int32Array(5), decoded = [];
            let index2 = 0;
            do {
              const semi = indexOf(mappings, index2), line = [];
              let sorted = true, lastCol = 0;
              state[0] = 0;
              for (let i = index2; i < semi; i++) {
                let seg;
                i = decodeInteger(mappings, i, state, 0);
                const col = state[0];
                col < lastCol && (sorted = false), lastCol = col, hasMoreVlq(mappings, i, semi) ? (i = decodeInteger(mappings, i, state, 1), i = decodeInteger(mappings, i, state, 2), i = decodeInteger(mappings, i, state, 3), hasMoreVlq(mappings, i, semi) ? (i = decodeInteger(mappings, i, state, 4), seg = [col, state[1], state[2], state[3], state[4]]) : seg = [col, state[1], state[2], state[3]]) : seg = [col], line.push(seg);
              }
              sorted || sort(line), decoded.push(line), index2 = semi + 1;
            } while (index2 <= mappings.length);
            return decoded;
          }
          function indexOf(mappings, index2) {
            const idx = mappings.indexOf(";", index2);
            return -1 === idx ? mappings.length : idx;
          }
          function decodeInteger(mappings, pos, state, j) {
            let value2 = 0, shift = 0, integer = 0;
            do {
              const c = mappings.charCodeAt(pos++);
              integer = charToInt[c], value2 |= (31 & integer) << shift, shift += 5;
            } while (32 & integer);
            const shouldNegate = 1 & value2;
            return value2 >>>= 1, shouldNegate && (value2 = -2147483648 | -value2), state[j] += value2, pos;
          }
          function hasMoreVlq(mappings, i, length) {
            return !(i >= length) && mappings.charCodeAt(i) !== comma;
          }
          function sort(line) {
            line.sort(sortComparator);
          }
          function sortComparator(a, b) {
            return a[0] - b[0];
          }
          function encode(decoded) {
            const state = new Int32Array(5), bufLength = 16384, subLength = bufLength - 36, buf = new Uint8Array(bufLength), sub = buf.subarray(0, subLength);
            let pos = 0, out = "";
            for (let i = 0; i < decoded.length; i++) {
              const line = decoded[i];
              if (i > 0 && (pos === bufLength && (out += td.decode(buf), pos = 0), buf[pos++] = semicolon), 0 !== line.length) {
                state[0] = 0;
                for (let j = 0; j < line.length; j++) {
                  const segment = line[j];
                  pos > subLength && (out += td.decode(sub), buf.copyWithin(0, subLength, pos), pos -= subLength), j > 0 && (buf[pos++] = comma), pos = encodeInteger(buf, pos, state, segment, 0), 1 !== segment.length && (pos = encodeInteger(buf, pos, state, segment, 1), pos = encodeInteger(buf, pos, state, segment, 2), pos = encodeInteger(buf, pos, state, segment, 3), 4 !== segment.length && (pos = encodeInteger(buf, pos, state, segment, 4)));
                }
              }
            }
            return out + td.decode(buf.subarray(0, pos));
          }
          function encodeInteger(buf, pos, state, segment, j) {
            const next = segment[j];
            let num = next - state[j];
            state[j] = next, num = num < 0 ? -num << 1 | 1 : num << 1;
            do {
              let clamped = 31 & num;
              num >>>= 5, num > 0 && (clamped |= 32), buf[pos++] = intToChar[clamped];
            } while (num > 0);
            return pos;
          }
          exports4.decode = decode, exports4.encode = encode, Object.defineProperty(exports4, "__esModule", { value: true });
        }(exports3);
      }, "./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.18/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js": function(__unused_webpack_module, exports3, __webpack_require__2) {
        !function(exports4, sourcemapCodec, resolveUri) {
          "use strict";
          function _interopDefaultLegacy(e) {
            return e && "object" == typeof e && "default" in e ? e : { default: e };
          }
          var resolveUri__default = _interopDefaultLegacy(resolveUri);
          function resolve3(input, base) {
            return base && !base.endsWith("/") && (base += "/"), resolveUri__default.default(input, base);
          }
          function stripFilename(path3) {
            if (!path3)
              return "";
            const index2 = path3.lastIndexOf("/");
            return path3.slice(0, index2 + 1);
          }
          const COLUMN = 0, SOURCES_INDEX = 1, SOURCE_LINE = 2, SOURCE_COLUMN = 3, NAMES_INDEX = 4, REV_GENERATED_LINE = 1, REV_GENERATED_COLUMN = 2;
          function maybeSort(mappings, owned) {
            const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
            if (unsortedIndex === mappings.length)
              return mappings;
            owned || (mappings = mappings.slice());
            for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))
              mappings[i] = sortSegments(mappings[i], owned);
            return mappings;
          }
          function nextUnsortedSegmentLine(mappings, start) {
            for (let i = start; i < mappings.length; i++)
              if (!isSorted(mappings[i]))
                return i;
            return mappings.length;
          }
          function isSorted(line) {
            for (let j = 1; j < line.length; j++)
              if (line[j][COLUMN] < line[j - 1][COLUMN])
                return false;
            return true;
          }
          function sortSegments(line, owned) {
            return owned || (line = line.slice()), line.sort(sortComparator);
          }
          function sortComparator(a, b) {
            return a[COLUMN] - b[COLUMN];
          }
          let found = false;
          function binarySearch(haystack, needle, low, high) {
            for (; low <= high; ) {
              const mid = low + (high - low >> 1), cmp = haystack[mid][COLUMN] - needle;
              if (0 === cmp)
                return found = true, mid;
              cmp < 0 ? low = mid + 1 : high = mid - 1;
            }
            return found = false, low - 1;
          }
          function upperBound(haystack, needle, index2) {
            for (let i = index2 + 1; i < haystack.length && haystack[i][COLUMN] === needle; index2 = i++)
              ;
            return index2;
          }
          function lowerBound(haystack, needle, index2) {
            for (let i = index2 - 1; i >= 0 && haystack[i][COLUMN] === needle; index2 = i--)
              ;
            return index2;
          }
          function memoizedState() {
            return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
          }
          function memoizedBinarySearch(haystack, needle, state, key) {
            const { lastKey, lastNeedle, lastIndex } = state;
            let low = 0, high = haystack.length - 1;
            if (key === lastKey) {
              if (needle === lastNeedle)
                return found = -1 !== lastIndex && haystack[lastIndex][COLUMN] === needle, lastIndex;
              needle >= lastNeedle ? low = -1 === lastIndex ? 0 : lastIndex : high = lastIndex;
            }
            return state.lastKey = key, state.lastNeedle = needle, state.lastIndex = binarySearch(haystack, needle, low, high);
          }
          function buildBySources(decoded, memos) {
            const sources = memos.map(buildNullArray);
            for (let i = 0; i < decoded.length; i++) {
              const line = decoded[i];
              for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                if (1 === seg.length)
                  continue;
                const sourceIndex = seg[SOURCES_INDEX], sourceLine = seg[SOURCE_LINE], sourceColumn = seg[SOURCE_COLUMN], originalSource = sources[sourceIndex], originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []), memo = memos[sourceIndex], index2 = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
                insert(originalLine, memo.lastIndex = index2 + 1, [sourceColumn, i, seg[COLUMN]]);
              }
            }
            return sources;
          }
          function insert(array, index2, value2) {
            for (let i = array.length; i > index2; i--)
              array[i] = array[i - 1];
            array[index2] = value2;
          }
          function buildNullArray() {
            return { __proto__: null };
          }
          const AnyMap = function(map, mapUrl) {
            const parsed = "string" == typeof map ? JSON.parse(map) : map;
            if (!("sections" in parsed))
              return new TraceMap(parsed, mapUrl);
            const mappings = [], sources = [], sourcesContent = [], names = [];
            recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, 1 / 0, 1 / 0);
            const joined = { version: 3, file: parsed.file, names, sources, sourcesContent, mappings };
            return exports4.presortedDecodedMap(joined);
          };
          function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
            const { sections } = input;
            for (let i = 0; i < sections.length; i++) {
              const { map, offset: offset2 } = sections[i];
              let sl = stopLine, sc = stopColumn;
              if (i + 1 < sections.length) {
                const nextOffset = sections[i + 1].offset;
                sl = Math.min(stopLine, lineOffset + nextOffset.line), sl === stopLine ? sc = Math.min(stopColumn, columnOffset + nextOffset.column) : sl < stopLine && (sc = columnOffset + nextOffset.column);
              }
              addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset2.line, columnOffset + offset2.column, sl, sc);
            }
          }
          function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
            if ("sections" in input)
              return recurse(...arguments);
            const map = new TraceMap(input, mapUrl), sourcesOffset = sources.length, namesOffset = names.length, decoded = exports4.decodedMappings(map), { resolvedSources, sourcesContent: contents } = map;
            if (append(sources, resolvedSources), append(names, map.names), contents)
              append(sourcesContent, contents);
            else
              for (let i = 0; i < resolvedSources.length; i++)
                sourcesContent.push(null);
            for (let i = 0; i < decoded.length; i++) {
              const lineI = lineOffset + i;
              if (lineI > stopLine)
                return;
              const out = getLine(mappings, lineI), cOffset = 0 === i ? columnOffset : 0, line = decoded[i];
              for (let j = 0; j < line.length; j++) {
                const seg = line[j], column = cOffset + seg[COLUMN];
                if (lineI === stopLine && column >= stopColumn)
                  return;
                if (1 === seg.length) {
                  out.push([column]);
                  continue;
                }
                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX], sourceLine = seg[SOURCE_LINE], sourceColumn = seg[SOURCE_COLUMN];
                out.push(4 === seg.length ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
              }
            }
          }
          function append(arr, other) {
            for (let i = 0; i < other.length; i++)
              arr.push(other[i]);
          }
          function getLine(arr, index2) {
            for (let i = arr.length; i <= index2; i++)
              arr[i] = [];
            return arr[index2];
          }
          const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)", COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)", LEAST_UPPER_BOUND = -1, GREATEST_LOWER_BOUND = 1;
          exports4.encodedMappings = void 0, exports4.decodedMappings = void 0, exports4.traceSegment = void 0, exports4.originalPositionFor = void 0, exports4.generatedPositionFor = void 0, exports4.allGeneratedPositionsFor = void 0, exports4.eachMapping = void 0, exports4.sourceContentFor = void 0, exports4.presortedDecodedMap = void 0, exports4.decodedMap = void 0, exports4.encodedMap = void 0;
          class TraceMap {
            constructor(map, mapUrl) {
              const isString = "string" == typeof map;
              if (!isString && map._decodedMemo)
                return map;
              const parsed = isString ? JSON.parse(map) : map, { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
              this.version = version2, this.file = file, this.names = names, this.sourceRoot = sourceRoot, this.sources = sources, this.sourcesContent = sourcesContent;
              const from = resolve3(sourceRoot || "", stripFilename(mapUrl));
              this.resolvedSources = sources.map((s) => resolve3(s || "", from));
              const { mappings } = parsed;
              "string" == typeof mappings ? (this._encoded = mappings, this._decoded = void 0) : (this._encoded = void 0, this._decoded = maybeSort(mappings, isString)), this._decodedMemo = memoizedState(), this._bySources = void 0, this._bySourceMemos = void 0;
            }
          }
          function clone(map, mappings) {
            return { version: map.version, file: map.file, names: map.names, sourceRoot: map.sourceRoot, sources: map.sources, sourcesContent: map.sourcesContent, mappings };
          }
          function OMapping(source, line, column, name) {
            return { source, line, column, name };
          }
          function GMapping(line, column) {
            return { line, column };
          }
          function traceSegmentInternal(segments, memo, line, column, bias) {
            let index2 = memoizedBinarySearch(segments, column, memo, line);
            return found ? index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2) : bias === LEAST_UPPER_BOUND && index2++, -1 === index2 || index2 === segments.length ? -1 : index2;
          }
          function sliceGeneratedPositions(segments, memo, line, column, bias) {
            let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
            if (found || bias !== LEAST_UPPER_BOUND || min++, -1 === min || min === segments.length)
              return [];
            const matchedColumn = found ? column : segments[min][COLUMN];
            found || (min = lowerBound(segments, matchedColumn, min));
            const max = upperBound(segments, matchedColumn, min), result = [];
            for (; min <= max; min++) {
              const segment = segments[min];
              result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
            }
            return result;
          }
          (() => {
            function generatedPosition(map, source, line, column, bias, all) {
              if (--line < 0)
                throw new Error(LINE_GTR_ZERO);
              if (column < 0)
                throw new Error(COL_GTR_EQ_ZERO);
              const { sources, resolvedSources } = map;
              let sourceIndex = sources.indexOf(source);
              if (-1 === sourceIndex && (sourceIndex = resolvedSources.indexOf(source)), -1 === sourceIndex)
                return all ? [] : GMapping(null, null);
              const segments = (map._bySources || (map._bySources = buildBySources(exports4.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState))))[sourceIndex][line];
              if (null == segments)
                return all ? [] : GMapping(null, null);
              const memo = map._bySourceMemos[sourceIndex];
              if (all)
                return sliceGeneratedPositions(segments, memo, line, column, bias);
              const index2 = traceSegmentInternal(segments, memo, line, column, bias);
              if (-1 === index2)
                return GMapping(null, null);
              const segment = segments[index2];
              return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
            }
            exports4.encodedMappings = (map) => {
              var _a;
              return null !== (_a = map._encoded) && void 0 !== _a ? _a : map._encoded = sourcemapCodec.encode(map._decoded);
            }, exports4.decodedMappings = (map) => map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded)), exports4.traceSegment = (map, line, column) => {
              const decoded = exports4.decodedMappings(map);
              if (line >= decoded.length)
                return null;
              const segments = decoded[line], index2 = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
              return -1 === index2 ? null : segments[index2];
            }, exports4.originalPositionFor = (map, { line, column, bias }) => {
              if (--line < 0)
                throw new Error(LINE_GTR_ZERO);
              if (column < 0)
                throw new Error(COL_GTR_EQ_ZERO);
              const decoded = exports4.decodedMappings(map);
              if (line >= decoded.length)
                return OMapping(null, null, null, null);
              const segments = decoded[line], index2 = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
              if (-1 === index2)
                return OMapping(null, null, null, null);
              const segment = segments[index2];
              if (1 === segment.length)
                return OMapping(null, null, null, null);
              const { names, resolvedSources } = map;
              return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], 5 === segment.length ? names[segment[NAMES_INDEX]] : null);
            }, exports4.allGeneratedPositionsFor = (map, { source, line, column, bias }) => generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true), exports4.generatedPositionFor = (map, { source, line, column, bias }) => generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false), exports4.eachMapping = (map, cb) => {
              const decoded = exports4.decodedMappings(map), { names, resolvedSources } = map;
              for (let i = 0; i < decoded.length; i++) {
                const line = decoded[i];
                for (let j = 0; j < line.length; j++) {
                  const seg = line[j], generatedLine = i + 1, generatedColumn = seg[0];
                  let source = null, originalLine = null, originalColumn = null, name = null;
                  1 !== seg.length && (source = resolvedSources[seg[1]], originalLine = seg[2] + 1, originalColumn = seg[3]), 5 === seg.length && (name = names[seg[4]]), cb({ generatedLine, generatedColumn, source, originalLine, originalColumn, name });
                }
              }
            }, exports4.sourceContentFor = (map, source) => {
              const { sources, resolvedSources, sourcesContent } = map;
              if (null == sourcesContent)
                return null;
              let index2 = sources.indexOf(source);
              return -1 === index2 && (index2 = resolvedSources.indexOf(source)), -1 === index2 ? null : sourcesContent[index2];
            }, exports4.presortedDecodedMap = (map, mapUrl) => {
              const tracer = new TraceMap(clone(map, []), mapUrl);
              return tracer._decoded = map.mappings, tracer;
            }, exports4.decodedMap = (map) => clone(map, exports4.decodedMappings(map)), exports4.encodedMap = (map) => clone(map, exports4.encodedMappings(map));
          })(), exports4.AnyMap = AnyMap, exports4.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND, exports4.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND, exports4.TraceMap = TraceMap, Object.defineProperty(exports4, "__esModule", { value: true });
        }(exports3, __webpack_require__2("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.14/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), __webpack_require__2("./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.0/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"));
      }, "./node_modules/.pnpm/@nicolo-ribaudo+semver-v6@6.3.3/node_modules/@nicolo-ribaudo/semver-v6/semver.js": (module4, exports3) => {
        var debug;
        exports3 = module4.exports = SemVer, debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
          var args = Array.prototype.slice.call(arguments, 0);
          args.unshift("SEMVER"), console.log.apply(console, args);
        } : function() {
        }, exports3.SEMVER_SPEC_VERSION = "2.0.0";
        var MAX_LENGTH = 256, MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991, re = exports3.re = [], safeRe = exports3.safeRe = [], src = exports3.src = [], t = exports3.tokens = {}, R = 0;
        function tok(n) {
          t[n] = R++;
        }
        tok("NUMERICIDENTIFIER"), src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*", tok("NUMERICIDENTIFIERLOOSE"), src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+", tok("NONNUMERICIDENTIFIER"), src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", tok("MAINVERSION"), src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")", tok("MAINVERSIONLOOSE"), src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")", tok("PRERELEASEIDENTIFIER"), src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")", tok("PRERELEASEIDENTIFIERLOOSE"), src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")", tok("PRERELEASE"), src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))", tok("PRERELEASELOOSE"), src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))", tok("BUILDIDENTIFIER"), src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+", tok("BUILD"), src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))", tok("FULL"), tok("FULLPLAIN"), src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?", src[t.FULL] = "^" + src[t.FULLPLAIN] + "$", tok("LOOSEPLAIN"), src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?", tok("LOOSE"), src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$", tok("GTLT"), src[t.GTLT] = "((?:<|>)?=?)", tok("XRANGEIDENTIFIERLOOSE"), src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", tok("XRANGEIDENTIFIER"), src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*", tok("XRANGEPLAIN"), src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?", tok("XRANGEPLAINLOOSE"), src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?", tok("XRANGE"), src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$", tok("XRANGELOOSE"), src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$", tok("COERCE"), src[t.COERCE] = "(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])", tok("COERCERTL"), re[t.COERCERTL] = new RegExp(src[t.COERCE], "g"), tok("LONETILDE"), src[t.LONETILDE] = "(?:~>?)", tok("TILDETRIM"), src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+", re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
        tok("TILDE"), src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$", tok("TILDELOOSE"), src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$", tok("LONECARET"), src[t.LONECARET] = "(?:\\^)", tok("CARETTRIM"), src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+", re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
        tok("CARET"), src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$", tok("CARETLOOSE"), src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$", tok("COMPARATORLOOSE"), src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$", tok("COMPARATOR"), src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$", tok("COMPARATORTRIM"), src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
        tok("HYPHENRANGE"), src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$", tok("HYPHENRANGELOOSE"), src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$", tok("STAR"), src[t.STAR] = "(<|>)?=?\\s*\\*";
        for (var i = 0; i < R; i++)
          debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
        for (var index2 = 0; index2 < re.length; index2++) {
          var safe = re[index2].source.split("\\s*").join("\\s{0,1}").split("\\s+").join("\\s");
          safeRe[index2] = new RegExp(safe, re[index2].flags);
        }
        function parse5(version2, options) {
          if (options && "object" == typeof options || (options = { loose: !!options, includePrerelease: false }), version2 instanceof SemVer)
            return version2;
          if ("string" != typeof version2)
            return null;
          if (version2.length > MAX_LENGTH)
            return null;
          if (!(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]).test(version2))
            return null;
          try {
            return new SemVer(version2, options);
          } catch (er) {
            return null;
          }
        }
        function SemVer(version2, options) {
          if (options && "object" == typeof options || (options = { loose: !!options, includePrerelease: false }), version2 instanceof SemVer) {
            if (version2.loose === options.loose)
              return version2;
            version2 = version2.version;
          } else if ("string" != typeof version2)
            throw new TypeError("Invalid Version: " + version2);
          if (version2.length > MAX_LENGTH)
            throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
          if (!(this instanceof SemVer))
            return new SemVer(version2, options);
          debug("SemVer", version2, options), this.options = options, this.loose = !!options.loose;
          var m2 = version2.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
          if (!m2)
            throw new TypeError("Invalid Version: " + version2);
          if (this.raw = version2, this.major = +m2[1], this.minor = +m2[2], this.patch = +m2[3], this.major > MAX_SAFE_INTEGER2 || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0)
            throw new TypeError("Invalid patch version");
          m2[4] ? this.prerelease = m2[4].split(".").map(function(id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2)
                return num;
            }
            return id;
          }) : this.prerelease = [], this.build = m2[5] ? m2[5].split(".") : [], this.format();
        }
        exports3.parse = parse5, exports3.valid = function(version2, options) {
          var v = parse5(version2, options);
          return v ? v.version : null;
        }, exports3.clean = function(version2, options) {
          var s = parse5(version2.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        }, exports3.SemVer = SemVer, SemVer.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, SemVer.prototype.toString = function() {
          return this.version;
        }, SemVer.prototype.compare = function(other) {
          return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), this.compareMain(other) || this.comparePre(other);
        }, SemVer.prototype.compareMain = function(other) {
          return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }, SemVer.prototype.comparePre = function(other) {
          if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
            return -1;
          if (!this.prerelease.length && other.prerelease.length)
            return 1;
          if (!this.prerelease.length && !other.prerelease.length)
            return 0;
          var i2 = 0;
          do {
            var a = this.prerelease[i2], b = other.prerelease[i2];
            if (debug("prerelease compare", i2, a, b), void 0 === a && void 0 === b)
              return 0;
            if (void 0 === b)
              return 1;
            if (void 0 === a)
              return -1;
            if (a !== b)
              return compareIdentifiers(a, b);
          } while (++i2);
        }, SemVer.prototype.compareBuild = function(other) {
          other instanceof SemVer || (other = new SemVer(other, this.options));
          var i2 = 0;
          do {
            var a = this.build[i2], b = other.build[i2];
            if (debug("prerelease compare", i2, a, b), void 0 === a && void 0 === b)
              return 0;
            if (void 0 === b)
              return 1;
            if (void 0 === a)
              return -1;
            if (a !== b)
              return compareIdentifiers(a, b);
          } while (++i2);
        }, SemVer.prototype.inc = function(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
              break;
            case "prerelease":
              0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
              break;
            case "major":
              0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              0 === this.prerelease.length && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (0 === this.prerelease.length)
                this.prerelease = [0];
              else {
                for (var i2 = this.prerelease.length; --i2 >= 0; )
                  "number" == typeof this.prerelease[i2] && (this.prerelease[i2]++, i2 = -2);
                -1 === i2 && this.prerelease.push(0);
              }
              identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
              break;
            default:
              throw new Error("invalid increment argument: " + release);
          }
          return this.format(), this.raw = this.version, this;
        }, exports3.inc = function(version2, release, loose, identifier) {
          "string" == typeof loose && (identifier = loose, loose = void 0);
          try {
            return new SemVer(version2, loose).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        }, exports3.diff = function(version1, version2) {
          if (eq2(version1, version2))
            return null;
          var v1 = parse5(version1), v2 = parse5(version2), prefix = "";
          if (v1.prerelease.length || v2.prerelease.length) {
            prefix = "pre";
            var defaultResult = "prerelease";
          }
          for (var key in v1)
            if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key])
              return prefix + key;
          return defaultResult;
        }, exports3.compareIdentifiers = compareIdentifiers;
        var numeric = /^[0-9]+$/;
        function compareIdentifiers(a, b) {
          var anum = numeric.test(a), bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        }
        function compare(a, b, loose) {
          return new SemVer(a, loose).compare(new SemVer(b, loose));
        }
        function gt(a, b, loose) {
          return compare(a, b, loose) > 0;
        }
        function lt(a, b, loose) {
          return compare(a, b, loose) < 0;
        }
        function eq2(a, b, loose) {
          return 0 === compare(a, b, loose);
        }
        function neq(a, b, loose) {
          return 0 !== compare(a, b, loose);
        }
        function gte(a, b, loose) {
          return compare(a, b, loose) >= 0;
        }
        function lte(a, b, loose) {
          return compare(a, b, loose) <= 0;
        }
        function cmp(a, op, b, loose) {
          switch (op) {
            case "===":
              return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), a === b;
            case "!==":
              return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), a !== b;
            case "":
            case "=":
            case "==":
              return eq2(a, b, loose);
            case "!=":
              return neq(a, b, loose);
            case ">":
              return gt(a, b, loose);
            case ">=":
              return gte(a, b, loose);
            case "<":
              return lt(a, b, loose);
            case "<=":
              return lte(a, b, loose);
            default:
              throw new TypeError("Invalid operator: " + op);
          }
        }
        function Comparator(comp, options) {
          if (options && "object" == typeof options || (options = { loose: !!options, includePrerelease: false }), comp instanceof Comparator) {
            if (comp.loose === !!options.loose)
              return comp;
            comp = comp.value;
          }
          if (!(this instanceof Comparator))
            return new Comparator(comp, options);
          comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
        }
        exports3.rcompareIdentifiers = function(a, b) {
          return compareIdentifiers(b, a);
        }, exports3.major = function(a, loose) {
          return new SemVer(a, loose).major;
        }, exports3.minor = function(a, loose) {
          return new SemVer(a, loose).minor;
        }, exports3.patch = function(a, loose) {
          return new SemVer(a, loose).patch;
        }, exports3.compare = compare, exports3.compareLoose = function(a, b) {
          return compare(a, b, true);
        }, exports3.compareBuild = function(a, b, loose) {
          var versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        }, exports3.rcompare = function(a, b, loose) {
          return compare(b, a, loose);
        }, exports3.sort = function(list, loose) {
          return list.sort(function(a, b) {
            return exports3.compareBuild(a, b, loose);
          });
        }, exports3.rsort = function(list, loose) {
          return list.sort(function(a, b) {
            return exports3.compareBuild(b, a, loose);
          });
        }, exports3.gt = gt, exports3.lt = lt, exports3.eq = eq2, exports3.neq = neq, exports3.gte = gte, exports3.lte = lte, exports3.cmp = cmp, exports3.Comparator = Comparator;
        var ANY = {};
        function Range(range, options) {
          if (options && "object" == typeof options || (options = { loose: !!options, includePrerelease: false }), range instanceof Range)
            return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
          if (range instanceof Comparator)
            return new Range(range.value, options);
          if (!(this instanceof Range))
            return new Range(range, options);
          if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split(/\s*\|\|\s*/).map(function(range2) {
            return this.parseRange(range2);
          }, this).filter(function(c) {
            return c.length;
          }), !this.set.length)
            throw new TypeError("Invalid SemVer Range: " + this.raw);
          this.format();
        }
        function isSatisfiable(comparators, options) {
          for (var result = true, remainingComparators = comparators.slice(), testComparator = remainingComparators.pop(); result && remainingComparators.length; )
            result = remainingComparators.every(function(otherComparator) {
              return testComparator.intersects(otherComparator, options);
            }), testComparator = remainingComparators.pop();
          return result;
        }
        function isX(id) {
          return !id || "x" === id.toLowerCase() || "*" === id;
        }
        function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
          return ((from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from) + " " + (to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to)).trim();
        }
        function testSet(set, version2, options) {
          for (var i2 = 0; i2 < set.length; i2++)
            if (!set[i2].test(version2))
              return false;
          if (version2.prerelease.length && !options.includePrerelease) {
            for (i2 = 0; i2 < set.length; i2++)
              if (debug(set[i2].semver), set[i2].semver !== ANY && set[i2].semver.prerelease.length > 0) {
                var allowed = set[i2].semver;
                if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch)
                  return true;
              }
            return false;
          }
          return true;
        }
        function satisfies2(version2, range, options) {
          try {
            range = new Range(range, options);
          } catch (er) {
            return false;
          }
          return range.test(version2);
        }
        function outside(version2, range, hilo, options) {
          var gtfn, ltefn, ltfn, comp, ecomp;
          switch (version2 = new SemVer(version2, options), range = new Range(range, options), hilo) {
            case ">":
              gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
              break;
            case "<":
              gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies2(version2, range, options))
            return false;
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            var comparators = range.set[i2], high = null, low = null;
            if (comparators.forEach(function(comparator) {
              comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
            }), high.operator === comp || high.operator === ecomp)
              return false;
            if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver))
              return false;
            if (low.operator === ecomp && ltfn(version2, low.semver))
              return false;
          }
          return true;
        }
        Comparator.prototype.parse = function(comp) {
          var r2 = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR], m2 = comp.match(r2);
          if (!m2)
            throw new TypeError("Invalid comparator: " + comp);
          this.operator = void 0 !== m2[1] ? m2[1] : "", "=" === this.operator && (this.operator = ""), m2[2] ? this.semver = new SemVer(m2[2], this.options.loose) : this.semver = ANY;
        }, Comparator.prototype.toString = function() {
          return this.value;
        }, Comparator.prototype.test = function(version2) {
          if (debug("Comparator.test", version2, this.options.loose), this.semver === ANY || version2 === ANY)
            return true;
          if ("string" == typeof version2)
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          return cmp(version2, this.operator, this.semver, this.options);
        }, Comparator.prototype.intersects = function(comp, options) {
          if (!(comp instanceof Comparator))
            throw new TypeError("a Comparator is required");
          var rangeTmp;
          if (options && "object" == typeof options || (options = { loose: !!options, includePrerelease: false }), "" === this.operator)
            return "" === this.value || (rangeTmp = new Range(comp.value, options), satisfies2(this.value, rangeTmp, options));
          if ("" === comp.operator)
            return "" === comp.value || (rangeTmp = new Range(this.value, options), satisfies2(comp.semver, rangeTmp, options));
          var sameDirectionIncreasing = !(">=" !== this.operator && ">" !== this.operator || ">=" !== comp.operator && ">" !== comp.operator), sameDirectionDecreasing = !("<=" !== this.operator && "<" !== this.operator || "<=" !== comp.operator && "<" !== comp.operator), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== comp.operator && "<=" !== comp.operator), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (">=" === this.operator || ">" === this.operator) && ("<=" === comp.operator || "<" === comp.operator), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ("<=" === this.operator || "<" === this.operator) && (">=" === comp.operator || ">" === comp.operator);
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }, exports3.Range = Range, Range.prototype.format = function() {
          return this.range = this.set.map(function(comps) {
            return comps.join(" ").trim();
          }).join("||").trim(), this.range;
        }, Range.prototype.toString = function() {
          return this.range;
        }, Range.prototype.parseRange = function(range) {
          var loose = this.options.loose, hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(safeRe[t.COMPARATORTRIM], "$1$2$3"), debug("comparator trim", range, safeRe[t.COMPARATORTRIM]), range = (range = range.replace(safeRe[t.TILDETRIM], "$1~")).replace(safeRe[t.CARETTRIM], "$1^");
          var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR], set = range.split(" ").map(function(comp) {
            return function(comp2, options) {
              return debug("comp", comp2, options), comp2 = function(comp3, options2) {
                return comp3.trim().split(/\s+/).map(function(comp4) {
                  return function(comp5, options3) {
                    debug("caret", comp5, options3);
                    var r2 = options3.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
                    return comp5.replace(r2, function(_, M, m2, p, pr) {
                      var ret;
                      return debug("caret", comp5, _, M, m2, p, pr), isX(M) ? ret = "" : isX(m2) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = "0" === M ? ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0" : ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), ret = "0" === M ? "0" === m2 ? ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1) : ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0" : ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), ret = "0" === M ? "0" === m2 ? ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1) : ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0" : ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
                    });
                  }(comp4, options2);
                }).join(" ");
              }(comp2, options), debug("caret", comp2), comp2 = function(comp3, options2) {
                return comp3.trim().split(/\s+/).map(function(comp4) {
                  return function(comp5, options3) {
                    var r2 = options3.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
                    return comp5.replace(r2, function(_, M, m2, p, pr) {
                      var ret;
                      return debug("tilde", comp5, _, M, m2, p, pr), isX(M) ? ret = "" : isX(m2) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0") : ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0", debug("tilde return", ret), ret;
                    });
                  }(comp4, options2);
                }).join(" ");
              }(comp2, options), debug("tildes", comp2), comp2 = function(comp3, options2) {
                return debug("replaceXRanges", comp3, options2), comp3.split(/\s+/).map(function(comp4) {
                  return function(comp5, options3) {
                    comp5 = comp5.trim();
                    var r2 = options3.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
                    return comp5.replace(r2, function(ret, gtlt, M, m2, p, pr) {
                      debug("xRange", comp5, ret, gtlt, M, m2, p, pr);
                      var xM = isX(M), xm = xM || isX(m2), xp = xm || isX(p), anyX = xp;
                      return "=" === gtlt && anyX && (gtlt = ""), pr = options3.includePrerelease ? "-0" : "", xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m2 = 0), p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m2 = 0, p = 0) : (m2 = +m2 + 1, p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m2 = +m2 + 1), ret = gtlt + M + "." + m2 + "." + p + pr) : xm ? ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr : xp && (ret = ">=" + M + "." + m2 + ".0" + pr + " <" + M + "." + (+m2 + 1) + ".0" + pr), debug("xRange return", ret), ret;
                    });
                  }(comp4, options2);
                }).join(" ");
              }(comp2, options), debug("xrange", comp2), comp2 = function(comp3, options2) {
                return debug("replaceStars", comp3, options2), comp3.trim().replace(safeRe[t.STAR], "");
              }(comp2, options), debug("stars", comp2), comp2;
            }(comp, this.options);
          }, this).join(" ").split(/\s+/);
          return this.options.loose && (set = set.filter(function(comp) {
            return !!comp.match(compRe);
          })), set = set.map(function(comp) {
            return new Comparator(comp, this.options);
          }, this);
        }, Range.prototype.intersects = function(range, options) {
          if (!(range instanceof Range))
            throw new TypeError("a Range is required");
          return this.set.some(function(thisComparators) {
            return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
              return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
                return rangeComparators.every(function(rangeComparator) {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }, exports3.toComparators = function(range, options) {
          return new Range(range, options).set.map(function(comp) {
            return comp.map(function(c) {
              return c.value;
            }).join(" ").trim().split(" ");
          });
        }, Range.prototype.test = function(version2) {
          if (!version2)
            return false;
          if ("string" == typeof version2)
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          for (var i2 = 0; i2 < this.set.length; i2++)
            if (testSet(this.set[i2], version2, this.options))
              return true;
          return false;
        }, exports3.satisfies = satisfies2, exports3.maxSatisfying = function(versions, range, options) {
          var max = null, maxSV = null;
          try {
            var rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach(function(v) {
            rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (maxSV = new SemVer(max = v, options)));
          }), max;
        }, exports3.minSatisfying = function(versions, range, options) {
          var min = null, minSV = null;
          try {
            var rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach(function(v) {
            rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (minSV = new SemVer(min = v, options)));
          }), min;
        }, exports3.minVersion = function(range, loose) {
          range = new Range(range, loose);
          var minver = new SemVer("0.0.0");
          if (range.test(minver))
            return minver;
          if (minver = new SemVer("0.0.0-0"), range.test(minver))
            return minver;
          minver = null;
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            range.set[i2].forEach(function(comparator) {
              var compver = new SemVer(comparator.semver.version);
              switch (comparator.operator) {
                case ">":
                  0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
                case "":
                case ">=":
                  minver && !gt(minver, compver) || (minver = compver);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error("Unexpected operation: " + comparator.operator);
              }
            });
          }
          if (minver && range.test(minver))
            return minver;
          return null;
        }, exports3.validRange = function(range, options) {
          try {
            return new Range(range, options).range || "*";
          } catch (er) {
            return null;
          }
        }, exports3.ltr = function(version2, range, options) {
          return outside(version2, range, "<", options);
        }, exports3.gtr = function(version2, range, options) {
          return outside(version2, range, ">", options);
        }, exports3.outside = outside, exports3.prerelease = function(version2, options) {
          var parsed = parse5(version2, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        }, exports3.intersects = function(r1, r2, options) {
          return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
        }, exports3.coerce = function(version2, options) {
          if (version2 instanceof SemVer)
            return version2;
          "number" == typeof version2 && (version2 = String(version2));
          if ("string" != typeof version2)
            return null;
          var match = null;
          if ((options = options || {}).rtl) {
            for (var next; (next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length); )
              match && next.index + next[0].length === match.index + match[0].length || (match = next), safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            safeRe[t.COERCERTL].lastIndex = -1;
          } else
            match = version2.match(safeRe[t.COERCE]);
          if (null === match)
            return null;
          return parse5(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
        };
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js": (module4, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(api) {
          var transformImport = (0, _utils.createDynamicImportTransform)(api);
          return { manipulateOptions: function(opts, parserOpts) {
            parserOpts.plugins.push("dynamicImport");
          }, visitor: { Import: function(path3) {
            transformImport(this, path3);
          } } };
        };
        var _utils = __webpack_require__2("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js");
        module4.exports = exports3.default;
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var _slicedToArray = function(arr, i) {
          if (Array.isArray(arr))
            return arr;
          if (Symbol.iterator in Object(arr))
            return function(arr2, i2) {
              var _arr = [], _n = true, _d = false, _e = void 0;
              try {
                for (var _s, _i = arr2[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i2 || _arr.length !== i2); _n = true)
                  ;
              } catch (err) {
                _d = true, _e = err;
              } finally {
                try {
                  !_n && _i.return && _i.return();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }(arr, i);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
        function getImportSource(t, callNode) {
          var importArguments = callNode.arguments, importPath = _slicedToArray(importArguments, 1)[0];
          return t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath) ? (t.removeComments(importPath), importPath) : t.templateLiteral([t.templateElement({ raw: "", cooked: "" }), t.templateElement({ raw: "", cooked: "" }, true)], importArguments);
        }
        exports3.getImportSource = getImportSource, exports3.createDynamicImportTransform = function(_ref) {
          var template2 = _ref.template, t = _ref.types, builders = { static: { interop: template2("Promise.resolve().then(() => INTEROP(require(SOURCE)))"), noInterop: template2("Promise.resolve().then(() => require(SOURCE))") }, dynamic: { interop: template2("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"), noInterop: template2("Promise.resolve(SOURCE).then(s => require(s))") } }, visited = "function" == typeof WeakSet && /* @__PURE__ */ new WeakSet();
          return function(context, path3) {
            if (visited) {
              if (visited.has(path3))
                return;
              visited.add(path3);
            }
            var node, SOURCE = getImportSource(t, path3.parent), builder = (node = SOURCE, t.isStringLiteral(node) || t.isTemplateLiteral(node) && 0 === node.expressions.length ? builders.static : builders.dynamic), newImport = context.opts.noInterop ? builder.noInterop({ SOURCE }) : builder.interop({ SOURCE, INTEROP: context.addHelper("interopRequireWildcard") });
            path3.parentPath.replaceWith(newImport);
          };
        };
      }, "./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _path = __webpack_require__2("path");
        function isInType(path3) {
          switch (path3.parent.type) {
            case "TSTypeReference":
            case "TSQualifiedName":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            default:
              return false;
          }
        }
        module4.exports = function(_ref) {
          var types2 = _ref.types, decoratorExpressionForConstructor = function(decorator, param) {
            return function(className) {
              var resultantDecorator = types2.callExpression(decorator.expression, [types2.Identifier(className), types2.Identifier("undefined"), types2.NumericLiteral(param.key)]), resultantDecoratorWithFallback = types2.logicalExpression("||", resultantDecorator, types2.Identifier(className)), assignment = types2.assignmentExpression("=", types2.Identifier(className), resultantDecoratorWithFallback);
              return types2.expressionStatement(assignment);
            };
          }, decoratorExpressionForMethod = function(decorator, param) {
            return function(className, functionName) {
              var resultantDecorator = types2.callExpression(decorator.expression, [types2.Identifier("".concat(className, ".prototype")), types2.StringLiteral(functionName), types2.NumericLiteral(param.key)]);
              return types2.expressionStatement(resultantDecorator);
            };
          };
          return { visitor: { Program: function(path3, state) {
            var extension = (0, _path.extname)(state.file.opts.filename);
            ".ts" !== extension && ".tsx" !== extension || function() {
              var decorators = /* @__PURE__ */ Object.create(null);
              path3.node.body.filter(function(it) {
                var type = it.type, declaration = it.declaration;
                switch (type) {
                  case "ClassDeclaration":
                    return true;
                  case "ExportNamedDeclaration":
                  case "ExportDefaultDeclaration":
                    return declaration && "ClassDeclaration" === declaration.type;
                  default:
                    return false;
                }
              }).map(function(it) {
                return "ClassDeclaration" === it.type ? it : it.declaration;
              }).forEach(function(clazz) {
                clazz.body.body.forEach(function(body) {
                  (body.params || []).forEach(function(param) {
                    (param.decorators || []).forEach(function(decorator) {
                      decorator.expression.callee ? decorators[decorator.expression.callee.name] = decorator : decorators[decorator.expression.name] = decorator;
                    });
                  });
                });
              });
              var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
              try {
                for (var _step, _iterator = path3.get("body")[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var stmt = _step.value;
                  if ("ImportDeclaration" === stmt.node.type) {
                    if (0 === stmt.node.specifiers.length)
                      continue;
                    var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
                    try {
                      for (var _step2, _loop = function() {
                        var specifier = _step2.value, binding = stmt.scope.getBinding(specifier.local.name);
                        binding.referencePaths.length ? binding.referencePaths.reduce(function(prev, next) {
                          return prev || isInType(next);
                        }, false) && Object.keys(decorators).forEach(function(k) {
                          var decorator = decorators[k];
                          (decorator.expression.arguments || []).forEach(function(arg) {
                            arg.name === specifier.local.name && binding.referencePaths.push({ parent: decorator.expression });
                          });
                        }) : decorators[specifier.local.name] && binding.referencePaths.push({ parent: decorators[specifier.local.name] });
                      }, _iterator2 = stmt.node.specifiers[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true)
                        _loop();
                    } catch (err) {
                      _didIteratorError2 = true, _iteratorError2 = err;
                    } finally {
                      try {
                        _iteratorNormalCompletion2 || null == _iterator2.return || _iterator2.return();
                      } finally {
                        if (_didIteratorError2)
                          throw _iteratorError2;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError = true, _iteratorError = err;
              } finally {
                try {
                  _iteratorNormalCompletion || null == _iterator.return || _iterator.return();
                } finally {
                  if (_didIteratorError)
                    throw _iteratorError;
                }
              }
            }();
          }, Function: function(path3) {
            var functionName = "";
            path3.node.id ? functionName = path3.node.id.name : path3.node.key && (functionName = path3.node.key.name), (path3.get("params") || []).slice().forEach(function(param) {
              var decorators = param.node.decorators || [], transformable = decorators.length;
              if (decorators.slice().forEach(function(decorator) {
                if ("ClassMethod" === path3.type) {
                  var classIdentifier, parentNode = path3.parentPath.parentPath, classDeclaration = path3.findParent(function(p) {
                    return "ClassDeclaration" === p.type;
                  });
                  if (classDeclaration ? classIdentifier = classDeclaration.node.id.name : (parentNode.insertAfter(null), classIdentifier = function(path4) {
                    var assignment = path4.findParent(function(p) {
                      return "AssignmentExpression" === p.node.type;
                    });
                    return "SequenceExpression" === assignment.node.right.type ? assignment.node.right.expressions[1].name : "ClassExpression" === assignment.node.right.type ? assignment.node.left.name : null;
                  }(path3)), "constructor" === functionName) {
                    var expression = decoratorExpressionForConstructor(decorator, param)(classIdentifier);
                    parentNode.insertAfter(expression);
                  } else {
                    var _expression = decoratorExpressionForMethod(decorator, param)(classIdentifier, functionName);
                    parentNode.insertAfter(_expression);
                  }
                } else {
                  var className = path3.findParent(function(p) {
                    return "VariableDeclarator" === p.node.type;
                  }).node.id.name;
                  if (functionName === className) {
                    var _expression2 = decoratorExpressionForConstructor(decorator, param)(className);
                    if ("body" === path3.parentKey)
                      path3.insertAfter(_expression2);
                    else
                      path3.findParent(function(p) {
                        return "body" === p.parentKey;
                      }).insertAfter(_expression2);
                  } else {
                    var classParent = path3.findParent(function(p) {
                      return "CallExpression" === p.node.type;
                    }), _expression3 = decoratorExpressionForMethod(decorator, param)(className, functionName);
                    classParent.insertAfter(_expression3);
                  }
                }
              }), transformable) {
                var replacement = function(path4) {
                  switch (path4.node.type) {
                    case "ObjectPattern":
                      return types2.ObjectPattern(path4.node.properties);
                    case "AssignmentPattern":
                      return types2.AssignmentPattern(path4.node.left, path4.node.right);
                    case "TSParameterProperty":
                      return types2.Identifier(path4.node.parameter.name);
                    default:
                      return types2.Identifier(path4.node.name);
                  }
                }(param);
                param.replaceWith(replacement);
              }
            });
          } } };
        };
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.metadataVisitor = function(classPath, path3) {
          const field = path3.node, classNode = classPath.node;
          switch (field.type) {
            case "ClassMethod":
              const decorators = "constructor" === field.kind ? classNode.decorators : field.decorators;
              if (!decorators || 0 === decorators.length)
                return;
              decorators.push(createMetadataDesignDecorator("design:type", _core.types.identifier("Function"))), decorators.push(createMetadataDesignDecorator("design:paramtypes", _core.types.arrayExpression(field.params.map((param) => (0, _serializeType.serializeType)(classPath, param)))));
              break;
            case "ClassProperty":
              if (!field.decorators || 0 === field.decorators.length)
                return;
              if (!field.typeAnnotation || "TSTypeAnnotation" !== field.typeAnnotation.type)
                return;
              field.decorators.push(createMetadataDesignDecorator("design:type", (0, _serializeType.serializeType)(classPath, field)));
          }
        };
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _serializeType = __webpack_require__2("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js");
        function createMetadataDesignDecorator(design, typeArg) {
          return _core.types.decorator(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier("Reflect"), _core.types.identifier("metadata")), [_core.types.stringLiteral(design), typeArg]));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.serializeType = function(classPath, param) {
          const node = getTypedNode(param);
          if (null == node)
            return createVoidZero();
          if (!node.typeAnnotation || "TSTypeAnnotation" !== node.typeAnnotation.type)
            return createVoidZero();
          const annotation = node.typeAnnotation.typeAnnotation;
          return serializeTypeNode(classPath.node.id ? classPath.node.id.name : "", annotation);
        }, exports3.isClassType = isClassType;
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js");
        function createVoidZero() {
          return _core.types.unaryExpression("void", _core.types.numericLiteral(0));
        }
        function getTypedNode(param) {
          return null == param ? null : "ClassProperty" === param.type || "Identifier" === param.type || "ObjectPattern" === param.type ? param : "AssignmentPattern" === param.type && "Identifier" === param.left.type ? param.left : "TSParameterProperty" === param.type ? getTypedNode(param.parameter) : null;
        }
        function serializeTypeReferenceNode(className, node) {
          const reference = serializeReference(node.typeName);
          return isClassType(className, reference) ? _core.types.identifier("Object") : _core.types.conditionalExpression(_core.types.binaryExpression("===", _core.types.unaryExpression("typeof", reference), _core.types.stringLiteral("undefined")), _core.types.identifier("Object"), _core.types.cloneDeep(reference));
        }
        function isClassType(className, node) {
          switch (node.type) {
            case "Identifier":
              return node.name === className;
            case "MemberExpression":
              return isClassType(className, node.object);
            default:
              throw new Error(`The property expression at ${node.start} is not valid as a Type to be used in Reflect.metadata`);
          }
        }
        function serializeReference(typeName) {
          return "Identifier" === typeName.type ? _core.types.identifier(typeName.name) : _core.types.memberExpression(serializeReference(typeName.left), typeName.right);
        }
        function serializeTypeNode(className, node) {
          if (void 0 === node)
            return _core.types.identifier("Object");
          switch (node.type) {
            case "TSVoidKeyword":
            case "TSUndefinedKeyword":
            case "TSNullKeyword":
            case "TSNeverKeyword":
              return createVoidZero();
            case "TSParenthesizedType":
              return serializeTypeNode(className, node.typeAnnotation);
            case "TSFunctionType":
            case "TSConstructorType":
              return _core.types.identifier("Function");
            case "TSArrayType":
            case "TSTupleType":
              return _core.types.identifier("Array");
            case "TSTypePredicate":
            case "TSBooleanKeyword":
              return _core.types.identifier("Boolean");
            case "TSStringKeyword":
              return _core.types.identifier("String");
            case "TSObjectKeyword":
              return _core.types.identifier("Object");
            case "TSLiteralType":
              switch (node.literal.type) {
                case "StringLiteral":
                  return _core.types.identifier("String");
                case "NumericLiteral":
                  return _core.types.identifier("Number");
                case "BooleanLiteral":
                  return _core.types.identifier("Boolean");
                default:
                  throw new Error("Bad type for decorator" + node.literal);
              }
            case "TSNumberKeyword":
            case "TSBigIntKeyword":
              return _core.types.identifier("Number");
            case "TSSymbolKeyword":
              return _core.types.identifier("Symbol");
            case "TSTypeReference":
              return serializeTypeReferenceNode(className, node);
            case "TSIntersectionType":
            case "TSUnionType":
              return serializeTypeList(className, node.types);
            case "TSConditionalType":
              return serializeTypeList(className, [node.trueType, node.falseType]);
            case "TSTypeQuery":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSTypeLiteral":
            case "TSAnyKeyword":
            case "TSUnknownKeyword":
            case "TSThisType":
              break;
            default:
              throw new Error("Bad type for decorator");
          }
          return _core.types.identifier("Object");
        }
        function serializeTypeList(className, types2) {
          let serializedUnion;
          for (let typeNode of types2) {
            for (; "TSParenthesizedType" === typeNode.type; )
              typeNode = typeNode.typeAnnotation;
            if ("TSNeverKeyword" === typeNode.type)
              continue;
            if ("TSNullKeyword" === typeNode.type || "TSUndefinedKeyword" === typeNode.type)
              continue;
            const serializedIndividual = serializeTypeNode(className, typeNode);
            if (_core.types.isIdentifier(serializedIndividual) && "Object" === serializedIndividual.name)
              return serializedIndividual;
            if (serializedUnion) {
              if (!_core.types.isIdentifier(serializedUnion) || !_core.types.isIdentifier(serializedIndividual) || serializedUnion.name !== serializedIndividual.name)
                return _core.types.identifier("Object");
            } else
              serializedUnion = serializedIndividual;
          }
          return serializedUnion || createVoidZero();
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.parameterVisitor = function(classPath, path3) {
          if ("ClassMethod" !== path3.type)
            return;
          if ("ClassMethod" !== path3.node.type)
            return;
          if ("Identifier" !== path3.node.key.type)
            return;
          const methodPath = path3;
          (methodPath.get("params") || []).slice().forEach(function(param) {
            let resultantDecorator;
            null != ("Identifier" === param.node.type || "ObjectPattern" === param.node.type ? param.node : "TSParameterProperty" === param.node.type && "Identifier" === param.node.parameter.type ? param.node.parameter : null) && ((param.node.decorators || []).slice().forEach(function(decorator) {
              "constructor" === methodPath.node.kind ? (resultantDecorator = createParamDecorator(param.key, decorator.expression, true), classPath.node.decorators || (classPath.node.decorators = []), classPath.node.decorators.push(resultantDecorator)) : (resultantDecorator = createParamDecorator(param.key, decorator.expression, false), methodPath.node.decorators || (methodPath.node.decorators = []), methodPath.node.decorators.push(resultantDecorator));
            }), resultantDecorator && (param.node.decorators = null));
          });
        };
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js");
        function createParamDecorator(paramIndex, decoratorExpression, isConstructor = false) {
          return _core.types.decorator(_core.types.functionExpression(null, [_core.types.identifier("target"), _core.types.identifier("key")], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(decoratorExpression, [_core.types.identifier("target"), _core.types.identifier(isConstructor ? "undefined" : "key"), _core.types.numericLiteral(paramIndex)]))])));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), _parameterVisitor = __webpack_require__2("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js"), _metadataVisitor = __webpack_require__2("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js"), _default = (0, _helperPluginUtils.declare)((api) => (api.assertVersion(7), { visitor: { Program(programPath) {
          programPath.traverse({ ClassDeclaration(path3) {
            for (const field of path3.get("body").get("body"))
              "ClassMethod" !== field.type && "ClassProperty" !== field.type || ((0, _parameterVisitor.parameterVisitor)(path3, field), (0, _metadataVisitor.metadataVisitor)(path3, field));
            path3.parentPath.scope.crawl();
          } });
        } } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/convert-source-map@1.9.0/node_modules/convert-source-map/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        var decodeBase64, fs4 = __webpack_require__2("fs"), path3 = __webpack_require__2("path");
        function Converter(sm, opts) {
          (opts = opts || {}).isFileComment && (sm = function(sm2, dir) {
            var r2 = exports3.mapFileCommentRegex.exec(sm2), filename = r2[1] || r2[2], filepath = path3.resolve(dir, filename);
            try {
              return fs4.readFileSync(filepath, "utf8");
            } catch (e) {
              throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e);
            }
          }(sm, opts.commentFileDir)), opts.hasComment && (sm = function(sm2) {
            return sm2.split(",").pop();
          }(sm)), opts.isEncoded && (sm = decodeBase64(sm)), (opts.isJSON || opts.isEncoded) && (sm = JSON.parse(sm)), this.sourcemap = sm;
        }
        Object.defineProperty(exports3, "commentRegex", { get: function() {
          return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm;
        } }), Object.defineProperty(exports3, "mapFileCommentRegex", { get: function() {
          return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm;
        } }), decodeBase64 = "undefined" != typeof Buffer ? "function" == typeof Buffer.from ? function(base64) {
          return Buffer.from(base64, "base64").toString();
        } : function(base64) {
          if ("number" == typeof value)
            throw new TypeError("The value to decode must not be of type number.");
          return new Buffer(base64, "base64").toString();
        } : function(base64) {
          return decodeURIComponent(escape(atob(base64)));
        }, Converter.prototype.toJSON = function(space) {
          return JSON.stringify(this.sourcemap, null, space);
        }, "undefined" != typeof Buffer ? "function" == typeof Buffer.from ? Converter.prototype.toBase64 = function() {
          var json = this.toJSON();
          return Buffer.from(json, "utf8").toString("base64");
        } : Converter.prototype.toBase64 = function() {
          var json = this.toJSON();
          if ("number" == typeof json)
            throw new TypeError("The json to encode must not be of type number.");
          return new Buffer(json, "utf8").toString("base64");
        } : Converter.prototype.toBase64 = function() {
          var json = this.toJSON();
          return btoa(unescape(encodeURIComponent(json)));
        }, Converter.prototype.toComment = function(options) {
          var data2 = "sourceMappingURL=data:application/json;charset=utf-8;base64," + this.toBase64();
          return options && options.multiline ? "/*# " + data2 + " */" : "//# " + data2;
        }, Converter.prototype.toObject = function() {
          return JSON.parse(this.toJSON());
        }, Converter.prototype.addProperty = function(key, value2) {
          if (this.sourcemap.hasOwnProperty(key))
            throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
          return this.setProperty(key, value2);
        }, Converter.prototype.setProperty = function(key, value2) {
          return this.sourcemap[key] = value2, this;
        }, Converter.prototype.getProperty = function(key) {
          return this.sourcemap[key];
        }, exports3.fromObject = function(obj) {
          return new Converter(obj);
        }, exports3.fromJSON = function(json) {
          return new Converter(json, { isJSON: true });
        }, exports3.fromBase64 = function(base64) {
          return new Converter(base64, { isEncoded: true });
        }, exports3.fromComment = function(comment) {
          return new Converter(comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), { isEncoded: true, hasComment: true });
        }, exports3.fromMapFileComment = function(comment, dir) {
          return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
        }, exports3.fromSource = function(content) {
          var m2 = content.match(exports3.commentRegex);
          return m2 ? exports3.fromComment(m2.pop()) : null;
        }, exports3.fromMapFileSource = function(content, dir) {
          var m2 = content.match(exports3.mapFileCommentRegex);
          return m2 ? exports3.fromMapFileComment(m2.pop(), dir) : null;
        }, exports3.removeComments = function(src) {
          return src.replace(exports3.commentRegex, "");
        }, exports3.removeMapFileComments = function(src) {
          return src.replace(exports3.mapFileCommentRegex, "");
        }, exports3.generateMapFileComment = function(file, options) {
          var data2 = "sourceMappingURL=" + file;
          return options && options.multiline ? "/*# " + data2 + " */" : "//# " + data2;
        };
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js": (module4, exports3, __webpack_require__2) => {
        exports3.formatArgs = function(args) {
          if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module4.exports.humanize(this.diff), !this.useColors)
            return;
          const c = "color: " + this.color;
          args.splice(1, 0, c, "color: inherit");
          let index2 = 0, lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, (match) => {
            "%%" !== match && (index2++, "%c" === match && (lastC = index2));
          }), args.splice(lastC, 0, c);
        }, exports3.save = function(namespaces) {
          try {
            namespaces ? exports3.storage.setItem("debug", namespaces) : exports3.storage.removeItem("debug");
          } catch (error) {
          }
        }, exports3.load = function() {
          let r2;
          try {
            r2 = exports3.storage.getItem("debug");
          } catch (error) {
          }
          !r2 && "undefined" != typeof process && "env" in process && (r2 = process.env.DEBUG);
          return r2;
        }, exports3.useColors = function() {
          if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs))
            return true;
          if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
            return false;
          return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, exports3.storage = function() {
          try {
            return localStorage;
          } catch (error) {
          }
        }(), exports3.destroy = (() => {
          let warned = false;
          return () => {
            warned || (warned = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), exports3.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], exports3.log = console.debug || console.log || (() => {
        }), module4.exports = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js")(exports3);
        const { formatters } = module4.exports;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error) {
            return "[UnexpectedJSONParseError]: " + error.message;
          }
        };
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        module4.exports = function(env) {
          function createDebug(namespace) {
            let prevTime, namespacesCache, enabledCache, enableOverride = null;
            function debug(...args) {
              if (!debug.enabled)
                return;
              const self2 = debug, curr = Number(/* @__PURE__ */ new Date()), ms = curr - (prevTime || curr);
              self2.diff = ms, self2.prev = prevTime, self2.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), "string" != typeof args[0] && args.unshift("%O");
              let index2 = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
                if ("%%" === match)
                  return "%";
                index2++;
                const formatter = createDebug.formatters[format2];
                if ("function" == typeof formatter) {
                  const val = args[index2];
                  match = formatter.call(self2, val), args.splice(index2, 1), index2--;
                }
                return match;
              }), createDebug.formatArgs.call(self2, args);
              (self2.log || createDebug.log).apply(self2, args);
            }
            return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend2, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", { enumerable: true, configurable: false, get: () => null !== enableOverride ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache), set: (v) => {
              enableOverride = v;
            } }), "function" == typeof createDebug.init && createDebug.init(debug), debug;
          }
          function extend2(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ":" : delimiter) + namespace);
            return newDebug.log = this.log, newDebug;
          }
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = function(val) {
            if (val instanceof Error)
              return val.stack || val.message;
            return val;
          }, createDebug.disable = function() {
            const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
            return createDebug.enable(""), namespaces;
          }, createDebug.enable = function(namespaces) {
            let i;
            createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
            const split = ("string" == typeof namespaces ? namespaces : "").split(/[\s,]+/), len = split.length;
            for (i = 0; i < len; i++)
              split[i] && ("-" === (namespaces = split[i].replace(/\*/g, ".*?"))[0] ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
          }, createDebug.enabled = function(name) {
            if ("*" === name[name.length - 1])
              return true;
            let i, len;
            for (i = 0, len = createDebug.skips.length; i < len; i++)
              if (createDebug.skips[i].test(name))
                return false;
            for (i = 0, len = createDebug.names.length; i < len; i++)
              if (createDebug.names[i].test(name))
                return true;
            return false;
          }, createDebug.humanize = __webpack_require__2("./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"), createDebug.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {}, createDebug.selectColor = function(namespace) {
            let hash2 = 0;
            for (let i = 0; i < namespace.length; i++)
              hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i), hash2 |= 0;
            return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
          }, createDebug.enable(createDebug.load()), createDebug;
        };
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        "undefined" == typeof process || "renderer" === process.type || true === process.browser || process.__nwjs ? module4.exports = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js") : module4.exports = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js");
      }, "./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js": (module4, exports3, __webpack_require__2) => {
        const tty = __webpack_require__2("tty"), util = __webpack_require__2("util");
        exports3.init = function(debug) {
          debug.inspectOpts = {};
          const keys2 = Object.keys(exports3.inspectOpts);
          for (let i = 0; i < keys2.length; i++)
            debug.inspectOpts[keys2[i]] = exports3.inspectOpts[keys2[i]];
        }, exports3.log = function(...args) {
          return process.stderr.write(util.format(...args) + "\n");
        }, exports3.formatArgs = function(args) {
          const { namespace: name, useColors } = this;
          if (useColors) {
            const c = this.color, colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} \x1B[0m`;
            args[0] = prefix + args[0].split("\n").join("\n" + prefix), args.push(colorCode + "m+" + module4.exports.humanize(this.diff) + "\x1B[0m");
          } else
            args[0] = function() {
              if (exports3.inspectOpts.hideDate)
                return "";
              return (/* @__PURE__ */ new Date()).toISOString() + " ";
            }() + name + " " + args[0];
        }, exports3.save = function(namespaces) {
          namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
        }, exports3.load = function() {
          return process.env.DEBUG;
        }, exports3.useColors = function() {
          return "colors" in exports3.inspectOpts ? Boolean(exports3.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }, exports3.destroy = util.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), exports3.colors = [6, 2, 3, 4, 5, 1];
        try {
          const supportsColor = __webpack_require__2("./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
          supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports3.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch (error) {
        }
        exports3.inspectOpts = Object.keys(process.env).filter((key) => /^debug_/i.test(key)).reduce((obj, key) => {
          const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase());
          let val = process.env[key];
          return val = !!/^(yes|on|true|enabled)$/i.test(val) || !/^(no|off|false|disabled)$/i.test(val) && ("null" === val ? null : Number(val)), obj[prop] = val, obj;
        }, {}), module4.exports = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js")(exports3);
        const { formatters } = module4.exports;
        formatters.o = function(v) {
          return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
        }, formatters.O = function(v) {
          return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
        };
      }, "./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js": (module4) => {
        "use strict";
        const GENSYNC_START = Symbol.for("gensync:v1:start"), GENSYNC_SUSPEND = Symbol.for("gensync:v1:suspend"), GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START", GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND", GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
        function assertTypeof(type, name, value2, allowUndefined) {
          if (typeof value2 === type || allowUndefined && void 0 === value2)
            return;
          let msg;
          throw msg = allowUndefined ? `Expected opts.${name} to be either a ${type}, or undefined.` : `Expected opts.${name} to be a ${type}.`, makeError(msg, GENSYNC_OPTIONS_ERROR);
        }
        function makeError(msg, code) {
          return Object.assign(new Error(msg), { code });
        }
        function buildOperation({ name, arity, sync, async }) {
          return setFunctionMetadata(name, arity, function* (...args) {
            const resume = yield GENSYNC_START;
            if (!resume) {
              return sync.call(this, args);
            }
            let result;
            try {
              async.call(this, args, (value2) => {
                result || (result = { value: value2 }, resume());
              }, (err) => {
                result || (result = { err }, resume());
              });
            } catch (err) {
              result = { err }, resume();
            }
            if (yield GENSYNC_SUSPEND, result.hasOwnProperty("err"))
              throw result.err;
            return result.value;
          });
        }
        function evaluateSync(gen) {
          let value2;
          for (; !({ value: value2 } = gen.next()).done; )
            assertStart(value2, gen);
          return value2;
        }
        function evaluateAsync(gen, resolve3, reject) {
          !function step() {
            try {
              let value2;
              for (; !({ value: value2 } = gen.next()).done; ) {
                assertStart(value2, gen);
                let sync = true, didSyncResume = false;
                const out = gen.next(() => {
                  sync ? didSyncResume = true : step();
                });
                if (sync = false, assertSuspend(out, gen), !didSyncResume)
                  return;
              }
              return resolve3(value2);
            } catch (err) {
              return reject(err);
            }
          }();
        }
        function assertStart(value2, gen) {
          value2 !== GENSYNC_START && throwError(gen, makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(value2)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, GENSYNC_EXPECTED_START));
        }
        function assertSuspend({ value: value2, done }, gen) {
          (done || value2 !== GENSYNC_SUSPEND) && throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(value2)}. If you get this, it is probably a gensync bug.`, GENSYNC_EXPECTED_SUSPEND));
        }
        function throwError(gen, err) {
          throw gen.throw && gen.throw(err), err;
        }
        function setFunctionMetadata(name, arity, fn) {
          if ("string" == typeof name) {
            const nameDesc = Object.getOwnPropertyDescriptor(fn, "name");
            nameDesc && !nameDesc.configurable || Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, { configurable: true, value: name }));
          }
          if ("number" == typeof arity) {
            const lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");
            lengthDesc && !lengthDesc.configurable || Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, { configurable: true, value: arity }));
          }
          return fn;
        }
        module4.exports = Object.assign(function(optsOrFn) {
          let genFn = optsOrFn;
          return genFn = "function" != typeof optsOrFn ? function({ name, arity, sync, async, errback }) {
            if (assertTypeof("string", "name", name, true), assertTypeof("number", "arity", arity, true), assertTypeof("function", "sync", sync), assertTypeof("function", "async", async, true), assertTypeof("function", "errback", errback, true), async && errback)
              throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
            if ("string" != typeof name) {
              let fnName;
              errback && errback.name && "errback" !== errback.name && (fnName = errback.name), async && async.name && "async" !== async.name && (fnName = async.name.replace(/Async$/, "")), sync && sync.name && "sync" !== sync.name && (fnName = sync.name.replace(/Sync$/, "")), "string" == typeof fnName && (name = fnName);
            }
            "number" != typeof arity && (arity = sync.length);
            return buildOperation({ name, arity, sync: function(args) {
              return sync.apply(this, args);
            }, async: function(args, resolve3, reject) {
              async ? async.apply(this, args).then(resolve3, reject) : errback ? errback.call(this, ...args, (err, value2) => {
                null == err ? resolve3(value2) : reject(err);
              }) : resolve3(sync.apply(this, args));
            } });
          }(optsOrFn) : function(genFn2) {
            return setFunctionMetadata(genFn2.name, genFn2.length, function(...args) {
              return genFn2.apply(this, args);
            });
          }(optsOrFn), Object.assign(genFn, function(genFn2) {
            const fns = { sync: function(...args) {
              return evaluateSync(genFn2.apply(this, args));
            }, async: function(...args) {
              return new Promise((resolve3, reject) => {
                evaluateAsync(genFn2.apply(this, args), resolve3, reject);
              });
            }, errback: function(...args) {
              const cb = args.pop();
              if ("function" != typeof cb)
                throw makeError("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
              let gen;
              try {
                gen = genFn2.apply(this, args);
              } catch (err) {
                return void cb(err);
              }
              evaluateAsync(gen, (val) => cb(void 0, val), (err) => cb(err));
            } };
            return fns;
          }(genFn));
        }, { all: buildOperation({ name: "all", arity: 1, sync: function(args) {
          return Array.from(args[0]).map((item) => evaluateSync(item));
        }, async: function(args, resolve3, reject) {
          const items = Array.from(args[0]);
          if (0 === items.length)
            return void Promise.resolve().then(() => resolve3([]));
          let count = 0;
          const results = items.map(() => {
          });
          items.forEach((item, i) => {
            evaluateAsync(item, (val) => {
              results[i] = val, count += 1, count === results.length && resolve3(results);
            }, reject);
          });
        } }), race: buildOperation({ name: "race", arity: 1, sync: function(args) {
          const items = Array.from(args[0]);
          if (0 === items.length)
            throw makeError("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          return evaluateSync(items[0]);
        }, async: function(args, resolve3, reject) {
          const items = Array.from(args[0]);
          if (0 === items.length)
            throw makeError("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          for (const item of items)
            evaluateAsync(item, resolve3, reject);
        } }) });
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        module4.exports = __webpack_require__2("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json");
      }, "./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": (module4) => {
        "use strict";
        module4.exports = (flag, argv = process.argv) => {
          const prefix = flag.startsWith("-") ? "" : 1 === flag.length ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
          return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
        };
      }, "./node_modules/.pnpm/jsesc@2.5.2/node_modules/jsesc/jsesc.js": (module4) => {
        "use strict";
        const object = {}, hasOwnProperty4 = object.hasOwnProperty, forOwn = (object2, callback) => {
          for (const key in object2)
            hasOwnProperty4.call(object2, key) && callback(key, object2[key]);
        }, toString3 = object.toString, isArray3 = Array.isArray, isBuffer2 = Buffer.isBuffer, singleEscapes = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, regexSingleEscape = /["'\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitelist = /[ !#-&\(-\[\]-_a-~]/, jsesc = (argument, options) => {
          const increaseIndentation = () => {
            oldIndent = indent, ++options.indentLevel, indent = options.indent.repeat(options.indentLevel);
          }, defaults3 = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, json = options && options.json;
          var destination, source;
          json && (defaults3.quotes = "double", defaults3.wrap = true), destination = defaults3, "single" != (options = (source = options) ? (forOwn(source, (key, value2) => {
            destination[key] = value2;
          }), destination) : destination).quotes && "double" != options.quotes && "backtick" != options.quotes && (options.quotes = "single");
          const quote = "double" == options.quotes ? '"' : "backtick" == options.quotes ? "`" : "'", compact = options.compact, lowercaseHex = options.lowercaseHex;
          let indent = options.indent.repeat(options.indentLevel), oldIndent = "";
          const inline1 = options.__inline1__, inline2 = options.__inline2__, newLine = compact ? "" : "\n";
          let result, isEmpty = true;
          const useBinNumbers = "binary" == options.numbers, useOctNumbers = "octal" == options.numbers, useDecNumbers = "decimal" == options.numbers, useHexNumbers = "hexadecimal" == options.numbers;
          if (json && argument && ((value2) => "function" == typeof value2)(argument.toJSON) && (argument = argument.toJSON()), !((value2) => "string" == typeof value2 || "[object String]" == toString3.call(value2))(argument)) {
            if (((value2) => "[object Map]" == toString3.call(value2))(argument))
              return 0 == argument.size ? "new Map()" : (compact || (options.__inline1__ = true, options.__inline2__ = false), "new Map(" + jsesc(Array.from(argument), options) + ")");
            if (((value2) => "[object Set]" == toString3.call(value2))(argument))
              return 0 == argument.size ? "new Set()" : "new Set(" + jsesc(Array.from(argument), options) + ")";
            if (isBuffer2(argument))
              return 0 == argument.length ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
            if (isArray3(argument))
              return result = [], options.wrap = true, inline1 && (options.__inline1__ = false, options.__inline2__ = true), inline2 || increaseIndentation(), ((array, callback) => {
                const length2 = array.length;
                let index3 = -1;
                for (; ++index3 < length2; )
                  callback(array[index3]);
              })(argument, (value2) => {
                isEmpty = false, inline2 && (options.__inline2__ = false), result.push((compact || inline2 ? "" : indent) + jsesc(value2, options));
              }), isEmpty ? "[]" : inline2 ? "[" + result.join(", ") + "]" : "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
            if (!((value2) => "number" == typeof value2 || "[object Number]" == toString3.call(value2))(argument))
              return ((value2) => "[object Object]" == toString3.call(value2))(argument) ? (result = [], options.wrap = true, increaseIndentation(), forOwn(argument, (key, value2) => {
                isEmpty = false, result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value2, options));
              }), isEmpty ? "{}" : "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}") : json ? JSON.stringify(argument) || "null" : String(argument);
            if (json)
              return JSON.stringify(argument);
            if (useDecNumbers)
              return String(argument);
            if (useHexNumbers) {
              let hexadecimal = argument.toString(16);
              return lowercaseHex || (hexadecimal = hexadecimal.toUpperCase()), "0x" + hexadecimal;
            }
            if (useBinNumbers)
              return "0b" + argument.toString(2);
            if (useOctNumbers)
              return "0o" + argument.toString(8);
          }
          const string = argument;
          let index2 = -1;
          const length = string.length;
          for (result = ""; ++index2 < length; ) {
            const character = string.charAt(index2);
            if (options.es6) {
              const first = string.charCodeAt(index2);
              if (first >= 55296 && first <= 56319 && length > index2 + 1) {
                const second = string.charCodeAt(index2 + 1);
                if (second >= 56320 && second <= 57343) {
                  let hexadecimal2 = (1024 * (first - 55296) + second - 56320 + 65536).toString(16);
                  lowercaseHex || (hexadecimal2 = hexadecimal2.toUpperCase()), result += "\\u{" + hexadecimal2 + "}", ++index2;
                  continue;
                }
              }
            }
            if (!options.escapeEverything) {
              if (regexWhitelist.test(character)) {
                result += character;
                continue;
              }
              if ('"' == character) {
                result += quote == character ? '\\"' : character;
                continue;
              }
              if ("`" == character) {
                result += quote == character ? "\\`" : character;
                continue;
              }
              if ("'" == character) {
                result += quote == character ? "\\'" : character;
                continue;
              }
            }
            if ("\0" == character && !json && !regexDigit.test(string.charAt(index2 + 1))) {
              result += "\\0";
              continue;
            }
            if (regexSingleEscape.test(character)) {
              result += singleEscapes[character];
              continue;
            }
            const charCode = character.charCodeAt(0);
            if (options.minimal && 8232 != charCode && 8233 != charCode) {
              result += character;
              continue;
            }
            let hexadecimal = charCode.toString(16);
            lowercaseHex || (hexadecimal = hexadecimal.toUpperCase());
            const longhand = hexadecimal.length > 2 || json, escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
            result += escaped;
          }
          return options.wrap && (result = quote + result + quote), "`" == quote && (result = result.replace(/\$\{/g, "\\${")), options.isScriptContext ? result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--") : result;
        };
        jsesc.version = "2.5.2", module4.exports = jsesc;
      }, "./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js": (module4) => {
        var s = 1e3, m2 = 60 * s, h = 60 * m2, d = 24 * h, w = 7 * d, y = 365.25 * d;
        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= 1.5 * n;
          return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
        module4.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if ("string" === type && val.length > 0)
            return function(str) {
              if ((str = String(str)).length > 100)
                return;
              var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
              if (!match)
                return;
              var n = parseFloat(match[1]);
              switch ((match[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return n * y;
                case "weeks":
                case "week":
                case "w":
                  return n * w;
                case "days":
                case "day":
                case "d":
                  return n * d;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return n * h;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return n * m2;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return n * s;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return n;
                default:
                  return;
              }
            }(val);
          if ("number" === type && isFinite(val))
            return options.long ? function(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d)
                return plural(ms, msAbs, d, "day");
              if (msAbs >= h)
                return plural(ms, msAbs, h, "hour");
              if (msAbs >= m2)
                return plural(ms, msAbs, m2, "minute");
              if (msAbs >= s)
                return plural(ms, msAbs, s, "second");
              return ms + " ms";
            }(val) : function(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d)
                return Math.round(ms / d) + "d";
              if (msAbs >= h)
                return Math.round(ms / h) + "h";
              if (msAbs >= m2)
                return Math.round(ms / m2) + "m";
              if (msAbs >= s)
                return Math.round(ms / s) + "s";
              return ms + "ms";
            }(val);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
      }, "./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js": (module4, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        const os = __webpack_require__2("os"), tty = __webpack_require__2("tty"), hasFlag = __webpack_require__2("./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"), { env } = process;
        let forceColor;
        function translateLevel(level) {
          return 0 !== level && { level, hasBasic: true, has256: level >= 2, has16m: level >= 3 };
        }
        function supportsColor(haveStream, streamIsTTY) {
          if (0 === forceColor)
            return 0;
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
            return 3;
          if (hasFlag("color=256"))
            return 2;
          if (haveStream && !streamIsTTY && void 0 === forceColor)
            return 0;
          const min = forceColor || 0;
          if ("dumb" === env.TERM)
            return min;
          if ("win32" === process.platform) {
            const osRelease = os.release().split(".");
            return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in env)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || "codeship" === env.CI_NAME ? 1 : min;
          if ("TEAMCITY_VERSION" in env)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
          if ("truecolor" === env.COLORTERM)
            return 3;
          if ("TERM_PROGRAM" in env) {
            const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env.TERM_PROGRAM) {
              case "iTerm.app":
                return version2 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
        }
        hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? forceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = 1), "FORCE_COLOR" in env && (forceColor = "true" === env.FORCE_COLOR ? 1 : "false" === env.FORCE_COLOR ? 0 : 0 === env.FORCE_COLOR.length ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3)), module4.exports = { supportsColor: function(stream) {
          return translateLevel(supportsColor(stream, stream && stream.isTTY));
        }, stdout: translateLevel(supportsColor(true, tty.isatty(1))), stderr: translateLevel(supportsColor(true, tty.isatty(2))) };
      }, "./node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js": (module4) => {
        "use strict";
        let fastProto = null;
        function FastObject(o) {
          if (null !== fastProto && (fastProto.property, 1)) {
            const result = fastProto;
            return fastProto = FastObject.prototype = null, result;
          }
          return fastProto = FastObject.prototype = null == o ? /* @__PURE__ */ Object.create(null) : o, new FastObject();
        }
        FastObject(), module4.exports = function(o) {
          return FastObject(o);
        };
      }, "./stubs/babel-codeframe.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
        "use strict";
        function codeFrameColumns() {
          return "";
        }
        __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, { codeFrameColumns: () => codeFrameColumns });
      }, "./stubs/helper-compilation-targets.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
        "use strict";
        function getTargets() {
          return {};
        }
        __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, { default: () => getTargets });
      }, assert: (module4) => {
        "use strict";
        module4.exports = require_assert();
      }, fs: (module4) => {
        "use strict";
        module4.exports = require_fs();
      }, module: (module4) => {
        "use strict";
        module4.exports = require_module();
      }, os: (module4) => {
        "use strict";
        module4.exports = require_os();
      }, path: (module4) => {
        "use strict";
        module4.exports = require_path();
      }, process: (module4) => {
        "use strict";
        module4.exports = require_process();
      }, tty: (module4) => {
        "use strict";
        module4.exports = require_tty();
      }, url: (module4) => {
        "use strict";
        module4.exports = require_url();
      }, util: (module4) => {
        "use strict";
        module4.exports = require_util();
      }, v8: (module4) => {
        "use strict";
        module4.exports = require_v8();
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/caching.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.assertSimpleType = assertSimpleType, exports3.makeStrongCache = makeStrongCache, exports3.makeStrongCacheSync = function(handler) {
          return synchronize(makeStrongCache(handler));
        }, exports3.makeWeakCache = makeWeakCache, exports3.makeWeakCacheSync = function(handler) {
          return synchronize(makeWeakCache(handler));
        };
        var _async = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/async.js"), _util = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/util.js");
        const synchronize = (gen) => _gensync()(gen).sync;
        function* genTrue() {
          return true;
        }
        function makeWeakCache(handler) {
          return makeCachedFunction(WeakMap, handler);
        }
        function makeStrongCache(handler) {
          return makeCachedFunction(Map, handler);
        }
        function makeCachedFunction(CallCache, handler) {
          const callCacheSync = new CallCache(), callCacheAsync = new CallCache(), futureCache = new CallCache();
          return function* (arg, data2) {
            const asyncContext = yield* (0, _async.isAsync)(), callCache = asyncContext ? callCacheAsync : callCacheSync, cached = yield* function* (asyncContext2, callCache2, futureCache2, arg2, data3) {
              const cached2 = yield* getCachedValue(callCache2, arg2, data3);
              if (cached2.valid)
                return cached2;
              if (asyncContext2) {
                const cached3 = yield* getCachedValue(futureCache2, arg2, data3);
                if (cached3.valid) {
                  return { valid: true, value: yield* (0, _async.waitFor)(cached3.value.promise) };
                }
              }
              return { valid: false, value: null };
            }(asyncContext, callCache, futureCache, arg, data2);
            if (cached.valid)
              return cached.value;
            const cache = new CacheConfigurator(data2), handlerResult = handler(arg, cache);
            let finishLock, value2;
            return value2 = (0, _util.isIterableIterator)(handlerResult) ? yield* (0, _async.onFirstPause)(handlerResult, () => {
              finishLock = function(config, futureCache2, arg2) {
                const finishLock2 = new Lock();
                return updateFunctionCache(futureCache2, config, arg2, finishLock2), finishLock2;
              }(cache, futureCache, arg);
            }) : handlerResult, updateFunctionCache(callCache, cache, arg, value2), finishLock && (futureCache.delete(arg), finishLock.release(value2)), value2;
          };
        }
        function* getCachedValue(cache, arg, data2) {
          const cachedValue = cache.get(arg);
          if (cachedValue) {
            for (const { value: value2, valid } of cachedValue)
              if (yield* valid(data2))
                return { valid: true, value: value2 };
          }
          return { valid: false, value: null };
        }
        function updateFunctionCache(cache, config, arg, value2) {
          config.configured() || config.forever();
          let cachedValue = cache.get(arg);
          switch (config.deactivate(), config.mode()) {
            case "forever":
              cachedValue = [{ value: value2, valid: genTrue }], cache.set(arg, cachedValue);
              break;
            case "invalidate":
              cachedValue = [{ value: value2, valid: config.validator() }], cache.set(arg, cachedValue);
              break;
            case "valid":
              cachedValue ? cachedValue.push({ value: value2, valid: config.validator() }) : (cachedValue = [{ value: value2, valid: config.validator() }], cache.set(arg, cachedValue));
          }
        }
        class CacheConfigurator {
          constructor(data2) {
            this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = data2;
          }
          simple() {
            return function(cache) {
              function cacheFn(val) {
                if ("boolean" != typeof val)
                  return cache.using(() => assertSimpleType(val()));
                val ? cache.forever() : cache.never();
              }
              return cacheFn.forever = () => cache.forever(), cacheFn.never = () => cache.never(), cacheFn.using = (cb) => cache.using(() => assertSimpleType(cb())), cacheFn.invalidate = (cb) => cache.invalidate(() => assertSimpleType(cb())), cacheFn;
            }(this);
          }
          mode() {
            return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
          }
          forever() {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never)
              throw new Error("Caching has already been configured with .never()");
            this._forever = true, this._configured = true;
          }
          never() {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._forever)
              throw new Error("Caching has already been configured with .forever()");
            this._never = true, this._configured = true;
          }
          using(handler) {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never || this._forever)
              throw new Error("Caching has already been configured with .never or .forever()");
            this._configured = true;
            const key = handler(this._data), fn = (0, _async.maybeAsync)(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");
            return (0, _async.isThenable)(key) ? key.then((key2) => (this._pairs.push([key2, fn]), key2)) : (this._pairs.push([key, fn]), key);
          }
          invalidate(handler) {
            return this._invalidate = true, this.using(handler);
          }
          validator() {
            const pairs = this._pairs;
            return function* (data2) {
              for (const [key, fn] of pairs)
                if (key !== (yield* fn(data2)))
                  return false;
              return true;
            };
          }
          deactivate() {
            this._active = false;
          }
          configured() {
            return this._configured;
          }
        }
        function assertSimpleType(value2) {
          if ((0, _async.isThenable)(value2))
            throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
          if (null != value2 && "string" != typeof value2 && "boolean" != typeof value2 && "number" != typeof value2)
            throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
          return value2;
        }
        class Lock {
          constructor() {
            this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((resolve3) => {
              this._resolve = resolve3;
            });
          }
          release(value2) {
            this.released = true, this._resolve(value2);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/config-chain.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        function _debug() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return _debug = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.buildPresetChain = function* (arg, context) {
          const chain = yield* buildPresetChainWalker(arg, context);
          return chain ? { plugins: dedupDescriptors(chain.plugins), presets: dedupDescriptors(chain.presets), options: chain.options.map((o) => normalizeOptions3(o)), files: /* @__PURE__ */ new Set() } : null;
        }, exports3.buildPresetChainWalker = void 0, exports3.buildRootChain = function* (opts, context) {
          let configReport, babelRcReport;
          const programmaticLogger = new _printer.ConfigPrinter(), programmaticChain = yield* loadProgrammaticChain({ options: opts, dirname: context.cwd }, context, void 0, programmaticLogger);
          if (!programmaticChain)
            return null;
          const programmaticReport = yield* programmaticLogger.output();
          let configFile;
          "string" == typeof opts.configFile ? configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller) : false !== opts.configFile && (configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller));
          let { babelrc, babelrcRoots } = opts, babelrcRootsDirectory = context.cwd;
          const configFileChain = emptyChain(), configFileLogger = new _printer.ConfigPrinter();
          if (configFile) {
            const validatedFile = validateConfigFile(configFile), result = yield* loadFileChain(validatedFile, context, void 0, configFileLogger);
            if (!result)
              return null;
            configReport = yield* configFileLogger.output(), void 0 === babelrc && (babelrc = validatedFile.options.babelrc), void 0 === babelrcRoots && (babelrcRootsDirectory = validatedFile.dirname, babelrcRoots = validatedFile.options.babelrcRoots), mergeChain(configFileChain, result);
          }
          let ignoreFile, babelrcFile, isIgnored = false;
          const fileChain = emptyChain();
          if ((true === babelrc || void 0 === babelrc) && "string" == typeof context.filename) {
            const pkgData = yield* (0, _files.findPackageData)(context.filename);
            if (pkgData && function(context2, pkgData2, babelrcRoots2, babelrcRootsDirectory2) {
              if ("boolean" == typeof babelrcRoots2)
                return babelrcRoots2;
              const absoluteRoot = context2.root;
              if (void 0 === babelrcRoots2)
                return -1 !== pkgData2.directories.indexOf(absoluteRoot);
              let babelrcPatterns = babelrcRoots2;
              Array.isArray(babelrcPatterns) || (babelrcPatterns = [babelrcPatterns]);
              if (babelrcPatterns = babelrcPatterns.map((pat) => "string" == typeof pat ? _path().resolve(babelrcRootsDirectory2, pat) : pat), 1 === babelrcPatterns.length && babelrcPatterns[0] === absoluteRoot)
                return -1 !== pkgData2.directories.indexOf(absoluteRoot);
              return babelrcPatterns.some((pat) => ("string" == typeof pat && (pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory2)), pkgData2.directories.some((directory) => matchPattern(pat, babelrcRootsDirectory2, directory, context2))));
            }(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
              if ({ ignore: ignoreFile, config: babelrcFile } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller), ignoreFile && fileChain.files.add(ignoreFile.filepath), ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname) && (isIgnored = true), babelrcFile && !isIgnored) {
                const validatedFile = validateBabelrcFile(babelrcFile), babelrcLogger = new _printer.ConfigPrinter(), result = yield* loadFileChain(validatedFile, context, void 0, babelrcLogger);
                result ? (babelRcReport = yield* babelrcLogger.output(), mergeChain(fileChain, result)) : isIgnored = true;
              }
              babelrcFile && isIgnored && fileChain.files.add(babelrcFile.filepath);
            }
          }
          context.showConfig && console.log(`Babel configs on "${context.filename}" (ascending priority):
` + [configReport, babelRcReport, programmaticReport].filter((x) => !!x).join("\n\n") + "\n-----End Babel configs-----");
          const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
          return { plugins: isIgnored ? [] : dedupDescriptors(chain.plugins), presets: isIgnored ? [] : dedupDescriptors(chain.presets), options: isIgnored ? [] : chain.options.map((o) => normalizeOptions3(o)), fileHandling: isIgnored ? "ignored" : "transpile", ignore: ignoreFile || void 0, babelrc: babelrcFile || void 0, config: configFile || void 0, files: chain.files };
        };
        var _options = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/options.js"), _patternToRegex = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/pattern-to-regex.js"), _printer = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/printer.js"), _rewriteStackTrace = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), _configError = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/config-error.js"), _files = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/index.js"), _caching = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/caching.js"), _configDescriptors = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/config-descriptors.js");
        const debug = _debug()("babel:config:config-chain");
        const buildPresetChainWalker = makeChainWalker({ root: (preset) => loadPresetDescriptors(preset), env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName), overrides: (preset, index2) => loadPresetOverridesDescriptors(preset)(index2), overridesEnv: (preset, index2, envName) => loadPresetOverridesEnvDescriptors(preset)(index2)(envName), createLogger: () => () => {
        } });
        exports3.buildPresetChainWalker = buildPresetChainWalker;
        const loadPresetDescriptors = (0, _caching.makeWeakCacheSync)((preset) => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors)), loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName))), loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index2) => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index2))), loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index2) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index2, envName))));
        const validateConfigFile = (0, _caching.makeWeakCacheSync)((file) => ({ filepath: file.filepath, dirname: file.dirname, options: (0, _options.validate)("configfile", file.options, file.filepath) })), validateBabelrcFile = (0, _caching.makeWeakCacheSync)((file) => ({ filepath: file.filepath, dirname: file.dirname, options: (0, _options.validate)("babelrcfile", file.options, file.filepath) })), validateExtendFile = (0, _caching.makeWeakCacheSync)((file) => ({ filepath: file.filepath, dirname: file.dirname, options: (0, _options.validate)("extendsfile", file.options, file.filepath) })), loadProgrammaticChain = makeChainWalker({ root: (input) => buildRootDescriptors(input, "base", _configDescriptors.createCachedDescriptors), env: (input, envName) => buildEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, envName), overrides: (input, index2) => buildOverrideDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index2), overridesEnv: (input, index2, envName) => buildOverrideEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index2, envName), createLogger: (input, context, baseLogger) => function(_, context2, baseLogger2) {
          var _context$caller;
          if (!baseLogger2)
            return () => {
            };
          return baseLogger2.configure(context2.showConfig, _printer.ChainFormatter.Programmatic, { callerName: null == (_context$caller = context2.caller) ? void 0 : _context$caller.name });
        }(0, context, baseLogger) }), loadFileChainWalker = makeChainWalker({ root: (file) => loadFileDescriptors(file), env: (file, envName) => loadFileEnvDescriptors(file)(envName), overrides: (file, index2) => loadFileOverridesDescriptors(file)(index2), overridesEnv: (file, index2, envName) => loadFileOverridesEnvDescriptors(file)(index2)(envName), createLogger: (file, context, baseLogger) => function(filepath, context2, baseLogger2) {
          if (!baseLogger2)
            return () => {
            };
          return baseLogger2.configure(context2.showConfig, _printer.ChainFormatter.Config, { filepath });
        }(file.filepath, context, baseLogger) });
        function* loadFileChain(input, context, files, baseLogger) {
          const chain = yield* loadFileChainWalker(input, context, files, baseLogger);
          return null == chain || chain.files.add(input.filepath), chain;
        }
        const loadFileDescriptors = (0, _caching.makeWeakCacheSync)((file) => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors)), loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName))), loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index2) => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index2))), loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index2) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index2, envName))));
        function buildRootDescriptors({ dirname: dirname3, options }, alias, descriptors) {
          return descriptors(dirname3, options, alias);
        }
        function buildEnvDescriptors({ dirname: dirname3, options }, alias, descriptors, envName) {
          const opts = options.env && options.env[envName];
          return opts ? descriptors(dirname3, opts, `${alias}.env["${envName}"]`) : null;
        }
        function buildOverrideDescriptors({ dirname: dirname3, options }, alias, descriptors, index2) {
          const opts = options.overrides && options.overrides[index2];
          if (!opts)
            throw new Error("Assertion failure - missing override");
          return descriptors(dirname3, opts, `${alias}.overrides[${index2}]`);
        }
        function buildOverrideEnvDescriptors({ dirname: dirname3, options }, alias, descriptors, index2, envName) {
          const override = options.overrides && options.overrides[index2];
          if (!override)
            throw new Error("Assertion failure - missing override");
          const opts = override.env && override.env[envName];
          return opts ? descriptors(dirname3, opts, `${alias}.overrides[${index2}].env["${envName}"]`) : null;
        }
        function makeChainWalker({ root: root2, env, overrides, overridesEnv, createLogger }) {
          return function* (input, context, files = /* @__PURE__ */ new Set(), baseLogger) {
            const { dirname: dirname3 } = input, flattenedConfigs = [], rootOpts = root2(input);
            if (configIsApplicable(rootOpts, dirname3, context, input.filepath)) {
              flattenedConfigs.push({ config: rootOpts, envName: void 0, index: void 0 });
              const envOpts = env(input, context.envName);
              envOpts && configIsApplicable(envOpts, dirname3, context, input.filepath) && flattenedConfigs.push({ config: envOpts, envName: context.envName, index: void 0 }), (rootOpts.options.overrides || []).forEach((_, index2) => {
                const overrideOps = overrides(input, index2);
                if (configIsApplicable(overrideOps, dirname3, context, input.filepath)) {
                  flattenedConfigs.push({ config: overrideOps, index: index2, envName: void 0 });
                  const overrideEnvOpts = overridesEnv(input, index2, context.envName);
                  overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname3, context, input.filepath) && flattenedConfigs.push({ config: overrideEnvOpts, index: index2, envName: context.envName });
                }
              });
            }
            if (flattenedConfigs.some(({ config: { options: { ignore: ignore2, only } } }) => shouldIgnore(context, ignore2, only, dirname3)))
              return null;
            const chain = emptyChain(), logger2 = createLogger(input, context, baseLogger);
            for (const { config, index: index2, envName } of flattenedConfigs) {
              if (!(yield* mergeExtendsChain(chain, config.options, dirname3, context, files, baseLogger)))
                return null;
              logger2(config, index2, envName), yield* mergeChainOpts(chain, config);
            }
            return chain;
          };
        }
        function* mergeExtendsChain(chain, opts, dirname3, context, files, baseLogger) {
          if (void 0 === opts.extends)
            return true;
          const file = yield* (0, _files.loadConfig)(opts.extends, dirname3, context.envName, context.caller);
          if (files.has(file))
            throw new Error(`Configuration cycle detected loading ${file.filepath}.
File already loaded following the config chain:
` + Array.from(files, (file2) => ` - ${file2.filepath}`).join("\n"));
          files.add(file);
          const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);
          return files.delete(file), !!fileChain && (mergeChain(chain, fileChain), true);
        }
        function mergeChain(target, source) {
          target.options.push(...source.options), target.plugins.push(...source.plugins), target.presets.push(...source.presets);
          for (const file of source.files)
            target.files.add(file);
          return target;
        }
        function* mergeChainOpts(target, { options, plugins, presets }) {
          return target.options.push(options), target.plugins.push(...yield* plugins()), target.presets.push(...yield* presets()), target;
        }
        function emptyChain() {
          return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
        }
        function normalizeOptions3(opts) {
          const options = Object.assign({}, opts);
          return delete options.extends, delete options.env, delete options.overrides, delete options.plugins, delete options.presets, delete options.passPerPreset, delete options.ignore, delete options.only, delete options.test, delete options.include, delete options.exclude, Object.prototype.hasOwnProperty.call(options, "sourceMap") && (options.sourceMaps = options.sourceMap, delete options.sourceMap), options;
        }
        function dedupDescriptors(items) {
          const map = /* @__PURE__ */ new Map(), descriptors = [];
          for (const item of items)
            if ("function" == typeof item.value) {
              const fnKey = item.value;
              let nameMap = map.get(fnKey);
              nameMap || (nameMap = /* @__PURE__ */ new Map(), map.set(fnKey, nameMap));
              let desc = nameMap.get(item.name);
              desc ? desc.value = item : (desc = { value: item }, descriptors.push(desc), item.ownPass || nameMap.set(item.name, desc));
            } else
              descriptors.push({ value: item });
          return descriptors.reduce((acc, desc) => (acc.push(desc.value), acc), []);
        }
        function configIsApplicable({ options }, dirname3, context, configName) {
          return (void 0 === options.test || configFieldIsApplicable(context, options.test, dirname3, configName)) && (void 0 === options.include || configFieldIsApplicable(context, options.include, dirname3, configName)) && (void 0 === options.exclude || !configFieldIsApplicable(context, options.exclude, dirname3, configName));
        }
        function configFieldIsApplicable(context, test, dirname3, configName) {
          return matchesPatterns(context, Array.isArray(test) ? test : [test], dirname3, configName);
        }
        function ignoreListReplacer(_key, value2) {
          return value2 instanceof RegExp ? String(value2) : value2;
        }
        function shouldIgnore(context, ignore2, only, dirname3) {
          if (ignore2 && matchesPatterns(context, ignore2, dirname3)) {
            var _context$filename;
            const message = `No config is applied to "${null != (_context$filename = context.filename) ? _context$filename : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ignore2, ignoreListReplacer)}\` from "${dirname3}"`;
            return debug(message), context.showConfig && console.log(message), true;
          }
          if (only && !matchesPatterns(context, only, dirname3)) {
            var _context$filename2;
            const message = `No config is applied to "${null != (_context$filename2 = context.filename) ? _context$filename2 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(only, ignoreListReplacer)}\` from "${dirname3}"`;
            return debug(message), context.showConfig && console.log(message), true;
          }
          return false;
        }
        function matchesPatterns(context, patterns, dirname3, configName) {
          return patterns.some((pattern) => matchPattern(pattern, dirname3, context.filename, context, configName));
        }
        function matchPattern(pattern, dirname3, pathToTest, context, configName) {
          if ("function" == typeof pattern)
            return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest, { dirname: dirname3, envName: context.envName, caller: context.caller });
          if ("string" != typeof pathToTest)
            throw new _configError.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", configName);
          return "string" == typeof pattern && (pattern = (0, _patternToRegex.default)(pattern, dirname3)), pattern.test(pathToTest);
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/config-descriptors.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.createCachedDescriptors = function(dirname3, options, alias) {
          const { plugins, presets, passPerPreset } = options;
          return { options: optionsWithResolvedBrowserslistConfigFile(options, dirname3), plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname3)(alias) : () => handlerOf([]), presets: presets ? () => createCachedPresetDescriptors(presets, dirname3)(alias)(!!passPerPreset) : () => handlerOf([]) };
        }, exports3.createDescriptor = createDescriptor, exports3.createUncachedDescriptors = function(dirname3, options, alias) {
          return { options: optionsWithResolvedBrowserslistConfigFile(options, dirname3), plugins: (0, _functional.once)(() => createPluginDescriptors(options.plugins || [], dirname3, alias)), presets: (0, _functional.once)(() => createPresetDescriptors(options.presets || [], dirname3, alias, !!options.passPerPreset)) };
        };
        var _functional = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/functional.js"), _files = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/index.js"), _item = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/item.js"), _caching = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/caching.js"), _resolveTargets = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/resolve-targets.js");
        function* handlerOf(value2) {
          return value2;
        }
        function optionsWithResolvedBrowserslistConfigFile(options, dirname3) {
          return "string" == typeof options.browserslistConfigFile && (options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname3)), options;
        }
        const PRESET_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap(), createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
          const dirname3 = cache.using((dir) => dir);
          return (0, _caching.makeStrongCacheSync)((alias) => (0, _caching.makeStrongCache)(function* (passPerPreset) {
            return (yield* createPresetDescriptors(items, dirname3, alias, passPerPreset)).map((desc) => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));
          }));
        }), PLUGIN_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap(), createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
          const dirname3 = cache.using((dir) => dir);
          return (0, _caching.makeStrongCache)(function* (alias) {
            return (yield* createPluginDescriptors(items, dirname3, alias)).map((desc) => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));
          });
        }), DEFAULT_OPTIONS = {};
        function loadCachedDescriptor(cache, desc) {
          const { value: value2, options = DEFAULT_OPTIONS } = desc;
          if (false === options)
            return desc;
          let cacheByOptions = cache.get(value2);
          cacheByOptions || (cacheByOptions = /* @__PURE__ */ new WeakMap(), cache.set(value2, cacheByOptions));
          let possibilities = cacheByOptions.get(options);
          if (possibilities || (possibilities = [], cacheByOptions.set(options, possibilities)), -1 === possibilities.indexOf(desc)) {
            const matches = possibilities.filter((possibility) => {
              return b = desc, (a = possibility).name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
              var a, b;
            });
            if (matches.length > 0)
              return matches[0];
            possibilities.push(desc);
          }
          return desc;
        }
        function* createPresetDescriptors(items, dirname3, alias, passPerPreset) {
          return yield* createDescriptors("preset", items, dirname3, alias, passPerPreset);
        }
        function* createPluginDescriptors(items, dirname3, alias) {
          return yield* createDescriptors("plugin", items, dirname3, alias);
        }
        function* createDescriptors(type, items, dirname3, alias, ownPass) {
          const descriptors = yield* _gensync().all(items.map((item, index2) => createDescriptor(item, dirname3, { type, alias: `${alias}$${index2}`, ownPass: !!ownPass })));
          return function(items2) {
            const map = /* @__PURE__ */ new Map();
            for (const item of items2) {
              if ("function" != typeof item.value)
                continue;
              let nameMap = map.get(item.value);
              if (nameMap || (nameMap = /* @__PURE__ */ new Set(), map.set(item.value, nameMap)), nameMap.has(item.name)) {
                const conflicts = items2.filter((i) => i.value === item.value);
                throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(conflicts, null, 2)}`].join("\n"));
              }
              nameMap.add(item.name);
            }
          }(descriptors), descriptors;
        }
        function* createDescriptor(pair, dirname3, { type, alias, ownPass }) {
          const desc = (0, _item.getItemDescriptor)(pair);
          if (desc)
            return desc;
          let name, options, file, value2 = pair;
          Array.isArray(value2) && (3 === value2.length ? [value2, options, name] = value2 : [value2, options] = value2);
          let filepath = null;
          if ("string" == typeof value2) {
            if ("string" != typeof type)
              throw new Error("To resolve a string-based item, the type of item must be given");
            const resolver = "plugin" === type ? _files.loadPlugin : _files.loadPreset, request = value2;
            ({ filepath, value: value2 } = yield* resolver(value2, dirname3)), file = { request, resolved: filepath };
          }
          if (!value2)
            throw new Error(`Unexpected falsy value: ${String(value2)}`);
          if ("object" == typeof value2 && value2.__esModule) {
            if (!value2.default)
              throw new Error("Must export a default export when using ES6 modules.");
            value2 = value2.default;
          }
          if ("object" != typeof value2 && "function" != typeof value2)
            throw new Error(`Unsupported format: ${typeof value2}. Expected an object or a function.`);
          if (null !== filepath && "object" == typeof value2 && value2)
            throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);
          return { name, alias: filepath || alias, value: value2, options, dirname: dirname3, ownPass, file };
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/configuration.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _debug() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return _debug = function() {
            return data2;
          }, data2;
        }
        function _fs() {
          const data2 = __webpack_require__2("fs");
          return _fs = function() {
            return data2;
          }, data2;
        }
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        function _json() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs");
          return _json = function() {
            return data2;
          }, data2;
        }
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ROOT_CONFIG_FILENAMES = void 0, exports3.findConfigUpwards = function(rootDir) {
          let dirname3 = rootDir;
          for (; ; ) {
            for (const filename of ROOT_CONFIG_FILENAMES)
              if (_fs().existsSync(_path().join(dirname3, filename)))
                return dirname3;
            const nextDir = _path().dirname(dirname3);
            if (dirname3 === nextDir)
              break;
            dirname3 = nextDir;
          }
          return null;
        }, exports3.findRelativeConfig = function* (packageData, envName, caller) {
          let config = null, ignore2 = null;
          const dirname3 = _path().dirname(packageData.filepath);
          for (const loc of packageData.directories) {
            var _packageData$pkg;
            if (!config)
              config = yield* loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, (null == (_packageData$pkg = packageData.pkg) ? void 0 : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null);
            if (!ignore2) {
              const ignoreLoc = _path().join(loc, BABELIGNORE_FILENAME);
              ignore2 = yield* readIgnoreConfig(ignoreLoc), ignore2 && debug("Found ignore %o from %o.", ignore2.filepath, dirname3);
            }
          }
          return { config, ignore: ignore2 };
        }, exports3.findRootConfig = function(dirname3, envName, caller) {
          return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname3, envName, caller);
        }, exports3.loadConfig = function* (name, dirname3, envName, caller) {
          const filepath = (v = process.versions.node, w = "8.9", v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1] ? __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").resolve : (r2, { paths: [b] }, M = __webpack_require__2("module")) => {
            let f = M._findPath(r2, M._nodeModulePaths(b).concat(b));
            if (f)
              return f;
            throw f = new Error(`Cannot resolve module '${r2}'`), f.code = "MODULE_NOT_FOUND", f;
          })(name, { paths: [dirname3] }), conf = yield* readConfig(filepath, envName, caller);
          var v, w;
          if (!conf)
            throw new _configError.default("Config file contains no configuration data", filepath);
          return debug("Loaded config %o from %o.", name, dirname3), conf;
        }, exports3.resolveShowConfigPath = function* (dirname3) {
          const targetPath = process.env.BABEL_SHOW_CONFIG_FOR;
          if (null != targetPath) {
            const absolutePath = _path().resolve(dirname3, targetPath);
            if (!(yield* fs4.stat(absolutePath)).isFile())
              throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
            return absolutePath;
          }
          return null;
        };
        var _caching = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/caching.js"), _configApi = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/config-api.js"), _utils = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/utils.js"), _moduleTypes = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/module-types.js"), _patternToRegex = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/pattern-to-regex.js"), _configError = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/config-error.js"), fs4 = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/fs.js"), _rewriteStackTrace = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const debug = _debug()("babel:config:loading:files:configuration"), ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts"];
        exports3.ROOT_CONFIG_FILENAMES = ROOT_CONFIG_FILENAMES;
        const RELATIVE_CONFIG_FILENAMES = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], BABELIGNORE_FILENAME = ".babelignore", LOADING_CONFIGS = /* @__PURE__ */ new Set(), readConfigCode = (0, _caching.makeStrongCache)(function* (filepath, cache) {
          if (!_fs().existsSync(filepath))
            return cache.never(), null;
          if (LOADING_CONFIGS.has(filepath))
            return cache.never(), debug("Auto-ignoring usage of config %o.", filepath), { filepath, dirname: _path().dirname(filepath), options: {} };
          let options;
          try {
            LOADING_CONFIGS.add(filepath), options = yield* (0, _moduleTypes.default)(filepath, "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously.");
          } finally {
            LOADING_CONFIGS.delete(filepath);
          }
          let assertCache = false;
          if ("function" == typeof options && (yield* [], options = (0, _rewriteStackTrace.endHiddenCallStack)(options)((0, _configApi.makeConfigAPI)(cache)), assertCache = true), !options || "object" != typeof options || Array.isArray(options))
            throw new _configError.default("Configuration should be an exported JavaScript object.", filepath);
          if ("function" == typeof options.then)
            throw new _configError.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.", filepath);
          return assertCache && !cache.configured() && function(filepath2) {
            throw new _configError.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, filepath2);
          }(filepath), { filepath, dirname: _path().dirname(filepath), options };
        }), packageToBabelConfig = (0, _caching.makeWeakCacheSync)((file) => {
          const babel = file.options.babel;
          if (void 0 === babel)
            return null;
          if ("object" != typeof babel || Array.isArray(babel) || null === babel)
            throw new _configError.default(".babel property must be an object", file.filepath);
          return { filepath: file.filepath, dirname: file.dirname, options: babel };
        }), readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {
          let options;
          try {
            options = _json().parse(content);
          } catch (err) {
            throw new _configError.default(`Error while parsing config - ${err.message}`, filepath);
          }
          if (!options)
            throw new _configError.default("No config detected", filepath);
          if ("object" != typeof options)
            throw new _configError.default("Config returned typeof " + typeof options, filepath);
          if (Array.isArray(options))
            throw new _configError.default("Expected config object but found array", filepath);
          return delete options.$schema, { filepath, dirname: _path().dirname(filepath), options };
        }), readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {
          const ignoreDir = _path().dirname(filepath), ignorePatterns = content.split("\n").map((line) => line.replace(/#(.*?)$/, "").trim()).filter((line) => !!line);
          for (const pattern of ignorePatterns)
            if ("!" === pattern[0])
              throw new _configError.default("Negation of file paths is not supported.", filepath);
          return { filepath, dirname: _path().dirname(filepath), ignore: ignorePatterns.map((pattern) => (0, _patternToRegex.default)(pattern, ignoreDir)) };
        });
        function* loadOneConfig(names, dirname3, envName, caller, previousConfig = null) {
          const config = (yield* _gensync().all(names.map((filename) => readConfig(_path().join(dirname3, filename), envName, caller)))).reduce((previousConfig2, config2) => {
            if (config2 && previousConfig2)
              throw new _configError.default(`Multiple configuration files found. Please remove one:
 - ${_path().basename(previousConfig2.filepath)}
 - ${config2.filepath}
from ${dirname3}`);
            return config2 || previousConfig2;
          }, previousConfig);
          return config && debug("Found configuration %o from %o.", config.filepath, dirname3), config;
        }
        function readConfig(filepath, envName, caller) {
          switch (_path().extname(filepath)) {
            case ".js":
            case ".cjs":
            case ".mjs":
            case ".cts":
              return readConfigCode(filepath, { envName, caller });
            default:
              return readConfigJSON5(filepath);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/import-meta-resolve.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(specifier, parent) {
          return importMetaResolve(specifier, parent);
        };
        var _importMetaResolve = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/vendor/import-meta-resolve.js");
        let importMetaResolve;
        importMetaResolve = _importMetaResolve.resolve;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/import.cjs": (module4, __unused_webpack_exports, __webpack_require__2) => {
        module4.exports = function(filepath) {
          return __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files lazy recursive")(filepath);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "ROOT_CONFIG_FILENAMES", { enumerable: true, get: function() {
          return _configuration.ROOT_CONFIG_FILENAMES;
        } }), Object.defineProperty(exports3, "findConfigUpwards", { enumerable: true, get: function() {
          return _configuration.findConfigUpwards;
        } }), Object.defineProperty(exports3, "findPackageData", { enumerable: true, get: function() {
          return _package.findPackageData;
        } }), Object.defineProperty(exports3, "findRelativeConfig", { enumerable: true, get: function() {
          return _configuration.findRelativeConfig;
        } }), Object.defineProperty(exports3, "findRootConfig", { enumerable: true, get: function() {
          return _configuration.findRootConfig;
        } }), Object.defineProperty(exports3, "loadConfig", { enumerable: true, get: function() {
          return _configuration.loadConfig;
        } }), Object.defineProperty(exports3, "loadPlugin", { enumerable: true, get: function() {
          return _plugins.loadPlugin;
        } }), Object.defineProperty(exports3, "loadPreset", { enumerable: true, get: function() {
          return _plugins.loadPreset;
        } }), Object.defineProperty(exports3, "resolvePlugin", { enumerable: true, get: function() {
          return _plugins.resolvePlugin;
        } }), Object.defineProperty(exports3, "resolvePreset", { enumerable: true, get: function() {
          return _plugins.resolvePreset;
        } }), Object.defineProperty(exports3, "resolveShowConfigPath", { enumerable: true, get: function() {
          return _configuration.resolveShowConfigPath;
        } });
        var _package = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/package.js"), _configuration = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/configuration.js"), _plugins = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/plugins.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/module-types.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function* (filepath, asyncError) {
          switch (_path().extname(filepath)) {
            case ".cjs":
              return loadCjsDefault(filepath, arguments[2]);
            case ".mjs":
              break;
            case ".cts":
              return function(filepath2) {
                const ext = ".cts", hasTsSupport = !!(__webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").extensions[".ts"] || __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").extensions[".cts"] || __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").extensions[".mts"]);
                let handler;
                if (!hasTsSupport) {
                  const opts = { babelrc: false, configFile: false, sourceType: "unambiguous", sourceMaps: "inline", sourceFileName: _path().basename(filepath2), presets: [[getTSPreset(filepath2), Object.assign({ onlyRemoveTypeImports: true, optimizeConstEnums: true }, { allowDeclareFields: true })]] };
                  handler = function(m2, filename) {
                    if (handler && filename.endsWith(ext))
                      try {
                        return m2._compile((0, _transformFile.transformFileSync)(filename, Object.assign({}, opts, { filename })).code, filename);
                      } catch (error) {
                        if (!hasTsSupport) {
                          const packageJson = __webpack_require__2("./node_modules/.pnpm/@babel+preset-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/preset-typescript/package.json");
                          _semverV().lt(packageJson.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                        }
                        throw error;
                      }
                    return __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").extensions[".js"](m2, filename);
                  }, __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").extensions[ext] = handler;
                }
                try {
                  const module4 = (0, _rewriteStackTrace.endHiddenCallStack)(__webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive"))(filepath2);
                  return null != module4 && module4.__esModule ? module4.default : module4;
                } finally {
                  hasTsSupport || (__webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").extensions[ext] === handler && delete __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").extensions[ext], handler = void 0);
                }
              }(filepath);
            default:
              try {
                return loadCjsDefault(filepath, arguments[2]);
              } catch (e) {
                if ("ERR_REQUIRE_ESM" !== e.code)
                  throw e;
              }
          }
          if (yield* (0, _async.isAsync)())
            return yield* (0, _async.waitFor)(function(_x) {
              return _loadMjsDefault.apply(this, arguments);
            }(filepath));
          throw new _configError.default(asyncError, filepath);
        }, exports3.supportsESM = void 0;
        var _async = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/async.js");
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        function _url() {
          const data2 = __webpack_require__2("url");
          return _url = function() {
            return data2;
          }, data2;
        }
        function _semverV() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@nicolo-ribaudo+semver-v6@6.3.3/node_modules/@nicolo-ribaudo/semver-v6/semver.js");
          return _semverV = function() {
            return data2;
          }, data2;
        }
        var _rewriteStackTrace = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), _configError = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/config-error.js"), _transformFile = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transform-file.js");
        function asyncGeneratorStep(gen, resolve3, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg), value2 = info.value;
          } catch (error) {
            return void reject(error);
          }
          info.done ? resolve3(value2) : Promise.resolve(value2).then(_next, _throw);
        }
        let import_;
        try {
          import_ = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/import.cjs");
        } catch (_unused) {
        }
        const supportsESM = _semverV().satisfies(process.versions.node, "^12.17 || >=13.2");
        function loadCjsDefault(filepath) {
          const module4 = (0, _rewriteStackTrace.endHiddenCallStack)(__webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive"))(filepath);
          return null != module4 && module4.__esModule ? module4.default || (arguments[1] ? module4 : void 0) : module4;
        }
        function _loadMjsDefault() {
          var fn;
          return fn = function* (filepath) {
            if (!import_)
              throw new _configError.default("Internal error: Native ECMAScript modules aren't supported by this platform.\n", filepath);
            return (yield (0, _rewriteStackTrace.endHiddenCallStack)(import_)((0, _url().pathToFileURL)(filepath))).default;
          }, _loadMjsDefault = function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve3, reject) {
              var gen = fn.apply(self2, args);
              function _next(value2) {
                asyncGeneratorStep(gen, resolve3, reject, _next, _throw, "next", value2);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve3, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          }, _loadMjsDefault.apply(this, arguments);
        }
        function getTSPreset(filepath) {
          try {
            return __webpack_require__2("./node_modules/.pnpm/@babel+preset-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/preset-typescript/lib/index.js");
          } catch (error) {
            if ("MODULE_NOT_FOUND" !== error.code)
              throw error;
            let message = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
            throw process.versions.pnp && (message += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new _configError.default(message, filepath);
          }
        }
        exports3.supportsESM = supportsESM;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/package.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.findPackageData = function* (filepath) {
          let pkg = null;
          const directories = [];
          let isPackage = true, dirname3 = _path().dirname(filepath);
          for (; !pkg && "node_modules" !== _path().basename(dirname3); ) {
            directories.push(dirname3), pkg = yield* readConfigPackage(_path().join(dirname3, PACKAGE_FILENAME));
            const nextLoc = _path().dirname(dirname3);
            if (dirname3 === nextLoc) {
              isPackage = false;
              break;
            }
            dirname3 = nextLoc;
          }
          return { filepath, directories, pkg, isPackage };
        };
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/utils.js"), _configError = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/config-error.js");
        const PACKAGE_FILENAME = "package.json", readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {
          let options;
          try {
            options = JSON.parse(content);
          } catch (err) {
            throw new _configError.default(`Error while parsing JSON - ${err.message}`, filepath);
          }
          if (!options)
            throw new Error(`${filepath}: No config detected`);
          if ("object" != typeof options)
            throw new _configError.default("Config returned typeof " + typeof options, filepath);
          if (Array.isArray(options))
            throw new _configError.default("Expected config object but found array", filepath);
          return { filepath, dirname: _path().dirname(filepath), options };
        });
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/plugins.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _debug() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return _debug = function() {
            return data2;
          }, data2;
        }
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.loadPlugin = function* (name, dirname3) {
          const filepath = resolvePlugin(name, dirname3, yield* (0, _async.isAsync)()), value2 = yield* requireModule("plugin", filepath);
          return debug("Loaded plugin %o from %o.", name, dirname3), { filepath, value: value2 };
        }, exports3.loadPreset = function* (name, dirname3) {
          const filepath = resolvePreset(name, dirname3, yield* (0, _async.isAsync)()), value2 = yield* requireModule("preset", filepath);
          return debug("Loaded preset %o from %o.", name, dirname3), { filepath, value: value2 };
        }, exports3.resolvePreset = exports3.resolvePlugin = void 0;
        var _async = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/async.js"), _moduleTypes = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/module-types.js");
        function _url() {
          const data2 = __webpack_require__2("url");
          return _url = function() {
            return data2;
          }, data2;
        }
        var _importMetaResolve = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/import-meta-resolve.js");
        const debug = _debug()("babel:config:loading:files:plugins"), EXACT_RE = /^module:/, BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/, BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/, BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/, BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/, OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/, OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/, resolvePlugin = resolveStandardizedName.bind(null, "plugin");
        exports3.resolvePlugin = resolvePlugin;
        const resolvePreset = resolveStandardizedName.bind(null, "preset");
        function standardizeName(type, name) {
          if (_path().isAbsolute(name))
            return name;
          const isPreset = "preset" === type;
          return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, "");
        }
        function* resolveAlternativesHelper(type, name) {
          const standardizedName = standardizeName(type, name), { error, value: value2 } = yield standardizedName;
          if (!error)
            return value2;
          if ("MODULE_NOT_FOUND" !== error.code)
            throw error;
          standardizedName === name || (yield name).error || (error.message += `
- If you want to resolve "${name}", use "module:${name}"`), (yield standardizeName(type, "@babel/" + name)).error || (error.message += `
- Did you mean "@babel/${name}"?`);
          const oppositeType = "preset" === type ? "plugin" : "preset";
          if ((yield standardizeName(oppositeType, name)).error || (error.message += `
- Did you accidentally pass a ${oppositeType} as a ${type}?`), "plugin" === type) {
            const transformName = standardizedName.replace("-proposal-", "-transform-");
            transformName === standardizedName || (yield transformName).error || (error.message += `
- Did you mean "${transformName}"?`);
          }
          throw error.message += "\n\nMake sure that all the Babel plugins and presets you are using\nare defined as dependencies or devDependencies in your package.json\nfile. It's possible that the missing plugin is loaded by a preset\nyou are using that forgot to add the plugin to its dependencies: you\ncan workaround this problem by explicitly adding the missing package\nto your top-level package.json.\n", error;
        }
        function tryRequireResolve(id, dirname3) {
          try {
            return dirname3 ? { error: null, value: (v = process.versions.node, w = "8.9", v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1] ? __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").resolve : (r2, { paths: [b] }, M = __webpack_require__2("module")) => {
              let f = M._findPath(r2, M._nodeModulePaths(b).concat(b));
              if (f)
                return f;
              throw f = new Error(`Cannot resolve module '${r2}'`), f.code = "MODULE_NOT_FOUND", f;
            })(id, { paths: [dirname3] }) } : { error: null, value: __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files sync recursive").resolve(id) };
          } catch (error) {
            return { error, value: null };
          }
          var v, w;
        }
        function tryImportMetaResolve(id, options) {
          try {
            return { error: null, value: (0, _importMetaResolve.default)(id, options) };
          } catch (error) {
            return { error, value: null };
          }
        }
        function resolveStandardizedNameForRequire(type, name, dirname3) {
          const it = resolveAlternativesHelper(type, name);
          let res = it.next();
          for (; !res.done; )
            res = it.next(tryRequireResolve(res.value, dirname3));
          return res.value;
        }
        function resolveStandardizedName(type, name, dirname3, resolveESM) {
          if (!_moduleTypes.supportsESM || !resolveESM)
            return resolveStandardizedNameForRequire(type, name, dirname3);
          try {
            return function(type2, name2, dirname4) {
              const parentUrl = (0, _url().pathToFileURL)(_path().join(dirname4, "./babel-virtual-resolve-base.js")).href, it = resolveAlternativesHelper(type2, name2);
              let res = it.next();
              for (; !res.done; )
                res = it.next(tryImportMetaResolve(res.value, parentUrl));
              return (0, _url().fileURLToPath)(res.value);
            }(type, name, dirname3);
          } catch (e) {
            try {
              return resolveStandardizedNameForRequire(type, name, dirname3);
            } catch (e2) {
              if ("MODULE_NOT_FOUND" === e.type)
                throw e;
              if ("MODULE_NOT_FOUND" === e2.type)
                throw e2;
              throw e;
            }
          }
        }
        exports3.resolvePreset = resolvePreset;
        var LOADING_MODULES = /* @__PURE__ */ new Set();
        function* requireModule(type, name) {
          if (!(yield* (0, _async.isAsync)()) && LOADING_MODULES.has(name))
            throw new Error(`Reentrant ${type} detected trying to load "${name}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
          try {
            return LOADING_MODULES.add(name), yield* (0, _moduleTypes.default)(name, `You appear to be using a native ECMAScript module ${type}, which is only supported when running Babel asynchronously.`, true);
          } catch (err) {
            throw err.message = `[BABEL]: ${err.message} (While processing: ${name})`, err;
          } finally {
            LOADING_MODULES.delete(name);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/utils.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.makeStaticFileCache = function(fn) {
          return (0, _caching.makeStrongCache)(function* (filepath, cache) {
            const cached = cache.invalidate(() => function(filepath2) {
              if (!_fs2().existsSync(filepath2))
                return null;
              try {
                return +_fs2().statSync(filepath2).mtime;
              } catch (e) {
                if ("ENOENT" !== e.code && "ENOTDIR" !== e.code)
                  throw e;
              }
              return null;
            }(filepath));
            return null === cached ? null : fn(filepath, yield* fs4.readFile(filepath, "utf8"));
          });
        };
        var _caching = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/caching.js"), fs4 = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/fs.js");
        function _fs2() {
          const data2 = __webpack_require__2("fs");
          return _fs2 = function() {
            return data2;
          }, data2;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/full.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _async = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/async.js"), _util = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/util.js"), context = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _plugin = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/plugin.js"), _item = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/item.js"), _configChain = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/config-chain.js"), _deepArray = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function _traverse() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data2;
          }, data2;
        }
        var _caching = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/caching.js"), _options = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/options.js"), _plugins = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/plugins.js"), _configApi = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/config-api.js"), _partial = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/partial.js"), _configError = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/config-error.js"), _default = _gensync()(function* (inputOpts) {
          var _opts$assumptions;
          const result = yield* (0, _partial.default)(inputOpts);
          if (!result)
            return null;
          const { options, context: context2, fileHandling } = result;
          if ("ignored" === fileHandling)
            return null;
          const optionDefaults = {}, { plugins, presets } = options;
          if (!plugins || !presets)
            throw new Error("Assertion failure - plugins and presets exist");
          const presetContext = Object.assign({}, context2, { targets: options.targets }), toDescriptor = (item) => {
            const desc = (0, _item.getItemDescriptor)(item);
            if (!desc)
              throw new Error("Assertion failure - must be config item");
            return desc;
          }, presetsDescriptors = presets.map(toDescriptor), initialPluginsDescriptors = plugins.map(toDescriptor), pluginDescriptorsByPass = [[]], passes = [], externalDependencies = [], ignored = yield* enhanceError(context2, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
            const presets2 = [];
            for (let i = 0; i < rawPresets.length; i++) {
              const descriptor = rawPresets[i];
              if (false !== descriptor.options) {
                try {
                  var preset = yield* loadPresetDescriptor(descriptor, presetContext);
                } catch (e) {
                  throw "BABEL_UNKNOWN_OPTION" === e.code && (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, "preset", e), e;
                }
                externalDependencies.push(preset.externalDependencies), descriptor.ownPass ? presets2.push({ preset: preset.chain, pass: [] }) : presets2.unshift({ preset: preset.chain, pass: pluginDescriptorsPass });
              }
            }
            if (presets2.length > 0) {
              pluginDescriptorsByPass.splice(1, 0, ...presets2.map((o) => o.pass).filter((p) => p !== pluginDescriptorsPass));
              for (const { preset: preset2, pass } of presets2) {
                if (!preset2)
                  return true;
                pass.push(...preset2.plugins);
                if (yield* recursePresetDescriptors(preset2.presets, pass))
                  return true;
                preset2.options.forEach((opts2) => {
                  (0, _util.mergeOptions)(optionDefaults, opts2);
                });
              }
            }
          })(presetsDescriptors, pluginDescriptorsByPass[0]);
          if (ignored)
            return null;
          const opts = optionDefaults;
          (0, _util.mergeOptions)(opts, options);
          const pluginContext = Object.assign({}, presetContext, { assumptions: null != (_opts$assumptions = opts.assumptions) ? _opts$assumptions : {} });
          return yield* enhanceError(context2, function* () {
            pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);
            for (const descs of pluginDescriptorsByPass) {
              const pass = [];
              passes.push(pass);
              for (let i = 0; i < descs.length; i++) {
                const descriptor = descs[i];
                if (false !== descriptor.options) {
                  try {
                    var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);
                  } catch (e) {
                    throw "BABEL_UNKNOWN_PLUGIN_PROPERTY" === e.code && (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, "plugin", e), e;
                  }
                  pass.push(plugin), externalDependencies.push(plugin.externalDependencies);
                }
              }
            }
          })(), opts.plugins = passes[0], opts.presets = passes.slice(1).filter((plugins2) => plugins2.length > 0).map((plugins2) => ({ plugins: plugins2 })), opts.passPerPreset = opts.presets.length > 0, { options: opts, passes, externalDependencies: (0, _deepArray.finalize)(externalDependencies) };
        });
        function enhanceError(context2, fn) {
          return function* (arg1, arg2) {
            try {
              return yield* fn(arg1, arg2);
            } catch (e) {
              var _context$filename;
              if (!/^\[BABEL\]/.test(e.message))
                e.message = `[BABEL] ${null != (_context$filename = context2.filename) ? _context$filename : "unknown file"}: ${e.message}`;
              throw e;
            }
          };
        }
        exports3.default = _default;
        const makeDescriptorLoader = (apiFactory) => (0, _caching.makeWeakCache)(function* ({ value: value2, options, dirname: dirname3, alias }, cache) {
          if (false === options)
            throw new Error("Assertion failure");
          options = options || {};
          const externalDependencies = [];
          let item = value2;
          if ("function" == typeof value2) {
            const factory = (0, _async.maybeAsync)(value2, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), api = Object.assign({}, context, apiFactory(cache, externalDependencies));
            try {
              item = yield* factory(api, options, dirname3);
            } catch (e) {
              throw alias && (e.message += ` (While processing: ${JSON.stringify(alias)})`), e;
            }
          }
          if (!item || "object" != typeof item)
            throw new Error("Plugin/Preset did not return an object.");
          if ((0, _async.isThenable)(item))
            throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);
          if (externalDependencies.length > 0 && (!cache.configured() || "forever" === cache.mode())) {
            let error = `A plugin/preset has external untracked dependencies (${externalDependencies[0]}), but the cache `;
            throw cache.configured() ? error += " has been configured to never be invalidated. " : error += "has not been configured to be invalidated when the external dependencies change. ", error += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(alias)})`, new Error(error);
          }
          return { value: item, options, dirname: dirname3, alias, externalDependencies: (0, _deepArray.finalize)(externalDependencies) };
        }), pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI), presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI), instantiatePlugin = (0, _caching.makeWeakCache)(function* ({ value: value2, options, dirname: dirname3, alias, externalDependencies }, cache) {
          const pluginObj = (0, _plugins.validatePluginObject)(value2), plugin = Object.assign({}, pluginObj);
          if (plugin.visitor && (plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor))), plugin.inherits) {
            const inheritsDescriptor = { name: void 0, alias: `${alias}$inherits`, value: plugin.inherits, options, dirname: dirname3 }, inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, (run) => cache.invalidate((data2) => run(inheritsDescriptor, data2)));
            plugin.pre = chain(inherits.pre, plugin.pre), plugin.post = chain(inherits.post, plugin.post), plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions), plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]), inherits.externalDependencies.length > 0 && (externalDependencies = 0 === externalDependencies.length ? inherits.externalDependencies : (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]));
          }
          return new _plugin.default(plugin, options, alias, externalDependencies);
        });
        function* loadPluginDescriptor(descriptor, context2) {
          if (descriptor.value instanceof _plugin.default) {
            if (descriptor.options)
              throw new Error("Passed options to an existing Plugin instance will not work.");
            return descriptor.value;
          }
          return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context2), context2);
        }
        const needsFilename = (val) => val && "function" != typeof val, validateIfOptionNeedsFilename = (options, descriptor) => {
          if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {
            const formattedPresetName = descriptor.name ? `"${descriptor.name}"` : "/* your preset */";
            throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
          }
        }, validatePreset = (preset, context2, descriptor) => {
          if (!context2.filename) {
            var _options$overrides;
            const { options } = preset;
            validateIfOptionNeedsFilename(options, descriptor), null == (_options$overrides = options.overrides) || _options$overrides.forEach((overrideOptions) => validateIfOptionNeedsFilename(overrideOptions, descriptor));
          }
        }, instantiatePreset = (0, _caching.makeWeakCacheSync)(({ value: value2, dirname: dirname3, alias, externalDependencies }) => ({ options: (0, _options.validate)("preset", value2), alias, dirname: dirname3, externalDependencies }));
        function* loadPresetDescriptor(descriptor, context2) {
          const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context2));
          return validatePreset(preset, context2, descriptor), { chain: yield* (0, _configChain.buildPresetChain)(preset, context2), externalDependencies: preset.externalDependencies };
        }
        function chain(a, b) {
          const fns = [a, b].filter(Boolean);
          return fns.length <= 1 ? fns[0] : function(...args) {
            for (const fn of fns)
              fn.apply(this, args);
          };
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/config-api.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _semverV() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@nicolo-ribaudo+semver-v6@6.3.3/node_modules/@nicolo-ribaudo/semver-v6/semver.js");
          return _semverV = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.makeConfigAPI = makeConfigAPI, exports3.makePluginAPI = function(cache, externalDependencies) {
          return Object.assign({}, makePresetAPI(cache, externalDependencies), { assumption: (name) => cache.using((data2) => data2.assumptions[name]) });
        }, exports3.makePresetAPI = makePresetAPI;
        var _ = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _caching = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/caching.js");
        function makeConfigAPI(cache) {
          return { version: _.version, cache: cache.simple(), env: (value2) => cache.using((data2) => void 0 === value2 ? data2.envName : "function" == typeof value2 ? (0, _caching.assertSimpleType)(value2(data2.envName)) : (Array.isArray(value2) ? value2 : [value2]).some((entry) => {
            if ("string" != typeof entry)
              throw new Error("Unexpected non-string value");
            return entry === data2.envName;
          })), async: () => false, caller: (cb) => cache.using((data2) => (0, _caching.assertSimpleType)(cb(data2.caller))), assertVersion };
        }
        function makePresetAPI(cache, externalDependencies) {
          return Object.assign({}, makeConfigAPI(cache), { targets: () => JSON.parse(cache.using((data2) => JSON.stringify(data2.targets))), addExternalDependency: (ref2) => {
            externalDependencies.push(ref2);
          } });
        }
        function assertVersion(range) {
          if ("number" == typeof range) {
            if (!Number.isInteger(range))
              throw new Error("Expected string or integer value.");
            range = `^${range}.0.0-0`;
          }
          if ("string" != typeof range)
            throw new Error("Expected string or integer value.");
          if (_semverV().satisfies(_.version, range))
            return;
          const limit = Error.stackTraceLimit;
          "number" == typeof limit && limit < 25 && (Error.stackTraceLimit = 25);
          const err = new Error(`Requires Babel "${range}", but was loaded with "${_.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
          throw "number" == typeof limit && (Error.stackTraceLimit = limit), Object.assign(err, { code: "BABEL_VERSION_UNSUPPORTED", version: _.version, range });
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/deep-array.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.finalize = function(deepArr) {
          return Object.freeze(deepArr);
        }, exports3.flattenToSet = function(arr) {
          const result = /* @__PURE__ */ new Set(), stack = [arr];
          for (; stack.length > 0; )
            for (const el of stack.pop())
              Array.isArray(el) ? stack.push(el) : result.add(el);
          return result;
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/environment.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.getEnv = function(defaultValue = "development") {
          return process.env.BABEL_ENV || "development";
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.createConfigItem = function(target, options, callback) {
          if (void 0 !== callback)
            createConfigItemRunner.errback(target, options, callback);
          else {
            if ("function" != typeof options)
              return createConfigItemRunner.sync(target, options);
            createConfigItemRunner.errback(target, void 0, callback);
          }
        }, exports3.createConfigItemSync = exports3.createConfigItemAsync = void 0, Object.defineProperty(exports3, "default", { enumerable: true, get: function() {
          return _full.default;
        } }), exports3.loadPartialConfigSync = exports3.loadPartialConfigAsync = exports3.loadPartialConfig = exports3.loadOptionsSync = exports3.loadOptionsAsync = exports3.loadOptions = void 0;
        var _full = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/full.js"), _partial = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/partial.js"), _item = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/item.js");
        const loadOptionsRunner = _gensync()(function* (opts) {
          var _config$options;
          const config = yield* (0, _full.default)(opts);
          return null != (_config$options = null == config ? void 0 : config.options) ? _config$options : null;
        }), createConfigItemRunner = _gensync()(_item.createConfigItem), maybeErrback = (runner) => (argOrCallback, maybeCallback) => {
          let arg, callback;
          if (void 0 === maybeCallback && "function" == typeof argOrCallback ? (callback = argOrCallback, arg = void 0) : (callback = maybeCallback, arg = argOrCallback), !callback)
            return runner.sync(arg);
          runner.errback(arg, callback);
        }, loadPartialConfig = maybeErrback(_partial.loadPartialConfig);
        exports3.loadPartialConfig = loadPartialConfig;
        const loadPartialConfigSync = _partial.loadPartialConfig.sync;
        exports3.loadPartialConfigSync = loadPartialConfigSync;
        const loadPartialConfigAsync = _partial.loadPartialConfig.async;
        exports3.loadPartialConfigAsync = loadPartialConfigAsync;
        const loadOptions = maybeErrback(loadOptionsRunner);
        exports3.loadOptions = loadOptions;
        const loadOptionsSync = loadOptionsRunner.sync;
        exports3.loadOptionsSync = loadOptionsSync;
        const loadOptionsAsync = loadOptionsRunner.async;
        exports3.loadOptionsAsync = loadOptionsAsync;
        const createConfigItemSync = createConfigItemRunner.sync;
        exports3.createConfigItemSync = createConfigItemSync;
        const createConfigItemAsync = createConfigItemRunner.async;
        exports3.createConfigItemAsync = createConfigItemAsync;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/item.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.createConfigItem = function* (value2, { dirname: dirname3 = ".", type } = {}) {
          return createItemFromDescriptor(yield* (0, _configDescriptors.createDescriptor)(value2, _path().resolve(dirname3), { type, alias: "programmatic item" }));
        }, exports3.createItemFromDescriptor = createItemFromDescriptor, exports3.getItemDescriptor = function(item) {
          if (null != item && item[CONFIG_ITEM_BRAND])
            return item._descriptor;
          return;
        };
        var _configDescriptors = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/config-descriptors.js");
        function createItemFromDescriptor(desc) {
          return new ConfigItem(desc);
        }
        const CONFIG_ITEM_BRAND = Symbol.for("@babel/core@7 - ConfigItem");
        class ConfigItem {
          constructor(descriptor) {
            this._descriptor = void 0, this[CONFIG_ITEM_BRAND] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = descriptor, Object.defineProperty(this, "_descriptor", { enumerable: false }), Object.defineProperty(this, CONFIG_ITEM_BRAND, { enumerable: false }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
          }
        }
        Object.freeze(ConfigItem.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/partial.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = loadPrivatePartialConfig, exports3.loadPartialConfig = void 0;
        var _plugin = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/plugin.js"), _util = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/util.js"), _item = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/item.js"), _configChain = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/config-chain.js"), _environment = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/environment.js"), _options = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/options.js"), _files = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/index.js"), _resolveTargets = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/resolve-targets.js");
        const _excluded = ["showIgnoredFiles"];
        function* loadPrivatePartialConfig(inputOpts) {
          if (null != inputOpts && ("object" != typeof inputOpts || Array.isArray(inputOpts)))
            throw new Error("Babel options must be an object, null, or undefined");
          const args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {}, { envName = (0, _environment.getEnv)(), cwd = ".", root: rootDir = ".", rootMode = "root", caller, cloneInputAst = true } = args, absoluteCwd = _path().resolve(cwd), absoluteRootDir = function(rootDir2, rootMode2) {
            switch (rootMode2) {
              case "root":
                return rootDir2;
              case "upward-optional": {
                const upwardRootDir = (0, _files.findConfigUpwards)(rootDir2);
                return null === upwardRootDir ? rootDir2 : upwardRootDir;
              }
              case "upward": {
                const upwardRootDir = (0, _files.findConfigUpwards)(rootDir2);
                if (null !== upwardRootDir)
                  return upwardRootDir;
                throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir2}".
One of the following config files must be in the directory tree: "${_files.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: rootDir2 });
              }
              default:
                throw new Error("Assertion failure - unknown rootMode value.");
            }
          }(_path().resolve(absoluteCwd, rootDir), rootMode), filename = "string" == typeof args.filename ? _path().resolve(cwd, args.filename) : void 0, context = { filename, cwd: absoluteCwd, root: absoluteRootDir, envName, caller, showConfig: (yield* (0, _files.resolveShowConfigPath)(absoluteCwd)) === filename }, configChain = yield* (0, _configChain.buildRootChain)(args, context);
          if (!configChain)
            return null;
          const merged = { assumptions: {} };
          configChain.options.forEach((opts) => {
            (0, _util.mergeOptions)(merged, opts);
          });
          return { options: Object.assign({}, merged, { targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir), cloneInputAst, babelrc: false, configFile: false, browserslistConfigFile: false, passPerPreset: false, envName: context.envName, cwd: context.cwd, root: context.root, rootMode: "root", filename: "string" == typeof context.filename ? context.filename : void 0, plugins: configChain.plugins.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor)), presets: configChain.presets.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor)) }), context, fileHandling: configChain.fileHandling, ignore: configChain.ignore, babelrc: configChain.babelrc, config: configChain.config, files: configChain.files };
        }
        const loadPartialConfig = _gensync()(function* (opts) {
          let showIgnoredFiles = false;
          if ("object" == typeof opts && null !== opts && !Array.isArray(opts)) {
            var _opts = opts;
            ({ showIgnoredFiles } = _opts), opts = function(source, excluded) {
              if (null == source)
                return {};
              var key, i, target = {}, sourceKeys = Object.keys(source);
              for (i = 0; i < sourceKeys.length; i++)
                key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
              return target;
            }(_opts, _excluded);
          }
          const result = yield* loadPrivatePartialConfig(opts);
          if (!result)
            return null;
          const { options, babelrc, ignore: ignore2, config, fileHandling, files } = result;
          return "ignored" !== fileHandling || showIgnoredFiles ? ((options.plugins || []).forEach((item) => {
            if (item.value instanceof _plugin.default)
              throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
          }), new PartialConfig(options, babelrc ? babelrc.filepath : void 0, ignore2 ? ignore2.filepath : void 0, config ? config.filepath : void 0, fileHandling, files)) : null;
        });
        exports3.loadPartialConfig = loadPartialConfig;
        class PartialConfig {
          constructor(options, babelrc, ignore2, config, fileHandling, files) {
            this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = options, this.babelignore = ignore2, this.babelrc = babelrc, this.config = config, this.fileHandling = fileHandling, this.files = files, Object.freeze(this);
          }
          hasFilesystemConfig() {
            return void 0 !== this.babelrc || void 0 !== this.config;
          }
        }
        Object.freeze(PartialConfig.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/pattern-to-regex.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(pattern, dirname3) {
          const parts = _path().resolve(dirname3, pattern).split(_path().sep);
          return new RegExp(["^", ...parts.map((part, i) => {
            const last = i === parts.length - 1;
            return "**" === part ? last ? starStarPatLast : starStarPat : "*" === part ? last ? starPatLast : starPat : 0 === part.indexOf("*.") ? substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep) : escapeRegExp(part) + (last ? endSep : sep);
          })].join(""));
        };
        const sep = `\\${_path().sep}`, endSep = `(?:${sep}|$)`, substitution = `[^${sep}]+`, starPat = `(?:${substitution}${sep})`, starPatLast = `(?:${substitution}${endSep})`, starStarPat = `${starPat}*?`, starStarPatLast = `${starPat}*?${starPatLast}?`;
        function escapeRegExp(string) {
          return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/plugin.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _deepArray = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        exports3.default = class {
          constructor(plugin, options, key, externalDependencies = (0, _deepArray.finalize)([])) {
            this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = plugin.name || key, this.manipulateOptions = plugin.manipulateOptions, this.post = plugin.post, this.pre = plugin.pre, this.visitor = plugin.visitor || {}, this.parserOverride = plugin.parserOverride, this.generatorOverride = plugin.generatorOverride, this.options = options, this.externalDependencies = externalDependencies;
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/printer.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ConfigPrinter = exports3.ChainFormatter = void 0;
        const ChainFormatter = { Programmatic: 0, Config: 1 };
        exports3.ChainFormatter = ChainFormatter;
        const Formatter = { title(type, callerName, filepath) {
          let title = "";
          return type === ChainFormatter.Programmatic ? (title = "programmatic options", callerName && (title += " from " + callerName)) : title = "config " + filepath, title;
        }, loc(index2, envName) {
          let loc = "";
          return null != index2 && (loc += `.overrides[${index2}]`), null != envName && (loc += `.env["${envName}"]`), loc;
        }, *optionsAndDescriptors(opt) {
          const content = Object.assign({}, opt.options);
          delete content.overrides, delete content.env;
          const pluginDescriptors = [...yield* opt.plugins()];
          pluginDescriptors.length && (content.plugins = pluginDescriptors.map((d) => descriptorToConfig(d)));
          const presetDescriptors = [...yield* opt.presets()];
          return presetDescriptors.length && (content.presets = [...presetDescriptors].map((d) => descriptorToConfig(d))), JSON.stringify(content, void 0, 2);
        } };
        function descriptorToConfig(d) {
          var _d$file;
          let name = null == (_d$file = d.file) ? void 0 : _d$file.request;
          return null == name && ("object" == typeof d.value ? name = d.value : "function" == typeof d.value && (name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`)), null == name && (name = "[Unknown]"), void 0 === d.options ? name : null == d.name ? [name, d.options] : [name, d.options, d.name];
        }
        class ConfigPrinter {
          constructor() {
            this._stack = [];
          }
          configure(enabled, type, { callerName, filepath }) {
            return enabled ? (content, index2, envName) => {
              this._stack.push({ type, callerName, filepath, content, index: index2, envName });
            } : () => {
            };
          }
          static *format(config) {
            let title = Formatter.title(config.type, config.callerName, config.filepath);
            const loc = Formatter.loc(config.index, config.envName);
            loc && (title += ` ${loc}`);
            return `${title}
${yield* Formatter.optionsAndDescriptors(config.content)}`;
          }
          *output() {
            if (0 === this._stack.length)
              return "";
            return (yield* _gensync().all(this._stack.map((s) => ConfigPrinter.format(s)))).join("\n\n");
          }
        }
        exports3.ConfigPrinter = ConfigPrinter;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/resolve-targets.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        function _helperCompilationTargets() {
          const data2 = __webpack_require__2("./stubs/helper-compilation-targets.js");
          return _helperCompilationTargets = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.resolveBrowserslistConfigFile = function(browserslistConfigFile, configFileDir) {
          return _path().resolve(configFileDir, browserslistConfigFile);
        }, exports3.resolveTargets = function(options, root2) {
          const optTargets = options.targets;
          let targets;
          "string" == typeof optTargets || Array.isArray(optTargets) ? targets = { browsers: optTargets } : optTargets && (targets = "esmodules" in optTargets ? Object.assign({}, optTargets, { esmodules: "intersect" }) : optTargets);
          const { browserslistConfigFile } = options;
          let configFile, ignoreBrowserslistConfig = false;
          "string" == typeof browserslistConfigFile ? configFile = browserslistConfigFile : ignoreBrowserslistConfig = false === browserslistConfigFile;
          return (0, _helperCompilationTargets().default)(targets, { ignoreBrowserslistConfig, configFile, configPath: root2, browserslistEnv: options.browserslistEnv });
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/util.js": (__unused_webpack_module, exports3) => {
        "use strict";
        function mergeDefaultFields(target, source) {
          for (const k of Object.keys(source)) {
            const val = source[k];
            void 0 !== val && (target[k] = val);
          }
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.isIterableIterator = function(value2) {
          return !!value2 && "function" == typeof value2.next && "function" == typeof value2[Symbol.iterator];
        }, exports3.mergeOptions = function(target, source) {
          for (const k of Object.keys(source))
            if ("parserOpts" !== k && "generatorOpts" !== k && "assumptions" !== k || !source[k]) {
              const val = source[k];
              void 0 !== val && (target[k] = val);
            } else {
              const parserOpts = source[k];
              mergeDefaultFields(target[k] || (target[k] = {}), parserOpts);
            }
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/option-assertions.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _helperCompilationTargets() {
          const data2 = __webpack_require__2("./stubs/helper-compilation-targets.js");
          return _helperCompilationTargets = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.access = access, exports3.assertArray = assertArray, exports3.assertAssumptions = function(loc, value2) {
          if (void 0 === value2)
            return;
          if ("object" != typeof value2 || null === value2)
            throw new Error(`${msg(loc)} must be an object or undefined.`);
          let root2 = loc;
          do {
            root2 = root2.parent;
          } while ("root" !== root2.type);
          const inPreset = "preset" === root2.source;
          for (const name of Object.keys(value2)) {
            const subLoc = access(loc, name);
            if (!_options.assumptionsNames.has(name))
              throw new Error(`${msg(subLoc)} is not a supported assumption.`);
            if ("boolean" != typeof value2[name])
              throw new Error(`${msg(subLoc)} must be a boolean.`);
            if (inPreset && false === value2[name])
              throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);
          }
          return value2;
        }, exports3.assertBabelrcSearch = function(loc, value2) {
          if (void 0 === value2 || "boolean" == typeof value2)
            return value2;
          if (Array.isArray(value2))
            value2.forEach((item, i) => {
              if (!checkValidTest(item))
                throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
            });
          else if (!checkValidTest(value2))
            throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(value2)}`);
          return value2;
        }, exports3.assertBoolean = assertBoolean, exports3.assertCallerMetadata = function(loc, value2) {
          const obj = assertObject(loc, value2);
          if (obj) {
            if ("string" != typeof obj.name)
              throw new Error(`${msg(loc)} set but does not contain "name" property string`);
            for (const prop of Object.keys(obj)) {
              const propLoc = access(loc, prop), value3 = obj[prop];
              if (null != value3 && "boolean" != typeof value3 && "string" != typeof value3 && "number" != typeof value3)
                throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);
            }
          }
          return value2;
        }, exports3.assertCompact = function(loc, value2) {
          if (void 0 !== value2 && "boolean" != typeof value2 && "auto" !== value2)
            throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
          return value2;
        }, exports3.assertConfigApplicableTest = function(loc, value2) {
          if (void 0 === value2)
            return value2;
          if (Array.isArray(value2))
            value2.forEach((item, i) => {
              if (!checkValidTest(item))
                throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
            });
          else if (!checkValidTest(value2))
            throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);
          return value2;
        }, exports3.assertConfigFileSearch = function(loc, value2) {
          if (void 0 !== value2 && "boolean" != typeof value2 && "string" != typeof value2)
            throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, got ${JSON.stringify(value2)}`);
          return value2;
        }, exports3.assertFunction = function(loc, value2) {
          if (void 0 !== value2 && "function" != typeof value2)
            throw new Error(`${msg(loc)} must be a function, or undefined`);
          return value2;
        }, exports3.assertIgnoreList = function(loc, value2) {
          const arr = assertArray(loc, value2);
          return null == arr || arr.forEach((item, i) => function(loc2, value3) {
            if ("string" != typeof value3 && "function" != typeof value3 && !(value3 instanceof RegExp))
              throw new Error(`${msg(loc2)} must be an array of string/Function/RegExp values, or undefined`);
            return value3;
          }(access(loc, i), item)), arr;
        }, exports3.assertInputSourceMap = function(loc, value2) {
          if (void 0 !== value2 && "boolean" != typeof value2 && ("object" != typeof value2 || !value2))
            throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
          return value2;
        }, exports3.assertObject = assertObject, exports3.assertPluginList = function(loc, value2) {
          const arr = assertArray(loc, value2);
          arr && arr.forEach((item, i) => function(loc2, value3) {
            if (Array.isArray(value3)) {
              if (0 === value3.length)
                throw new Error(`${msg(loc2)} must include an object`);
              if (value3.length > 3)
                throw new Error(`${msg(loc2)} may only be a two-tuple or three-tuple`);
              if (assertPluginTarget(access(loc2, 0), value3[0]), value3.length > 1) {
                const opts = value3[1];
                if (void 0 !== opts && false !== opts && ("object" != typeof opts || Array.isArray(opts) || null === opts))
                  throw new Error(`${msg(access(loc2, 1))} must be an object, false, or undefined`);
              }
              if (3 === value3.length) {
                const name = value3[2];
                if (void 0 !== name && "string" != typeof name)
                  throw new Error(`${msg(access(loc2, 2))} must be a string, or undefined`);
              }
            } else
              assertPluginTarget(loc2, value3);
            return value3;
          }(access(loc, i), item));
          return arr;
        }, exports3.assertRootMode = function(loc, value2) {
          if (void 0 !== value2 && "root" !== value2 && "upward" !== value2 && "upward-optional" !== value2)
            throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);
          return value2;
        }, exports3.assertSourceMaps = function(loc, value2) {
          if (void 0 !== value2 && "boolean" != typeof value2 && "inline" !== value2 && "both" !== value2)
            throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);
          return value2;
        }, exports3.assertSourceType = function(loc, value2) {
          if (void 0 !== value2 && "module" !== value2 && "script" !== value2 && "unambiguous" !== value2)
            throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);
          return value2;
        }, exports3.assertString = function(loc, value2) {
          if (void 0 !== value2 && "string" != typeof value2)
            throw new Error(`${msg(loc)} must be a string, or undefined`);
          return value2;
        }, exports3.assertTargets = function(loc, value2) {
          if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value2))
            return value2;
          if ("object" != typeof value2 || !value2 || Array.isArray(value2))
            throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);
          const browsersLoc = access(loc, "browsers"), esmodulesLoc = access(loc, "esmodules");
          assertBrowsersList(browsersLoc, value2.browsers), assertBoolean(esmodulesLoc, value2.esmodules);
          for (const key of Object.keys(value2)) {
            const val = value2[key], subLoc = access(loc, key);
            if ("esmodules" === key)
              assertBoolean(subLoc, val);
            else if ("browsers" === key)
              assertBrowsersList(subLoc, val);
            else {
              if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {
                const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
                throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);
              }
              assertBrowserVersion(subLoc, val);
            }
          }
          return value2;
        }, exports3.msg = msg;
        var _options = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/options.js");
        function msg(loc) {
          switch (loc.type) {
            case "root":
              return "";
            case "env":
              return `${msg(loc.parent)}.env["${loc.name}"]`;
            case "overrides":
              return `${msg(loc.parent)}.overrides[${loc.index}]`;
            case "option":
              return `${msg(loc.parent)}.${loc.name}`;
            case "access":
              return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
            default:
              throw new Error(`Assertion failure: Unknown type ${loc.type}`);
          }
        }
        function access(loc, name) {
          return { type: "access", name, parent: loc };
        }
        function assertBoolean(loc, value2) {
          if (void 0 !== value2 && "boolean" != typeof value2)
            throw new Error(`${msg(loc)} must be a boolean, or undefined`);
          return value2;
        }
        function assertObject(loc, value2) {
          if (void 0 !== value2 && ("object" != typeof value2 || Array.isArray(value2) || !value2))
            throw new Error(`${msg(loc)} must be an object, or undefined`);
          return value2;
        }
        function assertArray(loc, value2) {
          if (null != value2 && !Array.isArray(value2))
            throw new Error(`${msg(loc)} must be an array, or undefined`);
          return value2;
        }
        function checkValidTest(value2) {
          return "string" == typeof value2 || "function" == typeof value2 || value2 instanceof RegExp;
        }
        function assertPluginTarget(loc, value2) {
          if (("object" != typeof value2 || !value2) && "string" != typeof value2 && "function" != typeof value2)
            throw new Error(`${msg(loc)} must be a string, object, function`);
          return value2;
        }
        function assertBrowsersList(loc, value2) {
          if (void 0 !== value2 && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value2))
            throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);
        }
        function assertBrowserVersion(loc, value2) {
          if (("number" != typeof value2 || Math.round(value2) !== value2) && "string" != typeof value2)
            throw new Error(`${msg(loc)} must be a string or an integer number`);
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/options.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.assumptionsNames = void 0, exports3.checkNoUnwrappedItemOptionPairs = function(items, index2, type, e) {
          if (0 === index2)
            return;
          const lastItem = items[index2 - 1], thisItem = items[index2];
          lastItem.file && void 0 === lastItem.options && "object" == typeof thisItem.value && (e.message += `
- Maybe you meant to use
"${type}s": [
  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value, void 0, 2)}]
]
To be a valid ${type}, its name and options should be wrapped in a pair of brackets`);
        }, exports3.validate = function(type, opts, filename) {
          try {
            return validateNested({ type: "root", source: type }, opts);
          } catch (error) {
            const configError = new _configError.default(error.message, filename);
            throw error.code && (configError.code = error.code), configError;
          }
        };
        var _removed = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/removed.js"), _optionAssertions = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/option-assertions.js"), _configError = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/config-error.js");
        const ROOT_VALIDATORS = { cwd: _optionAssertions.assertString, root: _optionAssertions.assertString, rootMode: _optionAssertions.assertRootMode, configFile: _optionAssertions.assertConfigFileSearch, caller: _optionAssertions.assertCallerMetadata, filename: _optionAssertions.assertString, filenameRelative: _optionAssertions.assertString, code: _optionAssertions.assertBoolean, ast: _optionAssertions.assertBoolean, cloneInputAst: _optionAssertions.assertBoolean, envName: _optionAssertions.assertString }, BABELRC_VALIDATORS = { babelrc: _optionAssertions.assertBoolean, babelrcRoots: _optionAssertions.assertBabelrcSearch }, NONPRESET_VALIDATORS = { extends: _optionAssertions.assertString, ignore: _optionAssertions.assertIgnoreList, only: _optionAssertions.assertIgnoreList, targets: _optionAssertions.assertTargets, browserslistConfigFile: _optionAssertions.assertConfigFileSearch, browserslistEnv: _optionAssertions.assertString }, COMMON_VALIDATORS = { inputSourceMap: _optionAssertions.assertInputSourceMap, presets: _optionAssertions.assertPluginList, plugins: _optionAssertions.assertPluginList, passPerPreset: _optionAssertions.assertBoolean, assumptions: _optionAssertions.assertAssumptions, env: function(loc, value2) {
          if ("env" === loc.parent.type)
            throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);
          const parent = loc.parent, obj = (0, _optionAssertions.assertObject)(loc, value2);
          if (obj)
            for (const envName of Object.keys(obj)) {
              const env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
              if (!env)
                continue;
              validateNested({ type: "env", name: envName, parent }, env);
            }
          return obj;
        }, overrides: function(loc, value2) {
          if ("env" === loc.parent.type)
            throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);
          if ("overrides" === loc.parent.type)
            throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);
          const parent = loc.parent, arr = (0, _optionAssertions.assertArray)(loc, value2);
          if (arr)
            for (const [index2, item] of arr.entries()) {
              const objLoc = (0, _optionAssertions.access)(loc, index2), env = (0, _optionAssertions.assertObject)(objLoc, item);
              if (!env)
                throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);
              validateNested({ type: "overrides", index: index2, parent }, env);
            }
          return arr;
        }, test: _optionAssertions.assertConfigApplicableTest, include: _optionAssertions.assertConfigApplicableTest, exclude: _optionAssertions.assertConfigApplicableTest, retainLines: _optionAssertions.assertBoolean, comments: _optionAssertions.assertBoolean, shouldPrintComment: _optionAssertions.assertFunction, compact: _optionAssertions.assertCompact, minified: _optionAssertions.assertBoolean, auxiliaryCommentBefore: _optionAssertions.assertString, auxiliaryCommentAfter: _optionAssertions.assertString, sourceType: _optionAssertions.assertSourceType, wrapPluginVisitorMethod: _optionAssertions.assertFunction, highlightCode: _optionAssertions.assertBoolean, sourceMaps: _optionAssertions.assertSourceMaps, sourceMap: _optionAssertions.assertSourceMaps, sourceFileName: _optionAssertions.assertString, sourceRoot: _optionAssertions.assertString, parserOpts: _optionAssertions.assertObject, generatorOpts: _optionAssertions.assertObject };
        Object.assign(COMMON_VALIDATORS, { getModuleId: _optionAssertions.assertFunction, moduleRoot: _optionAssertions.assertString, moduleIds: _optionAssertions.assertBoolean, moduleId: _optionAssertions.assertString });
        const assumptionsNames = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
        function getSource(loc) {
          return "root" === loc.type ? loc.source : getSource(loc.parent);
        }
        function validateNested(loc, opts) {
          const type = getSource(loc);
          return function(opts2) {
            if (has(opts2, "sourceMap") && has(opts2, "sourceMaps"))
              throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
          }(opts), Object.keys(opts).forEach((key) => {
            const optLoc = { type: "option", name: key, parent: loc };
            if ("preset" === type && NONPRESET_VALIDATORS[key])
              throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);
            if ("arguments" !== type && ROOT_VALIDATORS[key])
              throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);
            if ("arguments" !== type && "configfile" !== type && BABELRC_VALIDATORS[key]) {
              if ("babelrcfile" === type || "extendsfile" === type)
                throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
              throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);
            }
            (COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError)(optLoc, opts[key]);
          }), opts;
        }
        function throwUnknownError(loc) {
          const key = loc.name;
          if (_removed.default[key]) {
            const { message, version: version2 = 5 } = _removed.default[key];
            throw new Error(`Using removed Babel ${version2} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);
          }
          {
            const unknownOptErr = new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
            throw unknownOptErr.code = "BABEL_UNKNOWN_OPTION", unknownOptErr;
          }
        }
        function has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports3.assumptionsNames = assumptionsNames;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/plugins.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.validatePluginObject = function(obj) {
          const rootPath = { type: "root", source: "plugin" };
          return Object.keys(obj).forEach((key) => {
            const validator = VALIDATORS[key];
            if (!validator) {
              const invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);
              throw invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", invalidPluginPropertyError;
            }
            validator({ type: "option", name: key, parent: rootPath }, obj[key]);
          }), obj;
        };
        var _optionAssertions = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/option-assertions.js");
        const VALIDATORS = { name: _optionAssertions.assertString, manipulateOptions: _optionAssertions.assertFunction, pre: _optionAssertions.assertFunction, post: _optionAssertions.assertFunction, inherits: _optionAssertions.assertFunction, visitor: function(loc, value2) {
          const obj = (0, _optionAssertions.assertObject)(loc, value2);
          if (obj && (Object.keys(obj).forEach((prop) => function(key, value3) {
            if (value3 && "object" == typeof value3)
              Object.keys(value3).forEach((handler) => {
                if ("enter" !== handler && "exit" !== handler)
                  throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`);
              });
            else if ("function" != typeof value3)
              throw new Error(`.visitor["${key}"] must be a function`);
            return value3;
          }(prop, obj[prop])), obj.enter || obj.exit))
            throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
          return obj;
        }, parserOverride: _optionAssertions.assertFunction, generatorOverride: _optionAssertions.assertFunction };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/validation/removed.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        exports3.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/config-error.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _rewriteStackTrace = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        class ConfigError extends Error {
          constructor(message, filename) {
            super(message), (0, _rewriteStackTrace.expectedError)(this), filename && (0, _rewriteStackTrace.injectVirtualStackFrame)(this, filename);
          }
        }
        exports3.default = ConfigError;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js": (__unused_webpack_module, exports3) => {
        "use strict";
        var _Object$getOwnPropert;
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.beginHiddenCallStack = function(fn) {
          return SUPPORTED ? Object.defineProperty(function(...args) {
            return setupPrepareStackTrace(), fn(...args);
          }, "name", { value: STOP_HIDING }) : fn;
        }, exports3.endHiddenCallStack = function(fn) {
          return SUPPORTED ? Object.defineProperty(function(...args) {
            return fn(...args);
          }, "name", { value: START_HIDING }) : fn;
        }, exports3.expectedError = function(error) {
          if (!SUPPORTED)
            return;
          return expectedErrors.add(error), error;
        }, exports3.injectVirtualStackFrame = function(error, filename) {
          if (!SUPPORTED)
            return;
          let frames = virtualFrames.get(error);
          frames || virtualFrames.set(error, frames = []);
          return frames.push(function(filename2) {
            return /* @__PURE__ */ Object.create({ isNative: () => false, isConstructor: () => false, isToplevel: () => true, getFileName: () => filename2, getLineNumber: () => {
            }, getColumnNumber: () => {
            }, getFunctionName: () => {
            }, getMethodName: () => {
            }, getTypeName: () => {
            }, toString: () => filename2 });
          }(filename)), error;
        };
        const ErrorToString = Function.call.bind(Error.prototype.toString), SUPPORTED = !!Error.captureStackTrace && true === (null == (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) ? void 0 : _Object$getOwnPropert.writable), START_HIDING = "startHiding - secret - don't use this - v1", STOP_HIDING = "stopHiding - secret - don't use this - v1", expectedErrors = /* @__PURE__ */ new WeakSet(), virtualFrames = /* @__PURE__ */ new WeakMap();
        function setupPrepareStackTrace() {
          setupPrepareStackTrace = () => {
          };
          const { prepareStackTrace = defaultPrepareStackTrace } = Error;
          Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 50)), Error.prepareStackTrace = function(err, trace) {
            let newTrace = [];
            let status = expectedErrors.has(err) ? "hiding" : "unknown";
            for (let i = 0; i < trace.length; i++) {
              const name = trace[i].getFunctionName();
              if (name === START_HIDING)
                status = "hiding";
              else if (name === STOP_HIDING) {
                if ("hiding" === status)
                  status = "showing", virtualFrames.has(err) && newTrace.unshift(...virtualFrames.get(err));
                else if ("unknown" === status) {
                  newTrace = trace;
                  break;
                }
              } else
                "hiding" !== status && newTrace.push(trace[i]);
            }
            return prepareStackTrace(err, newTrace);
          };
        }
        function defaultPrepareStackTrace(err, trace) {
          return 0 === trace.length ? ErrorToString(err) : `${ErrorToString(err)}
    at ${trace.join("\n    at ")}`;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/async.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        function asyncGeneratorStep(gen, resolve3, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg), value2 = info.value;
          } catch (error) {
            return void reject(error);
          }
          info.done ? resolve3(value2) : Promise.resolve(value2).then(_next, _throw);
        }
        function _asyncToGenerator(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve3, reject) {
              var gen = fn.apply(self2, args);
              function _next(value2) {
                asyncGeneratorStep(gen, resolve3, reject, _next, _throw, "next", value2);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve3, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.forwardAsync = function(action, cb) {
          const g = _gensync()(action);
          return withKind((kind) => {
            const adapted = g[kind];
            return cb(adapted);
          });
        }, exports3.isAsync = void 0, exports3.isThenable = isThenable, exports3.maybeAsync = function(fn, message) {
          return _gensync()({ sync(...args) {
            const result = fn.apply(this, args);
            if (isThenable(result))
              throw new Error(message);
            return result;
          }, async(...args) {
            return Promise.resolve(fn.apply(this, args));
          } });
        }, exports3.waitFor = exports3.onFirstPause = void 0;
        const runGenerator = _gensync()(function* (item) {
          return yield* item;
        }), isAsync = _gensync()({ sync: () => false, errback: (cb) => cb(null, true) });
        exports3.isAsync = isAsync;
        const withKind = _gensync()({ sync: (cb) => cb("sync"), async: (_ref = _asyncToGenerator(function* (cb) {
          return cb("async");
        }), function(_x) {
          return _ref.apply(this, arguments);
        }) });
        var _ref;
        const onFirstPause = _gensync()({ name: "onFirstPause", arity: 2, sync: function(item) {
          return runGenerator.sync(item);
        }, errback: function(item, firstPause, cb) {
          let completed = false;
          runGenerator.errback(item, (err, value2) => {
            completed = true, cb(err, value2);
          }), completed || firstPause();
        } });
        exports3.onFirstPause = onFirstPause;
        const waitFor = _gensync()({ sync: (x) => x, async: (_ref2 = _asyncToGenerator(function* (x) {
          return x;
        }), function(_x2) {
          return _ref2.apply(this, arguments);
        }) });
        var _ref2;
        function isThenable(val) {
          return !(!val || "object" != typeof val && "function" != typeof val || !val.then || "function" != typeof val.then);
        }
        exports3.waitFor = waitFor;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/fs.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _fs() {
          const data2 = __webpack_require__2("fs");
          return _fs = function() {
            return data2;
          }, data2;
        }
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.stat = exports3.readFile = void 0;
        const readFile = _gensync()({ sync: _fs().readFileSync, errback: _fs().readFile });
        exports3.readFile = readFile;
        const stat = _gensync()({ sync: _fs().statSync, errback: _fs().stat });
        exports3.stat = stat;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/functional.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.once = function(fn) {
          let result, resultP;
          return function* () {
            if (result)
              return result;
            if (!(yield* (0, _async.isAsync)()))
              return result = yield* fn();
            if (resultP)
              return yield* (0, _async.waitFor)(resultP);
            let resolve3, reject;
            resultP = new Promise((res, rej) => {
              resolve3 = res, reject = rej;
            });
            try {
              return result = yield* fn(), resultP = null, resolve3(result), result;
            } catch (error) {
              throw reject(error), error;
            }
          };
        };
        var _async = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/async.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(exports3, "File", { enumerable: true, get: function() {
          return _file.default;
        } }), Object.defineProperty(exports3, "buildExternalHelpers", { enumerable: true, get: function() {
          return _buildExternalHelpers.default;
        } }), Object.defineProperty(exports3, "createConfigItem", { enumerable: true, get: function() {
          return _config.createConfigItem;
        } }), Object.defineProperty(exports3, "createConfigItemAsync", { enumerable: true, get: function() {
          return _config.createConfigItemAsync;
        } }), Object.defineProperty(exports3, "createConfigItemSync", { enumerable: true, get: function() {
          return _config.createConfigItemSync;
        } }), Object.defineProperty(exports3, "getEnv", { enumerable: true, get: function() {
          return _environment.getEnv;
        } }), Object.defineProperty(exports3, "loadOptions", { enumerable: true, get: function() {
          return _config.loadOptions;
        } }), Object.defineProperty(exports3, "loadOptionsAsync", { enumerable: true, get: function() {
          return _config.loadOptionsAsync;
        } }), Object.defineProperty(exports3, "loadOptionsSync", { enumerable: true, get: function() {
          return _config.loadOptionsSync;
        } }), Object.defineProperty(exports3, "loadPartialConfig", { enumerable: true, get: function() {
          return _config.loadPartialConfig;
        } }), Object.defineProperty(exports3, "loadPartialConfigAsync", { enumerable: true, get: function() {
          return _config.loadPartialConfigAsync;
        } }), Object.defineProperty(exports3, "loadPartialConfigSync", { enumerable: true, get: function() {
          return _config.loadPartialConfigSync;
        } }), Object.defineProperty(exports3, "parse", { enumerable: true, get: function() {
          return _parse.parse;
        } }), Object.defineProperty(exports3, "parseAsync", { enumerable: true, get: function() {
          return _parse.parseAsync;
        } }), Object.defineProperty(exports3, "parseSync", { enumerable: true, get: function() {
          return _parse.parseSync;
        } }), Object.defineProperty(exports3, "resolvePlugin", { enumerable: true, get: function() {
          return _files.resolvePlugin;
        } }), Object.defineProperty(exports3, "resolvePreset", { enumerable: true, get: function() {
          return _files.resolvePreset;
        } }), Object.defineProperty(exports3, "template", { enumerable: true, get: function() {
          return _template().default;
        } }), Object.defineProperty(exports3, "tokTypes", { enumerable: true, get: function() {
          return _parser().tokTypes;
        } }), Object.defineProperty(exports3, "transform", { enumerable: true, get: function() {
          return _transform.transform;
        } }), Object.defineProperty(exports3, "transformAsync", { enumerable: true, get: function() {
          return _transform.transformAsync;
        } }), Object.defineProperty(exports3, "transformFile", { enumerable: true, get: function() {
          return _transformFile.transformFile;
        } }), Object.defineProperty(exports3, "transformFileAsync", { enumerable: true, get: function() {
          return _transformFile.transformFileAsync;
        } }), Object.defineProperty(exports3, "transformFileSync", { enumerable: true, get: function() {
          return _transformFile.transformFileSync;
        } }), Object.defineProperty(exports3, "transformFromAst", { enumerable: true, get: function() {
          return _transformAst.transformFromAst;
        } }), Object.defineProperty(exports3, "transformFromAstAsync", { enumerable: true, get: function() {
          return _transformAst.transformFromAstAsync;
        } }), Object.defineProperty(exports3, "transformFromAstSync", { enumerable: true, get: function() {
          return _transformAst.transformFromAstSync;
        } }), Object.defineProperty(exports3, "transformSync", { enumerable: true, get: function() {
          return _transform.transformSync;
        } }), Object.defineProperty(exports3, "traverse", { enumerable: true, get: function() {
          return _traverse().default;
        } }), exports3.version = exports3.types = void 0;
        var _file = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/file.js"), _buildExternalHelpers = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/tools/build-external-helpers.js"), _files = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/files/index.js"), _environment = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/environment.js");
        function _types() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
          return _types = function() {
            return data2;
          }, data2;
        }
        function _parser() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+parser@7.22.6/node_modules/@babel/parser/lib/index.js");
          return _parser = function() {
            return data2;
          }, data2;
        }
        function _traverse() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data2;
          }, data2;
        }
        function _template() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js");
          return _template = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "types", { enumerable: true, get: function() {
          return _types();
        } });
        var _config = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/index.js"), _transform = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transform.js"), _transformFile = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transform-file.js"), _transformAst = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transform-ast.js"), _parse = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/parse.js");
        __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js");
        exports3.version = "7.22.6";
        const DEFAULT_EXTENSIONS2 = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
        exports3.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS2, exports3.OptionManager = class {
          init(opts) {
            return (0, _config.loadOptionsSync)(opts);
          }
        }, exports3.Plugin = function(alias) {
          throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/parse.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.parse = void 0, exports3.parseAsync = function(...args) {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.async)(...args);
        }, exports3.parseSync = function(...args) {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(...args);
        };
        var _config = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/index.js"), _parser = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/parser/index.js"), _normalizeOpts = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/normalize-opts.js"), _rewriteStackTrace = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const parseRunner = _gensync()(function* (code, opts) {
          const config = yield* (0, _config.default)(opts);
          return null === config ? null : yield* (0, _parser.default)(config.passes, (0, _normalizeOpts.default)(config), code);
        });
        exports3.parse = function(code, opts, callback) {
          if ("function" == typeof opts && (callback = opts, opts = void 0), void 0 === callback)
            return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(code, opts);
          (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.errback)(code, opts, callback);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/parser/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _parser() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+parser@7.22.6/node_modules/@babel/parser/lib/index.js");
          return _parser = function() {
            return data2;
          }, data2;
        }
        function _codeFrame() {
          const data2 = __webpack_require__2("./stubs/babel-codeframe.js");
          return _codeFrame = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function* (pluginPasses, { parserOpts, highlightCode = true, filename = "unknown" }, code) {
          try {
            const results = [];
            for (const plugins of pluginPasses)
              for (const plugin of plugins) {
                const { parserOverride } = plugin;
                if (parserOverride) {
                  const ast = parserOverride(code, parserOpts, _parser().parse);
                  void 0 !== ast && results.push(ast);
                }
              }
            if (0 === results.length)
              return (0, _parser().parse)(code, parserOpts);
            if (1 === results.length) {
              if (yield* [], "function" == typeof results[0].then)
                throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
              return results[0];
            }
            throw new Error("More than one plugin attempted to override parsing.");
          } catch (err) {
            "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" === err.code && (err.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");
            const { loc, missingPlugin } = err;
            if (loc) {
              const codeFrame = (0, _codeFrame().codeFrameColumns)(code, { start: { line: loc.line, column: loc.column + 1 } }, { highlightCode });
              err.message = missingPlugin ? `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame) : `${filename}: ${err.message}

` + codeFrame, err.code = "BABEL_PARSE_ERROR";
            }
            throw err;
          }
        };
        var _missingPluginHelper = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(missingPluginName, loc, codeFrame) {
          let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${loc.column + 1}):

` + codeFrame;
          const pluginInfo = pluginNameMap[missingPluginName];
          if (pluginInfo) {
            const { syntax: syntaxPlugin, transform: transformPlugin } = pluginInfo;
            if (syntaxPlugin) {
              const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
              if (transformPlugin) {
                helpMessage += `

Add ${getNameURLCombination(transformPlugin)} to the '${transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;
              } else
                helpMessage += `

Add ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;
            }
          }
          return helpMessage;
        };
        const pluginNameMap = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow" }, transform: { name: "@babel/preset-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx" }, transform: { name: "@babel/preset-react", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react" } }, importAttributes: { syntax: { name: "@babel/plugin-syntax-import-attributes", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript" }, transform: { name: "@babel/preset-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript" } } };
        Object.assign(pluginNameMap, { asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators" }, transform: { name: "@babel/plugin-transform-async-generator-functions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-private-methods", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block" }, transform: { name: "@babel/plugin-transform-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from" }, transform: { name: "@babel/plugin-transform-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators" }, transform: { name: "@babel/plugin-transform-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator" }, transform: { name: "@babel/plugin-transform-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator" }, transform: { name: "@babel/plugin-transform-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread" }, transform: { name: "@babel/plugin-transform-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding" }, transform: { name: "@babel/plugin-transform-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining" }, transform: { name: "@babel/plugin-transform-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object" }, transform: { name: "@babel/plugin-transform-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object" } }, regexpUnicodeSets: { syntax: { name: "@babel/plugin-syntax-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md" }, transform: { name: "@babel/plugin-transform-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md" } } });
        const getNameURLCombination = ({ name, url }) => `${name} (${url})`;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/tools/build-external-helpers.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function helpers() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+helpers@7.22.6/node_modules/@babel/helpers/lib/index.js");
          return helpers = function() {
            return data2;
          }, data2;
        }
        function _generator() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/index.js");
          return _generator = function() {
            return data2;
          }, data2;
        }
        function _template() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js");
          return _template = function() {
            return data2;
          }, data2;
        }
        function _t() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(allowlist, outputType = "global") {
          let tree;
          const build2 = { global: buildGlobal, module: buildModule, umd: buildUmd, var: buildVar }[outputType];
          if (!build2)
            throw new Error(`Unsupported output type ${outputType}`);
          tree = build2(allowlist);
          return (0, _generator().default)(tree).code;
        };
        var _file = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/file.js");
        const { arrayExpression, assignmentExpression, binaryExpression, blockStatement, callExpression, cloneNode, conditionalExpression, exportNamedDeclaration, exportSpecifier, expressionStatement, functionExpression, identifier, memberExpression, objectExpression, program, stringLiteral, unaryExpression, variableDeclaration, variableDeclarator } = _t(), buildUmdWrapper = (replacements) => _template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);
        function buildGlobal(allowlist) {
          const namespace = identifier("babelHelpers"), body = [], container = functionExpression(null, [identifier("global")], blockStatement(body)), tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
          return body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))])), buildHelpers(body, namespace, allowlist), tree;
        }
        function buildModule(allowlist) {
          const body = [], refs = buildHelpers(body, null, allowlist);
          return body.unshift(exportNamedDeclaration(null, Object.keys(refs).map((name) => exportSpecifier(cloneNode(refs[name]), identifier(name))))), program(body, [], "module");
        }
        function buildUmd(allowlist) {
          const namespace = identifier("babelHelpers"), body = [];
          return body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))])), buildHelpers(body, namespace, allowlist), program([buildUmdWrapper({ FACTORY_PARAMETERS: identifier("global"), BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])), COMMON_ARGUMENTS: identifier("exports"), AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]), FACTORY_BODY: body, UMD_ROOT: identifier("this") })]);
        }
        function buildVar(allowlist) {
          const namespace = identifier("babelHelpers"), body = [];
          body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
          const tree = program(body);
          return buildHelpers(body, namespace, allowlist), body.push(expressionStatement(namespace)), tree;
        }
        function buildHelpers(body, namespace, allowlist) {
          const getHelperReference = (name) => namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`), refs = {};
          return helpers().list.forEach(function(name) {
            if (allowlist && allowlist.indexOf(name) < 0)
              return;
            const ref2 = refs[name] = getHelperReference(name);
            helpers().ensure(name, _file.default);
            const { nodes } = helpers().get(name, getHelperReference, ref2);
            body.push(...nodes);
          }), refs;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transform-ast.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.transformFromAst = void 0, exports3.transformFromAstAsync = function(...args) {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.async)(...args);
        }, exports3.transformFromAstSync = function(...args) {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(...args);
        };
        var _config = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/index.js"), _transformation = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/index.js"), _rewriteStackTrace = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const transformFromAstRunner = _gensync()(function* (ast, code, opts) {
          const config = yield* (0, _config.default)(opts);
          if (null === config)
            return null;
          if (!ast)
            throw new Error("No AST given");
          return yield* (0, _transformation.run)(config, code, ast);
        });
        exports3.transformFromAst = function(ast, code, optsOrCallback, maybeCallback) {
          let opts, callback;
          if ("function" == typeof optsOrCallback ? (callback = optsOrCallback, opts = void 0) : (opts = optsOrCallback, callback = maybeCallback), void 0 === callback)
            return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(ast, code, opts);
          (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.errback)(ast, code, opts, callback);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transform-file.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.transformFile = function(...args) {
          transformFileRunner.errback(...args);
        }, exports3.transformFileAsync = function(...args) {
          return transformFileRunner.async(...args);
        }, exports3.transformFileSync = function(...args) {
          return transformFileRunner.sync(...args);
        };
        var _config = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/index.js"), _transformation = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/index.js"), fs4 = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/gensync-utils/fs.js");
        const transformFileRunner = _gensync()(function* (filename, opts) {
          const options = Object.assign({}, opts, { filename }), config = yield* (0, _config.default)(options);
          if (null === config)
            return null;
          const code = yield* fs4.readFile(filename, "utf8");
          return yield* (0, _transformation.run)(config, code);
        });
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transform.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.transform = void 0, exports3.transformAsync = function(...args) {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.async)(...args);
        }, exports3.transformSync = function(...args) {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(...args);
        };
        var _config = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/index.js"), _transformation = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/index.js"), _rewriteStackTrace = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const transformRunner = _gensync()(function* (code, opts) {
          const config = yield* (0, _config.default)(opts);
          return null === config ? null : yield* (0, _transformation.run)(config, code);
        });
        exports3.transform = function(code, optsOrCallback, maybeCallback) {
          let opts, callback;
          if ("function" == typeof optsOrCallback ? (callback = optsOrCallback, opts = void 0) : (opts = optsOrCallback, callback = maybeCallback), void 0 === callback)
            return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(code, opts);
          (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.errback)(code, opts, callback);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _traverse() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function() {
          LOADED_PLUGIN || (LOADED_PLUGIN = new _plugin.default(Object.assign({}, blockHoistPlugin, { visitor: _traverse().default.explode(blockHoistPlugin.visitor) }), {}));
          return LOADED_PLUGIN;
        };
        var _plugin = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/plugin.js");
        let LOADED_PLUGIN;
        const blockHoistPlugin = { name: "internal.blockHoist", visitor: { Block: { exit({ node }) {
          const { body } = node;
          let max = Math.pow(2, 30) - 1, hasChange = false;
          for (let i = 0; i < body.length; i++) {
            const p = priority(body[i]);
            if (p > max) {
              hasChange = true;
              break;
            }
            max = p;
          }
          hasChange && (node.body = function(body2) {
            const buckets = /* @__PURE__ */ Object.create(null);
            for (let i = 0; i < body2.length; i++) {
              const n = body2[i], p = priority(n);
              (buckets[p] || (buckets[p] = [])).push(n);
            }
            const keys2 = Object.keys(buckets).map((k) => +k).sort((a, b) => b - a);
            let index2 = 0;
            for (const key of keys2) {
              const bucket = buckets[key];
              for (const n of bucket)
                body2[index2++] = n;
            }
            return body2;
          }(body.slice()));
        } } } };
        function priority(bodyNode) {
          const priority2 = null == bodyNode ? void 0 : bodyNode._blockHoist;
          return null == priority2 ? 1 : true === priority2 ? 2 : priority2;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/file.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function helpers() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+helpers@7.22.6/node_modules/@babel/helpers/lib/index.js");
          return helpers = function() {
            return data2;
          }, data2;
        }
        function _traverse() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data2;
          }, data2;
        }
        function _codeFrame() {
          const data2 = __webpack_require__2("./stubs/babel-codeframe.js");
          return _codeFrame = function() {
            return data2;
          }, data2;
        }
        function _t() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return data2;
          }, data2;
        }
        function _helperModuleTransforms() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/index.js");
          return _helperModuleTransforms = function() {
            return data2;
          }, data2;
        }
        function _semverV() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@nicolo-ribaudo+semver-v6@6.3.3/node_modules/@nicolo-ribaudo/semver-v6/semver.js");
          return _semverV = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        const { cloneNode, interpreterDirective } = _t(), errorVisitor = { enter(path3, state) {
          const loc = path3.node.loc;
          loc && (state.loc = loc, path3.stop());
        } };
        class File {
          constructor(options, { code, ast, inputMap }) {
            this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = options, this.code = code, this.ast = ast, this.inputMap = inputMap, this.path = _traverse().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
          }
          get shebang() {
            const { interpreter } = this.path.node;
            return interpreter ? interpreter.value : "";
          }
          set shebang(value2) {
            value2 ? this.path.get("interpreter").replaceWith(interpreterDirective(value2)) : this.path.get("interpreter").remove();
          }
          set(key, val) {
            if ("helpersNamespace" === key)
              throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
            this._map.set(key, val);
          }
          get(key) {
            return this._map.get(key);
          }
          has(key) {
            return this._map.has(key);
          }
          getModuleName() {
            return (0, _helperModuleTransforms().getModuleName)(this.opts, this.opts);
          }
          addImport() {
            throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
          }
          availableHelper(name, versionRange) {
            let minVersion;
            try {
              minVersion = helpers().minVersion(name);
            } catch (err) {
              if ("BABEL_HELPER_UNKNOWN" !== err.code)
                throw err;
              return false;
            }
            return "string" != typeof versionRange || (_semverV().valid(versionRange) && (versionRange = `^${versionRange}`), !_semverV().intersects(`<${minVersion}`, versionRange) && !_semverV().intersects(">=8.0.0", versionRange));
          }
          addHelper(name) {
            const declar = this.declarations[name];
            if (declar)
              return cloneNode(declar);
            const generator = this.get("helperGenerator");
            if (generator) {
              const res = generator(name);
              if (res)
                return res;
            }
            helpers().ensure(name, File);
            const uid = this.declarations[name] = this.scope.generateUidIdentifier(name), dependencies = {};
            for (const dep of helpers().getDependencies(name))
              dependencies[dep] = this.addHelper(dep);
            const { nodes, globals } = helpers().get(name, (dep) => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));
            return globals.forEach((name2) => {
              this.path.scope.hasBinding(name2, true) && this.path.scope.rename(name2);
            }), nodes.forEach((node) => {
              node._compact = true;
            }), this.path.unshiftContainer("body", nodes), this.path.get("body").forEach((path3) => {
              -1 !== nodes.indexOf(path3.node) && path3.isVariableDeclaration() && this.scope.registerDeclaration(path3);
            }), uid;
          }
          addTemplateObject() {
            throw new Error("This function has been moved into the template literal transform itself.");
          }
          buildCodeFrameError(node, msg, _Error = SyntaxError) {
            let loc = node && (node.loc || node._loc);
            if (!loc && node) {
              const state = { loc: null };
              (0, _traverse().default)(node, errorVisitor, this.scope, state), loc = state.loc;
              let txt = "This is an error on an internal node. Probably an internal error.";
              loc && (txt += " Location has been estimated."), msg += ` (${txt})`;
            }
            if (loc) {
              const { highlightCode = true } = this.opts;
              msg += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, { start: { line: loc.start.line, column: loc.start.column + 1 }, end: loc.end && loc.start.line === loc.end.line ? { line: loc.end.line, column: loc.end.column + 1 } : void 0 }, { highlightCode });
            }
            return new _Error(msg);
          }
        }
        exports3.default = File;
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/generate.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _convertSourceMap() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/convert-source-map@1.9.0/node_modules/convert-source-map/index.js");
          return _convertSourceMap = function() {
            return data2;
          }, data2;
        }
        function _generator() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/index.js");
          return _generator = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(pluginPasses, file) {
          const { opts, ast, code, inputMap } = file, { generatorOpts } = opts;
          generatorOpts.inputSourceMap = null == inputMap ? void 0 : inputMap.toObject();
          const results = [];
          for (const plugins of pluginPasses)
            for (const plugin of plugins) {
              const { generatorOverride } = plugin;
              if (generatorOverride) {
                const result2 = generatorOverride(ast, generatorOpts, code, _generator().default);
                void 0 !== result2 && results.push(result2);
              }
            }
          let result;
          if (0 === results.length)
            result = (0, _generator().default)(ast, generatorOpts, code);
          else {
            if (1 !== results.length)
              throw new Error("More than one plugin attempted to override codegen.");
            if (result = results[0], "function" == typeof result.then)
              throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          }
          let { code: outputCode, decodedMap: outputMap = result.map } = result;
          result.__mergedMap ? outputMap = Object.assign({}, result.map) : outputMap && (outputMap = inputMap ? (0, _mergeMap.default)(inputMap.toObject(), outputMap, generatorOpts.sourceFileName) : result.map);
          "inline" !== opts.sourceMaps && "both" !== opts.sourceMaps || (outputCode += "\n" + _convertSourceMap().fromObject(outputMap).toComment());
          "inline" === opts.sourceMaps && (outputMap = null);
          return { outputCode, outputMap };
        };
        var _mergeMap = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/merge-map.js");
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/merge-map.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _remapping() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js");
          return _remapping = function() {
            return data2;
          }, data2;
        }
        function rootless(map) {
          return Object.assign({}, map, { sourceRoot: null });
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(inputMap, map, sourceFileName) {
          const source = sourceFileName.replace(/\\/g, "/");
          let found = false;
          const result = _remapping()(rootless(map), (s, ctx) => s !== source || found ? null : (found = true, ctx.source = "", rootless(inputMap)));
          "string" == typeof inputMap.sourceRoot && (result.sourceRoot = inputMap.sourceRoot);
          return Object.assign({}, result);
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _traverse() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.run = function* (config, code, ast) {
          const file = yield* (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast), opts = file.opts;
          try {
            yield* function* (file2, pluginPasses) {
              for (const pluginPairs of pluginPasses) {
                const passPairs = [], passes = [], visitors = [];
                for (const plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {
                  const pass = new _pluginPass.default(file2, plugin.key, plugin.options);
                  passPairs.push([plugin, pass]), passes.push(pass), visitors.push(plugin.visitor);
                }
                for (const [plugin, pass] of passPairs) {
                  const fn = plugin.pre;
                  if (fn) {
                    const result = fn.call(pass, file2);
                    if (yield* [], isThenable(result))
                      throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
                const visitor = _traverse().default.visitors.merge(visitors, passes, file2.opts.wrapPluginVisitorMethod);
                (0, _traverse().default)(file2.ast, visitor, file2.scope);
                for (const [plugin, pass] of passPairs) {
                  const fn = plugin.post;
                  if (fn) {
                    const result = fn.call(pass, file2);
                    if (yield* [], isThenable(result))
                      throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
              }
            }(file, config.passes);
          } catch (e) {
            var _opts$filename;
            throw e.message = `${null != (_opts$filename = opts.filename) ? _opts$filename : "unknown file"}: ${e.message}`, e.code || (e.code = "BABEL_TRANSFORM_ERROR"), e;
          }
          let outputCode, outputMap;
          try {
            false !== opts.code && ({ outputCode, outputMap } = (0, _generate.default)(config.passes, file));
          } catch (e) {
            var _opts$filename2;
            throw e.message = `${null != (_opts$filename2 = opts.filename) ? _opts$filename2 : "unknown file"}: ${e.message}`, e.code || (e.code = "BABEL_GENERATE_ERROR"), e;
          }
          return { metadata: file.metadata, options: opts, ast: true === opts.ast ? file.ast : null, code: void 0 === outputCode ? null : outputCode, map: void 0 === outputMap ? null : outputMap, sourceType: file.ast.program.sourceType, externalDependencies: (0, _deepArray.flattenToSet)(config.externalDependencies) };
        };
        var _pluginPass = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/plugin-pass.js"), _blockHoistPlugin = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"), _normalizeOpts = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/normalize-opts.js"), _normalizeFile = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/normalize-file.js"), _generate = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/generate.js"), _deepArray = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function isThenable(val) {
          return !(!val || "object" != typeof val && "function" != typeof val || !val.then || "function" != typeof val.then);
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/normalize-file.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _fs() {
          const data2 = __webpack_require__2("fs");
          return _fs = function() {
            return data2;
          }, data2;
        }
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        function _debug() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js");
          return _debug = function() {
            return data2;
          }, data2;
        }
        function _t() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return data2;
          }, data2;
        }
        function _convertSourceMap() {
          const data2 = __webpack_require__2("./node_modules/.pnpm/convert-source-map@1.9.0/node_modules/convert-source-map/index.js");
          return _convertSourceMap = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function* (pluginPasses, options, code, ast) {
          if (code = `${code || ""}`, ast) {
            if ("Program" === ast.type)
              ast = file(ast, [], []);
            else if ("File" !== ast.type)
              throw new Error("AST root must be a Program or File node");
            options.cloneInputAst && (ast = (0, _cloneDeep.default)(ast));
          } else
            ast = yield* (0, _parser.default)(pluginPasses, options, code);
          let inputMap = null;
          if (false !== options.inputSourceMap) {
            if ("object" == typeof options.inputSourceMap && (inputMap = _convertSourceMap().fromObject(options.inputSourceMap)), !inputMap) {
              const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);
              if (lastComment)
                try {
                  inputMap = _convertSourceMap().fromComment(lastComment);
                } catch (err) {
                  debug("discarding unknown inline input sourcemap", err);
                }
            }
            if (!inputMap) {
              const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);
              if ("string" == typeof options.filename && lastComment)
                try {
                  const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment), inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]), "utf8");
                  inputMap = _convertSourceMap().fromJSON(inputMapContent);
                } catch (err) {
                  debug("discarding unknown file input sourcemap", err);
                }
              else
                lastComment && debug("discarding un-loadable file input sourcemap");
            }
          }
          return new _file.default(options, { code, ast, inputMap });
        };
        var _file = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/file/file.js"), _parser = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/parser/index.js"), _cloneDeep = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/util/clone-deep.js");
        const { file, traverseFast } = _t(), debug = _debug()("babel:transform:file"), INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/, EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
        function extractCommentsFromList(regex, comments, lastComment) {
          return comments && (comments = comments.filter(({ value: value2 }) => !regex.test(value2) || (lastComment = value2, false))), [comments, lastComment];
        }
        function extractComments(regex, ast) {
          let lastComment = null;
          return traverseFast(ast, (node) => {
            [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment), [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment), [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);
          }), lastComment;
        }
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/normalize-opts.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(config) {
          const { filename, cwd, filenameRelative = "string" == typeof filename ? _path().relative(cwd, filename) : "unknown", sourceType = "module", inputSourceMap, sourceMaps = !!inputSourceMap, sourceRoot = config.options.moduleRoot, sourceFileName = _path().basename(filenameRelative), comments = true, compact = "auto" } = config.options, opts = config.options, options = Object.assign({}, opts, { parserOpts: Object.assign({ sourceType: ".mjs" === _path().extname(filenameRelative) ? "module" : sourceType, sourceFileName: filename, plugins: [] }, opts.parserOpts), generatorOpts: Object.assign({ filename, auxiliaryCommentBefore: opts.auxiliaryCommentBefore, auxiliaryCommentAfter: opts.auxiliaryCommentAfter, retainLines: opts.retainLines, comments, shouldPrintComment: opts.shouldPrintComment, compact, minified: opts.minified, sourceMaps, sourceRoot, sourceFileName }, opts.generatorOpts) });
          for (const plugins of config.passes)
            for (const plugin of plugins)
              plugin.manipulateOptions && plugin.manipulateOptions(options, options.parserOpts);
          return options;
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/plugin-pass.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        class PluginPass {
          constructor(file, key, options) {
            this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = key, this.file = file, this.opts = options || {}, this.cwd = file.opts.cwd, this.filename = file.opts.filename;
          }
          set(key, val) {
            this._map.set(key, val);
          }
          get(key) {
            return this._map.get(key);
          }
          availableHelper(name, versionRange) {
            return this.file.availableHelper(name, versionRange);
          }
          addHelper(name) {
            return this.file.addHelper(name);
          }
          buildCodeFrameError(node, msg, _Error) {
            return this.file.buildCodeFrameError(node, msg, _Error);
          }
        }
        exports3.default = PluginPass, PluginPass.prototype.getModuleName = function() {
          return this.file.getModuleName();
        }, PluginPass.prototype.addImport = function() {
          this.file.addImport();
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/transformation/util/clone-deep.js": (__unused_webpack_module, exports3) => {
        "use strict";
        function deepClone(value2, cache) {
          if (null !== value2) {
            if (cache.has(value2))
              return cache.get(value2);
            let cloned;
            if (Array.isArray(value2)) {
              cloned = new Array(value2.length), cache.set(value2, cloned);
              for (let i = 0; i < value2.length; i++)
                cloned[i] = "object" != typeof value2[i] ? value2[i] : deepClone(value2[i], cache);
            } else {
              cloned = {}, cache.set(value2, cloned);
              const keys2 = Object.keys(value2);
              for (let i = 0; i < keys2.length; i++) {
                const key = keys2[i];
                cloned[key] = "object" != typeof value2[key] ? value2[key] : deepClone(value2[key], cache);
              }
            }
            return cloned;
          }
          return value2;
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(value2) {
          return "object" != typeof value2 ? value2 : deepClone(value2, /* @__PURE__ */ new Map());
        };
      }, "./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/vendor/import-meta-resolve.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _assert() {
          const data2 = __webpack_require__2("assert");
          return _assert = function() {
            return data2;
          }, data2;
        }
        function _fs() {
          const data2 = function(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule)
              return obj;
            if (null === obj || "object" != typeof obj && "function" != typeof obj)
              return { default: obj };
            var cache = _getRequireWildcardCache(nodeInterop);
            if (cache && cache.has(obj))
              return cache.get(obj);
            var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key in obj)
              if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
              }
            newObj.default = obj, cache && cache.set(obj, newObj);
            return newObj;
          }(__webpack_require__2("fs"), true);
          return _fs = function() {
            return data2;
          }, data2;
        }
        function _process() {
          const data2 = __webpack_require__2("process");
          return _process = function() {
            return data2;
          }, data2;
        }
        function _url() {
          const data2 = __webpack_require__2("url");
          return _url = function() {
            return data2;
          }, data2;
        }
        function _path() {
          const data2 = __webpack_require__2("path");
          return _path = function() {
            return data2;
          }, data2;
        }
        function _module() {
          const data2 = __webpack_require__2("module");
          return _module = function() {
            return data2;
          }, data2;
        }
        function _v() {
          const data2 = __webpack_require__2("v8");
          return _v = function() {
            return data2;
          }, data2;
        }
        function _util() {
          const data2 = __webpack_require__2("util");
          return _util = function() {
            return data2;
          }, data2;
        }
        function _getRequireWildcardCache(nodeInterop) {
          if ("function" != typeof WeakMap)
            return null;
          var cacheBabelInterop = /* @__PURE__ */ new WeakMap(), cacheNodeInterop = /* @__PURE__ */ new WeakMap();
          return (_getRequireWildcardCache = function(nodeInterop2) {
            return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
          })(nodeInterop);
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.moduleResolve = moduleResolve2, exports3.resolve = function(specifier, parent) {
          if (!parent)
            throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
          try {
            return function(specifier2, context = {}) {
              const { parentURL } = context;
              let parsedParentURL, parsed;
              if (_assert()(void 0 !== parentURL, "expected `parentURL` to be defined"), function(parentURL2) {
                if (void 0 === parentURL2)
                  return;
                if ("string" != typeof parentURL2 && (self2 = parentURL2, !Boolean(self2 && "object" == typeof self2 && "href" in self2 && "string" == typeof self2.href && "protocol" in self2 && "string" == typeof self2.protocol && self2.href && self2.protocol)))
                  throw new codes2.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], parentURL2);
                var self2;
              }(parentURL), parentURL)
                try {
                  parsedParentURL = new (_url()).URL(parentURL);
                } catch (_unused5) {
                }
              try {
                parsed = shouldBeTreatedAsRelativeOrAbsolutePath2(specifier2) ? new (_url()).URL(specifier2, parsedParentURL) : new (_url()).URL(specifier2);
                const protocol = parsed.protocol;
                if ("data:" === protocol || experimentalNetworkImports && ("https:" === protocol || "http:" === protocol))
                  return { url: parsed.href, format: null };
              } catch (_unused6) {
              }
              const maybeReturn = function(specifier3, parsed2, parsedParentURL2) {
                if (parsedParentURL2) {
                  const parentProtocol = parsedParentURL2.protocol;
                  if ("http:" === parentProtocol || "https:" === parentProtocol) {
                    if (shouldBeTreatedAsRelativeOrAbsolutePath2(specifier3)) {
                      const parsedProtocol = null == parsed2 ? void 0 : parsed2.protocol;
                      if (parsedProtocol && "https:" !== parsedProtocol && "http:" !== parsedProtocol)
                        throw new ERR_NETWORK_IMPORT_DISALLOWED2(specifier3, parsedParentURL2, "remote imports cannot import from a local location.");
                      return { url: (null == parsed2 ? void 0 : parsed2.href) || "" };
                    }
                    if (_module().builtinModules.includes(specifier3))
                      throw new ERR_NETWORK_IMPORT_DISALLOWED2(specifier3, parsedParentURL2, "remote imports cannot import from a local location.");
                    throw new ERR_NETWORK_IMPORT_DISALLOWED2(specifier3, parsedParentURL2, "only relative and absolute specifiers are supported.");
                  }
                }
              }(specifier2, parsed, parsedParentURL);
              if (maybeReturn)
                return maybeReturn;
              if (parsed && "node:" === parsed.protocol)
                return { url: specifier2 };
              !function(parsed2, experimentalNetworkImports2) {
                const protocol = null == parsed2 ? void 0 : parsed2.protocol;
                if (protocol && "file:" !== protocol && "data:" !== protocol && (!experimentalNetworkImports2 || "https:" !== protocol && "http:" !== protocol))
                  throw new ERR_UNSUPPORTED_ESM_URL_SCHEME2(parsed2, ["file", "data"].concat(experimentalNetworkImports2 ? ["https", "http"] : []));
              }(parsed, experimentalNetworkImports);
              const conditions = function(conditions2) {
                if (void 0 !== conditions2 && conditions2 !== DEFAULT_CONDITIONS) {
                  if (!Array.isArray(conditions2))
                    throw new ERR_INVALID_ARG_VALUE("conditions", conditions2, "expected an array");
                  return new Set(conditions2);
                }
                return DEFAULT_CONDITIONS_SET2;
              }(context.conditions), url = moduleResolve2(specifier2, new (_url()).URL(parentURL), conditions, false);
              return function(url2) {
                const protocol = url2.protocol;
                if ("file:" !== protocol && "data:" !== protocol && "node:" !== protocol)
                  throw new ERR_UNSUPPORTED_ESM_URL_SCHEME2(url2);
              }(url), { url: url.href, format: defaultGetFormatWithoutErrors2(url, { parentURL }) };
            }(specifier, { parentURL: parent }).url;
          } catch (error) {
            const exception = error;
            if ("ERR_UNSUPPORTED_DIR_IMPORT" === exception.code && "string" == typeof exception.url)
              return exception.url;
            throw error;
          }
        };
        const isWindows3 = "win32" === _process().platform, own$12 = {}.hasOwnProperty, classRegExp2 = /^([A-Z][a-z\d]*)+$/, kTypes2 = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), codes2 = {};
        function formatList2(array, type = "and") {
          return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
        }
        const messages2 = /* @__PURE__ */ new Map();
        let userStackTraceLimit2;
        function createError2(sym, value2, def) {
          return messages2.set(sym, value2), function(Base, key) {
            return NodeError;
            function NodeError(...args) {
              const limit = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable2() && (Error.stackTraceLimit = 0);
              const error = new Base();
              isErrorStackTraceLimitWritable2() && (Error.stackTraceLimit = limit);
              const message = function(key2, args2, self2) {
                const message2 = messages2.get(key2);
                if (_assert()(void 0 !== message2, "expected `message` to be found"), "function" == typeof message2)
                  return _assert()(message2.length <= args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${message2.length}).`), Reflect.apply(message2, self2, args2);
                const regex = /%[dfijoOs]/g;
                let expectedLength = 0;
                for (; null !== regex.exec(message2); )
                  expectedLength++;
                return _assert()(expectedLength === args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${expectedLength}).`), 0 === args2.length ? message2 : (args2.unshift(message2), Reflect.apply(_util().format, null, args2));
              }(key, args, error);
              return Object.defineProperties(error, { message: { value: message, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${key}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), captureLargerStackTrace2(error), error.code = key, error;
            }
          }(def, sym);
        }
        function isErrorStackTraceLimitWritable2() {
          try {
            if (_v().startupSnapshot.isBuildingSnapshot())
              return false;
          } catch (_unused) {
          }
          const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return void 0 === desc ? Object.isExtensible(Error) : own$12.call(desc, "writable") && void 0 !== desc.writable ? desc.writable : void 0 !== desc.set;
        }
        codes2.ERR_INVALID_ARG_TYPE = createError2("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
          _assert()("string" == typeof name, "'name' must be a string"), Array.isArray(expected) || (expected = [expected]);
          let message = "The ";
          if (name.endsWith(" argument"))
            message += `${name} `;
          else {
            const type = name.includes(".") ? "property" : "argument";
            message += `"${name}" ${type} `;
          }
          message += "must be ";
          const types2 = [], instances = [], other = [];
          for (const value2 of expected)
            _assert()("string" == typeof value2, "All expected entries have to be of type string"), kTypes2.has(value2) ? types2.push(value2.toLowerCase()) : null === classRegExp2.exec(value2) ? (_assert()("object" !== value2, 'The value "object" should be written as "Object"'), other.push(value2)) : instances.push(value2);
          if (instances.length > 0) {
            const pos = types2.indexOf("object");
            -1 !== pos && (types2.slice(pos, 1), instances.push("Object"));
          }
          return types2.length > 0 && (message += `${types2.length > 1 ? "one of type" : "of type"} ${formatList2(types2, "or")}`, (instances.length > 0 || other.length > 0) && (message += " or ")), instances.length > 0 && (message += `an instance of ${formatList2(instances, "or")}`, other.length > 0 && (message += " or ")), other.length > 0 && (other.length > 1 ? message += `one of ${formatList2(other, "or")}` : (other[0].toLowerCase() !== other[0] && (message += "an "), message += `${other[0]}`)), message += `. Received ${function(value2) {
            if (null == value2)
              return String(value2);
            if ("function" == typeof value2 && value2.name)
              return `function ${value2.name}`;
            if ("object" == typeof value2)
              return value2.constructor && value2.constructor.name ? `an instance of ${value2.constructor.name}` : `${(0, _util().inspect)(value2, { depth: -1 })}`;
            let inspected = (0, _util().inspect)(value2, { colors: false });
            inspected.length > 28 && (inspected = `${inspected.slice(0, 25)}...`);
            return `type ${typeof value2} (${inspected})`;
          }(actual)}`, message;
        }, TypeError), codes2.ERR_INVALID_MODULE_SPECIFIER = createError2("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base = void 0) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`, TypeError), codes2.ERR_INVALID_PACKAGE_CONFIG = createError2("ERR_INVALID_PACKAGE_CONFIG", (path3, base, message) => `Invalid package config ${path3}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`, Error), codes2.ERR_INVALID_PACKAGE_TARGET = createError2("ERR_INVALID_PACKAGE_TARGET", (pkgPath, key, target, isImport = false, base = void 0) => {
          const relError = "string" == typeof target && !isImport && target.length > 0 && !target.startsWith("./");
          return "." === key ? (_assert()(false === isImport), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }, Error), codes2.ERR_MODULE_NOT_FOUND = createError2("ERR_MODULE_NOT_FOUND", (path3, base, type = "package") => `Cannot find ${type} '${path3}' imported from ${base}`, Error), codes2.ERR_NETWORK_IMPORT_DISALLOWED = createError2("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), codes2.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError2("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`, TypeError), codes2.ERR_PACKAGE_PATH_NOT_EXPORTED = createError2("ERR_PACKAGE_PATH_NOT_EXPORTED", (pkgPath, subpath, base = void 0) => "." === subpath ? `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`, Error), codes2.ERR_UNSUPPORTED_DIR_IMPORT = createError2("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), codes2.ERR_UNKNOWN_FILE_EXTENSION = createError2("ERR_UNKNOWN_FILE_EXTENSION", (ext, path3) => `Unknown file extension "${ext}" for ${path3}`, TypeError), codes2.ERR_INVALID_ARG_VALUE = createError2("ERR_INVALID_ARG_VALUE", (name, value2, reason = "is invalid") => {
          let inspected = (0, _util().inspect)(value2);
          inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`);
          return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
        }, TypeError), codes2.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError2("ERR_UNSUPPORTED_ESM_URL_SCHEME", (url, supported) => {
          let message = `Only URLs with a scheme in: ${formatList2(supported)} are supported by the default ESM loader`;
          return isWindows3 && 2 === url.protocol.length && (message += ". On Windows, absolute paths must be valid file:// URLs"), message += `. Received protocol '${url.protocol}'`, message;
        }, Error);
        const captureLargerStackTrace2 = function(fn) {
          const hidden = "__node_internal_" + fn.name;
          return Object.defineProperty(fn, "name", { value: hidden }), fn;
        }(function(error) {
          const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable2();
          return stackTraceLimitIsWritable && (userStackTraceLimit2 = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit2), error;
        });
        var packageJsonReader2 = { read: function(jsonPath) {
          try {
            return { string: _fs().default.readFileSync(_path().toNamespacedPath(_path().join(_path().dirname(jsonPath), "package.json")), "utf8") };
          } catch (error) {
            const exception = error;
            if ("ENOENT" === exception.code)
              return { string: void 0 };
            throw exception;
          }
        } };
        const { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$12 } = codes2, packageJsonCache2 = /* @__PURE__ */ new Map();
        function getPackageConfig2(path3, specifier, base) {
          const existing = packageJsonCache2.get(path3);
          if (void 0 !== existing)
            return existing;
          const source = packageJsonReader2.read(path3).string;
          if (void 0 === source) {
            const packageConfig2 = { pjsonPath: path3, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
            return packageJsonCache2.set(path3, packageConfig2), packageConfig2;
          }
          let packageJson;
          try {
            packageJson = JSON.parse(source);
          } catch (error) {
            const exception = error;
            throw new ERR_INVALID_PACKAGE_CONFIG$12(path3, (base ? `"${specifier}" from ` : "") + (0, _url().fileURLToPath)(base || specifier), exception.message);
          }
          const { exports: exports4, imports, main, name, type } = packageJson, packageConfig = { pjsonPath: path3, exists: true, main: "string" == typeof main ? main : void 0, name: "string" == typeof name ? name : void 0, type: "module" === type || "commonjs" === type ? type : "none", exports: exports4, imports: imports && "object" == typeof imports ? imports : void 0 };
          return packageJsonCache2.set(path3, packageConfig), packageConfig;
        }
        function getPackageScopeConfig2(resolved) {
          let packageJsonUrl = new (_url()).URL("package.json", resolved);
          for (; ; ) {
            if (packageJsonUrl.pathname.endsWith("node_modules/package.json"))
              break;
            const packageConfig2 = getPackageConfig2((0, _url().fileURLToPath)(packageJsonUrl), resolved);
            if (packageConfig2.exists)
              return packageConfig2;
            const lastPackageJsonUrl = packageJsonUrl;
            if (packageJsonUrl = new (_url()).URL("../package.json", packageJsonUrl), packageJsonUrl.pathname === lastPackageJsonUrl.pathname)
              break;
          }
          const packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl), packageConfig = { pjsonPath: packageJsonPath, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          return packageJsonCache2.set(packageJsonPath, packageConfig), packageConfig;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: ERR_UNKNOWN_FILE_EXTENSION2 } = codes2, hasOwnProperty4 = {}.hasOwnProperty, extensionFormatMap2 = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" };
        const protocolHandlers2 = { __proto__: null, "data:": function(parsed) {
          const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
          return function(mime2) {
            return mime2 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime2) ? "module" : "application/json" === mime2 ? "json" : null;
          }(mime);
        }, "file:": function(url, _context, ignoreErrors) {
          const ext = function(url2) {
            const pathname = url2.pathname;
            let index2 = pathname.length;
            for (; index2--; ) {
              const code = pathname.codePointAt(index2);
              if (47 === code)
                return "";
              if (46 === code)
                return 47 === pathname.codePointAt(index2 - 1) ? "" : pathname.slice(index2);
            }
            return "";
          }(url);
          if (".js" === ext)
            return "module" === function(url2) {
              return getPackageScopeConfig2(url2).type;
            }(url) ? "module" : "commonjs";
          const format2 = extensionFormatMap2[ext];
          if (format2)
            return format2;
          if (ignoreErrors)
            return;
          const filepath = (0, _url().fileURLToPath)(url);
          throw new ERR_UNKNOWN_FILE_EXTENSION2(ext, filepath);
        }, "http:": getHttpProtocolModuleFormat2, "https:": getHttpProtocolModuleFormat2, "node:": () => "builtin" };
        function getHttpProtocolModuleFormat2() {
        }
        function defaultGetFormatWithoutErrors2(url, context) {
          return hasOwnProperty4.call(protocolHandlers2, url.protocol) && protocolHandlers2[url.protocol](url, context, true) || null;
        }
        const { ERR_INVALID_ARG_VALUE } = codes2, DEFAULT_CONDITIONS = Object.freeze(["node", "import"]), DEFAULT_CONDITIONS_SET2 = new Set(DEFAULT_CONDITIONS);
        const RegExpPrototypeSymbolReplace2 = RegExp.prototype[Symbol.replace], experimentalNetworkImports = false, { ERR_NETWORK_IMPORT_DISALLOWED: ERR_NETWORK_IMPORT_DISALLOWED2, ERR_INVALID_MODULE_SPECIFIER: ERR_INVALID_MODULE_SPECIFIER2, ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2, ERR_INVALID_PACKAGE_TARGET: ERR_INVALID_PACKAGE_TARGET2, ERR_MODULE_NOT_FOUND: ERR_MODULE_NOT_FOUND2, ERR_PACKAGE_IMPORT_NOT_DEFINED: ERR_PACKAGE_IMPORT_NOT_DEFINED2, ERR_PACKAGE_PATH_NOT_EXPORTED: ERR_PACKAGE_PATH_NOT_EXPORTED2, ERR_UNSUPPORTED_DIR_IMPORT: ERR_UNSUPPORTED_DIR_IMPORT2, ERR_UNSUPPORTED_ESM_URL_SCHEME: ERR_UNSUPPORTED_ESM_URL_SCHEME2 } = codes2, own2 = {}.hasOwnProperty, invalidSegmentRegEx2 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, deprecatedInvalidSegmentRegEx2 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, invalidPackageNameRegEx2 = /^\.|%|\\/, patternRegEx2 = /\*/g, encodedSepRegEx2 = /%2f|%5c/i, emittedPackageWarnings2 = /* @__PURE__ */ new Set(), doubleSlashRegEx2 = /[/\\]{2}/;
        function emitInvalidSegmentDeprecation2(target, request, match, packageJsonUrl, internal2, base, isTarget) {
          const pjsonPath = (0, _url().fileURLToPath)(packageJsonUrl), double = null !== doubleSlashRegEx2.exec(isTarget ? target : request);
          _process().emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal2 ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function emitLegacyIndexDeprecation2(url, packageJsonUrl, base, main) {
          if ("module" !== defaultGetFormatWithoutErrors2(url, { parentURL: base.href }))
            return;
          const path3 = (0, _url().fileURLToPath)(url.href), pkgPath = (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), basePath = (0, _url().fileURLToPath)(base);
          main ? _process().emitWarning(`Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path3.slice(pkgPath.length)}", imported from ${basePath}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`, "DeprecationWarning", "DEP0151") : _process().emitWarning(`No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path3.slice(pkgPath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function tryStatSync2(path3) {
          try {
            return (0, _fs().statSync)(path3);
          } catch (_unused2) {
            return new (_fs()).Stats();
          }
        }
        function fileExists2(url) {
          const stats = (0, _fs().statSync)(url, { throwIfNoEntry: false }), isFile = stats ? stats.isFile() : void 0;
          return null != isFile && isFile;
        }
        function legacyMainResolve2(packageJsonUrl, packageConfig, base) {
          let guess;
          if (void 0 !== packageConfig.main) {
            if (guess = new (_url()).URL(packageConfig.main, packageJsonUrl), fileExists2(guess))
              return guess;
            const tries2 = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
            let i2 = -1;
            for (; ++i2 < tries2.length && (guess = new (_url()).URL(tries2[i2], packageJsonUrl), !fileExists2(guess)); )
              guess = void 0;
            if (guess)
              return emitLegacyIndexDeprecation2(guess, packageJsonUrl, base, packageConfig.main), guess;
          }
          const tries = ["./index.js", "./index.json", "./index.node"];
          let i = -1;
          for (; ++i < tries.length && (guess = new (_url()).URL(tries[i], packageJsonUrl), !fileExists2(guess)); )
            guess = void 0;
          if (guess)
            return emitLegacyIndexDeprecation2(guess, packageJsonUrl, base, packageConfig.main), guess;
          throw new ERR_MODULE_NOT_FOUND2((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
        }
        function exportsNotFound2(subpath, packageJsonUrl, base) {
          return new ERR_PACKAGE_PATH_NOT_EXPORTED2((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));
        }
        function invalidPackageTarget2(subpath, target, packageJsonUrl, internal2, base) {
          return target = "object" == typeof target && null !== target ? JSON.stringify(target, null, "") : `${target}`, new ERR_INVALID_PACKAGE_TARGET2((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, target, internal2, base && (0, _url().fileURLToPath)(base));
        }
        function resolvePackageTargetString2(target, subpath, match, packageJsonUrl, base, pattern, internal2, isPathMap, conditions) {
          if ("" !== subpath && !pattern && "/" !== target[target.length - 1])
            throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
          if (!target.startsWith("./")) {
            if (internal2 && !target.startsWith("../") && !target.startsWith("/")) {
              let isURL = false;
              try {
                new (_url()).URL(target), isURL = true;
              } catch (_unused3) {
              }
              if (!isURL) {
                return packageResolve2(pattern ? RegExpPrototypeSymbolReplace2.call(patternRegEx2, target, () => subpath) : target + subpath, packageJsonUrl, conditions);
              }
            }
            throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
          }
          if (null !== invalidSegmentRegEx2.exec(target.slice(2))) {
            if (null !== deprecatedInvalidSegmentRegEx2.exec(target.slice(2)))
              throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
            if (!isPathMap) {
              const request = pattern ? match.replace("*", () => subpath) : match + subpath;
              emitInvalidSegmentDeprecation2(pattern ? RegExpPrototypeSymbolReplace2.call(patternRegEx2, target, () => subpath) : target, request, match, packageJsonUrl, internal2, base, true);
            }
          }
          const resolved = new (_url()).URL(target, packageJsonUrl), resolvedPath = resolved.pathname, packagePath = new (_url()).URL(".", packageJsonUrl).pathname;
          if (!resolvedPath.startsWith(packagePath))
            throw invalidPackageTarget2(match, target, packageJsonUrl, internal2, base);
          if ("" === subpath)
            return resolved;
          if (null !== invalidSegmentRegEx2.exec(subpath)) {
            const request = pattern ? match.replace("*", () => subpath) : match + subpath;
            if (null === deprecatedInvalidSegmentRegEx2.exec(subpath)) {
              if (!isPathMap) {
                emitInvalidSegmentDeprecation2(pattern ? RegExpPrototypeSymbolReplace2.call(patternRegEx2, target, () => subpath) : target, request, match, packageJsonUrl, internal2, base, false);
              }
            } else
              !function(request2, match2, packageJsonUrl2, internal3, base2) {
                const reason = `request is not a valid match in pattern "${match2}" for the "${internal3 ? "imports" : "exports"}" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl2)}`;
                throw new ERR_INVALID_MODULE_SPECIFIER2(request2, reason, base2 && (0, _url().fileURLToPath)(base2));
              }(request, match, packageJsonUrl, internal2, base);
          }
          return pattern ? new (_url()).URL(RegExpPrototypeSymbolReplace2.call(patternRegEx2, resolved.href, () => subpath)) : new (_url()).URL(subpath, resolved);
        }
        function isArrayIndex2(key) {
          const keyNumber = Number(key);
          return `${keyNumber}` === key && (keyNumber >= 0 && keyNumber < 4294967295);
        }
        function resolvePackageTarget2(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal2, isPathMap, conditions) {
          if ("string" == typeof target)
            return resolvePackageTargetString2(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal2, isPathMap, conditions);
          if (Array.isArray(target)) {
            const targetList = target;
            if (0 === targetList.length)
              return null;
            let lastException, i = -1;
            for (; ++i < targetList.length; ) {
              const targetItem = targetList[i];
              let resolveResult;
              try {
                resolveResult = resolvePackageTarget2(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal2, isPathMap, conditions);
              } catch (error) {
                if (lastException = error, "ERR_INVALID_PACKAGE_TARGET" === error.code)
                  continue;
                throw error;
              }
              if (void 0 !== resolveResult) {
                if (null !== resolveResult)
                  return resolveResult;
                lastException = null;
              }
            }
            if (null == lastException)
              return null;
            throw lastException;
          }
          if ("object" == typeof target && null !== target) {
            const keys2 = Object.getOwnPropertyNames(target);
            let i = -1;
            for (; ++i < keys2.length; ) {
              if (isArrayIndex2(keys2[i]))
                throw new ERR_INVALID_PACKAGE_CONFIG2((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
            }
            for (i = -1; ++i < keys2.length; ) {
              const key = keys2[i];
              if ("default" === key || conditions && conditions.has(key)) {
                const resolveResult = resolvePackageTarget2(packageJsonUrl, target[key], subpath, packageSubpath, base, pattern, internal2, isPathMap, conditions);
                if (void 0 === resolveResult)
                  continue;
                return resolveResult;
              }
            }
            return null;
          }
          if (null === target)
            return null;
          throw invalidPackageTarget2(packageSubpath, target, packageJsonUrl, internal2, base);
        }
        function emitTrailingSlashPatternDeprecation2(match, pjsonUrl, base) {
          const pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
          emittedPackageWarnings2.has(pjsonPath + "|" + match) || (emittedPackageWarnings2.add(pjsonPath + "|" + match), _process().emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function packageExportsResolve2(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
          let exports4 = packageConfig.exports;
          if (function(exports5, packageJsonUrl2, base2) {
            if ("string" == typeof exports5 || Array.isArray(exports5))
              return true;
            if ("object" != typeof exports5 || null === exports5)
              return false;
            const keys3 = Object.getOwnPropertyNames(exports5);
            let isConditionalSugar = false, i2 = 0, j = -1;
            for (; ++j < keys3.length; ) {
              const key = keys3[j], curIsConditionalSugar = "" === key || "." !== key[0];
              if (0 == i2++)
                isConditionalSugar = curIsConditionalSugar;
              else if (isConditionalSugar !== curIsConditionalSugar)
                throw new ERR_INVALID_PACKAGE_CONFIG2((0, _url().fileURLToPath)(packageJsonUrl2), base2, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return isConditionalSugar;
          }(exports4, packageJsonUrl, base) && (exports4 = { ".": exports4 }), own2.call(exports4, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
            const resolveResult = resolvePackageTarget2(packageJsonUrl, exports4[packageSubpath], "", packageSubpath, base, false, false, false, conditions);
            if (null == resolveResult)
              throw exportsNotFound2(packageSubpath, packageJsonUrl, base);
            return resolveResult;
          }
          let bestMatch = "", bestMatchSubpath = "";
          const keys2 = Object.getOwnPropertyNames(exports4);
          let i = -1;
          for (; ++i < keys2.length; ) {
            const key = keys2[i], patternIndex = key.indexOf("*");
            if (-1 !== patternIndex && packageSubpath.startsWith(key.slice(0, patternIndex))) {
              packageSubpath.endsWith("/") && emitTrailingSlashPatternDeprecation2(packageSubpath, packageJsonUrl, base);
              const patternTrailer = key.slice(patternIndex + 1);
              packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && 1 === patternKeyCompare2(bestMatch, key) && key.lastIndexOf("*") === patternIndex && (bestMatch = key, bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length));
            }
          }
          if (bestMatch) {
            const resolveResult = resolvePackageTarget2(packageJsonUrl, exports4[bestMatch], bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
            if (null == resolveResult)
              throw exportsNotFound2(packageSubpath, packageJsonUrl, base);
            return resolveResult;
          }
          throw exportsNotFound2(packageSubpath, packageJsonUrl, base);
        }
        function patternKeyCompare2(a, b) {
          const aPatternIndex = a.indexOf("*"), bPatternIndex = b.indexOf("*"), baseLengthA = -1 === aPatternIndex ? a.length : aPatternIndex + 1, baseLengthB = -1 === bPatternIndex ? b.length : bPatternIndex + 1;
          return baseLengthA > baseLengthB ? -1 : baseLengthB > baseLengthA || -1 === aPatternIndex ? 1 : -1 === bPatternIndex || a.length > b.length ? -1 : b.length > a.length ? 1 : 0;
        }
        function packageImportsResolve2(name, base, conditions) {
          if ("#" === name || name.startsWith("#/") || name.endsWith("/")) {
            throw new ERR_INVALID_MODULE_SPECIFIER2(name, "is not a valid internal imports specifier name", (0, _url().fileURLToPath)(base));
          }
          let packageJsonUrl;
          const packageConfig = getPackageScopeConfig2(base);
          if (packageConfig.exists) {
            packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
            const imports = packageConfig.imports;
            if (imports)
              if (own2.call(imports, name) && !name.includes("*")) {
                const resolveResult = resolvePackageTarget2(packageJsonUrl, imports[name], "", name, base, false, true, false, conditions);
                if (null != resolveResult)
                  return resolveResult;
              } else {
                let bestMatch = "", bestMatchSubpath = "";
                const keys2 = Object.getOwnPropertyNames(imports);
                let i = -1;
                for (; ++i < keys2.length; ) {
                  const key = keys2[i], patternIndex = key.indexOf("*");
                  if (-1 !== patternIndex && name.startsWith(key.slice(0, -1))) {
                    const patternTrailer = key.slice(patternIndex + 1);
                    name.length >= key.length && name.endsWith(patternTrailer) && 1 === patternKeyCompare2(bestMatch, key) && key.lastIndexOf("*") === patternIndex && (bestMatch = key, bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length));
                  }
                }
                if (bestMatch) {
                  const resolveResult = resolvePackageTarget2(packageJsonUrl, imports[bestMatch], bestMatchSubpath, bestMatch, base, true, true, false, conditions);
                  if (null != resolveResult)
                    return resolveResult;
                }
              }
          }
          throw function(specifier, packageJsonUrl2, base2) {
            return new ERR_PACKAGE_IMPORT_NOT_DEFINED2(specifier, packageJsonUrl2 && (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl2)), (0, _url().fileURLToPath)(base2));
          }(name, packageJsonUrl, base);
        }
        function packageResolve2(specifier, base, conditions) {
          if (_module().builtinModules.includes(specifier))
            return new (_url()).URL("node:" + specifier);
          const { packageName, packageSubpath, isScoped } = function(specifier2, base2) {
            let separatorIndex = specifier2.indexOf("/"), validPackageName = true, isScoped2 = false;
            "@" === specifier2[0] && (isScoped2 = true, -1 === separatorIndex || 0 === specifier2.length ? validPackageName = false : separatorIndex = specifier2.indexOf("/", separatorIndex + 1));
            const packageName2 = -1 === separatorIndex ? specifier2 : specifier2.slice(0, separatorIndex);
            if (null !== invalidPackageNameRegEx2.exec(packageName2) && (validPackageName = false), !validPackageName)
              throw new ERR_INVALID_MODULE_SPECIFIER2(specifier2, "is not a valid package name", (0, _url().fileURLToPath)(base2));
            return { packageName: packageName2, packageSubpath: "." + (-1 === separatorIndex ? "" : specifier2.slice(separatorIndex)), isScoped: isScoped2 };
          }(specifier, base), packageConfig = getPackageScopeConfig2(base);
          if (packageConfig.exists) {
            const packageJsonUrl2 = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
            if (packageConfig.name === packageName && void 0 !== packageConfig.exports && null !== packageConfig.exports)
              return packageExportsResolve2(packageJsonUrl2, packageSubpath, packageConfig, base, conditions);
          }
          let lastPath, packageJsonUrl = new (_url()).URL("./node_modules/" + packageName + "/package.json", base), packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
          do {
            if (!tryStatSync2(packageJsonPath.slice(0, -13)).isDirectory()) {
              lastPath = packageJsonPath, packageJsonUrl = new (_url()).URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl), packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
              continue;
            }
            const packageConfig2 = getPackageConfig2(packageJsonPath, specifier, base);
            return void 0 !== packageConfig2.exports && null !== packageConfig2.exports ? packageExportsResolve2(packageJsonUrl, packageSubpath, packageConfig2, base, conditions) : "." === packageSubpath ? legacyMainResolve2(packageJsonUrl, packageConfig2, base) : new (_url()).URL(packageSubpath, packageJsonUrl);
          } while (packageJsonPath.length !== lastPath.length);
          throw new ERR_MODULE_NOT_FOUND2(packageName, (0, _url().fileURLToPath)(base));
        }
        function shouldBeTreatedAsRelativeOrAbsolutePath2(specifier) {
          return "" !== specifier && ("/" === specifier[0] || function(specifier2) {
            if ("." === specifier2[0]) {
              if (1 === specifier2.length || "/" === specifier2[1])
                return true;
              if ("." === specifier2[1] && (2 === specifier2.length || "/" === specifier2[2]))
                return true;
            }
            return false;
          }(specifier));
        }
        function moduleResolve2(specifier, base, conditions, preserveSymlinks) {
          const protocol = base.protocol, isRemote = "http:" === protocol || "https:" === protocol;
          let resolved;
          if (shouldBeTreatedAsRelativeOrAbsolutePath2(specifier))
            resolved = new (_url()).URL(specifier, base);
          else if (isRemote || "#" !== specifier[0])
            try {
              resolved = new (_url()).URL(specifier);
            } catch (_unused4) {
              isRemote || (resolved = packageResolve2(specifier, base, conditions));
            }
          else
            resolved = packageImportsResolve2(specifier, base, conditions);
          return _assert()(void 0 !== resolved, "expected to be defined"), "file:" !== resolved.protocol ? resolved : function(resolved2, base2, preserveSymlinks2) {
            if (null !== encodedSepRegEx2.exec(resolved2.pathname))
              throw new ERR_INVALID_MODULE_SPECIFIER2(resolved2.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(base2));
            const filePath = (0, _url().fileURLToPath)(resolved2), stats = tryStatSync2(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
            if (stats.isDirectory()) {
              const error = new ERR_UNSUPPORTED_DIR_IMPORT2(filePath, (0, _url().fileURLToPath)(base2));
              throw error.url = String(resolved2), error;
            }
            if (!stats.isFile())
              throw new ERR_MODULE_NOT_FOUND2(filePath || resolved2.pathname, base2 && (0, _url().fileURLToPath)(base2), "module");
            if (!preserveSymlinks2) {
              const real = (0, _fs().realpathSync)(filePath), { search, hash: hash2 } = resolved2;
              (resolved2 = (0, _url().pathToFileURL)(real + (filePath.endsWith(_path().sep) ? "/" : ""))).search = search, resolved2.hash = hash2;
            }
            return resolved2;
          }(resolved, base, preserveSymlinks);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/buffer.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        exports3.default = class {
          constructor(map) {
            this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = true, this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = map, this._allocQueue();
          }
          _allocQueue() {
            const queue2 = this._queue;
            for (let i = 0; i < 16; i++)
              queue2.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
          }
          _pushQueue(char, repeat, line, column, filename) {
            const cursor = this._queueCursor;
            cursor === this._queue.length && this._allocQueue();
            const item = this._queue[cursor];
            item.char = char, item.repeat = repeat, item.line = line, item.column = column, item.filename = filename, this._queueCursor++;
          }
          _popQueue() {
            if (0 === this._queueCursor)
              throw new Error("Cannot pop from empty queue");
            return this._queue[--this._queueCursor];
          }
          get() {
            this._flush();
            const map = this._map, result = { code: (this._buf + this._str).trimRight(), decodedMap: null == map ? void 0 : map.getDecoded(), get __mergedMap() {
              return this.map;
            }, get map() {
              const resultMap = map ? map.get() : null;
              return result.map = resultMap, resultMap;
            }, set map(value2) {
              Object.defineProperty(result, "map", { value: value2, writable: true });
            }, get rawMappings() {
              const mappings = null == map ? void 0 : map.getRawMappings();
              return result.rawMappings = mappings, mappings;
            }, set rawMappings(value2) {
              Object.defineProperty(result, "rawMappings", { value: value2, writable: true });
            } };
            return result;
          }
          append(str, maybeNewline) {
            this._flush(), this._append(str, this._sourcePosition, maybeNewline);
          }
          appendChar(char) {
            this._flush(), this._appendChar(char, 1, this._sourcePosition);
          }
          queue(char) {
            if (10 === char)
              for (; 0 !== this._queueCursor; ) {
                const char2 = this._queue[this._queueCursor - 1].char;
                if (32 !== char2 && 9 !== char2)
                  break;
                this._queueCursor--;
              }
            const sourcePosition = this._sourcePosition;
            this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
          }
          queueIndentation(char, repeat) {
            this._pushQueue(char, repeat, void 0, void 0, void 0);
          }
          _flush() {
            const queueCursor = this._queueCursor, queue2 = this._queue;
            for (let i = 0; i < queueCursor; i++) {
              const item = queue2[i];
              this._appendChar(item.char, item.repeat, item);
            }
            this._queueCursor = 0;
          }
          _appendChar(char, repeat, sourcePos) {
            this._last = char, this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char), 10 !== char ? (this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename), this._position.column += repeat) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (sourcePos.identifierName = void 0, sourcePos.identifierNamePos = void 0);
          }
          _append(str, sourcePos, maybeNewline) {
            const len = str.length, position = this._position;
            if (this._last = str.charCodeAt(len - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = str, this._appendCount = 0) : this._str += str, !maybeNewline && !this._map)
              return void (position.column += len);
            const { column, identifierName, identifierNamePos, filename } = sourcePos;
            let line = sourcePos.line;
            null == identifierName && null == identifierNamePos || !this._canMarkIdName || (sourcePos.identifierName = void 0, sourcePos.identifierNamePos = void 0);
            let i = str.indexOf("\n"), last = 0;
            for (0 !== i && this._mark(line, column, identifierName, identifierNamePos, filename); -1 !== i; )
              position.line++, position.column = 0, last = i + 1, last < len && void 0 !== line && this._mark(++line, 0, null, null, filename), i = str.indexOf("\n", last);
            position.column += len - last;
          }
          _mark(line, column, identifierName, identifierNamePos, filename) {
            var _this$_map;
            null == (_this$_map = this._map) || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
          }
          removeTrailingNewline() {
            const queueCursor = this._queueCursor;
            0 !== queueCursor && 10 === this._queue[queueCursor - 1].char && this._queueCursor--;
          }
          removeLastSemicolon() {
            const queueCursor = this._queueCursor;
            0 !== queueCursor && 59 === this._queue[queueCursor - 1].char && this._queueCursor--;
          }
          getLastChar() {
            const queueCursor = this._queueCursor;
            return 0 !== queueCursor ? this._queue[queueCursor - 1].char : this._last;
          }
          getNewlineCount() {
            const queueCursor = this._queueCursor;
            let count = 0;
            if (0 === queueCursor)
              return 10 === this._last ? 1 : 0;
            for (let i = queueCursor - 1; i >= 0 && 10 === this._queue[i].char; i--)
              count++;
            return count === queueCursor && 10 === this._last ? count + 1 : count;
          }
          endsWithCharAndNewline() {
            const queue2 = this._queue, queueCursor = this._queueCursor;
            if (0 !== queueCursor) {
              if (10 !== queue2[queueCursor - 1].char)
                return;
              return queueCursor > 1 ? queue2[queueCursor - 2].char : this._last;
            }
          }
          hasContent() {
            return 0 !== this._queueCursor || !!this._last;
          }
          exactSource(loc, cb) {
            if (!this._map)
              return void cb();
            this.source("start", loc);
            const identifierName = loc.identifierName, sourcePos = this._sourcePosition;
            identifierName && (this._canMarkIdName = false, sourcePos.identifierName = identifierName), cb(), identifierName && (this._canMarkIdName = true, sourcePos.identifierName = void 0, sourcePos.identifierNamePos = void 0), this.source("end", loc);
          }
          source(prop, loc) {
            this._map && this._normalizePosition(prop, loc, 0, 0);
          }
          sourceWithOffset(prop, loc, lineOffset, columnOffset) {
            this._map && this._normalizePosition(prop, loc, lineOffset, columnOffset);
          }
          withSource(prop, loc, cb) {
            this._map && this.source(prop, loc), cb();
          }
          _normalizePosition(prop, loc, lineOffset, columnOffset) {
            const pos = loc[prop], target = this._sourcePosition;
            pos && (target.line = pos.line + lineOffset, target.column = pos.column + columnOffset, target.filename = loc.filename);
          }
          getCurrentColumn() {
            const queue2 = this._queue, queueCursor = this._queueCursor;
            let lastIndex = -1, len = 0;
            for (let i = 0; i < queueCursor; i++) {
              const item = queue2[i];
              10 === item.char && (lastIndex = len), len += item.repeat;
            }
            return -1 === lastIndex ? this._position.column + len : len - 1 - lastIndex;
          }
          getCurrentLine() {
            let count = 0;
            const queue2 = this._queue;
            for (let i = 0; i < this._queueCursor; i++)
              10 === queue2[i].char && count++;
            return this._position.line + count;
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/base.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.BlockStatement = function(node) {
          var _node$directives2;
          this.tokenChar(123);
          const directivesLen = null == (_node$directives2 = node.directives) ? void 0 : _node$directives2.length;
          if (directivesLen) {
            var _node$directives$trai2;
            const newline = node.body.length ? 2 : 1;
            this.printSequence(node.directives, node, { indent: true, trailingCommentsLineOffset: newline }), null != (_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) && _node$directives$trai2.length || this.newline(newline);
          }
          this.printSequence(node.body, node, { indent: true }), this.rightBrace(node);
        }, exports3.Directive = function(node) {
          this.print(node.value, node), this.semicolon();
        }, exports3.DirectiveLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && void 0 !== raw)
            return void this.token(raw);
          const { value: value2 } = node;
          if (unescapedDoubleQuoteRE.test(value2)) {
            if (unescapedSingleQuoteRE.test(value2))
              throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
            this.token(`'${value2}'`);
          } else
            this.token(`"${value2}"`);
        }, exports3.File = function(node) {
          node.program && this.print(node.program.interpreter, node);
          this.print(node.program, node);
        }, exports3.InterpreterDirective = function(node) {
          this.token(`#!${node.value}`), this.newline(1, true);
        }, exports3.Placeholder = function(node) {
          this.token("%%"), this.print(node.name), this.token("%%"), "Statement" === node.expectedNode && this.semicolon();
        }, exports3.Program = function(node) {
          var _node$directives;
          this.noIndentInnerCommentsHere(), this.printInnerComments();
          const directivesLen = null == (_node$directives = node.directives) ? void 0 : _node$directives.length;
          if (directivesLen) {
            var _node$directives$trai;
            const newline = node.body.length ? 2 : 1;
            this.printSequence(node.directives, node, { trailingCommentsLineOffset: newline }), null != (_node$directives$trai = node.directives[directivesLen - 1].trailingComments) && _node$directives$trai.length || this.newline(newline);
          }
          this.printSequence(node.body, node);
        };
        const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/, unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/classes.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ClassAccessorProperty = function(node) {
          var _node$key$loc2, _node$key$loc2$end;
          this.printJoin(node.decorators, node);
          const endLine = null == (_node$key$loc2 = node.key.loc) || null == (_node$key$loc2$end = _node$key$loc2.end) ? void 0 : _node$key$loc2$end.line;
          endLine && this.catchUp(endLine);
          this.tsPrintClassMemberModifiers(node), this.word("accessor", true), this.space(), node.computed ? (this.tokenChar(91), this.print(node.key, node), this.tokenChar(93)) : (this._variance(node), this.print(node.key, node));
          node.optional && this.tokenChar(63);
          node.definite && this.tokenChar(33);
          this.print(node.typeAnnotation, node), node.value && (this.space(), this.tokenChar(61), this.space(), this.print(node.value, node));
          this.semicolon();
        }, exports3.ClassBody = function(node) {
          this.tokenChar(123), 0 === node.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(node.body, node, { indent: true }), this.endsWith(10) || this.newline(), this.rightBrace(node));
        }, exports3.ClassExpression = exports3.ClassDeclaration = function(node, parent) {
          (isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent)) && this._shouldPrintDecoratorsBeforeExport(parent) || this.printJoin(node.decorators, node);
          node.declare && (this.word("declare"), this.space());
          node.abstract && (this.word("abstract"), this.space());
          this.word("class"), node.id && (this.space(), this.print(node.id, node));
          this.print(node.typeParameters, node), node.superClass && (this.space(), this.word("extends"), this.space(), this.print(node.superClass, node), this.print(node.superTypeParameters, node));
          node.implements && (this.space(), this.word("implements"), this.space(), this.printList(node.implements, node));
          this.space(), this.print(node.body, node);
        }, exports3.ClassMethod = function(node) {
          this._classMethodHead(node), this.space(), this.print(node.body, node);
        }, exports3.ClassPrivateMethod = function(node) {
          this._classMethodHead(node), this.space(), this.print(node.body, node);
        }, exports3.ClassPrivateProperty = function(node) {
          this.printJoin(node.decorators, node), node.static && (this.word("static"), this.space());
          this.print(node.key, node), this.print(node.typeAnnotation, node), node.value && (this.space(), this.tokenChar(61), this.space(), this.print(node.value, node));
          this.semicolon();
        }, exports3.ClassProperty = function(node) {
          var _node$key$loc, _node$key$loc$end;
          this.printJoin(node.decorators, node);
          const endLine = null == (_node$key$loc = node.key.loc) || null == (_node$key$loc$end = _node$key$loc.end) ? void 0 : _node$key$loc$end.line;
          endLine && this.catchUp(endLine);
          this.tsPrintClassMemberModifiers(node), node.computed ? (this.tokenChar(91), this.print(node.key, node), this.tokenChar(93)) : (this._variance(node), this.print(node.key, node));
          node.optional && this.tokenChar(63);
          node.definite && this.tokenChar(33);
          this.print(node.typeAnnotation, node), node.value && (this.space(), this.tokenChar(61), this.space(), this.print(node.value, node));
          this.semicolon();
        }, exports3.StaticBlock = function(node) {
          this.word("static"), this.space(), this.tokenChar(123), 0 === node.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(node.body, node, { indent: true }), this.rightBrace(node));
        }, exports3._classMethodHead = function(node) {
          var _node$key$loc3, _node$key$loc3$end;
          this.printJoin(node.decorators, node);
          const endLine = null == (_node$key$loc3 = node.key.loc) || null == (_node$key$loc3$end = _node$key$loc3.end) ? void 0 : _node$key$loc3$end.line;
          endLine && this.catchUp(endLine);
          this.tsPrintClassMemberModifiers(node), this._methodHead(node);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { isExportDefaultDeclaration, isExportNamedDeclaration } = _t;
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/expressions.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.LogicalExpression = exports3.BinaryExpression = exports3.AssignmentExpression = function(node, parent) {
          const parens = this.inForStatementInitCounter && "in" === node.operator && !n.needsParens(node, parent);
          parens && this.tokenChar(40);
          this.print(node.left, node), this.space(), "in" === node.operator || "instanceof" === node.operator ? this.word(node.operator) : this.token(node.operator);
          this.space(), this.print(node.right, node), parens && this.tokenChar(41);
        }, exports3.AssignmentPattern = function(node) {
          this.print(node.left, node), node.left.optional && this.tokenChar(63);
          this.print(node.left.typeAnnotation, node), this.space(), this.tokenChar(61), this.space(), this.print(node.right, node);
        }, exports3.AwaitExpression = function(node) {
          this.word("await"), node.argument && (this.space(), this.printTerminatorless(node.argument, node, false));
        }, exports3.BindExpression = function(node) {
          this.print(node.object, node), this.token("::"), this.print(node.callee, node);
        }, exports3.CallExpression = function(node) {
          this.print(node.callee, node), this.print(node.typeArguments, node), this.print(node.typeParameters, node), this.tokenChar(40), this.printList(node.arguments, node), this.rightParens(node);
        }, exports3.ConditionalExpression = function(node) {
          this.print(node.test, node), this.space(), this.tokenChar(63), this.space(), this.print(node.consequent, node), this.space(), this.tokenChar(58), this.space(), this.print(node.alternate, node);
        }, exports3.Decorator = function(node) {
          this.tokenChar(64);
          const { expression } = node;
          !function(node2) {
            if ("ParenthesizedExpression" === node2.type)
              return false;
            return !isDecoratorMemberExpression("CallExpression" === node2.type ? node2.callee : node2);
          }(expression) ? this.print(expression, node) : (this.tokenChar(40), this.print(expression, node), this.tokenChar(41));
          this.newline();
        }, exports3.DoExpression = function(node) {
          node.async && (this.word("async", true), this.space());
          this.word("do"), this.space(), this.print(node.body, node);
        }, exports3.EmptyStatement = function() {
          this.semicolon(true);
        }, exports3.ExpressionStatement = function(node) {
          this.print(node.expression, node), this.semicolon();
        }, exports3.Import = function() {
          this.word("import");
        }, exports3.MemberExpression = function(node) {
          if (this.print(node.object, node), !node.computed && isMemberExpression(node.property))
            throw new TypeError("Got a MemberExpression for MemberExpression property");
          let computed = node.computed;
          isLiteral(node.property) && "number" == typeof node.property.value && (computed = true);
          computed ? (this.tokenChar(91), this.print(node.property, node), this.tokenChar(93)) : (this.tokenChar(46), this.print(node.property, node));
        }, exports3.MetaProperty = function(node) {
          this.print(node.meta, node), this.tokenChar(46), this.print(node.property, node);
        }, exports3.ModuleExpression = function(node) {
          this.word("module", true), this.space(), this.tokenChar(123), this.indent();
          const { body } = node;
          (body.body.length || body.directives.length) && this.newline();
          this.print(body, node), this.dedent(), this.rightBrace(node);
        }, exports3.NewExpression = function(node, parent) {
          if (this.word("new"), this.space(), this.print(node.callee, node), this.format.minified && 0 === node.arguments.length && !node.optional && !isCallExpression(parent, { callee: node }) && !isMemberExpression(parent) && !isNewExpression(parent))
            return;
          this.print(node.typeArguments, node), this.print(node.typeParameters, node), node.optional && this.token("?.");
          this.tokenChar(40), this.printList(node.arguments, node), this.rightParens(node);
        }, exports3.OptionalCallExpression = function(node) {
          this.print(node.callee, node), this.print(node.typeParameters, node), node.optional && this.token("?.");
          this.print(node.typeArguments, node), this.tokenChar(40), this.printList(node.arguments, node), this.rightParens(node);
        }, exports3.OptionalMemberExpression = function(node) {
          let { computed } = node;
          const { optional, property } = node;
          if (this.print(node.object, node), !computed && isMemberExpression(property))
            throw new TypeError("Got a MemberExpression for MemberExpression property");
          isLiteral(property) && "number" == typeof property.value && (computed = true);
          optional && this.token("?.");
          computed ? (this.tokenChar(91), this.print(property, node), this.tokenChar(93)) : (optional || this.tokenChar(46), this.print(property, node));
        }, exports3.ParenthesizedExpression = function(node) {
          this.tokenChar(40), this.print(node.expression, node), this.rightParens(node);
        }, exports3.PrivateName = function(node) {
          this.tokenChar(35), this.print(node.id, node);
        }, exports3.SequenceExpression = function(node) {
          this.printList(node.expressions, node);
        }, exports3.Super = function() {
          this.word("super");
        }, exports3.ThisExpression = function() {
          this.word("this");
        }, exports3.UnaryExpression = function(node) {
          const { operator } = node;
          "void" === operator || "delete" === operator || "typeof" === operator || "throw" === operator ? (this.word(operator), this.space()) : this.token(operator);
          this.print(node.argument, node);
        }, exports3.UpdateExpression = function(node) {
          node.prefix ? (this.token(node.operator), this.print(node.argument, node)) : (this.printTerminatorless(node.argument, node, true), this.token(node.operator));
        }, exports3.V8IntrinsicIdentifier = function(node) {
          this.tokenChar(37), this.word(node.name);
        }, exports3.YieldExpression = function(node) {
          this.word("yield", true), node.delegate ? (this.tokenChar(42), node.argument && (this.space(), this.print(node.argument, node))) : node.argument && (this.space(), this.printTerminatorless(node.argument, node, false));
        }, exports3._shouldPrintDecoratorsBeforeExport = function(node) {
          if ("boolean" == typeof this.format.decoratorsBeforeExport)
            return this.format.decoratorsBeforeExport;
          return "number" == typeof node.start && node.start === node.declaration.start;
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), n = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/node/index.js");
        const { isCallExpression, isLiteral, isMemberExpression, isNewExpression } = _t;
        function isDecoratorMemberExpression(node) {
          switch (node.type) {
            case "Identifier":
              return true;
            case "MemberExpression":
              return !node.computed && "Identifier" === node.property.type && isDecoratorMemberExpression(node.object);
            default:
              return false;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/flow.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.AnyTypeAnnotation = function() {
          this.word("any");
        }, exports3.ArrayTypeAnnotation = function(node) {
          this.print(node.elementType, node, true), this.tokenChar(91), this.tokenChar(93);
        }, exports3.BooleanLiteralTypeAnnotation = function(node) {
          this.word(node.value ? "true" : "false");
        }, exports3.BooleanTypeAnnotation = function() {
          this.word("boolean");
        }, exports3.DeclareClass = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.word("class"), this.space(), this._interfaceish(node);
        }, exports3.DeclareExportAllDeclaration = function(node) {
          this.word("declare"), this.space(), _modules.ExportAllDeclaration.call(this, node);
        }, exports3.DeclareExportDeclaration = function(node) {
          this.word("declare"), this.space(), this.word("export"), this.space(), node.default && (this.word("default"), this.space());
          FlowExportDeclaration.call(this, node);
        }, exports3.DeclareFunction = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.word("function"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation.typeAnnotation, node), node.predicate && (this.space(), this.print(node.predicate, node));
          this.semicolon();
        }, exports3.DeclareInterface = function(node) {
          this.word("declare"), this.space(), this.InterfaceDeclaration(node);
        }, exports3.DeclareModule = function(node) {
          this.word("declare"), this.space(), this.word("module"), this.space(), this.print(node.id, node), this.space(), this.print(node.body, node);
        }, exports3.DeclareModuleExports = function(node) {
          this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(node.typeAnnotation, node);
        }, exports3.DeclareOpaqueType = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.OpaqueType(node);
        }, exports3.DeclareTypeAlias = function(node) {
          this.word("declare"), this.space(), this.TypeAlias(node);
        }, exports3.DeclareVariable = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.word("var"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation, node), this.semicolon();
        }, exports3.DeclaredPredicate = function(node) {
          this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(node.value, node), this.tokenChar(41);
        }, exports3.EmptyTypeAnnotation = function() {
          this.word("empty");
        }, exports3.EnumBooleanBody = function(node) {
          const { explicitType } = node;
          enumExplicitType(this, "boolean", explicitType), enumBody(this, node);
        }, exports3.EnumBooleanMember = function(node) {
          enumInitializedMember(this, node);
        }, exports3.EnumDeclaration = function(node) {
          const { id, body } = node;
          this.word("enum"), this.space(), this.print(id, node), this.print(body, node);
        }, exports3.EnumDefaultedMember = function(node) {
          const { id } = node;
          this.print(id, node), this.tokenChar(44);
        }, exports3.EnumNumberBody = function(node) {
          const { explicitType } = node;
          enumExplicitType(this, "number", explicitType), enumBody(this, node);
        }, exports3.EnumNumberMember = function(node) {
          enumInitializedMember(this, node);
        }, exports3.EnumStringBody = function(node) {
          const { explicitType } = node;
          enumExplicitType(this, "string", explicitType), enumBody(this, node);
        }, exports3.EnumStringMember = function(node) {
          enumInitializedMember(this, node);
        }, exports3.EnumSymbolBody = function(node) {
          enumExplicitType(this, "symbol", true), enumBody(this, node);
        }, exports3.ExistsTypeAnnotation = function() {
          this.tokenChar(42);
        }, exports3.FunctionTypeAnnotation = function(node, parent) {
          this.print(node.typeParameters, node), this.tokenChar(40), node.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(node.this.typeAnnotation, node), (node.params.length || node.rest) && (this.tokenChar(44), this.space()));
          this.printList(node.params, node), node.rest && (node.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(node.rest, node));
          this.tokenChar(41);
          const type = null == parent ? void 0 : parent.type;
          null != type && ("ObjectTypeCallProperty" === type || "ObjectTypeInternalSlot" === type || "DeclareFunction" === type || "ObjectTypeProperty" === type && parent.method) ? this.tokenChar(58) : (this.space(), this.token("=>"));
          this.space(), this.print(node.returnType, node);
        }, exports3.FunctionTypeParam = function(node) {
          this.print(node.name, node), node.optional && this.tokenChar(63);
          node.name && (this.tokenChar(58), this.space());
          this.print(node.typeAnnotation, node);
        }, exports3.IndexedAccessType = function(node) {
          this.print(node.objectType, node, true), this.tokenChar(91), this.print(node.indexType, node), this.tokenChar(93);
        }, exports3.InferredPredicate = function() {
          this.tokenChar(37), this.word("checks");
        }, exports3.InterfaceDeclaration = function(node) {
          this.word("interface"), this.space(), this._interfaceish(node);
        }, exports3.GenericTypeAnnotation = exports3.ClassImplements = exports3.InterfaceExtends = function(node) {
          this.print(node.id, node), this.print(node.typeParameters, node, true);
        }, exports3.InterfaceTypeAnnotation = function(node) {
          var _node$extends2;
          this.word("interface"), null != (_node$extends2 = node.extends) && _node$extends2.length && (this.space(), this.word("extends"), this.space(), this.printList(node.extends, node));
          this.space(), this.print(node.body, node);
        }, exports3.IntersectionTypeAnnotation = function(node) {
          this.printJoin(node.types, node, { separator: andSeparator });
        }, exports3.MixedTypeAnnotation = function() {
          this.word("mixed");
        }, exports3.NullLiteralTypeAnnotation = function() {
          this.word("null");
        }, exports3.NullableTypeAnnotation = function(node) {
          this.tokenChar(63), this.print(node.typeAnnotation, node);
        }, Object.defineProperty(exports3, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _types2.NumericLiteral;
        } }), exports3.NumberTypeAnnotation = function() {
          this.word("number");
        }, exports3.ObjectTypeAnnotation = function(node) {
          node.exact ? this.token("{|") : this.tokenChar(123);
          const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
          props.length && (this.newline(), this.space(), this.printJoin(props, node, { addNewlines(leading) {
            if (leading && !props[0])
              return 1;
          }, indent: true, statement: true, iterator: () => {
            (1 !== props.length || node.inexact) && (this.tokenChar(44), this.space());
          } }), this.space());
          node.inexact && (this.indent(), this.token("..."), props.length && this.newline(), this.dedent());
          node.exact ? this.token("|}") : this.tokenChar(125);
        }, exports3.ObjectTypeCallProperty = function(node) {
          node.static && (this.word("static"), this.space());
          this.print(node.value, node);
        }, exports3.ObjectTypeIndexer = function(node) {
          node.static && (this.word("static"), this.space());
          this._variance(node), this.tokenChar(91), node.id && (this.print(node.id, node), this.tokenChar(58), this.space());
          this.print(node.key, node), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(node.value, node);
        }, exports3.ObjectTypeInternalSlot = function(node) {
          node.static && (this.word("static"), this.space());
          this.tokenChar(91), this.tokenChar(91), this.print(node.id, node), this.tokenChar(93), this.tokenChar(93), node.optional && this.tokenChar(63);
          node.method || (this.tokenChar(58), this.space());
          this.print(node.value, node);
        }, exports3.ObjectTypeProperty = function(node) {
          node.proto && (this.word("proto"), this.space());
          node.static && (this.word("static"), this.space());
          "get" !== node.kind && "set" !== node.kind || (this.word(node.kind), this.space());
          this._variance(node), this.print(node.key, node), node.optional && this.tokenChar(63);
          node.method || (this.tokenChar(58), this.space());
          this.print(node.value, node);
        }, exports3.ObjectTypeSpreadProperty = function(node) {
          this.token("..."), this.print(node.argument, node);
        }, exports3.OpaqueType = function(node) {
          this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(node.id, node), this.print(node.typeParameters, node), node.supertype && (this.tokenChar(58), this.space(), this.print(node.supertype, node));
          node.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(node.impltype, node));
          this.semicolon();
        }, exports3.OptionalIndexedAccessType = function(node) {
          this.print(node.objectType, node), node.optional && this.token("?.");
          this.tokenChar(91), this.print(node.indexType, node), this.tokenChar(93);
        }, exports3.QualifiedTypeIdentifier = function(node) {
          this.print(node.qualification, node), this.tokenChar(46), this.print(node.id, node);
        }, Object.defineProperty(exports3, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _types2.StringLiteral;
        } }), exports3.StringTypeAnnotation = function() {
          this.word("string");
        }, exports3.SymbolTypeAnnotation = function() {
          this.word("symbol");
        }, exports3.ThisTypeAnnotation = function() {
          this.word("this");
        }, exports3.TupleTypeAnnotation = function(node) {
          this.tokenChar(91), this.printList(node.types, node), this.tokenChar(93);
        }, exports3.TypeAlias = function(node) {
          this.word("type"), this.space(), this.print(node.id, node), this.print(node.typeParameters, node), this.space(), this.tokenChar(61), this.space(), this.print(node.right, node), this.semicolon();
        }, exports3.TypeAnnotation = function(node) {
          this.tokenChar(58), this.space(), node.optional && this.tokenChar(63);
          this.print(node.typeAnnotation, node);
        }, exports3.TypeCastExpression = function(node) {
          this.tokenChar(40), this.print(node.expression, node), this.print(node.typeAnnotation, node), this.tokenChar(41);
        }, exports3.TypeParameter = function(node) {
          this._variance(node), this.word(node.name), node.bound && this.print(node.bound, node);
          node.default && (this.space(), this.tokenChar(61), this.space(), this.print(node.default, node));
        }, exports3.TypeParameterDeclaration = exports3.TypeParameterInstantiation = function(node) {
          this.tokenChar(60), this.printList(node.params, node, {}), this.tokenChar(62);
        }, exports3.TypeofTypeAnnotation = function(node) {
          this.word("typeof"), this.space(), this.print(node.argument, node);
        }, exports3.UnionTypeAnnotation = function(node) {
          this.printJoin(node.types, node, { separator: orSeparator });
        }, exports3.Variance = function(node) {
          "plus" === node.kind ? this.tokenChar(43) : this.tokenChar(45);
        }, exports3.VoidTypeAnnotation = function() {
          this.word("void");
        }, exports3._interfaceish = function(node) {
          var _node$extends;
          this.print(node.id, node), this.print(node.typeParameters, node), null != (_node$extends = node.extends) && _node$extends.length && (this.space(), this.word("extends"), this.space(), this.printList(node.extends, node));
          if ("DeclareClass" === node.type) {
            var _node$mixins, _node$implements;
            null != (_node$mixins = node.mixins) && _node$mixins.length && (this.space(), this.word("mixins"), this.space(), this.printList(node.mixins, node)), null != (_node$implements = node.implements) && _node$implements.length && (this.space(), this.word("implements"), this.space(), this.printList(node.implements, node));
          }
          this.space(), this.print(node.body, node);
        }, exports3._variance = function(node) {
          var _node$variance;
          const kind = null == (_node$variance = node.variance) ? void 0 : _node$variance.kind;
          null != kind && ("plus" === kind ? this.tokenChar(43) : "minus" === kind && this.tokenChar(45));
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _modules = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/modules.js"), _types2 = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/types.js");
        const { isDeclareExportDeclaration, isStatement } = _t;
        function enumExplicitType(context, name, hasExplicitType) {
          hasExplicitType && (context.space(), context.word("of"), context.space(), context.word(name)), context.space();
        }
        function enumBody(context, node) {
          const { members } = node;
          context.token("{"), context.indent(), context.newline();
          for (const member of members)
            context.print(member, node), context.newline();
          node.hasUnknownMembers && (context.token("..."), context.newline()), context.dedent(), context.token("}");
        }
        function enumInitializedMember(context, node) {
          const { id, init } = node;
          context.print(id, node), context.space(), context.token("="), context.space(), context.print(init, node), context.token(",");
        }
        function FlowExportDeclaration(node) {
          if (node.declaration) {
            const declar = node.declaration;
            this.print(declar, node), isStatement(declar) || this.semicolon();
          } else
            this.tokenChar(123), node.specifiers.length && (this.space(), this.printList(node.specifiers, node), this.space()), this.tokenChar(125), node.source && (this.space(), this.word("from"), this.space(), this.print(node.source, node)), this.semicolon();
        }
        function andSeparator() {
          this.space(), this.tokenChar(38), this.space();
        }
        function orSeparator() {
          this.space(), this.tokenChar(124), this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var _templateLiterals = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/template-literals.js");
        Object.keys(_templateLiterals).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _templateLiterals[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _templateLiterals[key];
          } }));
        });
        var _expressions = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/expressions.js");
        Object.keys(_expressions).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _expressions[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _expressions[key];
          } }));
        });
        var _statements = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/statements.js");
        Object.keys(_statements).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _statements[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _statements[key];
          } }));
        });
        var _classes = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/classes.js");
        Object.keys(_classes).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _classes[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _classes[key];
          } }));
        });
        var _methods = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/methods.js");
        Object.keys(_methods).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _methods[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _methods[key];
          } }));
        });
        var _modules = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/modules.js");
        Object.keys(_modules).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _modules[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _modules[key];
          } }));
        });
        var _types = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/types.js");
        Object.keys(_types).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _types[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _types[key];
          } }));
        });
        var _flow = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/flow.js");
        Object.keys(_flow).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _flow[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _flow[key];
          } }));
        });
        var _base = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/base.js");
        Object.keys(_base).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _base[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _base[key];
          } }));
        });
        var _jsx = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/jsx.js");
        Object.keys(_jsx).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _jsx[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _jsx[key];
          } }));
        });
        var _typescript = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/typescript.js");
        Object.keys(_typescript).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (key in exports3 && exports3[key] === _typescript[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _typescript[key];
          } }));
        });
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/jsx.js": (__unused_webpack_module, exports3) => {
        "use strict";
        function spaceSeparator() {
          this.space();
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.JSXAttribute = function(node) {
          this.print(node.name, node), node.value && (this.tokenChar(61), this.print(node.value, node));
        }, exports3.JSXClosingElement = function(node) {
          this.token("</"), this.print(node.name, node), this.tokenChar(62);
        }, exports3.JSXClosingFragment = function() {
          this.token("</"), this.tokenChar(62);
        }, exports3.JSXElement = function(node) {
          const open = node.openingElement;
          if (this.print(open, node), open.selfClosing)
            return;
          this.indent();
          for (const child of node.children)
            this.print(child, node);
          this.dedent(), this.print(node.closingElement, node);
        }, exports3.JSXEmptyExpression = function() {
          this.printInnerComments();
        }, exports3.JSXExpressionContainer = function(node) {
          this.tokenChar(123), this.print(node.expression, node), this.tokenChar(125);
        }, exports3.JSXFragment = function(node) {
          this.print(node.openingFragment, node), this.indent();
          for (const child of node.children)
            this.print(child, node);
          this.dedent(), this.print(node.closingFragment, node);
        }, exports3.JSXIdentifier = function(node) {
          this.word(node.name);
        }, exports3.JSXMemberExpression = function(node) {
          this.print(node.object, node), this.tokenChar(46), this.print(node.property, node);
        }, exports3.JSXNamespacedName = function(node) {
          this.print(node.namespace, node), this.tokenChar(58), this.print(node.name, node);
        }, exports3.JSXOpeningElement = function(node) {
          this.tokenChar(60), this.print(node.name, node), this.print(node.typeParameters, node), node.attributes.length > 0 && (this.space(), this.printJoin(node.attributes, node, { separator: spaceSeparator }));
          node.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
        }, exports3.JSXOpeningFragment = function() {
          this.tokenChar(60), this.tokenChar(62);
        }, exports3.JSXSpreadAttribute = function(node) {
          this.tokenChar(123), this.token("..."), this.print(node.argument, node), this.tokenChar(125);
        }, exports3.JSXSpreadChild = function(node) {
          this.tokenChar(123), this.token("..."), this.print(node.expression, node), this.tokenChar(125);
        }, exports3.JSXText = function(node) {
          const raw = this.getPossibleRaw(node);
          void 0 !== raw ? this.token(raw, true) : this.token(node.value, true);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/methods.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ArrowFunctionExpression = function(node, parent) {
          node.async && (this.word("async", true), this.space());
          let firstParam;
          this.format.retainLines || 1 !== node.params.length || !isIdentifier(firstParam = node.params[0]) || function(node2, param) {
            var _param$leadingComment, _param$trailingCommen;
            return !!(node2.typeParameters || node2.returnType || node2.predicate || param.typeAnnotation || param.optional || null != (_param$leadingComment = param.leadingComments) && _param$leadingComment.length || null != (_param$trailingCommen = param.trailingComments) && _param$trailingCommen.length);
          }(node, firstParam) ? this._params(node, void 0, parent) : this.print(firstParam, node, true);
          this._predicate(node, true), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(node.body, node);
        }, exports3.FunctionDeclaration = exports3.FunctionExpression = function(node, parent) {
          this._functionHead(node, parent), this.space(), this.print(node.body, node);
        }, exports3._functionHead = function(node, parent) {
          node.async && (this.word("async"), this._endsWithInnerRaw = false, this.space());
          this.word("function"), node.generator && (this._endsWithInnerRaw = false, this.tokenChar(42));
          this.space(), node.id && this.print(node.id, node);
          this._params(node, node.id, parent), "TSDeclareFunction" !== node.type && this._predicate(node);
        }, exports3._methodHead = function(node) {
          const kind = node.kind, key = node.key;
          "get" !== kind && "set" !== kind || (this.word(kind), this.space());
          node.async && (this.word("async", true), this.space());
          "method" !== kind && "init" !== kind || node.generator && this.tokenChar(42);
          node.computed ? (this.tokenChar(91), this.print(key, node), this.tokenChar(93)) : this.print(key, node);
          node.optional && this.tokenChar(63);
          this._params(node, node.computed && "StringLiteral" !== node.key.type ? void 0 : node.key, void 0);
        }, exports3._param = function(parameter, parent) {
          this.printJoin(parameter.decorators, parameter), this.print(parameter, parent), parameter.optional && this.tokenChar(63);
          this.print(parameter.typeAnnotation, parameter);
        }, exports3._parameters = function(parameters, parent) {
          const paramLength = parameters.length;
          for (let i = 0; i < paramLength; i++)
            this._param(parameters[i], parent), i < parameters.length - 1 && (this.tokenChar(44), this.space());
        }, exports3._params = function(node, idNode, parentNode) {
          this.print(node.typeParameters, node);
          const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
          nameInfo && this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
          this.tokenChar(40), this._parameters(node.params, node), this.tokenChar(41);
          const noLineTerminator = "ArrowFunctionExpression" === node.type;
          this.print(node.returnType, node, noLineTerminator), this._noLineTerminator = noLineTerminator;
        }, exports3._predicate = function(node, noLineTerminatorAfter) {
          node.predicate && (node.returnType || this.tokenChar(58), this.space(), this.print(node.predicate, node, noLineTerminatorAfter));
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { isIdentifier } = _t;
        function _getFuncIdName(idNode, parent) {
          let nameInfo, id = idNode;
          if (!id && parent) {
            const parentType = parent.type;
            "VariableDeclarator" === parentType ? id = parent.id : "AssignmentExpression" === parentType || "AssignmentPattern" === parentType ? id = parent.left : "ObjectProperty" === parentType || "ClassProperty" === parentType ? parent.computed && "StringLiteral" !== parent.key.type || (id = parent.key) : "ClassPrivateProperty" !== parentType && "ClassAccessorProperty" !== parentType || (id = parent.key);
          }
          if (id) {
            var _id$loc, _id$loc2;
            if ("Identifier" === id.type)
              nameInfo = { pos: null == (_id$loc = id.loc) ? void 0 : _id$loc.start, name: (null == (_id$loc2 = id.loc) ? void 0 : _id$loc2.identifierName) || id.name };
            else if ("PrivateName" === id.type) {
              var _id$loc3;
              nameInfo = { pos: null == (_id$loc3 = id.loc) ? void 0 : _id$loc3.start, name: "#" + id.id.name };
            } else if ("StringLiteral" === id.type) {
              var _id$loc4;
              nameInfo = { pos: null == (_id$loc4 = id.loc) ? void 0 : _id$loc4.start, name: id.value };
            }
            return nameInfo;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/modules.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ExportAllDeclaration = function(node) {
          var _node$attributes, _node$assertions;
          this.word("export"), this.space(), "type" === node.exportKind && (this.word("type"), this.space());
          this.tokenChar(42), this.space(), this.word("from"), this.space(), null != (_node$attributes = node.attributes) && _node$attributes.length || null != (_node$assertions = node.assertions) && _node$assertions.length ? (this.print(node.source, node, true), this.space(), this._printAttributes(node)) : this.print(node.source, node);
          this.semicolon();
        }, exports3.ExportDefaultDeclaration = function(node) {
          maybePrintDecoratorsBeforeExport(this, node), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
          const declar = node.declaration;
          this.print(declar, node), isStatement(declar) || this.semicolon();
        }, exports3.ExportDefaultSpecifier = function(node) {
          this.print(node.exported, node);
        }, exports3.ExportNamedDeclaration = function(node) {
          if (maybePrintDecoratorsBeforeExport(this, node), this.word("export"), this.space(), node.declaration) {
            const declar = node.declaration;
            this.print(declar, node), isStatement(declar) || this.semicolon();
          } else {
            "type" === node.exportKind && (this.word("type"), this.space());
            const specifiers = node.specifiers.slice(0);
            let hasSpecial = false;
            for (; ; ) {
              const first = specifiers[0];
              if (!isExportDefaultSpecifier(first) && !isExportNamespaceSpecifier(first))
                break;
              hasSpecial = true, this.print(specifiers.shift(), node), specifiers.length && (this.tokenChar(44), this.space());
            }
            var _node$attributes2, _node$assertions2;
            if ((specifiers.length || !specifiers.length && !hasSpecial) && (this.tokenChar(123), specifiers.length && (this.space(), this.printList(specifiers, node), this.space()), this.tokenChar(125)), node.source)
              this.space(), this.word("from"), this.space(), null != (_node$attributes2 = node.attributes) && _node$attributes2.length || null != (_node$assertions2 = node.assertions) && _node$assertions2.length ? (this.print(node.source, node, true), this.space(), this._printAttributes(node)) : this.print(node.source, node);
            this.semicolon();
          }
        }, exports3.ExportNamespaceSpecifier = function(node) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(node.exported, node);
        }, exports3.ExportSpecifier = function(node) {
          "type" === node.exportKind && (this.word("type"), this.space());
          this.print(node.local, node), node.exported && node.local.name !== node.exported.name && (this.space(), this.word("as"), this.space(), this.print(node.exported, node));
        }, exports3.ImportAttribute = function(node) {
          this.print(node.key), this.tokenChar(58), this.space(), this.print(node.value);
        }, exports3.ImportDeclaration = function(node) {
          var _node$attributes3, _node$assertions3;
          this.word("import"), this.space();
          const isTypeKind = "type" === node.importKind || "typeof" === node.importKind;
          isTypeKind ? (this.noIndentInnerCommentsHere(), this.word(node.importKind), this.space()) : node.module && (this.noIndentInnerCommentsHere(), this.word("module"), this.space());
          const specifiers = node.specifiers.slice(0), hasSpecifiers = !!specifiers.length;
          for (; hasSpecifiers; ) {
            const first = specifiers[0];
            if (!isImportDefaultSpecifier(first) && !isImportNamespaceSpecifier(first))
              break;
            this.print(specifiers.shift(), node), specifiers.length && (this.tokenChar(44), this.space());
          }
          specifiers.length ? (this.tokenChar(123), this.space(), this.printList(specifiers, node), this.space(), this.tokenChar(125)) : isTypeKind && !hasSpecifiers && (this.tokenChar(123), this.tokenChar(125));
          (hasSpecifiers || isTypeKind) && (this.space(), this.word("from"), this.space());
          null != (_node$attributes3 = node.attributes) && _node$attributes3.length || null != (_node$assertions3 = node.assertions) && _node$assertions3.length ? (this.print(node.source, node, true), this.space(), this._printAttributes(node)) : this.print(node.source, node);
          this.semicolon();
        }, exports3.ImportDefaultSpecifier = function(node) {
          this.print(node.local, node);
        }, exports3.ImportNamespaceSpecifier = function(node) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(node.local, node);
        }, exports3.ImportSpecifier = function(node) {
          "type" !== node.importKind && "typeof" !== node.importKind || (this.word(node.importKind), this.space());
          this.print(node.imported, node), node.local && node.local.name !== node.imported.name && (this.space(), this.word("as"), this.space(), this.print(node.local, node));
        }, exports3._printAttributes = function(node) {
          const { importAttributesKeyword } = this.format, { attributes, assertions } = node;
          !attributes || importAttributesKeyword || warningShown || (warningShown = true, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
          const useAssertKeyword = "assert" === importAttributesKeyword || !importAttributesKeyword && assertions;
          if (this.word(useAssertKeyword ? "assert" : "with"), this.space(), !useAssertKeyword && "with" !== importAttributesKeyword)
            return void this.printList(attributes || assertions, node);
          this.tokenChar(123), this.space(), this.printList(attributes || assertions, node), this.space(), this.tokenChar(125);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { isClassDeclaration, isExportDefaultSpecifier, isExportNamespaceSpecifier, isImportDefaultSpecifier, isImportNamespaceSpecifier, isStatement } = _t;
        let warningShown = false;
        function maybePrintDecoratorsBeforeExport(printer, node) {
          isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node) && printer.printJoin(node.declaration.decorators, node);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/statements.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.BreakStatement = function(node) {
          this.word("break"), printStatementAfterKeyword(this, node.label, node, true);
        }, exports3.CatchClause = function(node) {
          this.word("catch"), this.space(), node.param && (this.tokenChar(40), this.print(node.param, node), this.print(node.param.typeAnnotation, node), this.tokenChar(41), this.space());
          this.print(node.body, node);
        }, exports3.ContinueStatement = function(node) {
          this.word("continue"), printStatementAfterKeyword(this, node.label, node, true);
        }, exports3.DebuggerStatement = function() {
          this.word("debugger"), this.semicolon();
        }, exports3.DoWhileStatement = function(node) {
          this.word("do"), this.space(), this.print(node.body, node), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(node.test, node), this.tokenChar(41), this.semicolon();
        }, exports3.ForOfStatement = exports3.ForInStatement = void 0, exports3.ForStatement = function(node) {
          this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(node.init, node), this.inForStatementInitCounter--, this.tokenChar(59), node.test && (this.space(), this.print(node.test, node));
          this.tokenChar(59), node.update && (this.space(), this.print(node.update, node));
          this.tokenChar(41), this.printBlock(node);
        }, exports3.IfStatement = function(node) {
          this.word("if"), this.space(), this.tokenChar(40), this.print(node.test, node), this.tokenChar(41), this.space();
          const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
          needsBlock && (this.tokenChar(123), this.newline(), this.indent());
          this.printAndIndentOnComments(node.consequent, node), needsBlock && (this.dedent(), this.newline(), this.tokenChar(125));
          node.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(node.alternate, node));
        }, exports3.LabeledStatement = function(node) {
          this.print(node.label, node), this.tokenChar(58), this.space(), this.print(node.body, node);
        }, exports3.ReturnStatement = function(node) {
          this.word("return"), printStatementAfterKeyword(this, node.argument, node, false);
        }, exports3.SwitchCase = function(node) {
          node.test ? (this.word("case"), this.space(), this.print(node.test, node), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58));
          node.consequent.length && (this.newline(), this.printSequence(node.consequent, node, { indent: true }));
        }, exports3.SwitchStatement = function(node) {
          this.word("switch"), this.space(), this.tokenChar(40), this.print(node.discriminant, node), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(node.cases, node, { indent: true, addNewlines(leading, cas) {
            if (!leading && node.cases[node.cases.length - 1] === cas)
              return -1;
          } }), this.rightBrace(node);
        }, exports3.ThrowStatement = function(node) {
          this.word("throw"), printStatementAfterKeyword(this, node.argument, node, false);
        }, exports3.TryStatement = function(node) {
          this.word("try"), this.space(), this.print(node.block, node), this.space(), node.handlers ? this.print(node.handlers[0], node) : this.print(node.handler, node);
          node.finalizer && (this.space(), this.word("finally"), this.space(), this.print(node.finalizer, node));
        }, exports3.VariableDeclaration = function(node, parent) {
          node.declare && (this.word("declare"), this.space());
          const { kind } = node;
          this.word(kind, "using" === kind || "await using" === kind), this.space();
          let hasInits = false;
          if (!isFor(parent))
            for (const declar of node.declarations)
              declar.init && (hasInits = true);
          if (this.printList(node.declarations, node, { separator: hasInits ? function() {
            this.tokenChar(44), this.newline();
          } : void 0, indent: node.declarations.length > 1 }), isFor(parent)) {
            if (isForStatement(parent)) {
              if (parent.init === node)
                return;
            } else if (parent.left === node)
              return;
          }
          this.semicolon();
        }, exports3.VariableDeclarator = function(node) {
          this.print(node.id, node), node.definite && this.tokenChar(33);
          this.print(node.id.typeAnnotation, node), node.init && (this.space(), this.tokenChar(61), this.space(), this.print(node.init, node));
        }, exports3.WhileStatement = function(node) {
          this.word("while"), this.space(), this.tokenChar(40), this.print(node.test, node), this.tokenChar(41), this.printBlock(node);
        }, exports3.WithStatement = function(node) {
          this.word("with"), this.space(), this.tokenChar(40), this.print(node.object, node), this.tokenChar(41), this.printBlock(node);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { isFor, isForStatement, isIfStatement, isStatement } = _t;
        function getLastStatement(statement) {
          const { body } = statement;
          return false === isStatement(body) ? statement : getLastStatement(body);
        }
        function ForXStatement(node) {
          this.word("for"), this.space();
          const isForOf = "ForOfStatement" === node.type;
          isForOf && node.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(node.left, node), this.space(), this.word(isForOf ? "of" : "in"), this.space(), this.print(node.right, node), this.tokenChar(41), this.printBlock(node);
        }
        const ForInStatement = ForXStatement;
        exports3.ForInStatement = ForInStatement;
        const ForOfStatement = ForXStatement;
        function printStatementAfterKeyword(printer, node, parent, isLabel) {
          node && (printer.space(), printer.printTerminatorless(node, parent, isLabel)), printer.semicolon();
        }
        exports3.ForOfStatement = ForOfStatement;
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/template-literals.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.TaggedTemplateExpression = function(node) {
          this.print(node.tag, node), this.print(node.typeParameters, node), this.print(node.quasi, node);
        }, exports3.TemplateElement = function(node, parent) {
          const isFirst = parent.quasis[0] === node, isLast = parent.quasis[parent.quasis.length - 1] === node, value2 = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
          this.token(value2, true);
        }, exports3.TemplateLiteral = function(node) {
          const quasis = node.quasis;
          for (let i = 0; i < quasis.length; i++)
            this.print(quasis[i], node), i + 1 < quasis.length && this.print(node.expressions[i], node);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/types.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ArgumentPlaceholder = function() {
          this.tokenChar(63);
        }, exports3.ArrayPattern = exports3.ArrayExpression = function(node) {
          const elems = node.elements, len = elems.length;
          this.tokenChar(91);
          for (let i = 0; i < elems.length; i++) {
            const elem = elems[i];
            elem ? (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.tokenChar(44)) : this.tokenChar(44);
          }
          this.tokenChar(93);
        }, exports3.BigIntLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && void 0 !== raw)
            return void this.word(raw);
          this.word(node.value + "n");
        }, exports3.BooleanLiteral = function(node) {
          this.word(node.value ? "true" : "false");
        }, exports3.DecimalLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && void 0 !== raw)
            return void this.word(raw);
          this.word(node.value + "m");
        }, exports3.Identifier = function(node) {
          var _node$loc;
          this.sourceIdentifierName((null == (_node$loc = node.loc) ? void 0 : _node$loc.identifierName) || node.name), this.word(node.name);
        }, exports3.NullLiteral = function() {
          this.word("null");
        }, exports3.NumericLiteral = function(node) {
          const raw = this.getPossibleRaw(node), opts = this.format.jsescOption, value2 = node.value + "";
          opts.numbers ? this.number(_jsesc(node.value, opts)) : null == raw ? this.number(value2) : this.format.minified ? this.number(raw.length < value2.length ? raw : value2) : this.number(raw);
        }, exports3.ObjectPattern = exports3.ObjectExpression = function(node) {
          const props = node.properties;
          this.tokenChar(123), props.length && (this.space(), this.printList(props, node, { indent: true, statement: true }), this.space());
          this.sourceWithOffset("end", node.loc, 0, -1), this.tokenChar(125);
        }, exports3.ObjectMethod = function(node) {
          this.printJoin(node.decorators, node), this._methodHead(node), this.space(), this.print(node.body, node);
        }, exports3.ObjectProperty = function(node) {
          if (this.printJoin(node.decorators, node), node.computed)
            this.tokenChar(91), this.print(node.key, node), this.tokenChar(93);
          else {
            if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name)
              return void this.print(node.value, node);
            if (this.print(node.key, node), node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name)
              return;
          }
          this.tokenChar(58), this.space(), this.print(node.value, node);
        }, exports3.PipelineBareFunction = function(node) {
          this.print(node.callee, node);
        }, exports3.PipelinePrimaryTopicReference = function() {
          this.tokenChar(35);
        }, exports3.PipelineTopicExpression = function(node) {
          this.print(node.expression, node);
        }, exports3.RecordExpression = function(node) {
          const props = node.properties;
          let startToken, endToken;
          if ("bar" === this.format.recordAndTupleSyntaxType)
            startToken = "{|", endToken = "|}";
          else {
            if ("hash" !== this.format.recordAndTupleSyntaxType && null != this.format.recordAndTupleSyntaxType)
              throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            startToken = "#{", endToken = "}";
          }
          this.token(startToken), props.length && (this.space(), this.printList(props, node, { indent: true, statement: true }), this.space());
          this.token(endToken);
        }, exports3.RegExpLiteral = function(node) {
          this.word(`/${node.pattern}/${node.flags}`);
        }, exports3.SpreadElement = exports3.RestElement = function(node) {
          this.token("..."), this.print(node.argument, node);
        }, exports3.StringLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && void 0 !== raw)
            return void this.token(raw);
          const val = _jsesc(node.value, this.format.jsescOption);
          this.token(val);
        }, exports3.TopicReference = function() {
          const { topicToken } = this.format;
          if (!validTopicTokenSet.has(topicToken)) {
            const givenTopicTokenJSON = JSON.stringify(topicToken), validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
            throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
          }
          this.token(topicToken);
        }, exports3.TupleExpression = function(node) {
          const elems = node.elements, len = elems.length;
          let startToken, endToken;
          if ("bar" === this.format.recordAndTupleSyntaxType)
            startToken = "[|", endToken = "|]";
          else {
            if ("hash" !== this.format.recordAndTupleSyntaxType)
              throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
            startToken = "#[", endToken = "]";
          }
          this.token(startToken);
          for (let i = 0; i < elems.length; i++) {
            const elem = elems[i];
            elem && (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.tokenChar(44));
          }
          this.token(endToken);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _jsesc = __webpack_require__2("./node_modules/.pnpm/jsesc@2.5.2/node_modules/jsesc/jsesc.js");
        const { isAssignmentPattern, isIdentifier } = _t;
        const validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/typescript.js": (__unused_webpack_module, exports3) => {
        "use strict";
        function tsPrintBraced(printer, members, node) {
          if (printer.token("{"), members.length) {
            printer.indent(), printer.newline();
            for (const member of members)
              printer.print(member, node), printer.newline();
            printer.dedent();
          }
          printer.rightBrace(node);
        }
        function tsPrintUnionOrIntersectionType(printer, node, sep) {
          printer.printJoin(node.types, node, { separator() {
            this.space(), this.token(sep), this.space();
          } });
        }
        function tokenIfPlusMinus(self2, tok) {
          true !== tok && self2.token(tok);
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.TSAnyKeyword = function() {
          this.word("any");
        }, exports3.TSArrayType = function(node) {
          this.print(node.elementType, node, true), this.token("[]");
        }, exports3.TSSatisfiesExpression = exports3.TSAsExpression = function(node) {
          var _expression$trailingC;
          const { type, expression, typeAnnotation } = node, forceParens = !(null == (_expression$trailingC = expression.trailingComments) || !_expression$trailingC.length);
          this.print(expression, node, true, void 0, forceParens), this.space(), this.word("TSAsExpression" === type ? "as" : "satisfies"), this.space(), this.print(typeAnnotation, node);
        }, exports3.TSBigIntKeyword = function() {
          this.word("bigint");
        }, exports3.TSBooleanKeyword = function() {
          this.word("boolean");
        }, exports3.TSCallSignatureDeclaration = function(node) {
          this.tsPrintSignatureDeclarationBase(node), this.tokenChar(59);
        }, exports3.TSConditionalType = function(node) {
          this.print(node.checkType), this.space(), this.word("extends"), this.space(), this.print(node.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(node.trueType), this.space(), this.tokenChar(58), this.space(), this.print(node.falseType);
        }, exports3.TSConstructSignatureDeclaration = function(node) {
          this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(node), this.tokenChar(59);
        }, exports3.TSConstructorType = function(node) {
          node.abstract && (this.word("abstract"), this.space());
          this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(node);
        }, exports3.TSDeclareFunction = function(node, parent) {
          node.declare && (this.word("declare"), this.space());
          this._functionHead(node, parent), this.tokenChar(59);
        }, exports3.TSDeclareMethod = function(node) {
          this._classMethodHead(node), this.tokenChar(59);
        }, exports3.TSEnumDeclaration = function(node) {
          const { declare, const: isConst, id, members } = node;
          declare && (this.word("declare"), this.space());
          isConst && (this.word("const"), this.space());
          this.word("enum"), this.space(), this.print(id, node), this.space(), tsPrintBraced(this, members, node);
        }, exports3.TSEnumMember = function(node) {
          const { id, initializer } = node;
          this.print(id, node), initializer && (this.space(), this.tokenChar(61), this.space(), this.print(initializer, node));
          this.tokenChar(44);
        }, exports3.TSExportAssignment = function(node) {
          this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(node.expression, node), this.tokenChar(59);
        }, exports3.TSExpressionWithTypeArguments = function(node) {
          this.print(node.expression, node), this.print(node.typeParameters, node);
        }, exports3.TSExternalModuleReference = function(node) {
          this.token("require("), this.print(node.expression, node), this.tokenChar(41);
        }, exports3.TSFunctionType = function(node) {
          this.tsPrintFunctionOrConstructorType(node);
        }, exports3.TSImportEqualsDeclaration = function(node) {
          const { isExport, id, moduleReference } = node;
          isExport && (this.word("export"), this.space());
          this.word("import"), this.space(), this.print(id, node), this.space(), this.tokenChar(61), this.space(), this.print(moduleReference, node), this.tokenChar(59);
        }, exports3.TSImportType = function(node) {
          const { argument, qualifier, typeParameters } = node;
          this.word("import"), this.tokenChar(40), this.print(argument, node), this.tokenChar(41), qualifier && (this.tokenChar(46), this.print(qualifier, node));
          typeParameters && this.print(typeParameters, node);
        }, exports3.TSIndexSignature = function(node) {
          const { readonly, static: isStatic } = node;
          isStatic && (this.word("static"), this.space());
          readonly && (this.word("readonly"), this.space());
          this.tokenChar(91), this._parameters(node.parameters, node), this.tokenChar(93), this.print(node.typeAnnotation, node), this.tokenChar(59);
        }, exports3.TSIndexedAccessType = function(node) {
          this.print(node.objectType, node, true), this.tokenChar(91), this.print(node.indexType, node), this.tokenChar(93);
        }, exports3.TSInferType = function(node) {
          this.token("infer"), this.space(), this.print(node.typeParameter);
        }, exports3.TSInstantiationExpression = function(node) {
          this.print(node.expression, node), this.print(node.typeParameters, node);
        }, exports3.TSInterfaceBody = function(node) {
          this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
        }, exports3.TSInterfaceDeclaration = function(node) {
          const { declare, id, typeParameters, extends: extendz, body } = node;
          declare && (this.word("declare"), this.space());
          this.word("interface"), this.space(), this.print(id, node), this.print(typeParameters, node), null != extendz && extendz.length && (this.space(), this.word("extends"), this.space(), this.printList(extendz, node));
          this.space(), this.print(body, node);
        }, exports3.TSIntersectionType = function(node) {
          tsPrintUnionOrIntersectionType(this, node, "&");
        }, exports3.TSIntrinsicKeyword = function() {
          this.word("intrinsic");
        }, exports3.TSLiteralType = function(node) {
          this.print(node.literal, node);
        }, exports3.TSMappedType = function(node) {
          const { nameType, optional, readonly, typeParameter } = node;
          this.tokenChar(123), this.space(), readonly && (tokenIfPlusMinus(this, readonly), this.word("readonly"), this.space());
          this.tokenChar(91), this.word(typeParameter.name), this.space(), this.word("in"), this.space(), this.print(typeParameter.constraint, typeParameter), nameType && (this.space(), this.word("as"), this.space(), this.print(nameType, node));
          this.tokenChar(93), optional && (tokenIfPlusMinus(this, optional), this.tokenChar(63));
          this.tokenChar(58), this.space(), this.print(node.typeAnnotation, node), this.space(), this.tokenChar(125);
        }, exports3.TSMethodSignature = function(node) {
          const { kind } = node;
          "set" !== kind && "get" !== kind || (this.word(kind), this.space());
          this.tsPrintPropertyOrMethodName(node), this.tsPrintSignatureDeclarationBase(node), this.tokenChar(59);
        }, exports3.TSModuleBlock = function(node) {
          tsPrintBraced(this, node.body, node);
        }, exports3.TSModuleDeclaration = function(node) {
          const { declare, id } = node;
          declare && (this.word("declare"), this.space());
          node.global || (this.word("Identifier" === id.type ? "namespace" : "module"), this.space());
          if (this.print(id, node), !node.body)
            return void this.tokenChar(59);
          let body = node.body;
          for (; "TSModuleDeclaration" === body.type; )
            this.tokenChar(46), this.print(body.id, body), body = body.body;
          this.space(), this.print(body, node);
        }, exports3.TSNamedTupleMember = function(node) {
          this.print(node.label, node), node.optional && this.tokenChar(63);
          this.tokenChar(58), this.space(), this.print(node.elementType, node);
        }, exports3.TSNamespaceExportDeclaration = function(node) {
          this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(node.id, node);
        }, exports3.TSNeverKeyword = function() {
          this.word("never");
        }, exports3.TSNonNullExpression = function(node) {
          this.print(node.expression, node), this.tokenChar(33);
        }, exports3.TSNullKeyword = function() {
          this.word("null");
        }, exports3.TSNumberKeyword = function() {
          this.word("number");
        }, exports3.TSObjectKeyword = function() {
          this.word("object");
        }, exports3.TSOptionalType = function(node) {
          this.print(node.typeAnnotation, node), this.tokenChar(63);
        }, exports3.TSParameterProperty = function(node) {
          node.accessibility && (this.word(node.accessibility), this.space());
          node.readonly && (this.word("readonly"), this.space());
          this._param(node.parameter);
        }, exports3.TSParenthesizedType = function(node) {
          this.tokenChar(40), this.print(node.typeAnnotation, node), this.tokenChar(41);
        }, exports3.TSPropertySignature = function(node) {
          const { readonly, initializer } = node;
          readonly && (this.word("readonly"), this.space());
          this.tsPrintPropertyOrMethodName(node), this.print(node.typeAnnotation, node), initializer && (this.space(), this.tokenChar(61), this.space(), this.print(initializer, node));
          this.tokenChar(59);
        }, exports3.TSQualifiedName = function(node) {
          this.print(node.left, node), this.tokenChar(46), this.print(node.right, node);
        }, exports3.TSRestType = function(node) {
          this.token("..."), this.print(node.typeAnnotation, node);
        }, exports3.TSStringKeyword = function() {
          this.word("string");
        }, exports3.TSSymbolKeyword = function() {
          this.word("symbol");
        }, exports3.TSThisType = function() {
          this.word("this");
        }, exports3.TSTupleType = function(node) {
          this.tokenChar(91), this.printList(node.elementTypes, node), this.tokenChar(93);
        }, exports3.TSTypeAliasDeclaration = function(node) {
          const { declare, id, typeParameters, typeAnnotation } = node;
          declare && (this.word("declare"), this.space());
          this.word("type"), this.space(), this.print(id, node), this.print(typeParameters, node), this.space(), this.tokenChar(61), this.space(), this.print(typeAnnotation, node), this.tokenChar(59);
        }, exports3.TSTypeAnnotation = function(node) {
          this.tokenChar(58), this.space(), node.optional && this.tokenChar(63);
          this.print(node.typeAnnotation, node);
        }, exports3.TSTypeAssertion = function(node) {
          const { typeAnnotation, expression } = node;
          this.tokenChar(60), this.print(typeAnnotation, node), this.tokenChar(62), this.space(), this.print(expression, node);
        }, exports3.TSTypeLiteral = function(node) {
          this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
        }, exports3.TSTypeOperator = function(node) {
          this.word(node.operator), this.space(), this.print(node.typeAnnotation, node);
        }, exports3.TSTypeParameter = function(node) {
          node.in && (this.word("in"), this.space());
          node.out && (this.word("out"), this.space());
          this.word(node.name), node.constraint && (this.space(), this.word("extends"), this.space(), this.print(node.constraint, node));
          node.default && (this.space(), this.tokenChar(61), this.space(), this.print(node.default, node));
        }, exports3.TSTypeParameterDeclaration = exports3.TSTypeParameterInstantiation = function(node, parent) {
          this.tokenChar(60), this.printList(node.params, node, {}), "ArrowFunctionExpression" === parent.type && 1 === node.params.length && this.tokenChar(44);
          this.tokenChar(62);
        }, exports3.TSTypePredicate = function(node) {
          node.asserts && (this.word("asserts"), this.space());
          this.print(node.parameterName), node.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(node.typeAnnotation.typeAnnotation));
        }, exports3.TSTypeQuery = function(node) {
          this.word("typeof"), this.space(), this.print(node.exprName), node.typeParameters && this.print(node.typeParameters, node);
        }, exports3.TSTypeReference = function(node) {
          this.print(node.typeName, node, true), this.print(node.typeParameters, node, true);
        }, exports3.TSUndefinedKeyword = function() {
          this.word("undefined");
        }, exports3.TSUnionType = function(node) {
          tsPrintUnionOrIntersectionType(this, node, "|");
        }, exports3.TSUnknownKeyword = function() {
          this.word("unknown");
        }, exports3.TSVoidKeyword = function() {
          this.word("void");
        }, exports3.tsPrintClassMemberModifiers = function(node) {
          const isField = "ClassAccessorProperty" === node.type || "ClassProperty" === node.type;
          isField && node.declare && (this.word("declare"), this.space());
          node.accessibility && (this.word(node.accessibility), this.space());
          node.static && (this.word("static"), this.space());
          node.override && (this.word("override"), this.space());
          node.abstract && (this.word("abstract"), this.space());
          isField && node.readonly && (this.word("readonly"), this.space());
        }, exports3.tsPrintFunctionOrConstructorType = function(node) {
          const { typeParameters } = node, parameters = node.parameters;
          this.print(typeParameters, node), this.tokenChar(40), this._parameters(parameters, node), this.tokenChar(41), this.space(), this.token("=>"), this.space();
          const returnType = node.typeAnnotation;
          this.print(returnType.typeAnnotation, node);
        }, exports3.tsPrintPropertyOrMethodName = function(node) {
          node.computed && this.tokenChar(91);
          this.print(node.key, node), node.computed && this.tokenChar(93);
          node.optional && this.tokenChar(63);
        }, exports3.tsPrintSignatureDeclarationBase = function(node) {
          const { typeParameters } = node, parameters = node.parameters;
          this.print(typeParameters, node), this.tokenChar(40), this._parameters(parameters, node), this.tokenChar(41);
          const returnType = node.typeAnnotation;
          this.print(returnType, node);
        }, exports3.tsPrintTypeLiteralOrInterfaceBody = function(members, node) {
          tsPrintBraced(this, members, node);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.CodeGenerator = void 0, exports3.default = function(ast, opts, code) {
          return new Generator(ast, opts, code).generate();
        };
        var _sourceMap = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/source-map.js"), _printer = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/printer.js");
        class Generator extends _printer.default {
          constructor(ast, opts = {}, code) {
            const format2 = function(code2, opts2) {
              const format3 = { auxiliaryCommentBefore: opts2.auxiliaryCommentBefore, auxiliaryCommentAfter: opts2.auxiliaryCommentAfter, shouldPrintComment: opts2.shouldPrintComment, retainLines: opts2.retainLines, retainFunctionParens: opts2.retainFunctionParens, comments: null == opts2.comments || opts2.comments, compact: opts2.compact, minified: opts2.minified, concise: opts2.concise, indent: { adjustMultilineComment: true, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, opts2.jsescOption), recordAndTupleSyntaxType: opts2.recordAndTupleSyntaxType, topicToken: opts2.topicToken, importAttributesKeyword: opts2.importAttributesKeyword };
              format3.decoratorsBeforeExport = opts2.decoratorsBeforeExport, format3.jsescOption.json = opts2.jsonCompatibleStrings, format3.minified ? (format3.compact = true, format3.shouldPrintComment = format3.shouldPrintComment || (() => format3.comments)) : format3.shouldPrintComment = format3.shouldPrintComment || ((value2) => format3.comments || value2.includes("@license") || value2.includes("@preserve"));
              "auto" === format3.compact && (format3.compact = "string" == typeof code2 && code2.length > 5e5, format3.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts2.filename} as it exceeds the max of 500KB.`));
              format3.compact && (format3.indent.adjustMultilineComment = false);
              const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } = format3;
              auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore) && (format3.auxiliaryCommentBefore = void 0);
              auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter) && (format3.auxiliaryCommentAfter = void 0);
              return format3;
            }(code, opts);
            super(format2, opts.sourceMaps ? new _sourceMap.default(opts, code) : null), this.ast = void 0, this.ast = ast;
          }
          generate() {
            return super.generate(this.ast);
          }
        }
        exports3.CodeGenerator = class {
          constructor(ast, opts, code) {
            this._generator = void 0, this._generator = new Generator(ast, opts, code);
          }
          generate() {
            return this._generator.generate();
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/node/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.needsParens = function(node, parent, printStack) {
          if (!parent)
            return false;
          if (isNewExpression(parent) && parent.callee === node && isOrHasCallExpression(node))
            return true;
          return find(expandedParens, node, parent, printStack);
        }, exports3.needsWhitespace = needsWhitespace, exports3.needsWhitespaceAfter = function(node, parent) {
          return needsWhitespace(node, parent, 2);
        }, exports3.needsWhitespaceBefore = function(node, parent) {
          return needsWhitespace(node, parent, 1);
        };
        var whitespace = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/node/whitespace.js"), parens = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/node/parentheses.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS, isCallExpression, isExpressionStatement, isMemberExpression, isNewExpression } = _t;
        function expandAliases(obj) {
          const newObj = {};
          function add(type, func) {
            const fn = newObj[type];
            newObj[type] = fn ? function(node, parent, stack) {
              const result = fn(node, parent, stack);
              return null == result ? func(node, parent, stack) : result;
            } : func;
          }
          for (const type of Object.keys(obj)) {
            const aliases = FLIPPED_ALIAS_KEYS[type];
            if (aliases)
              for (const alias of aliases)
                add(alias, obj[type]);
            else
              add(type, obj[type]);
          }
          return newObj;
        }
        const expandedParens = expandAliases(parens), expandedWhitespaceNodes = expandAliases(whitespace.nodes);
        function find(obj, node, parent, printStack) {
          const fn = obj[node.type];
          return fn ? fn(node, parent, printStack) : null;
        }
        function isOrHasCallExpression(node) {
          return !!isCallExpression(node) || isMemberExpression(node) && isOrHasCallExpression(node.object);
        }
        function needsWhitespace(node, parent, type) {
          if (!node)
            return false;
          isExpressionStatement(node) && (node = node.expression);
          const flag = find(expandedWhitespaceNodes, node, parent);
          return "number" == typeof flag && 0 != (flag & type);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/node/parentheses.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ArrowFunctionExpression = function(node, parent) {
          return isExportDeclaration(parent) || ConditionalExpression(node, parent);
        }, exports3.AssignmentExpression = function(node, parent) {
          return !!isObjectPattern(node.left) || ConditionalExpression(node, parent);
        }, exports3.Binary = function(node, parent) {
          if ("**" === node.operator && isBinaryExpression(parent, { operator: "**" }))
            return parent.left === node;
          if (isClassExtendsClause(node, parent))
            return true;
          if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent))
            return true;
          if (isBinary(parent)) {
            const parentOp = parent.operator, parentPos = PRECEDENCE[parentOp], nodeOp = node.operator, nodePos = PRECEDENCE[nodeOp];
            if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos)
              return true;
          }
        }, exports3.BinaryExpression = function(node, parent) {
          return "in" === node.operator && (isVariableDeclarator(parent) || isFor(parent));
        }, exports3.ClassExpression = function(node, parent, printStack) {
          return isFirstInContext(printStack, 5);
        }, exports3.ConditionalExpression = ConditionalExpression, exports3.DoExpression = function(node, parent, printStack) {
          return !node.async && isFirstInContext(printStack, 1);
        }, exports3.FunctionExpression = function(node, parent, printStack) {
          return isFirstInContext(printStack, 5);
        }, exports3.FunctionTypeAnnotation = function(node, parent, printStack) {
          if (printStack.length < 3)
            return;
          return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
        }, exports3.Identifier = function(node, parent, printStack) {
          var _node$extra;
          if (null != (_node$extra = node.extra) && _node$extra.parenthesized && isAssignmentExpression(parent, { left: node }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && null == parent.right.id)
            return true;
          if ("let" === node.name) {
            return isFirstInContext(printStack, isMemberExpression(parent, { object: node, computed: true }) || isOptionalMemberExpression(parent, { object: node, computed: true, optional: false }) ? 57 : 32);
          }
          return "async" === node.name && isForOfStatement(parent) && node === parent.left;
        }, exports3.LogicalExpression = function(node, parent) {
          if (isTSTypeExpression(parent))
            return true;
          switch (node.operator) {
            case "||":
              return !!isLogicalExpression(parent) && ("??" === parent.operator || "&&" === parent.operator);
            case "&&":
              return isLogicalExpression(parent, { operator: "??" });
            case "??":
              return isLogicalExpression(parent) && "??" !== parent.operator;
          }
        }, exports3.NullableTypeAnnotation = function(node, parent) {
          return isArrayTypeAnnotation(parent);
        }, exports3.ObjectExpression = function(node, parent, printStack) {
          return isFirstInContext(printStack, 3);
        }, exports3.OptionalIndexedAccessType = function(node, parent) {
          return isIndexedAccessType(parent, { objectType: node });
        }, exports3.OptionalCallExpression = exports3.OptionalMemberExpression = function(node, parent) {
          return isCallExpression(parent, { callee: node }) || isMemberExpression(parent, { object: node });
        }, exports3.SequenceExpression = function(node, parent) {
          if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node)
            return false;
          return true;
        }, exports3.TSTypeAssertion = exports3.TSSatisfiesExpression = exports3.TSAsExpression = function() {
          return true;
        }, exports3.TSInferType = function(node, parent) {
          return isTSArrayType(parent) || isTSOptionalType(parent);
        }, exports3.TSInstantiationExpression = function(node, parent) {
          return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;
        }, exports3.TSIntersectionType = exports3.TSUnionType = function(node, parent) {
          return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
        }, exports3.UnaryLike = UnaryLike, exports3.IntersectionTypeAnnotation = exports3.UnionTypeAnnotation = function(node, parent) {
          return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
        }, exports3.UpdateExpression = function(node, parent) {
          return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
        }, exports3.AwaitExpression = exports3.YieldExpression = function(node, parent) {
          return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { isArrayTypeAnnotation, isArrowFunctionExpression, isAssignmentExpression, isAwaitExpression, isBinary, isBinaryExpression, isUpdateExpression, isCallExpression, isClass, isClassExpression, isConditional, isConditionalExpression, isExportDeclaration, isExportDefaultDeclaration, isExpressionStatement, isFor, isForInStatement, isForOfStatement, isForStatement, isFunctionExpression, isIfStatement, isIndexedAccessType, isIntersectionTypeAnnotation, isLogicalExpression, isMemberExpression, isNewExpression, isNullableTypeAnnotation, isObjectPattern, isOptionalCallExpression, isOptionalMemberExpression, isReturnStatement, isSequenceExpression, isSwitchStatement, isTSArrayType, isTSAsExpression, isTSInstantiationExpression, isTSIntersectionType, isTSNonNullExpression, isTSOptionalType, isTSRestType, isTSTypeAssertion, isTSUnionType, isTaggedTemplateExpression, isThrowStatement, isTypeAnnotation, isUnaryLike, isUnionTypeAnnotation, isVariableDeclarator, isWhileStatement, isYieldExpression, isTSSatisfiesExpression } = _t, PRECEDENCE = { "||": 0, "??": 0, "|>": 0, "&&": 1, "|": 2, "^": 3, "&": 4, "==": 5, "===": 5, "!=": 5, "!==": 5, "<": 6, ">": 6, "<=": 6, ">=": 6, in: 6, instanceof: 6, ">>": 7, "<<": 7, ">>>": 7, "+": 8, "-": 8, "*": 9, "/": 9, "%": 9, "**": 10 };
        function isTSTypeExpression(node) {
          return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node);
        }
        const isClassExtendsClause = (node, parent) => isClass(parent, { superClass: node }), hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
        function UnaryLike(node, parent) {
          return hasPostfixPart(node, parent) || isBinaryExpression(parent, { operator: "**", left: node }) || isClassExtendsClause(node, parent);
        }
        function ConditionalExpression(node, parent) {
          return !!(isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, { test: node }) || isAwaitExpression(parent) || isTSTypeExpression(parent)) || UnaryLike(node, parent);
        }
        function isFirstInContext(printStack, checkParam) {
          const expressionStatement = 1 & checkParam, arrowBody = 2 & checkParam, exportDefault = 4 & checkParam, forHead = 8 & checkParam, forInHead = 16 & checkParam, forOfHead = 32 & checkParam;
          let i = printStack.length - 1;
          if (i <= 0)
            return;
          let node = printStack[i];
          i--;
          let parent = printStack[i];
          for (; i >= 0; ) {
            if (expressionStatement && isExpressionStatement(parent, { expression: node }) || exportDefault && isExportDefaultDeclaration(parent, { declaration: node }) || arrowBody && isArrowFunctionExpression(parent, { body: node }) || forHead && isForStatement(parent, { init: node }) || forInHead && isForInStatement(parent, { left: node }) || forOfHead && isForOfStatement(parent, { left: node }))
              return true;
            if (!(i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, { test: node }) || isBinary(parent, { left: node }) || isAssignmentExpression(parent, { left: node }))))
              return false;
            node = parent, i--, parent = printStack[i];
          }
          return false;
        }
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/node/whitespace.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.nodes = void 0;
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS, isArrayExpression, isAssignmentExpression, isBinary, isBlockStatement, isCallExpression, isFunction: isFunction2, isIdentifier, isLiteral, isMemberExpression, isObjectExpression, isOptionalCallExpression, isOptionalMemberExpression, isStringLiteral } = _t;
        function crawlInternal(node, state) {
          return node ? (isMemberExpression(node) || isOptionalMemberExpression(node) ? (crawlInternal(node.object, state), node.computed && crawlInternal(node.property, state)) : isBinary(node) || isAssignmentExpression(node) ? (crawlInternal(node.left, state), crawlInternal(node.right, state)) : isCallExpression(node) || isOptionalCallExpression(node) ? (state.hasCall = true, crawlInternal(node.callee, state)) : isFunction2(node) ? state.hasFunction = true : isIdentifier(node) && (state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee)), state) : state;
        }
        function crawl(node) {
          return crawlInternal(node, { hasCall: false, hasFunction: false, hasHelper: false });
        }
        function isHelper(node) {
          return !!node && (isMemberExpression(node) ? isHelper(node.object) || isHelper(node.property) : isIdentifier(node) ? "require" === node.name || 95 === node.name.charCodeAt(0) : isCallExpression(node) ? isHelper(node.callee) : !(!isBinary(node) && !isAssignmentExpression(node)) && (isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right)));
        }
        function isType(node) {
          return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
        }
        const nodes = { AssignmentExpression(node) {
          const state = crawl(node.right);
          if (state.hasCall && state.hasHelper || state.hasFunction)
            return state.hasFunction ? 3 : 2;
        }, SwitchCase: (node, parent) => (node.consequent.length || parent.cases[0] === node ? 1 : 0) | (node.consequent.length || parent.cases[parent.cases.length - 1] !== node ? 0 : 2), LogicalExpression(node) {
          if (isFunction2(node.left) || isFunction2(node.right))
            return 2;
        }, Literal(node) {
          if (isStringLiteral(node) && "use strict" === node.value)
            return 2;
        }, CallExpression(node) {
          if (isFunction2(node.callee) || isHelper(node))
            return 3;
        }, OptionalCallExpression(node) {
          if (isFunction2(node.callee))
            return 3;
        }, VariableDeclaration(node) {
          for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            let enabled = isHelper(declar.id) && !isType(declar.init);
            if (!enabled && declar.init) {
              const state = crawl(declar.init);
              enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
            }
            if (enabled)
              return 3;
          }
        }, IfStatement(node) {
          if (isBlockStatement(node.consequent))
            return 3;
        } };
        exports3.nodes = nodes, nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
          if (parent.properties[0] === node)
            return 1;
        }, nodes.ObjectTypeCallProperty = function(node, parent) {
          var _parent$properties;
          if (parent.callProperties[0] === node && (null == (_parent$properties = parent.properties) || !_parent$properties.length))
            return 1;
        }, nodes.ObjectTypeIndexer = function(node, parent) {
          var _parent$properties2, _parent$callPropertie;
          if (!(parent.indexers[0] !== node || null != (_parent$properties2 = parent.properties) && _parent$properties2.length || null != (_parent$callPropertie = parent.callProperties) && _parent$callPropertie.length))
            return 1;
        }, nodes.ObjectTypeInternalSlot = function(node, parent) {
          var _parent$properties3, _parent$callPropertie2, _parent$indexers;
          if (!(parent.internalSlots[0] !== node || null != (_parent$properties3 = parent.properties) && _parent$properties3.length || null != (_parent$callPropertie2 = parent.callProperties) && _parent$callPropertie2.length || null != (_parent$indexers = parent.indexers) && _parent$indexers.length))
            return 1;
        }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
          [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
            const ret = amounts ? 3 : 0;
            nodes[type2] = () => ret;
          });
        });
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/printer.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _buffer = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/buffer.js"), n = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/node/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), generatorFunctions = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/generators/index.js");
        const { isFunction: isFunction2, isStatement, isClassBody, isTSInterfaceBody, isTSEnumDeclaration } = _t, SCIENTIFIC_NOTATION = /e/i, ZERO_DECIMAL_INTEGER = /\.0+$/, NON_DECIMAL_LITERAL = /^0[box]/, PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/, HAS_NEWLINE = /[\n\r\u2028\u2029]/, HAS_BlOCK_COMMENT_END = /\*\//, { needsParens } = n;
        class Printer {
          constructor(format2, map) {
            this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentChar = 0, this._indentRepeat = 0, this._insideAux = false, this._parenPushNewlineState = null, this._noLineTerminator = false, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = false, this._endsWithWord = false, this._lastCommentLine = 0, this._endsWithInnerRaw = false, this._indentInnerComments = true, this.format = format2, this._buf = new _buffer.default(map), this._indentChar = format2.indent.style.charCodeAt(0), this._indentRepeat = format2.indent.style.length, this._inputMap = null == map ? void 0 : map._inputMap;
          }
          generate(ast) {
            return this.print(ast), this._maybeAddAuxComment(), this._buf.get();
          }
          indent() {
            this.format.compact || this.format.concise || this._indent++;
          }
          dedent() {
            this.format.compact || this.format.concise || this._indent--;
          }
          semicolon(force = false) {
            this._maybeAddAuxComment(), force ? this._appendChar(59) : this._queue(59), this._noLineTerminator = false;
          }
          rightBrace(node) {
            this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", node.loc, 0, -1), this.tokenChar(125);
          }
          rightParens(node) {
            this.sourceWithOffset("end", node.loc, 0, -1), this.tokenChar(41);
          }
          space(force = false) {
            if (!this.format.compact) {
              if (force)
                this._space();
              else if (this._buf.hasContent()) {
                const lastCp = this.getLastChar();
                32 !== lastCp && 10 !== lastCp && this._space();
              }
            }
          }
          word(str, noLineTerminatorAfter = false) {
            this._maybePrintInnerComments(), (this._endsWithWord || 47 === str.charCodeAt(0) && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(str, false), this._endsWithWord = true, this._noLineTerminator = noLineTerminatorAfter;
          }
          number(str) {
            this.word(str), this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && 46 !== str.charCodeAt(str.length - 1);
          }
          token(str, maybeNewline = false) {
            this._maybePrintInnerComments();
            const lastChar = this.getLastChar(), strFirst = str.charCodeAt(0);
            (33 === lastChar && ("--" === str || 61 === strFirst) || 43 === strFirst && 43 === lastChar || 45 === strFirst && 45 === lastChar || 46 === strFirst && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(str, maybeNewline), this._noLineTerminator = false;
          }
          tokenChar(char) {
            this._maybePrintInnerComments();
            const lastChar = this.getLastChar();
            (43 === char && 43 === lastChar || 45 === char && 45 === lastChar || 46 === char && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(char), this._noLineTerminator = false;
          }
          newline(i = 1, force) {
            if (!(i <= 0)) {
              if (!force) {
                if (this.format.retainLines || this.format.compact)
                  return;
                if (this.format.concise)
                  return void this.space();
              }
              i > 2 && (i = 2), i -= this._buf.getNewlineCount();
              for (let j = 0; j < i; j++)
                this._newline();
            }
          }
          endsWith(char) {
            return this.getLastChar() === char;
          }
          getLastChar() {
            return this._buf.getLastChar();
          }
          endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
          removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
          exactSource(loc, cb) {
            loc ? (this._catchUp("start", loc), this._buf.exactSource(loc, cb)) : cb();
          }
          source(prop, loc) {
            loc && (this._catchUp(prop, loc), this._buf.source(prop, loc));
          }
          sourceWithOffset(prop, loc, lineOffset, columnOffset) {
            loc && (this._catchUp(prop, loc), this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset));
          }
          withSource(prop, loc, cb) {
            loc ? (this._catchUp(prop, loc), this._buf.withSource(prop, loc, cb)) : cb();
          }
          sourceIdentifierName(identifierName, pos) {
            if (!this._buf._canMarkIdName)
              return;
            const sourcePosition = this._buf._sourcePosition;
            sourcePosition.identifierNamePos = pos, sourcePosition.identifierName = identifierName;
          }
          _space() {
            this._queue(32);
          }
          _newline() {
            this._queue(10);
          }
          _append(str, maybeNewline) {
            this._maybeAddParen(str), this._maybeIndent(str.charCodeAt(0)), this._buf.append(str, maybeNewline), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _appendChar(char) {
            this._maybeAddParenChar(char), this._maybeIndent(char), this._buf.appendChar(char), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _queue(char) {
            this._maybeAddParenChar(char), this._maybeIndent(char), this._buf.queue(char), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _maybeIndent(firstChar) {
            this._indent && 10 !== firstChar && this.endsWith(10) && this._buf.queueIndentation(this._indentChar, this._getIndent());
          }
          _shouldIndent(firstChar) {
            if (this._indent && 10 !== firstChar && this.endsWith(10))
              return true;
          }
          _maybeAddParenChar(char) {
            const parenPushNewlineState = this._parenPushNewlineState;
            parenPushNewlineState && 32 !== char && (10 === char ? (this.tokenChar(40), this.indent(), parenPushNewlineState.printed = true) : this._parenPushNewlineState = null);
          }
          _maybeAddParen(str) {
            const parenPushNewlineState = this._parenPushNewlineState;
            if (!parenPushNewlineState)
              return;
            const len = str.length;
            let i;
            for (i = 0; i < len && 32 === str.charCodeAt(i); i++)
              continue;
            if (i === len)
              return;
            const cha = str.charCodeAt(i);
            if (10 !== cha) {
              if (47 !== cha || i + 1 === len)
                return void (this._parenPushNewlineState = null);
              const chaPost = str.charCodeAt(i + 1);
              if (42 === chaPost) {
                if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2)))
                  return;
              } else if (47 !== chaPost)
                return void (this._parenPushNewlineState = null);
            }
            this.tokenChar(40), this.indent(), parenPushNewlineState.printed = true;
          }
          catchUp(line) {
            if (!this.format.retainLines)
              return;
            const count = line - this._buf.getCurrentLine();
            for (let i = 0; i < count; i++)
              this._newline();
          }
          _catchUp(prop, loc) {
            var _loc$prop;
            if (!this.format.retainLines)
              return;
            const line = null == loc || null == (_loc$prop = loc[prop]) ? void 0 : _loc$prop.line;
            if (null != line) {
              const count = line - this._buf.getCurrentLine();
              for (let i = 0; i < count; i++)
                this._newline();
            }
          }
          _getIndent() {
            return this._indentRepeat * this._indent;
          }
          printTerminatorless(node, parent, isLabel) {
            if (isLabel)
              this._noLineTerminator = true, this.print(node, parent);
            else {
              const terminatorState = { printed: false };
              this._parenPushNewlineState = terminatorState, this.print(node, parent), terminatorState.printed && (this.dedent(), this.newline(), this.tokenChar(41));
            }
          }
          print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {
            var _node$extra;
            if (!node)
              return;
            this._endsWithInnerRaw = false;
            const nodeType = node.type, format2 = this.format, oldConcise = format2.concise;
            node._compact && (format2.concise = true);
            const printMethod = this[nodeType];
            if (void 0 === printMethod)
              throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
            this._printStack.push(node);
            const oldInAux = this._insideAux;
            this._insideAux = null == node.loc, this._maybeAddAuxComment(this._insideAux && !oldInAux);
            const shouldPrintParens = forceParens || format2.retainFunctionParens && "FunctionExpression" === nodeType && (null == (_node$extra = node.extra) ? void 0 : _node$extra.parenthesized) || needsParens(node, parent, this._printStack);
            shouldPrintParens && (this.tokenChar(40), this._endsWithInnerRaw = false), this._lastCommentLine = 0, this._printLeadingComments(node, parent);
            const loc = "Program" === nodeType || "File" === nodeType ? null : node.loc;
            this.exactSource(loc, printMethod.bind(this, node, parent)), shouldPrintParens ? (this._printTrailingComments(node, parent), this.tokenChar(41), this._noLineTerminator = noLineTerminatorAfter) : noLineTerminatorAfter && !this._noLineTerminator ? (this._noLineTerminator = true, this._printTrailingComments(node, parent)) : this._printTrailingComments(node, parent, trailingCommentsLineOffset), this._printStack.pop(), format2.concise = oldConcise, this._insideAux = oldInAux, this._endsWithInnerRaw = false;
          }
          _maybeAddAuxComment(enteredPositionlessNode) {
            enteredPositionlessNode && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
          }
          _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = true;
            const comment = this.format.auxiliaryCommentBefore;
            comment && this._printComment({ type: "CommentBlock", value: comment }, 0);
          }
          _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = false;
            const comment = this.format.auxiliaryCommentAfter;
            comment && this._printComment({ type: "CommentBlock", value: comment }, 0);
          }
          getPossibleRaw(node) {
            const extra = node.extra;
            if (extra && null != extra.raw && null != extra.rawValue && node.value === extra.rawValue)
              return extra.raw;
          }
          printJoin(nodes, parent, opts = {}) {
            if (null == nodes || !nodes.length)
              return;
            let { indent } = opts;
            if (null == indent && this.format.retainLines) {
              var _nodes$0$loc;
              const startLine = null == (_nodes$0$loc = nodes[0].loc) ? void 0 : _nodes$0$loc.start.line;
              null != startLine && startLine !== this._buf.getCurrentLine() && (indent = true);
            }
            indent && this.indent();
            const newlineOpts = { addNewlines: opts.addNewlines, nextNodeStartLine: 0 }, separator = opts.separator ? opts.separator.bind(this) : null, len = nodes.length;
            for (let i = 0; i < len; i++) {
              const node = nodes[i];
              if (node && (opts.statement && this._printNewline(0 === i, newlineOpts), this.print(node, parent, void 0, opts.trailingCommentsLineOffset || 0), null == opts.iterator || opts.iterator(node, i), i < len - 1 && (null == separator || separator()), opts.statement))
                if (i + 1 === len)
                  this.newline(1);
                else {
                  var _nextNode$loc;
                  const nextNode = nodes[i + 1];
                  newlineOpts.nextNodeStartLine = (null == (_nextNode$loc = nextNode.loc) ? void 0 : _nextNode$loc.start.line) || 0, this._printNewline(true, newlineOpts);
                }
            }
            indent && this.dedent();
          }
          printAndIndentOnComments(node, parent) {
            const indent = node.leadingComments && node.leadingComments.length > 0;
            indent && this.indent(), this.print(node, parent), indent && this.dedent();
          }
          printBlock(parent) {
            const node = parent.body;
            "EmptyStatement" !== node.type && this.space(), this.print(node, parent);
          }
          _printTrailingComments(node, parent, lineOffset) {
            const { innerComments, trailingComments } = node;
            null != innerComments && innerComments.length && this._printComments(2, innerComments, node, parent, lineOffset), null != trailingComments && trailingComments.length && this._printComments(2, trailingComments, node, parent, lineOffset);
          }
          _printLeadingComments(node, parent) {
            const comments = node.leadingComments;
            null != comments && comments.length && this._printComments(0, comments, node, parent);
          }
          _maybePrintInnerComments() {
            this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = true, this._indentInnerComments = true;
          }
          printInnerComments() {
            const node = this._printStack[this._printStack.length - 1], comments = node.innerComments;
            if (null == comments || !comments.length)
              return;
            const hasSpace = this.endsWith(32), indent = this._indentInnerComments, printedCommentsCount = this._printedComments.size;
            indent && this.indent(), this._printComments(1, comments, node), hasSpace && printedCommentsCount !== this._printedComments.size && this.space(), indent && this.dedent();
          }
          noIndentInnerCommentsHere() {
            this._indentInnerComments = false;
          }
          printSequence(nodes, parent, opts = {}) {
            opts.statement = true, null != opts.indent || (opts.indent = false), this.printJoin(nodes, parent, opts);
          }
          printList(items, parent, opts = {}) {
            null == opts.separator && (opts.separator = commaSeparator), this.printJoin(items, parent, opts);
          }
          _printNewline(newLine, opts) {
            const format2 = this.format;
            if (format2.retainLines || format2.compact)
              return;
            if (format2.concise)
              return void this.space();
            if (!newLine)
              return;
            const startLine = opts.nextNodeStartLine, lastCommentLine = this._lastCommentLine;
            if (startLine > 0 && lastCommentLine > 0) {
              const offset2 = startLine - lastCommentLine;
              if (offset2 >= 0)
                return void this.newline(offset2 || 1);
            }
            this._buf.hasContent() && this.newline(1);
          }
          _shouldPrintComment(comment) {
            return comment.ignore || this._printedComments.has(comment) ? 0 : this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value)) ? 2 : (this._printedComments.add(comment), this.format.shouldPrintComment(comment.value) ? 1 : 0);
          }
          _printComment(comment, skipNewLines) {
            const noLineTerminator = this._noLineTerminator, isBlockComment = "CommentBlock" === comment.type, printNewLines = isBlockComment && 1 !== skipNewLines && !this._noLineTerminator;
            printNewLines && this._buf.hasContent() && 2 !== skipNewLines && this.newline(1);
            const lastCharCode = this.getLastChar();
            let val;
            if (91 !== lastCharCode && 123 !== lastCharCode && this.space(), isBlockComment) {
              if (val = `/*${comment.value}*/`, this.format.indent.adjustMultilineComment) {
                var _comment$loc;
                const offset2 = null == (_comment$loc = comment.loc) ? void 0 : _comment$loc.start.column;
                if (offset2) {
                  const newlineRegex = new RegExp("\\n\\s{1," + offset2 + "}", "g");
                  val = val.replace(newlineRegex, "\n");
                }
                let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                (this._shouldIndent(47) || this.format.retainLines) && (indentSize += this._getIndent()), val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
              }
            } else
              val = noLineTerminator ? `/*${comment.value}*/` : `//${comment.value}`;
            this.endsWith(47) && this._space(), this.source("start", comment.loc), this._append(val, isBlockComment), isBlockComment || noLineTerminator || this.newline(1, true), printNewLines && 3 !== skipNewLines && this.newline(1);
          }
          _printComments(type, comments, node, parent, lineOffset = 0) {
            const nodeLoc = node.loc, len = comments.length;
            let hasLoc = !!nodeLoc;
            const nodeStartLine = hasLoc ? nodeLoc.start.line : 0, nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
            let lastLine = 0, leadingCommentNewline = 0;
            const maybeNewline = this._noLineTerminator ? function() {
            } : this.newline.bind(this);
            for (let i = 0; i < len; i++) {
              const comment = comments[i], shouldPrint = this._shouldPrintComment(comment);
              if (2 === shouldPrint) {
                hasLoc = false;
                break;
              }
              if (hasLoc && comment.loc && 1 === shouldPrint) {
                const commentStartLine = comment.loc.start.line, commentEndLine = comment.loc.end.line;
                if (0 === type) {
                  let offset2 = 0;
                  0 === i ? !this._buf.hasContent() || "CommentLine" !== comment.type && commentStartLine == commentEndLine || (offset2 = leadingCommentNewline = 1) : offset2 = commentStartLine - lastLine, lastLine = commentEndLine, maybeNewline(offset2), this._printComment(comment, 1), i + 1 === len && (maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline)), lastLine = nodeStartLine);
                } else if (1 === type) {
                  const offset2 = commentStartLine - (0 === i ? nodeStartLine : lastLine);
                  lastLine = commentEndLine, maybeNewline(offset2), this._printComment(comment, 1), i + 1 === len && (maybeNewline(Math.min(1, nodeEndLine - lastLine)), lastLine = nodeEndLine);
                } else {
                  const offset2 = commentStartLine - (0 === i ? nodeEndLine - lineOffset : lastLine);
                  lastLine = commentEndLine, maybeNewline(offset2), this._printComment(comment, 1);
                }
              } else {
                if (hasLoc = false, 1 !== shouldPrint)
                  continue;
                if (1 === len) {
                  const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value), shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);
                  0 === type ? this._printComment(comment, shouldSkipNewline && "ObjectExpression" !== node.type || singleLine && isFunction2(parent, { body: node }) ? 1 : 0) : shouldSkipNewline && 2 === type ? this._printComment(comment, 1) : this._printComment(comment, 0);
                } else
                  1 !== type || "ObjectExpression" === node.type && node.properties.length > 1 || "ClassBody" === node.type || "TSInterfaceBody" === node.type ? this._printComment(comment, 0) : this._printComment(comment, 0 === i ? 2 : i === len - 1 ? 3 : 0);
              }
            }
            2 === type && hasLoc && lastLine && (this._lastCommentLine = lastLine);
          }
        }
        Object.assign(Printer.prototype, generatorFunctions), Printer.prototype.Noop = function() {
        };
        var _default = Printer;
        function commaSeparator() {
          this.tokenChar(44), this.space();
        }
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/source-map.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _genMapping = __webpack_require__2("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"), _traceMapping = __webpack_require__2("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.18/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js");
        exports3.default = class {
          constructor(opts, code) {
            var _opts$sourceFileName;
            this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
            const map = this._map = new _genMapping.GenMapping({ sourceRoot: opts.sourceRoot });
            if (this._sourceFileName = null == (_opts$sourceFileName = opts.sourceFileName) ? void 0 : _opts$sourceFileName.replace(/\\/g, "/"), this._rawMappings = void 0, opts.inputSourceMap) {
              this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
              const resolvedSources = this._inputMap.resolvedSources;
              if (resolvedSources.length)
                for (let i = 0; i < resolvedSources.length; i++) {
                  var _this$_inputMap$sourc;
                  (0, _genMapping.setSourceContent)(map, resolvedSources[i], null == (_this$_inputMap$sourc = this._inputMap.sourcesContent) ? void 0 : _this$_inputMap$sourc[i]);
                }
            }
            if ("string" != typeof code || opts.inputSourceMap) {
              if ("object" == typeof code)
                for (const sourceFileName of Object.keys(code))
                  (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
            } else
              (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
          }
          get() {
            return (0, _genMapping.toEncodedMap)(this._map);
          }
          getDecoded() {
            return (0, _genMapping.toDecodedMap)(this._map);
          }
          getRawMappings() {
            return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
          }
          mark(generated, line, column, identifierName, identifierNamePos, filename) {
            var _originalMapping;
            let originalMapping;
            if (this._rawMappings = void 0, null != line)
              if (this._inputMap) {
                if (originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, { line, column }), !originalMapping.name && identifierNamePos) {
                  const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
                  originalIdentifierMapping.name && (identifierName = originalIdentifierMapping.name);
                }
              } else
                originalMapping = { source: (null == filename ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName, line, column };
            (0, _genMapping.maybeAddMapping)(this._map, { name: identifierName, generated, source: null == (_originalMapping = originalMapping) ? void 0 : _originalMapping.source, original: originalMapping });
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.22.5/node_modules/@babel/helper-annotate-as-pure/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(pathOrNode) {
          const node = pathOrNode.node || pathOrNode;
          if (isPureAnnotated(node))
            return;
          addComment(node, "leading", PURE_ANNOTATION);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { addComment } = _t, PURE_ANNOTATION = "#__PURE__", isPureAnnotated = ({ leadingComments }) => !!leadingComments && leadingComments.some((comment) => /[@#]__PURE__/.test(comment.value));
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.buildDecoratedClass = function(ref2, path3, elements, file) {
          const { node, scope } = path3, initializeId = scope.generateUidIdentifier("initialize"), isDeclaration = node.id && path3.isDeclaration(), isStrict = path3.isInStrictMode(), { superClass } = node;
          node.type = "ClassDeclaration", node.id || (node.id = _core.types.cloneNode(ref2));
          let superId;
          superClass && (superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super"), node.superClass = superId);
          const classDecorators = takeDecorators(node), definitions = _core.types.arrayExpression(elements.filter((element) => !element.node.abstract && "TSIndexSignature" !== element.node.type).map((path4) => function(file2, classRef, superRef, path5) {
            const isMethod = path5.isClassMethod();
            if (path5.isPrivate())
              throw path5.buildCodeFrameError(`Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`);
            if ("ClassAccessorProperty" === path5.node.type)
              throw path5.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            if ("StaticBlock" === path5.node.type)
              throw path5.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            const { node: node2, scope: scope2 } = path5;
            path5.isTSDeclareMethod() || new _helperReplaceSupers.default({ methodPath: path5, objectRef: classRef, superRef, file: file2, refToPreserve: classRef }).replace();
            const properties = [prop("kind", _core.types.stringLiteral(_core.types.isClassMethod(node2) ? node2.kind : "field")), prop("decorators", takeDecorators(node2)), prop("static", node2.static && _core.types.booleanLiteral(true)), prop("key", getKey(node2))].filter(Boolean);
            if (_core.types.isClassMethod(node2)) {
              const id = node2.computed ? null : node2.key, transformed = _core.types.toExpression(node2);
              properties.push(prop("value", (0, _helperFunctionName.default)({ node: transformed, id, scope: scope2 }) || transformed));
            } else
              _core.types.isClassProperty(node2) && node2.value ? properties.push((key = "value", body = _core.template.statements.ast`return ${node2.value}`, _core.types.objectMethod("method", _core.types.identifier(key), [], _core.types.blockStatement(body)))) : properties.push(prop("value", scope2.buildUndefinedNode()));
            var key, body;
            return path5.remove(), _core.types.objectExpression(properties);
          }(file, node.id, superId, path4))), wrapperCall = _core.template.expression.ast`
    ${function(file2) {
            return file2.addHelper("decorate");
          }(file)}(
      ${classDecorators || _core.types.nullLiteral()},
      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;
          isStrict || wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
          let replacement = wrapperCall, classPathDesc = "arguments.1.body.body.0";
          isDeclaration && (replacement = _core.template.statement.ast`let ${ref2} = ${wrapperCall}`, classPathDesc = "declarations.0.init." + classPathDesc);
          return { instanceNodes: [_core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)`], wrapClass: (path4) => (path4.replaceWith(replacement), path4.get(classPathDesc)) };
        }, exports3.hasDecorators = function(node) {
          return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
        }, exports3.hasOwnDecorators = hasOwnDecorators;
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _helperReplaceSupers = __webpack_require__2("./node_modules/.pnpm/@babel+helper-replace-supers@7.22.5/node_modules/@babel/helper-replace-supers/lib/index.js"), _helperFunctionName = __webpack_require__2("./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js");
        function hasOwnDecorators(node) {
          return !(!node.decorators || !node.decorators.length);
        }
        function prop(key, value2) {
          return value2 ? _core.types.objectProperty(_core.types.identifier(key), value2) : null;
        }
        function takeDecorators(node) {
          let result;
          return node.decorators && node.decorators.length > 0 && (result = _core.types.arrayExpression(node.decorators.map((decorator) => decorator.expression))), node.decorators = void 0, result;
        }
        function getKey(node) {
          return node.computed ? node.key : _core.types.isIdentifier(node.key) ? _core.types.stringLiteral(node.key.name) : _core.types.stringLiteral(String(node.key.value));
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/features.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.FEATURES = void 0, exports3.enableFeature = function(file, feature, loose) {
          hasFeature(file, feature) && !canIgnoreLoose(file, feature) || (file.set(featuresKey, file.get(featuresKey) | feature), "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" === loose ? (setLoose(file, feature, true), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" === loose ? (setLoose(file, feature, false), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : setLoose(file, feature, loose));
          let resolvedLoose, higherPriorityPluginName;
          for (const [mask, name] of featuresSameLoose) {
            if (!hasFeature(file, mask))
              continue;
            const loose2 = isLoose(file, mask);
            if (!canIgnoreLoose(file, mask)) {
              if (resolvedLoose === !loose2)
                throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");
              resolvedLoose = loose2, higherPriorityPluginName = name;
            }
          }
          if (void 0 !== resolvedLoose)
            for (const [mask, name] of featuresSameLoose)
              hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose && (setLoose(file, mask, resolvedLoose), console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${name}", { "loose": ${resolvedLoose} }]
to the "plugins" section of your Babel config.`));
        }, exports3.isLoose = isLoose, exports3.shouldTransform = function(path3, file) {
          let decoratorPath = null, publicFieldPath = null, privateFieldPath = null, privateMethodPath = null, staticBlockPath = null;
          (0, _decorators.hasOwnDecorators)(path3.node) && (decoratorPath = path3.get("decorators.0"));
          for (const el of path3.get("body.body"))
            !decoratorPath && (0, _decorators.hasOwnDecorators)(el.node) && (decoratorPath = el.get("decorators.0")), !publicFieldPath && el.isClassProperty() && (publicFieldPath = el), !privateFieldPath && el.isClassPrivateProperty() && (privateFieldPath = el), !privateMethodPath && null != el.isClassPrivateMethod && el.isClassPrivateMethod() && (privateMethodPath = el), !staticBlockPath && null != el.isStaticBlock && el.isStaticBlock() && (staticBlockPath = el);
          if (decoratorPath && privateFieldPath)
            throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
          if (decoratorPath && privateMethodPath)
            throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
          if (decoratorPath && !hasFeature(file, FEATURES.decorators))
            throw path3.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n	["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n	["@babel/plugin-transform-class-properties", { "loose": true }]');
          if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods))
            throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
          if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods))
            throw path3.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
          if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks))
            throw path3.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
          if (decoratorPath || privateMethodPath || staticBlockPath)
            return true;
          if ((publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields))
            return true;
          return false;
        };
        var _decorators = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js");
        const FEATURES = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 });
        exports3.FEATURES = FEATURES;
        const featuresSameLoose = /* @__PURE__ */ new Map([[FEATURES.fields, "@babel/plugin-transform-class-properties"], [FEATURES.privateMethods, "@babel/plugin-transform-private-methods"], [FEATURES.privateIn, "@babel/plugin-transform-private-property-in-object"]]), featuresKey = "@babel/plugin-class-features/featuresKey", looseKey = "@babel/plugin-class-features/looseKey", looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
        function hasFeature(file, feature) {
          return !!(file.get(featuresKey) & feature);
        }
        function isLoose(file, feature) {
          return !!(file.get(looseKey) & feature);
        }
        function setLoose(file, feature, loose) {
          loose ? file.set(looseKey, file.get(looseKey) | feature) : file.set(looseKey, file.get(looseKey) & ~feature), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
        }
        function canIgnoreLoose(file, feature) {
          return !!(file.get(looseLowPriorityKey) & feature);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.buildCheckInRHS = buildCheckInRHS, exports3.buildFieldsInitNodes = function(ref2, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {
          let injectSuperRef, needsClassRef = false;
          const staticNodes = [], instanceNodes = [], pureStaticNodes = [], getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => (null != injectSuperRef || (injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef)), injectSuperRef);
          for (const prop of props) {
            prop.isClassProperty() && ts.assertFieldTransformed(prop);
            const isStatic = !(null != _core.types.isStaticBlock && _core.types.isStaticBlock(prop.node)) && prop.node.static, isInstance = !isStatic, isPrivate = prop.isPrivate(), isPublic = !isPrivate, isField = prop.isProperty(), isMethod = !isField, isStaticBlock = null == prop.isStaticBlock ? void 0 : prop.isStaticBlock();
            if (isStatic || isMethod && isPrivate || isStaticBlock) {
              const replaced = replaceThisContext(prop, ref2, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);
              needsClassRef = needsClassRef || replaced;
            }
            switch (true) {
              case isStaticBlock: {
                const blockBody = prop.node.body;
                1 === blockBody.length && _core.types.isExpressionStatement(blockBody[0]) ? staticNodes.push(inheritPropComments(blockBody[0], prop)) : staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`, prop.node));
                break;
              }
              case (isStatic && isPrivate && isField && privateFieldsAsProperties):
                needsClassRef = true, staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref2), prop, privateNamesMap));
                break;
              case (isStatic && isPrivate && isField && !privateFieldsAsProperties):
                needsClassRef = true, staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
                break;
              case (isStatic && isPublic && isField && setPublicClassFields):
                if (!isNameOrLength(prop.node)) {
                  needsClassRef = true, staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref2), prop));
                  break;
                }
              case (isStatic && isPublic && isField && !setPublicClassFields):
                needsClassRef = true, staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref2), prop, state));
                break;
              case (isInstance && isPrivate && isField && privateFieldsAsProperties):
                instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
                break;
              case (isInstance && isPrivate && isField && !privateFieldsAsProperties):
                instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));
                break;
              case (isInstance && isPrivate && isMethod && privateFieldsAsProperties):
                instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isInstance && isPrivate && isMethod && !privateFieldsAsProperties):
                instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isStatic && isPrivate && isMethod && !privateFieldsAsProperties):
                needsClassRef = true, staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isStatic && isPrivate && isMethod && privateFieldsAsProperties):
                needsClassRef = true, staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref2), prop, state, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isInstance && isPublic && isField && setPublicClassFields):
                instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
                break;
              case (isInstance && isPublic && isField && !setPublicClassFields):
                instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));
                break;
              default:
                throw new Error("Unreachable.");
            }
          }
          return { staticNodes: staticNodes.filter(Boolean), instanceNodes: instanceNodes.filter(Boolean), pureStaticNodes: pureStaticNodes.filter(Boolean), wrapClass(path3) {
            for (const prop of props)
              prop.node.leadingComments = null, prop.remove();
            return injectSuperRef && (path3.scope.push({ id: _core.types.cloneNode(injectSuperRef) }), path3.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path3.node.superClass))), needsClassRef ? (path3.isClassExpression() ? (path3.scope.push({ id: ref2 }), path3.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref2), path3.node))) : path3.node.id || (path3.node.id = ref2), path3) : path3;
          } };
        }, exports3.buildPrivateNamesMap = function(props) {
          const privateNamesMap = /* @__PURE__ */ new Map();
          for (const prop of props)
            if (prop.isPrivate()) {
              const { name } = prop.node.key.id, update = privateNamesMap.has(name) ? privateNamesMap.get(name) : { id: prop.scope.generateUidIdentifier(name), static: prop.node.static, method: !prop.isProperty() };
              prop.isClassPrivateMethod() && ("get" === prop.node.kind ? update.getId = prop.scope.generateUidIdentifier(`get_${name}`) : "set" === prop.node.kind ? update.setId = prop.scope.generateUidIdentifier(`set_${name}`) : "method" === prop.node.kind && (update.methodId = prop.scope.generateUidIdentifier(name))), privateNamesMap.set(name, update);
            }
          return privateNamesMap;
        }, exports3.buildPrivateNamesNodes = function(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {
          const initNodes = [];
          for (const [name, value2] of privateNamesMap) {
            const { static: isStatic, method: isMethod, getId, setId } = value2, isAccessor = getId || setId, id = _core.types.cloneNode(value2.id);
            let init;
            privateFieldsAsProperties ? init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [_core.types.stringLiteral(name)]) : privateFieldsAsSymbols ? init = _core.types.callExpression(_core.types.identifier("Symbol"), [_core.types.stringLiteral(name)]) : isStatic || (init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), [])), init && ((0, _helperAnnotateAsPure.default)(init), initNodes.push(_core.template.statement.ast`var ${id} = ${init}`));
          }
          return initNodes;
        }, exports3.transformPrivateNamesUsage = function(ref2, path3, privateNamesMap, { privateFieldsAsProperties, noDocumentAll, innerBinding }, state) {
          if (!privateNamesMap.size)
            return;
          const body = path3.get("body"), handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
          (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({ privateNamesMap, classRef: ref2, file: state }, handler, { noDocumentAll, innerBinding })), body.traverse(privateInVisitor, { privateNamesMap, classRef: ref2, file: state, privateFieldsAsProperties, innerBinding });
        };
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _helperReplaceSupers = __webpack_require__2("./node_modules/.pnpm/@babel+helper-replace-supers@7.22.5/node_modules/@babel/helper-replace-supers/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), _helperMemberExpressionToFunctions = __webpack_require__2("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.22.5/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), _helperOptimiseCallExpression = __webpack_require__2("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.22.5/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), _helperAnnotateAsPure = __webpack_require__2("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.22.5/node_modules/@babel/helper-annotate-as-pure/lib/index.js"), _helperSkipTransparentExpressionWrappers = __webpack_require__2("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.22.5/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), ts = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        function privateNameVisitorFactory(visitor) {
          const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor.default]), privateNameVisitor2 = Object.assign({}, visitor, { Class(path3) {
            const { privateNamesMap } = this, body = path3.get("body.body"), visiblePrivateNames = new Map(privateNamesMap), redeclared = [];
            for (const prop of body) {
              if (!prop.isPrivate())
                continue;
              const { name } = prop.node.key.id;
              visiblePrivateNames.delete(name), redeclared.push(name);
            }
            redeclared.length && (path3.get("body").traverse(nestedVisitor, Object.assign({}, this, { redeclared })), path3.traverse(privateNameVisitor2, Object.assign({}, this, { privateNamesMap: visiblePrivateNames })), path3.skipKey("body"));
          } });
          return privateNameVisitor2;
        }
        const privateNameVisitor = privateNameVisitorFactory({ PrivateName(path3, { noDocumentAll }) {
          const { privateNamesMap, redeclared } = this, { node, parentPath } = path3;
          if (!parentPath.isMemberExpression({ property: node }) && !parentPath.isOptionalMemberExpression({ property: node }))
            return;
          const { name } = node.id;
          privateNamesMap.has(name) && (redeclared && redeclared.includes(name) || this.handle(parentPath, noDocumentAll));
        } });
        function unshadow(name, scope, innerBinding) {
          for (; null != (_scope = scope) && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding); ) {
            var _scope;
            scope.rename(name), scope = scope.parent;
          }
        }
        function buildCheckInRHS(rhs, file, inRHSIsObject) {
          return inRHSIsObject || null == file.availableHelper || !file.availableHelper("checkInRHS") ? rhs : _core.types.callExpression(file.addHelper("checkInRHS"), [rhs]);
        }
        const privateInVisitor = privateNameVisitorFactory({ BinaryExpression(path3, { file }) {
          const { operator, left, right } = path3.node;
          if ("in" !== operator)
            return;
          if (!_core.types.isPrivateName(left))
            return;
          const { privateFieldsAsProperties, privateNamesMap, redeclared } = this, { name } = left.id;
          if (!privateNamesMap.has(name))
            return;
          if (redeclared && redeclared.includes(name))
            return;
          if (unshadow(this.classRef.name, path3.scope, this.innerBinding), privateFieldsAsProperties) {
            const { id: id2 } = privateNamesMap.get(name);
            return void path3.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${_core.types.cloneNode(id2)})
      `);
          }
          const { id, static: isStatic } = privateNamesMap.get(name);
          isStatic ? path3.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right, file)} === ${_core.types.cloneNode(this.classRef)}`) : path3.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);
        } }), privateNameHandlerSpec = { memoise(member, count) {
          const { scope } = member, { object } = member.node, memo = scope.maybeGenerateMemoised(object);
          memo && this.memoiser.set(object, memo, count);
        }, receiver(member) {
          const { object } = member.node;
          return this.memoiser.has(object) ? _core.types.cloneNode(this.memoiser.get(object)) : _core.types.cloneNode(object);
        }, get(member) {
          const { classRef, privateNamesMap, file, innerBinding } = this, { name } = member.node.property.id, { id, static: isStatic, method: isMethod, methodId, getId, setId } = privateNamesMap.get(name), isAccessor = getId || setId;
          if (isStatic) {
            const helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
            return unshadow(classRef.name, member.scope, innerBinding), _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);
          }
          if (isMethod) {
            if (isAccessor) {
              if (!getId && setId) {
                if (file.availableHelper("writeOnlyError"))
                  return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper("writeOnlyError"), [_core.types.stringLiteral(`#${name}`)])]);
                console.warn("@babel/helpers is outdated, update it to silence this warning.");
              }
              return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
            }
            return _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);
          }
          return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
        }, boundGet(member) {
          return this.memoise(member, 1), _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [this.receiver(member)]);
        }, set(member, value2) {
          const { classRef, privateNamesMap, file } = this, { name } = member.node.property.id, { id, static: isStatic, method: isMethod, setId, getId } = privateNamesMap.get(name);
          if (isStatic) {
            const helperName = isMethod && !(getId || setId) ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
            return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value2]);
          }
          return isMethod ? setId ? _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value2]) : _core.types.sequenceExpression([this.receiver(member), value2, _core.types.callExpression(file.addHelper("readOnlyError"), [_core.types.stringLiteral(`#${name}`)])]) : _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value2]);
        }, destructureSet(member) {
          const { classRef, privateNamesMap, file } = this, { name } = member.node.property.id, { id, static: isStatic } = privateNamesMap.get(name);
          if (isStatic) {
            try {
              var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
            } catch (_unused) {
              throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
            }
            return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier("value"));
          }
          return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier("value"));
        }, call(member, args) {
          return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);
        }, optionalCall(member, args) {
          return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } }, privateNameHandlerLoose = { get(member) {
          const { privateNamesMap, file } = this, { object } = member.node, { name } = member.node.property.id;
          return _core.template.expression`BASE(REF, PROP)[PROP]`({ BASE: file.addHelper("classPrivateFieldLooseBase"), REF: _core.types.cloneNode(object), PROP: _core.types.cloneNode(privateNamesMap.get(name).id) });
        }, set() {
          throw new Error("private name handler with loose = true don't need set()");
        }, boundGet(member) {
          return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [_core.types.cloneNode(member.node.object)]);
        }, simpleSet(member) {
          return this.get(member);
        }, destructureSet(member) {
          return this.get(member);
        }, call(member, args) {
          return _core.types.callExpression(this.get(member), args);
        }, optionalCall(member, args) {
          return _core.types.optionalCallExpression(this.get(member), args, true);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } };
        function buildPrivateFieldInitLoose(ref2, prop, privateNamesMap) {
          const { id } = privateNamesMap.get(prop.node.key.id.name), value2 = prop.node.value || prop.scope.buildUndefinedNode();
          return inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref2}, ${_core.types.cloneNode(id)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${value2}
      });
    `, prop);
        }
        function buildPrivateInstanceFieldInitSpec(ref2, prop, privateNamesMap, state) {
          const { id } = privateNamesMap.get(prop.node.key.id.name), value2 = prop.node.value || prop.scope.buildUndefinedNode();
          if (!state.availableHelper("classPrivateFieldInitSpec"))
            return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref2}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${value2},
        })`, prop);
          const helper = state.addHelper("classPrivateFieldInitSpec");
          return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)},
      {
        writable: true,
        value: ${value2}
      },
    )`, prop);
        }
        function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { id, getId, setId, initAdded } = privateName, isAccessor = getId || setId;
          if (!prop.isProperty() && (initAdded || !isAccessor))
            return;
          if (isAccessor)
            return privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true })), inheritPropComments(_core.template.statement.ast`
        var ${_core.types.cloneNode(id)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        }
      `, prop);
          const value2 = prop.node.value || prop.scope.buildUndefinedNode();
          return inheritPropComments(_core.template.statement.ast`
      var ${_core.types.cloneNode(id)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${value2}
      };
    `, prop);
        }
        function buildPrivateMethodInitLoose(ref2, prop, privateNamesMap) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { methodId, id, getId, setId, initAdded } = privateName;
          if (initAdded)
            return;
          if (methodId)
            return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref2}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `, prop);
          return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true })), inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref2}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        });
      `, prop)) : void 0;
        }
        function buildPrivateInstanceMethodInitSpec(ref2, prop, privateNamesMap, state) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { getId, setId, initAdded } = privateName;
          if (initAdded)
            return;
          return getId || setId ? function(ref3, prop2, privateNamesMap2, state2) {
            const privateName2 = privateNamesMap2.get(prop2.node.key.id.name), { id, getId: getId2, setId: setId2 } = privateName2;
            if (privateNamesMap2.set(prop2.node.key.id.name, Object.assign({}, privateName2, { initAdded: true })), !state2.availableHelper("classPrivateFieldInitSpec"))
              return inheritPropComments(_core.template.statement.ast`
          ${id}.set(${ref3}, {
            get: ${getId2 ? getId2.name : prop2.scope.buildUndefinedNode()},
            set: ${setId2 ? setId2.name : prop2.scope.buildUndefinedNode()}
          });
        `, prop2);
            const helper = state2.addHelper("classPrivateFieldInitSpec");
            return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)},
      {
        get: ${getId2 ? getId2.name : prop2.scope.buildUndefinedNode()},
        set: ${setId2 ? setId2.name : prop2.scope.buildUndefinedNode()}
      },
    )`, prop2);
          }(ref2, prop, privateNamesMap, state) : function(ref3, prop2, privateNamesMap2, state2) {
            const privateName2 = privateNamesMap2.get(prop2.node.key.id.name), { id } = privateName2;
            if (!state2.availableHelper("classPrivateMethodInitSpec"))
              return inheritPropComments(_core.template.statement.ast`${id}.add(${ref3})`, prop2);
            const helper = state2.addHelper("classPrivateMethodInitSpec");
            return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)}
    )`, prop2);
          }(ref2, prop, privateNamesMap, state);
        }
        function buildPublicFieldInitLoose(ref2, prop) {
          const { key, computed } = prop.node, value2 = prop.node.value || prop.scope.buildUndefinedNode();
          return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref2, key, computed || _core.types.isLiteral(key)), value2)), prop);
        }
        function buildPublicFieldInitSpec(ref2, prop, state) {
          const { key, computed } = prop.node, value2 = prop.node.value || prop.scope.buildUndefinedNode();
          return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ref2, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value2])), prop);
        }
        function buildPrivateStaticMethodInitLoose(ref2, prop, state, privateNamesMap) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { id, methodId, getId, setId, initAdded } = privateName;
          if (initAdded)
            return;
          return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true })), inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref2}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        })
      `, prop)) : inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref2}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${methodId.name}
      });
    `, prop);
        }
        function buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = false) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { id, methodId, getId, setId, getterDeclared, setterDeclared, static: isStatic } = privateName, { params, body, generator, async } = prop.node, isGetter = getId && !getterDeclared && 0 === params.length, isSetter = setId && !setterDeclared && params.length > 0;
          let declId = methodId;
          return isGetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { getterDeclared: true })), declId = getId) : isSetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { setterDeclared: true })), declId = setId) : isStatic && !privateFieldsAsProperties && (declId = id), inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);
        }
        const thisContextVisitor = _core.traverse.visitors.merge([{ UnaryExpression(path3) {
          const { node } = path3;
          if ("delete" === node.operator) {
            const argument = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);
            _core.types.isThisExpression(argument) && path3.replaceWith(_core.types.booleanLiteral(true));
          }
        }, ThisExpression(path3, state) {
          state.needsClassRef = true, path3.replaceWith(_core.types.cloneNode(state.classRef));
        }, MetaProperty(path3) {
          const { node, scope } = path3;
          "new" === node.meta.name && "target" === node.property.name && path3.replaceWith(scope.buildUndefinedNode());
        } }, _helperEnvironmentVisitor.default]), innerReferencesVisitor = { ReferencedIdentifier(path3, state) {
          path3.scope.bindingIdentifierEquals(path3.node.name, state.innerBinding) && (state.needsClassRef = true, path3.node.name = state.classRef.name);
        } };
        function replaceThisContext(path3, ref2, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {
          var _state$classRef;
          const state = { classRef: ref2, needsClassRef: false, innerBinding: innerBindingRef };
          return new _helperReplaceSupers.default({ methodPath: path3, constantSuper, file, refToPreserve: ref2, getSuperRef, getObjectRef: () => (state.needsClassRef = true, null != _core.types.isStaticBlock && _core.types.isStaticBlock(path3.node) || path3.node.static ? ref2 : _core.types.memberExpression(ref2, _core.types.identifier("prototype"))) }).replace(), (isStaticBlock || path3.isProperty()) && path3.traverse(thisContextVisitor, state), null != innerBindingRef && null != (_state$classRef = state.classRef) && _state$classRef.name && state.classRef.name !== (null == innerBindingRef ? void 0 : innerBindingRef.name) && path3.traverse(innerReferencesVisitor, state), state.needsClassRef;
        }
        function isNameOrLength({ key, computed }) {
          return "Identifier" === key.type ? !computed && ("name" === key.name || "length" === key.name) : "StringLiteral" === key.type && ("name" === key.value || "length" === key.value);
        }
        function inheritPropComments(node, prop) {
          return _core.types.inheritLeadingComments(node, prop.node), _core.types.inheritInnerComments(node, prop.node), node;
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "FEATURES", { enumerable: true, get: function() {
          return _features.FEATURES;
        } }), Object.defineProperty(exports3, "buildCheckInRHS", { enumerable: true, get: function() {
          return _fields.buildCheckInRHS;
        } }), exports3.createClassFeaturePlugin = function({ name, feature, loose, manipulateOptions, api, inherits }) {
          null != api || (api = { assumption: () => {
          } });
          const setPublicClassFields = api.assumption("setPublicClassFields"), privateFieldsAsSymbols = api.assumption("privateFieldsAsSymbols"), privateFieldsAsProperties = api.assumption("privateFieldsAsProperties"), constantSuper = api.assumption("constantSuper"), noDocumentAll = api.assumption("noDocumentAll");
          if (privateFieldsAsProperties && privateFieldsAsSymbols)
            throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
          const privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;
          if (true === loose) {
            const explicit = [];
            void 0 !== setPublicClassFields && explicit.push('"setPublicClassFields"'), void 0 !== privateFieldsAsProperties && explicit.push('"privateFieldsAsProperties"'), void 0 !== privateFieldsAsSymbols && explicit.push('"privateFieldsAsSymbols"'), 0 !== explicit.length && console.warn(`[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${explicit.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
          }
          return { name, manipulateOptions, inherits, pre(file) {
            (0, _features.enableFeature)(file, feature, loose), "number" != typeof file.get(versionKey) && file.get(versionKey) && !_semverV.lt(file.get(versionKey), "7.22.6") || file.set(versionKey, "7.22.6");
          }, visitor: { Class(path3, { file }) {
            if ("7.22.6" !== file.get(versionKey))
              return;
            if (!(0, _features.shouldTransform)(path3, file))
              return;
            path3.isClassDeclaration() && (0, _typescript.assertFieldTransformed)(path3);
            const loose2 = (0, _features.isLoose)(file, feature);
            let constructor;
            const isDecorated = (0, _decorators.hasDecorators)(path3.node), props = [], elements = [], computedPaths = [], privateNames = /* @__PURE__ */ new Set(), body = path3.get("body");
            for (const path4 of body.get("body")) {
              if ((path4.isClassProperty() || path4.isClassMethod()) && path4.node.computed && computedPaths.push(path4), path4.isPrivate()) {
                const { name: name2 } = path4.node.key.id, getName = `get ${name2}`, setName = `set ${name2}`;
                if (path4.isClassPrivateMethod()) {
                  if ("get" === path4.node.kind) {
                    if (privateNames.has(getName) || privateNames.has(name2) && !privateNames.has(setName))
                      throw path4.buildCodeFrameError("Duplicate private field");
                    privateNames.add(getName).add(name2);
                  } else if ("set" === path4.node.kind) {
                    if (privateNames.has(setName) || privateNames.has(name2) && !privateNames.has(getName))
                      throw path4.buildCodeFrameError("Duplicate private field");
                    privateNames.add(setName).add(name2);
                  }
                } else {
                  if (privateNames.has(name2) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name2) && (privateNames.has(getName) || privateNames.has(setName)))
                    throw path4.buildCodeFrameError("Duplicate private field");
                  privateNames.add(name2);
                }
              }
              path4.isClassMethod({ kind: "constructor" }) ? constructor = path4 : (elements.push(path4), (path4.isProperty() || path4.isPrivate() || null != path4.isStaticBlock && path4.isStaticBlock()) && props.push(path4));
            }
            if (!props.length && !isDecorated)
              return;
            const innerBinding = path3.node.id;
            let ref2;
            !innerBinding || path3.isClassExpression() ? ((0, _helperFunctionName.default)(path3), ref2 = path3.scope.generateUidIdentifier("class")) : ref2 = _core.types.cloneNode(path3.node.id);
            const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props), privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, null != privateFieldsAsProperties ? privateFieldsAsProperties : loose2, null != privateFieldsAsSymbols && privateFieldsAsSymbols, file);
            let keysNodes, staticNodes, instanceNodes, pureStaticNodes, wrapClass;
            (0, _fields.transformPrivateNamesUsage)(ref2, path3, privateNamesMap, { privateFieldsAsProperties: null != privateFieldsAsSymbolsOrProperties ? privateFieldsAsSymbolsOrProperties : loose2, noDocumentAll, innerBinding }, file), isDecorated ? (staticNodes = pureStaticNodes = keysNodes = [], { instanceNodes, wrapClass } = (0, _decorators.buildDecoratedClass)(ref2, path3, elements, file)) : (keysNodes = (0, _misc.extractComputedKeys)(path3, computedPaths, file), { staticNodes, pureStaticNodes, instanceNodes, wrapClass } = (0, _fields.buildFieldsInitNodes)(ref2, path3.node.superClass, props, privateNamesMap, file, null != setPublicClassFields ? setPublicClassFields : loose2, null != privateFieldsAsSymbolsOrProperties ? privateFieldsAsSymbolsOrProperties : loose2, null != constantSuper ? constantSuper : loose2, innerBinding)), instanceNodes.length > 0 && (0, _misc.injectInitialization)(path3, constructor, instanceNodes, (referenceVisitor, state) => {
              if (!isDecorated)
                for (const prop of props)
                  null != _core.types.isStaticBlock && _core.types.isStaticBlock(prop.node) || prop.node.static || prop.traverse(referenceVisitor, state);
            });
            const wrappedPath = wrapClass(path3);
            wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]), staticNodes.length > 0 && wrappedPath.insertAfter(staticNodes), pureStaticNodes.length > 0 && wrappedPath.find((parent) => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);
          }, ExportDefaultDeclaration(path3, { file }) {
            {
              if ("7.22.6" !== file.get(versionKey))
                return;
              const decl = path3.get("declaration");
              decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node) && (decl.node.id ? (0, _helperSplitExportDeclaration.default)(path3) : decl.node.type = "ClassExpression");
            }
          } } };
        }, Object.defineProperty(exports3, "enableFeature", { enumerable: true, get: function() {
          return _features.enableFeature;
        } }), Object.defineProperty(exports3, "injectInitialization", { enumerable: true, get: function() {
          return _misc.injectInitialization;
        } });
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _helperFunctionName = __webpack_require__2("./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js"), _helperSplitExportDeclaration = __webpack_require__2("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js"), _semverV = __webpack_require__2("./node_modules/.pnpm/@nicolo-ribaudo+semver-v6@6.3.3/node_modules/@nicolo-ribaudo/semver-v6/semver.js"), _fields = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), _decorators = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"), _misc = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"), _features = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/features.js"), _typescript = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        const versionKey = "@babel/plugin-class-features/version";
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.extractComputedKeys = function(path3, computedPaths, file) {
          const declarations = [], state = { classBinding: path3.node.id && path3.scope.getBinding(path3.node.id.name), file };
          for (const computedPath of computedPaths) {
            const computedKey = computedPath.get("key");
            computedKey.isReferencedIdentifier() ? handleClassTDZ(computedKey, state) : computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
            const computedNode = computedPath.node;
            if (!computedKey.isConstantExpression()) {
              const ident = path3.scope.generateUidIdentifierBasedOnNode(computedNode.key);
              path3.scope.push({ id: ident, kind: "let" }), declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(ident), computedNode.key))), computedNode.key = _core.types.cloneNode(ident);
            }
          }
          return declarations;
        }, exports3.injectInitialization = function(path3, constructor, nodes, renamer) {
          if (!nodes.length)
            return;
          const isDerived = !!path3.node.superClass;
          if (!constructor) {
            const newConstructor = _core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([]));
            isDerived && (newConstructor.params = [_core.types.restElement(_core.types.identifier("args"))], newConstructor.body.body.push(_core.template.statement.ast`super(...args)`)), [constructor] = path3.get("body").unshiftContainer("body", newConstructor);
          }
          renamer && renamer(referenceVisitor, { scope: constructor.scope });
          if (isDerived) {
            const bareSupers = [];
            constructor.traverse(findBareSupers, bareSupers);
            let isFirst = true;
            for (const bareSuper of bareSupers)
              isFirst ? (bareSuper.insertAfter(nodes), isFirst = false) : bareSuper.insertAfter(nodes.map((n) => _core.types.cloneNode(n)));
          } else
            constructor.get("body").unshiftContainer("body", nodes);
        };
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js");
        const findBareSupers = _core.traverse.visitors.merge([{ Super(path3) {
          const { node, parentPath } = path3;
          parentPath.isCallExpression({ callee: node }) && this.push(parentPath);
        } }, _helperEnvironmentVisitor.default]), referenceVisitor = { "TSTypeAnnotation|TypeAnnotation"(path3) {
          path3.skip();
        }, ReferencedIdentifier(path3, { scope }) {
          scope.hasOwnBinding(path3.node.name) && (scope.rename(path3.node.name), path3.skip());
        } };
        function handleClassTDZ(path3, state) {
          if (state.classBinding && state.classBinding === path3.scope.getBinding(path3.node.name)) {
            const classNameTDZError = state.file.addHelper("classNameTDZError"), throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path3.node.name)]);
            path3.replaceWith(_core.types.sequenceExpression([throwNode, path3.node])), path3.skip();
          }
        }
        const classFieldDefinitionEvaluationTDZVisitor = { ReferencedIdentifier: handleClassTDZ };
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.assertFieldTransformed = function(path3) {
          if (path3.node.declare)
            throw path3.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-transform-class-properties\n - @babel/plugin-transform-private-methods\n - @babel/plugin-proposal-decorators");
        };
      }, "./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js": (__unused_webpack_module, exports3) => {
        "use strict";
        function requeueComputedKeyAndDecorators(path3) {
          const { context, node } = path3;
          if (node.computed && context.maybeQueue(path3.get("key")), node.decorators)
            for (const decorator of path3.get("decorators"))
              context.maybeQueue(decorator);
        }
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0, exports3.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators, exports3.skipAllButComputedKey = function(path3) {
          path3.skip(), path3.node.computed && path3.context.maybeQueue(path3.get("key"));
        };
        var _default = { FunctionParent(path3) {
          path3.isArrowFunctionExpression() || (path3.skip(), path3.isMethod() && requeueComputedKeyAndDecorators(path3));
        }, Property(path3) {
          path3.isObjectProperty() || (path3.skip(), requeueComputedKeyAndDecorators(path3));
        } };
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function({ node, parent, scope, id }, localBinding = false, supportUnicodeId = false) {
          if (node.id)
            return;
          if (!isObjectProperty(parent) && !isObjectMethod(parent, { kind: "method" }) || parent.computed && !isLiteral(parent.key)) {
            if (isVariableDeclarator(parent)) {
              if (id = parent.id, isIdentifier(id) && !localBinding) {
                const binding = scope.parent.getBinding(id.name);
                if (binding && binding.constant && scope.getBinding(id.name) === binding)
                  return node.id = cloneNode(id), void (node.id[NOT_LOCAL_BINDING] = true);
              }
            } else if (isAssignmentExpression(parent, { operator: "=" }))
              id = parent.left;
            else if (!id)
              return;
          } else
            id = parent.key;
          let name;
          id && isLiteral(id) ? name = function(id2) {
            if (isNullLiteral(id2))
              return "null";
            if (isRegExpLiteral(id2))
              return `_${id2.pattern}_${id2.flags}`;
            if (isTemplateLiteral(id2))
              return id2.quasis.map((quasi) => quasi.value.raw).join("");
            if (void 0 !== id2.value)
              return id2.value + "";
            return "";
          }(id) : id && isIdentifier(id) && (name = id.name);
          if (void 0 === name)
            return;
          if (!supportUnicodeId && isFunction2(node) && /[\uD800-\uDFFF]/.test(name))
            return;
          name = toBindingIdentifierName(name);
          const newId = identifier(name);
          newId[NOT_LOCAL_BINDING] = true;
          return function(state, method, id2, scope2) {
            if (state.selfReference) {
              if (!scope2.hasBinding(id2.name) || scope2.hasGlobal(id2.name)) {
                if (!isFunction2(method))
                  return;
                let build2 = buildPropertyMethodAssignmentWrapper;
                method.generator && (build2 = buildGeneratorPropertyMethodAssignmentWrapper);
                const template2 = build2({ FUNCTION: method, FUNCTION_ID: id2, FUNCTION_KEY: scope2.generateUidIdentifier(id2.name) }).expression, params = template2.callee.body.body[0].params;
                for (let i = 0, len = function(node2) {
                  const count = node2.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
                  return -1 === count ? node2.params.length : count;
                }(method); i < len; i++)
                  params.push(scope2.generateUidIdentifier("x"));
                return template2;
              }
              scope2.rename(id2.name);
            }
            method.id = id2, scope2.getProgramParent().references[id2.name] = true;
          }(function(node2, name2, scope2) {
            const state = { selfAssignment: false, selfReference: false, outerDeclar: scope2.getBindingIdentifier(name2), name: name2 }, binding = scope2.getOwnBinding(name2);
            binding ? "param" === binding.kind && (state.selfReference = true) : (state.outerDeclar || scope2.hasGlobal(name2)) && scope2.traverse(node2, visitor, state);
            return state;
          }(node, name, scope), node, newId, scope) || node;
        };
        var _template = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { NOT_LOCAL_BINDING, cloneNode, identifier, isAssignmentExpression, isAssignmentPattern, isFunction: isFunction2, isIdentifier, isLiteral, isNullLiteral, isObjectMethod, isObjectProperty, isRegExpLiteral, isRestElement, isTemplateLiteral, isVariableDeclarator, toBindingIdentifierName } = _t;
        const buildPropertyMethodAssignmentWrapper = _template.default.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), visitor = { "ReferencedIdentifier|BindingIdentifier"(path3, state) {
          if (path3.node.name !== state.name)
            return;
          path3.scope.getBindingIdentifier(state.name) === state.outerDeclar && (state.selfReference = true, path3.stop());
        } };
      }, "./node_modules/.pnpm/@babel+helper-hoist-variables@7.22.5/node_modules/@babel/helper-hoist-variables/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(path3, emit, kind = "var") {
          path3.traverse(visitor, { kind, emit });
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { assignmentExpression, expressionStatement, identifier } = _t, visitor = { Scope(path3, state) {
          "let" === state.kind && path3.skip();
        }, FunctionParent(path3) {
          path3.skip();
        }, VariableDeclaration(path3, state) {
          if (state.kind && path3.node.kind !== state.kind)
            return;
          const nodes = [], declarations = path3.get("declarations");
          let firstId;
          for (const declar of declarations) {
            firstId = declar.node.id, declar.node.init && nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));
            for (const name of Object.keys(declar.getBindingIdentifiers()))
              state.emit(identifier(name), name, null !== declar.node.init);
          }
          path3.parentPath.isFor({ left: path3.node }) ? path3.replaceWith(firstId) : path3.replaceWithMultiple(nodes);
        } };
      }, "./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.22.5/node_modules/@babel/helper-member-expression-to-functions/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        function _interopNamespace(e) {
          if (e && e.__esModule)
            return e;
          var n = /* @__PURE__ */ Object.create(null);
          return e && Object.keys(e).forEach(function(k) {
            if ("default" !== k) {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : { enumerable: true, get: function() {
                return e[k];
              } });
            }
          }), n.default = e, Object.freeze(n);
        }
        Object.defineProperty(exports3, "__esModule", { value: true });
        var _t__namespace = _interopNamespace(__webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"));
        function willPathCastToBoolean(path3) {
          const maybeWrapped = path3, { node, parentPath } = maybeWrapped;
          if (parentPath.isLogicalExpression()) {
            const { operator, right } = parentPath.node;
            if ("&&" === operator || "||" === operator || "??" === operator && node === right)
              return willPathCastToBoolean(parentPath);
          }
          if (parentPath.isSequenceExpression()) {
            const { expressions } = parentPath.node;
            return expressions[expressions.length - 1] !== node || willPathCastToBoolean(parentPath);
          }
          return parentPath.isConditional({ test: node }) || parentPath.isUnaryExpression({ operator: "!" }) || parentPath.isLoop({ test: node });
        }
        const { LOGICAL_OPERATORS, arrowFunctionExpression, assignmentExpression, binaryExpression, booleanLiteral, callExpression, cloneNode, conditionalExpression, identifier, isMemberExpression, isOptionalCallExpression, isOptionalMemberExpression, isUpdateExpression, logicalExpression, memberExpression, nullLiteral, optionalCallExpression, optionalMemberExpression, sequenceExpression, updateExpression } = _t__namespace;
        class AssignmentMemoiser {
          constructor() {
            this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
          }
          has(key) {
            return this._map.has(key);
          }
          get(key) {
            if (!this.has(key))
              return;
            const record = this._map.get(key), { value: value2 } = record;
            return record.count--, 0 === record.count ? assignmentExpression("=", value2, key) : value2;
          }
          set(key, value2, count) {
            return this._map.set(key, { count, value: value2 });
          }
        }
        function toNonOptional(path3, base) {
          const { node } = path3;
          if (isOptionalMemberExpression(node))
            return memberExpression(base, node.property, node.computed);
          if (path3.isOptionalCallExpression()) {
            const callee = path3.get("callee");
            if (path3.node.optional && callee.isOptionalMemberExpression()) {
              const object = callee.node.object, context = path3.scope.maybeGenerateMemoised(object);
              return callee.get("object").replaceWith(assignmentExpression("=", context, object)), callExpression(memberExpression(base, identifier("call")), [context, ...path3.node.arguments]);
            }
            return callExpression(base, path3.node.arguments);
          }
          return path3.node;
        }
        const handle = { memoise() {
        }, handle(member, noDocumentAll) {
          const { node, parent, parentPath, scope } = member;
          if (member.isOptionalMemberExpression()) {
            if (function(path3) {
              for (; path3 && !path3.isProgram(); ) {
                const { parentPath: parentPath2, container, listKey } = path3, parentNode = parentPath2.node;
                if (listKey) {
                  if (container !== parentNode[listKey])
                    return true;
                } else if (container !== parentNode)
                  return true;
                path3 = parentPath2;
              }
              return false;
            }(member))
              return;
            const endPath = member.find(({ node: node2, parent: parent2 }) => isOptionalMemberExpression(parent2) ? parent2.optional || parent2.object !== node2 : !isOptionalCallExpression(parent2) || (node2 !== member.node && parent2.optional || parent2.callee !== node2));
            if (scope.path.isPattern())
              return void endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
            const willEndPathCastToBoolean = willPathCastToBoolean(endPath), rootParentPath = endPath.parentPath;
            if (rootParentPath.isUpdateExpression({ argument: node }) || rootParentPath.isAssignmentExpression({ left: node }))
              throw member.buildCodeFrameError("can't handle assignment");
            const isDeleteOperation = rootParentPath.isUnaryExpression({ operator: "delete" });
            if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName())
              throw member.buildCodeFrameError("can't delete a private class element");
            let startingOptional = member;
            for (; ; )
              if (startingOptional.isOptionalMemberExpression()) {
                if (startingOptional.node.optional)
                  break;
                startingOptional = startingOptional.get("object");
              } else {
                if (!startingOptional.isOptionalCallExpression())
                  throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);
                if (startingOptional.node.optional)
                  break;
                startingOptional = startingOptional.get("callee");
              }
            const startingNode = startingOptional.isOptionalMemberExpression() ? startingOptional.node.object : startingOptional.node.callee, baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode), baseRef = null != baseNeedsMemoised ? baseNeedsMemoised : startingNode, parentIsOptionalCall = parentPath.isOptionalCallExpression({ callee: node }), isOptionalCall = (parent2) => parentIsOptionalCall, parentIsCall = parentPath.isCallExpression({ callee: node });
            startingOptional.replaceWith(toNonOptional(startingOptional, baseRef)), isOptionalCall() ? parent.optional ? parentPath.replaceWith(this.optionalCall(member, parent.arguments)) : parentPath.replaceWith(this.call(member, parent.arguments)) : parentIsCall ? member.replaceWith(this.boundGet(member)) : this.delete && parentPath.isUnaryExpression({ operator: "delete" }) ? parentPath.replaceWith(this.delete(member)) : member.replaceWith(this.get(member));
            let context, regular = member.node;
            for (let current2 = member; current2 !== endPath; ) {
              const parentPath2 = current2.parentPath;
              if (parentPath2 === endPath && isOptionalCall() && parent.optional) {
                regular = parentPath2.node;
                break;
              }
              regular = toNonOptional(parentPath2, regular), current2 = parentPath2;
            }
            const endParentPath = endPath.parentPath;
            if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({ callee: endPath.node, optional: true })) {
              const { object } = regular;
              context = member.scope.maybeGenerateMemoised(object), context && (regular.object = assignmentExpression("=", context, object));
            }
            let replacementPath = endPath;
            isDeleteOperation && (replacementPath = endParentPath, regular = endParentPath.node);
            const baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);
            if (willEndPathCastToBoolean) {
              let nonNullishCheck;
              nonNullishCheck = noDocumentAll ? binaryExpression("!=", baseMemoised, nullLiteral()) : logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode())), replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
            } else {
              let nullishCheck;
              nullishCheck = noDocumentAll ? binaryExpression("==", baseMemoised, nullLiteral()) : logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode())), replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));
            }
            if (context) {
              const endParent = endParentPath.node;
              endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), false, true), [cloneNode(context), ...endParent.arguments], false));
            }
          } else {
            if (isUpdateExpression(parent, { argument: node })) {
              if (this.simpleSet)
                return void member.replaceWith(this.simpleSet(member));
              const { operator, prefix } = parent;
              this.memoise(member, 2);
              const ref2 = scope.generateUidIdentifierBasedOnNode(node);
              scope.push({ id: ref2 });
              const seq = [assignmentExpression("=", cloneNode(ref2), this.get(member))];
              if (prefix) {
                seq.push(updateExpression(operator, cloneNode(ref2), prefix));
                const value2 = sequenceExpression(seq);
                return void parentPath.replaceWith(this.set(member, value2));
              }
              {
                const ref22 = scope.generateUidIdentifierBasedOnNode(node);
                scope.push({ id: ref22 }), seq.push(assignmentExpression("=", cloneNode(ref22), updateExpression(operator, cloneNode(ref2), prefix)), cloneNode(ref2));
                const value2 = sequenceExpression(seq);
                return void parentPath.replaceWith(sequenceExpression([this.set(member, value2), cloneNode(ref22)]));
              }
            }
            if (parentPath.isAssignmentExpression({ left: node })) {
              if (this.simpleSet)
                return void member.replaceWith(this.simpleSet(member));
              const { operator, right: value2 } = parentPath.node;
              if ("=" === operator)
                parentPath.replaceWith(this.set(member, value2));
              else {
                const operatorTrunc = operator.slice(0, -1);
                LOGICAL_OPERATORS.includes(operatorTrunc) ? (this.memoise(member, 1), parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, value2)))) : (this.memoise(member, 2), parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), value2))));
              }
            } else {
              if (!parentPath.isCallExpression({ callee: node }))
                return parentPath.isOptionalCallExpression({ callee: node }) ? scope.path.isPattern() ? void parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), [])) : void parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments)) : void (this.delete && parentPath.isUnaryExpression({ operator: "delete" }) ? parentPath.replaceWith(this.delete(member)) : parentPath.isForXStatement({ left: node }) || parentPath.isObjectProperty({ value: node }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({ left: node }) && parentPath.parentPath.isObjectProperty({ value: parent }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({ left: node }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement() ? member.replaceWith(this.destructureSet(member)) : parentPath.isTaggedTemplateExpression() ? member.replaceWith(this.boundGet(member)) : member.replaceWith(this.get(member)));
              parentPath.replaceWith(this.call(member, parentPath.node.arguments));
            }
          }
        } };
        exports3.default = function(path3, visitor, state) {
          path3.traverse(visitor, Object.assign({}, handle, state, { memoiser: new AssignmentMemoiser() }));
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/import-builder.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { callExpression, cloneNode, expressionStatement, identifier, importDeclaration, importDefaultSpecifier, importNamespaceSpecifier, importSpecifier, memberExpression, stringLiteral, variableDeclaration, variableDeclarator } = _t;
        exports3.default = class {
          constructor(importedSource, scope, hub) {
            this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = scope, this._hub = hub, this._importedSource = importedSource;
          }
          done() {
            return { statements: this._statements, resultName: this._resultName };
          }
          import() {
            return this._statements.push(importDeclaration([], stringLiteral(this._importedSource))), this;
          }
          require() {
            return this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)]))), this;
          }
          namespace(name = "namespace") {
            const local = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
            return _assert("ImportDeclaration" === statement.type), _assert(0 === statement.specifiers.length), statement.specifiers = [importNamespaceSpecifier(local)], this._resultName = cloneNode(local), this;
          }
          default(name) {
            const id = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
            return _assert("ImportDeclaration" === statement.type), _assert(0 === statement.specifiers.length), statement.specifiers = [importDefaultSpecifier(id)], this._resultName = cloneNode(id), this;
          }
          named(name, importName2) {
            if ("default" === importName2)
              return this.default(name);
            const id = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
            return _assert("ImportDeclaration" === statement.type), _assert(0 === statement.specifiers.length), statement.specifiers = [importSpecifier(id, identifier(importName2))], this._resultName = cloneNode(id), this;
          }
          var(name) {
            const id = this._scope.generateUidIdentifier(name);
            let statement = this._statements[this._statements.length - 1];
            return "ExpressionStatement" !== statement.type && (_assert(this._resultName), statement = expressionStatement(this._resultName), this._statements.push(statement)), this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(id, statement.expression)]), this._resultName = cloneNode(id), this;
          }
          defaultInterop() {
            return this._interop(this._hub.addHelper("interopRequireDefault"));
          }
          wildcardInterop() {
            return this._interop(this._hub.addHelper("interopRequireWildcard"));
          }
          _interop(callee) {
            const statement = this._statements[this._statements.length - 1];
            return "ExpressionStatement" === statement.type ? statement.expression = callExpression(callee, [statement.expression]) : "VariableDeclaration" === statement.type ? (_assert(1 === statement.declarations.length), statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init])) : _assert.fail("Unexpected type."), this;
          }
          prop(name) {
            const statement = this._statements[this._statements.length - 1];
            return "ExpressionStatement" === statement.type ? statement.expression = memberExpression(statement.expression, identifier(name)) : "VariableDeclaration" === statement.type ? (_assert(1 === statement.declarations.length), statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name))) : _assert.fail("Unexpected type:" + statement.type), this;
          }
          read(name) {
            this._resultName = memberExpression(this._resultName, identifier(name));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/import-injector.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _importBuilder = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/import-builder.js"), _isModule = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/is-module.js");
        const { numericLiteral, sequenceExpression } = _t;
        exports3.default = class {
          constructor(path3, importedSource, opts) {
            this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: false, ensureNoContext: false, importPosition: "before" };
            const programPath = path3.find((p) => p.isProgram());
            this._programPath = programPath, this._programScope = programPath.scope, this._hub = programPath.hub, this._defaultOpts = this._applyDefaults(importedSource, opts, true);
          }
          addDefault(importedSourceIn, opts) {
            return this.addNamed("default", importedSourceIn, opts);
          }
          addNamed(importName2, importedSourceIn, opts) {
            return _assert("string" == typeof importName2), this._generateImport(this._applyDefaults(importedSourceIn, opts), importName2);
          }
          addNamespace(importedSourceIn, opts) {
            return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
          }
          addSideEffect(importedSourceIn, opts) {
            return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
          }
          _applyDefaults(importedSource, opts, isInit = false) {
            let newOpts;
            return "string" == typeof importedSource ? newOpts = Object.assign({}, this._defaultOpts, { importedSource }, opts) : (_assert(!opts, "Unexpected secondary arguments."), newOpts = Object.assign({}, this._defaultOpts, importedSource)), !isInit && opts && (void 0 !== opts.nameHint && (newOpts.nameHint = opts.nameHint), void 0 !== opts.blockHoist && (newOpts.blockHoist = opts.blockHoist)), newOpts;
          }
          _generateImport(opts, importName2) {
            const isDefault = "default" === importName2, isNamed = !!importName2 && !isDefault, isNamespace = null === importName2, { importedSource, importedType, importedInterop, importingInterop, ensureLiveReference, ensureNoContext, nameHint, importPosition, blockHoist } = opts;
            let name = nameHint || importName2;
            const isMod = (0, _isModule.default)(this._programPath), isModuleForNode = isMod && "node" === importingInterop, isModuleForBabel = isMod && "babel" === importingInterop;
            if ("after" === importPosition && !isMod)
              throw new Error('"importPosition": "after" is only supported in modules');
            const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
            if ("es6" === importedType) {
              if (!isModuleForNode && !isModuleForBabel)
                throw new Error("Cannot import an ES6 module from CommonJS");
              builder.import(), isNamespace ? builder.namespace(nameHint || importedSource) : (isDefault || isNamed) && builder.named(name, importName2);
            } else {
              if ("commonjs" !== importedType)
                throw new Error(`Unexpected interopType "${importedType}"`);
              if ("babel" === importedInterop)
                if (isModuleForNode) {
                  name = "default" !== name ? name : importedSource;
                  const es6Default = `${importedSource}$es6Default`;
                  builder.import(), isNamespace ? builder.default(es6Default).var(name || importedSource).wildcardInterop() : isDefault ? ensureLiveReference ? builder.default(es6Default).var(name || importedSource).defaultInterop().read("default") : builder.default(es6Default).var(name).defaultInterop().prop(importName2) : isNamed && builder.default(es6Default).read(importName2);
                } else
                  isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName2)) : (builder.require(), isNamespace ? builder.var(name || importedSource).wildcardInterop() : (isDefault || isNamed) && ensureLiveReference ? isDefault ? (name = "default" !== name ? name : importedSource, builder.var(name).read(importName2), builder.defaultInterop()) : builder.var(importedSource).read(importName2) : isDefault ? builder.var(name).defaultInterop().prop(importName2) : isNamed && builder.var(name).prop(importName2));
              else if ("compiled" === importedInterop)
                isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : (isDefault || isNamed) && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName2)) : (builder.require(), isNamespace ? builder.var(name || importedSource) : (isDefault || isNamed) && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.prop(importName2).var(name)));
              else {
                if ("uncompiled" !== importedInterop)
                  throw new Error(`Unknown importedInterop "${importedInterop}".`);
                if (isDefault && ensureLiveReference)
                  throw new Error("No live reference for commonjs default");
                isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.named(name, importName2)) : (builder.require(), isNamespace ? builder.var(name || importedSource) : isDefault ? builder.var(name) : isNamed && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.var(name).prop(importName2)));
              }
            }
            const { statements, resultName } = builder.done();
            return this._insertStatements(statements, importPosition, blockHoist), (isDefault || isNamed) && ensureNoContext && "Identifier" !== resultName.type ? sequenceExpression([numericLiteral(0), resultName]) : resultName;
          }
          _insertStatements(statements, importPosition = "before", blockHoist = 3) {
            const body = this._programPath.get("body");
            if ("after" === importPosition) {
              for (let i = body.length - 1; i >= 0; i--)
                if (body[i].isImportDeclaration())
                  return void body[i].insertAfter(statements);
            } else {
              statements.forEach((node) => {
                node._blockHoist = blockHoist;
              });
              const targetPath = body.find((p) => {
                const val = p.node._blockHoist;
                return Number.isFinite(val) && val < 4;
              });
              if (targetPath)
                return void targetPath.insertBefore(statements);
            }
            this._programPath.unshiftContainer("body", statements);
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "ImportInjector", { enumerable: true, get: function() {
          return _importInjector.default;
        } }), exports3.addDefault = function(path3, importedSource, opts) {
          return new _importInjector.default(path3).addDefault(importedSource, opts);
        }, exports3.addNamed = function(path3, name, importedSource, opts) {
          return new _importInjector.default(path3).addNamed(name, importedSource, opts);
        }, exports3.addNamespace = function(path3, importedSource, opts) {
          return new _importInjector.default(path3).addNamespace(importedSource, opts);
        }, exports3.addSideEffect = function(path3, importedSource, opts) {
          return new _importInjector.default(path3).addSideEffect(importedSource, opts);
        }, Object.defineProperty(exports3, "isModule", { enumerable: true, get: function() {
          return _isModule.default;
        } });
        var _importInjector = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/import-injector.js"), _isModule = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/is-module.js");
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/is-module.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(path3) {
          return "module" === path3.node.sourceType;
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.buildDynamicImport = function(node, deferToThen, wrapWithPromise, builder) {
          const [specifier] = node.arguments;
          if (t.isStringLiteral(specifier) || t.isTemplateLiteral(specifier) && 0 === specifier.quasis.length)
            return deferToThen ? _template.default.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      ` : builder(specifier);
          const specifierToString = t.isTemplateLiteral(specifier) ? t.identifier("specifier") : t.templateLiteral([t.templateElement({ raw: "" }), t.templateElement({ raw: "" })], [t.identifier("specifier")]);
          return deferToThen ? _template.default.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(t.identifier("s"))})
      )(${specifier})
    ` : wrapWithPromise ? _template.default.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    ` : _template.default.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `;
        };
        var t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _template = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js");
        exports3.getDynamicImportSource = function(node) {
          const [source] = node.arguments;
          return t.isStringLiteral(source) || t.isTemplateLiteral(source) ? source : _template.default.expression.ast`\`\${${source}}\``;
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/get-module-name.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = getModuleName;
        {
          const originalGetModuleName = getModuleName;
          exports3.default = getModuleName = function(rootOpts, pluginOpts) {
            var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
            return originalGetModuleName(rootOpts, { moduleId: null != (_pluginOpts$moduleId = pluginOpts.moduleId) ? _pluginOpts$moduleId : rootOpts.moduleId, moduleIds: null != (_pluginOpts$moduleIds = pluginOpts.moduleIds) ? _pluginOpts$moduleIds : rootOpts.moduleIds, getModuleId: null != (_pluginOpts$getModule = pluginOpts.getModuleId) ? _pluginOpts$getModule : rootOpts.getModuleId, moduleRoot: null != (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) ? _pluginOpts$moduleRoo : rootOpts.moduleRoot });
          };
        }
        function getModuleName(rootOpts, pluginOpts) {
          const { filename, filenameRelative = filename, sourceRoot = pluginOpts.moduleRoot } = rootOpts, { moduleId, moduleIds = !!moduleId, getModuleId, moduleRoot = sourceRoot } = pluginOpts;
          if (!moduleIds)
            return null;
          if (null != moduleId && !getModuleId)
            return moduleId;
          let moduleName = null != moduleRoot ? moduleRoot + "/" : "";
          if (filenameRelative) {
            const sourceRootReplacer = null != sourceRoot ? new RegExp("^" + sourceRoot + "/?") : "";
            moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
          }
          return moduleName = moduleName.replace(/\\/g, "/"), getModuleId && getModuleId(moduleName) || moduleName;
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "buildDynamicImport", { enumerable: true, get: function() {
          return _dynamicImport.buildDynamicImport;
        } }), exports3.buildNamespaceInitStatements = function(metadata, sourceMetadata, constantReexports = false) {
          const statements = [];
          let srcNamespace = identifier(sourceMetadata.name);
          sourceMetadata.lazy && (srcNamespace = callExpression(srcNamespace, []));
          for (const localName of sourceMetadata.importsNamespace)
            localName !== sourceMetadata.name && statements.push(_template.default.statement`var NAME = SOURCE;`({ NAME: localName, SOURCE: cloneNode(srcNamespace) }));
          constantReexports && statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));
          for (const exportName of sourceMetadata.reexportNamespace)
            statements.push((sourceMetadata.lazy ? _template.default.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({ EXPORTS: metadata.exportName, NAME: exportName, NAMESPACE: cloneNode(srcNamespace) }));
          if (sourceMetadata.reexportAll) {
            const statement = function(metadata2, namespace, constantReexports2) {
              return (constantReexports2 ? _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: namespace, EXPORTS: metadata2.exportName, VERIFY_NAME_LIST: metadata2.exportNameListName ? _template.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: metadata2.exportNameListName }) : null });
            }(metadata, cloneNode(srcNamespace), constantReexports);
            statement.loc = sourceMetadata.reexportAll.loc, statements.push(statement);
          }
          return statements;
        }, exports3.ensureStatementsHoisted = function(statements) {
          statements.forEach((header) => {
            header._blockHoist = 3;
          });
        }, Object.defineProperty(exports3, "getModuleName", { enumerable: true, get: function() {
          return _getModuleName.default;
        } }), Object.defineProperty(exports3, "hasExports", { enumerable: true, get: function() {
          return _normalizeAndLoadMetadata.hasExports;
        } }), Object.defineProperty(exports3, "isModule", { enumerable: true, get: function() {
          return _helperModuleImports.isModule;
        } }), Object.defineProperty(exports3, "isSideEffectImport", { enumerable: true, get: function() {
          return _normalizeAndLoadMetadata.isSideEffectImport;
        } }), exports3.rewriteModuleStatementsAndPrepareHeader = function(path3, { exportName, strict, allowTopLevelThis, strictMode, noInterop, importInterop = noInterop ? "none" : "babel", lazy, esNamespaceOnly, filename, constantReexports = arguments[1].loose, enumerableModuleMeta = arguments[1].loose, noIncompleteNsImportDetection }) {
          (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop), _assert((0, _helperModuleImports.isModule)(path3), "Cannot process module statements in a script"), path3.node.sourceType = "script";
          const meta = (0, _normalizeAndLoadMetadata.default)(path3, exportName, { importInterop, initializeReexports: constantReexports, lazy, esNamespaceOnly, filename });
          allowTopLevelThis || (0, _rewriteThis.default)(path3);
          if ((0, _rewriteLiveReferences.default)(path3, meta), false !== strictMode) {
            const hasStrict = path3.node.directives.some((directive2) => "use strict" === directive2.value.value);
            hasStrict || path3.unshiftContainer("directives", directive(directiveLiteral("use strict")));
          }
          const headers = [];
          (0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict && headers.push(function(metadata, enumerableModuleMeta2 = false) {
            return (enumerableModuleMeta2 ? _template.default.statement`
        EXPORTS.__esModule = true;
      ` : _template.default.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: metadata.exportName });
          }(meta, enumerableModuleMeta));
          const nameList = function(programPath, metadata) {
            const exportedVars = /* @__PURE__ */ Object.create(null);
            for (const data2 of metadata.local.values())
              for (const name2 of data2.names)
                exportedVars[name2] = true;
            let hasReexport = false;
            for (const data2 of metadata.source.values()) {
              for (const exportName2 of data2.reexports.keys())
                exportedVars[exportName2] = true;
              for (const exportName2 of data2.reexportNamespace)
                exportedVars[exportName2] = true;
              hasReexport = hasReexport || !!data2.reexportAll;
            }
            if (!hasReexport || 0 === Object.keys(exportedVars).length)
              return null;
            const name = programPath.scope.generateUidIdentifier("exportNames");
            return delete exportedVars.default, { name: name.name, statement: variableDeclaration("var", [variableDeclarator(name, valueToNode(exportedVars))]) };
          }(path3, meta);
          nameList && (meta.exportNameListName = nameList.name, headers.push(nameList.statement));
          return headers.push(...function(programPath, metadata, constantReexports2 = false, noIncompleteNsImportDetection2 = false) {
            const initStatements = [];
            for (const [localName, data2] of metadata.local)
              if ("import" === data2.kind)
                ;
              else if ("hoisted" === data2.kind)
                initStatements.push([data2.names[0], buildInitStatement(metadata, data2.names, identifier(localName))]);
              else if (!noIncompleteNsImportDetection2)
                for (const exportName2 of data2.names)
                  initStatements.push([exportName2, null]);
            for (const data2 of metadata.source.values()) {
              if (!constantReexports2) {
                const reexportsStatements = buildReexportsFromMeta(metadata, data2, false), reexports = [...data2.reexports.keys()];
                for (let i = 0; i < reexportsStatements.length; i++)
                  initStatements.push([reexports[i], reexportsStatements[i]]);
              }
              if (!noIncompleteNsImportDetection2)
                for (const exportName2 of data2.reexportNamespace)
                  initStatements.push([exportName2, null]);
            }
            initStatements.sort(([a], [b]) => a < b ? -1 : b < a ? 1 : 0);
            const results = [];
            if (noIncompleteNsImportDetection2)
              for (const [, initStatement] of initStatements)
                results.push(initStatement);
            else {
              const chunkSize = 100;
              for (let i = 0; i < initStatements.length; i += chunkSize) {
                let uninitializedExportNames = [];
                for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
                  const [exportName2, initStatement] = initStatements[i + j];
                  null !== initStatement ? (uninitializedExportNames.length > 0 && (results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode())), uninitializedExportNames = []), results.push(initStatement)) : uninitializedExportNames.push(exportName2);
                }
                uninitializedExportNames.length > 0 && results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
              }
            }
            return results;
          }(path3, meta, constantReexports, noIncompleteNsImportDetection)), { meta, headers };
        }, Object.defineProperty(exports3, "rewriteThis", { enumerable: true, get: function() {
          return _rewriteThis.default;
        } }), exports3.wrapInterop = function(programPath, expr, type) {
          if ("none" === type)
            return null;
          if ("node-namespace" === type)
            return callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, booleanLiteral(true)]);
          if ("node-default" === type)
            return null;
          let helper;
          if ("default" === type)
            helper = "interopRequireDefault";
          else {
            if ("namespace" !== type)
              throw new Error(`Unknown interop: ${type}`);
            helper = "interopRequireWildcard";
          }
          return callExpression(programPath.hub.addHelper(helper), [expr]);
        };
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _template = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js"), _helperModuleImports = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-imports@7.22.5/node_modules/@babel/helper-module-imports/lib/index.js"), _rewriteThis = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"), _rewriteLiveReferences = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"), _normalizeAndLoadMetadata = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"), _dynamicImport = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"), _getModuleName = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/get-module-name.js");
        const { booleanLiteral, callExpression, cloneNode, directive, directiveLiteral, expressionStatement, identifier, isIdentifier, memberExpression, stringLiteral, valueToNode, variableDeclaration, variableDeclarator } = _t;
        exports3.getDynamicImportSource = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js").getDynamicImportSource;
        const ReexportTemplate = { constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`, constantComputed: _template.default.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`, spec: _template.default.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    ` };
        function buildReexportsFromMeta(meta, metadata, constantReexports) {
          const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name), { stringSpecifiers } = meta;
          return Array.from(metadata.reexports, ([exportName, importName2]) => {
            let NAMESPACE_IMPORT = cloneNode(namespace);
            "default" === importName2 && "node-default" === metadata.interop || (NAMESPACE_IMPORT = stringSpecifiers.has(importName2) ? memberExpression(NAMESPACE_IMPORT, stringLiteral(importName2), true) : memberExpression(NAMESPACE_IMPORT, identifier(importName2)));
            const astNodes = { EXPORTS: meta.exportName, EXPORT_NAME: exportName, NAMESPACE_IMPORT };
            return constantReexports || isIdentifier(NAMESPACE_IMPORT) ? stringSpecifiers.has(exportName) ? ReexportTemplate.constantComputed(astNodes) : ReexportTemplate.constant(astNodes) : ReexportTemplate.spec(astNodes);
          });
        }
        const InitTemplate = { computed: _template.default.expression`EXPORTS["NAME"] = VALUE`, default: _template.default.expression`EXPORTS.NAME = VALUE` };
        function buildInitStatement(metadata, exportNames, initExpr) {
          const { stringSpecifiers, exportName: EXPORTS } = metadata;
          return expressionStatement(exportNames.reduce((acc, exportName) => {
            const params = { EXPORTS, NAME: exportName, VALUE: acc };
            return stringSpecifiers.has(exportName) ? InitTemplate.computed(params) : InitTemplate.default(params);
          }, initExpr));
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(programPath, exportName, { importInterop, initializeReexports = false, lazy = false, esNamespaceOnly = false, filename }) {
          exportName || (exportName = programPath.scope.generateUidIdentifier("exports").name);
          const stringSpecifiers = /* @__PURE__ */ new Set();
          !function(programPath2) {
            programPath2.get("body").forEach((child) => {
              child.isExportDefaultDeclaration() && (0, _helperSplitExportDeclaration.default)(child);
            });
          }(programPath);
          const { local, sources, hasExports } = function(programPath2, { lazy: lazy2, initializeReexports: initializeReexports2 }, stringSpecifiers2) {
            const localData = function(programPath3, initializeReexports3, stringSpecifiers3) {
              const bindingKindLookup = /* @__PURE__ */ new Map();
              programPath3.get("body").forEach((child) => {
                let kind;
                if (child.isImportDeclaration())
                  kind = "import";
                else {
                  if (child.isExportDefaultDeclaration() && (child = child.get("declaration")), child.isExportNamedDeclaration()) {
                    if (child.node.declaration)
                      child = child.get("declaration");
                    else if (initializeReexports3 && child.node.source && child.get("source").isStringLiteral())
                      return void child.get("specifiers").forEach((spec) => {
                        assertExportSpecifier(spec), bindingKindLookup.set(spec.get("local").node.name, "block");
                      });
                  }
                  if (child.isFunctionDeclaration())
                    kind = "hoisted";
                  else if (child.isClassDeclaration())
                    kind = "block";
                  else if (child.isVariableDeclaration({ kind: "var" }))
                    kind = "var";
                  else {
                    if (!child.isVariableDeclaration())
                      return;
                    kind = "block";
                  }
                }
                Object.keys(child.getOuterBindingIdentifiers()).forEach((name) => {
                  bindingKindLookup.set(name, kind);
                });
              });
              const localMetadata = /* @__PURE__ */ new Map(), getLocalMetadata = (idPath) => {
                const localName = idPath.node.name;
                let metadata = localMetadata.get(localName);
                if (!metadata) {
                  const kind = bindingKindLookup.get(localName);
                  if (void 0 === kind)
                    throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
                  metadata = { names: [], kind }, localMetadata.set(localName, metadata);
                }
                return metadata;
              };
              return programPath3.get("body").forEach((child) => {
                if (!child.isExportNamedDeclaration() || !initializeReexports3 && child.node.source) {
                  if (child.isExportDefaultDeclaration()) {
                    const declaration = child.get("declaration");
                    if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration())
                      throw declaration.buildCodeFrameError("Unexpected default expression export.");
                    getLocalMetadata(declaration.get("id")).names.push("default");
                  }
                } else if (child.node.declaration) {
                  const declaration = child.get("declaration"), ids = declaration.getOuterBindingIdentifierPaths();
                  Object.keys(ids).forEach((name) => {
                    if ("__esModule" === name)
                      throw declaration.buildCodeFrameError('Illegal export "__esModule".');
                    getLocalMetadata(ids[name]).names.push(name);
                  });
                } else
                  child.get("specifiers").forEach((spec) => {
                    const local2 = spec.get("local"), exported = spec.get("exported"), localMetadata2 = getLocalMetadata(local2), exportName2 = getExportSpecifierName(exported, stringSpecifiers3);
                    if ("__esModule" === exportName2)
                      throw exported.buildCodeFrameError('Illegal export "__esModule".');
                    localMetadata2.names.push(exportName2);
                  });
              }), localMetadata;
            }(programPath2, initializeReexports2, stringSpecifiers2), sourceData = /* @__PURE__ */ new Map(), getData = (sourceNode) => {
              const source = sourceNode.value;
              let data2 = sourceData.get(source);
              return data2 || (data2 = { name: programPath2.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, lazy: false, referenced: false }, sourceData.set(source, data2)), data2;
            };
            let hasExports2 = false;
            programPath2.get("body").forEach((child) => {
              if (child.isImportDeclaration()) {
                const data2 = getData(child.node.source);
                data2.loc || (data2.loc = child.node.loc), child.get("specifiers").forEach((spec) => {
                  if (spec.isImportDefaultSpecifier()) {
                    const localName = spec.get("local").node.name;
                    data2.imports.set(localName, "default");
                    const reexport = localData.get(localName);
                    reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                      data2.reexports.set(name, "default");
                    }), data2.referenced = true);
                  } else if (spec.isImportNamespaceSpecifier()) {
                    const localName = spec.get("local").node.name;
                    data2.importsNamespace.add(localName);
                    const reexport = localData.get(localName);
                    reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                      data2.reexportNamespace.add(name);
                    }), data2.referenced = true);
                  } else if (spec.isImportSpecifier()) {
                    const importName2 = getExportSpecifierName(spec.get("imported"), stringSpecifiers2), localName = spec.get("local").node.name;
                    data2.imports.set(localName, importName2);
                    const reexport = localData.get(localName);
                    reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                      data2.reexports.set(name, importName2);
                    }), data2.referenced = true);
                  }
                });
              } else if (child.isExportAllDeclaration()) {
                hasExports2 = true;
                const data2 = getData(child.node.source);
                data2.loc || (data2.loc = child.node.loc), data2.reexportAll = { loc: child.node.loc }, data2.referenced = true;
              } else if (child.isExportNamedDeclaration() && child.node.source) {
                hasExports2 = true;
                const data2 = getData(child.node.source);
                data2.loc || (data2.loc = child.node.loc), child.get("specifiers").forEach((spec) => {
                  assertExportSpecifier(spec);
                  const importName2 = getExportSpecifierName(spec.get("local"), stringSpecifiers2), exportName2 = getExportSpecifierName(spec.get("exported"), stringSpecifiers2);
                  if (data2.reexports.set(exportName2, importName2), data2.referenced = true, "__esModule" === exportName2)
                    throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                });
              } else
                (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) && (hasExports2 = true);
            });
            for (const metadata of sourceData.values()) {
              let needsDefault = false, needsNamed = false;
              metadata.importsNamespace.size > 0 && (needsDefault = true, needsNamed = true), metadata.reexportAll && (needsNamed = true);
              for (const importName2 of metadata.imports.values())
                "default" === importName2 ? needsDefault = true : needsNamed = true;
              for (const importName2 of metadata.reexports.values())
                "default" === importName2 ? needsDefault = true : needsNamed = true;
              needsDefault && needsNamed ? metadata.interop = "namespace" : needsDefault && (metadata.interop = "default");
            }
            for (const [source, metadata] of sourceData)
              if (false !== lazy2 && !isSideEffectImport(metadata) && !metadata.reexportAll)
                if (true === lazy2)
                  metadata.lazy = !/\./.test(source);
                else if (Array.isArray(lazy2))
                  metadata.lazy = -1 !== lazy2.indexOf(source);
                else {
                  if ("function" != typeof lazy2)
                    throw new Error(".lazy must be a boolean, string array, or function");
                  metadata.lazy = lazy2(source);
                }
            return { hasExports: hasExports2, local: localData, sources: sourceData };
          }(programPath, { initializeReexports, lazy }, stringSpecifiers);
          !function(programPath2) {
            programPath2.get("body").forEach((child) => {
              if (child.isImportDeclaration())
                child.remove();
              else if (child.isExportNamedDeclaration())
                child.node.declaration ? (child.node.declaration._blockHoist = child.node._blockHoist, child.replaceWith(child.node.declaration)) : child.remove();
              else if (child.isExportDefaultDeclaration()) {
                const declaration = child.get("declaration");
                if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration())
                  throw declaration.buildCodeFrameError("Unexpected default expression export.");
                declaration._blockHoist = child.node._blockHoist, child.replaceWith(declaration);
              } else
                child.isExportAllDeclaration() && child.remove();
            });
          }(programPath);
          for (const [source, metadata] of sources) {
            metadata.importsNamespace.size > 0 && (metadata.name = metadata.importsNamespace.values().next().value);
            const resolvedInterop = resolveImportInterop(importInterop, source, filename);
            "none" === resolvedInterop ? metadata.interop = "none" : "node" === resolvedInterop && "namespace" === metadata.interop ? metadata.interop = "node-namespace" : "node" === resolvedInterop && "default" === metadata.interop ? metadata.interop = "node-default" : esNamespaceOnly && "namespace" === metadata.interop && (metadata.interop = "default");
          }
          return { exportName, exportNameListName: null, hasExports, local, source: sources, stringSpecifiers };
        }, exports3.hasExports = function(metadata) {
          return metadata.hasExports;
        }, exports3.isSideEffectImport = isSideEffectImport, exports3.validateImportInteropOption = validateImportInteropOption;
        var _path = __webpack_require__2("path"), _helperValidatorIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/index.js"), _helperSplitExportDeclaration = __webpack_require__2("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js");
        function isSideEffectImport(source) {
          return 0 === source.imports.size && 0 === source.importsNamespace.size && 0 === source.reexports.size && 0 === source.reexportNamespace.size && !source.reexportAll;
        }
        function validateImportInteropOption(importInterop) {
          if ("function" != typeof importInterop && "none" !== importInterop && "babel" !== importInterop && "node" !== importInterop)
            throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
          return importInterop;
        }
        function resolveImportInterop(importInterop, source, filename) {
          return "function" == typeof importInterop ? validateImportInteropOption(importInterop(source, filename)) : importInterop;
        }
        function getExportSpecifierName(path3, stringSpecifiers) {
          if (path3.isIdentifier())
            return path3.node.name;
          if (path3.isStringLiteral()) {
            const stringValue = path3.node.value;
            return (0, _helperValidatorIdentifier.isIdentifierName)(stringValue) || stringSpecifiers.add(stringValue), stringValue;
          }
          throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path3.node.type}`);
        }
        function assertExportSpecifier(path3) {
          if (!path3.isExportSpecifier())
            throw path3.isExportNamespaceSpecifier() ? path3.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : path3.buildCodeFrameError("Unexpected export specifier type");
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(programPath, metadata) {
          const imported = /* @__PURE__ */ new Map(), exported = /* @__PURE__ */ new Map(), requeueInParent = (path3) => {
            programPath.requeue(path3);
          };
          for (const [source, data2] of metadata.source) {
            for (const [localName, importName2] of data2.imports)
              imported.set(localName, [source, importName2, null]);
            for (const localName of data2.importsNamespace)
              imported.set(localName, [source, null, localName]);
          }
          for (const [local, data2] of metadata.local) {
            let exportMeta = exported.get(local);
            exportMeta || (exportMeta = [], exported.set(local, exportMeta)), exportMeta.push(...data2.names);
          }
          const rewriteBindingInitVisitorState = { metadata, requeueInParent, scope: programPath.scope, exported };
          programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
          const bindingNames = /* @__PURE__ */ new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]);
          (0, _helperSimpleAccess.default)(programPath, bindingNames, false);
          const rewriteReferencesVisitorState = { seen: /* @__PURE__ */ new WeakSet(), metadata, requeueInParent, scope: programPath.scope, imported, exported, buildImportReference: ([source, importName2, localName], identNode) => {
            const meta = metadata.source.get(source);
            if (meta.referenced = true, localName)
              return meta.lazy && (identNode = callExpression(identNode, [])), identNode;
            let namespace = identifier(meta.name);
            if (meta.lazy && (namespace = callExpression(namespace, [])), "default" === importName2 && "node-default" === meta.interop)
              return namespace;
            const computed = metadata.stringSpecifiers.has(importName2);
            return memberExpression(namespace, computed ? stringLiteral(importName2) : identifier(importName2), computed);
          } };
          programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
        };
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _template = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js"), _helperSimpleAccess = __webpack_require__2("./node_modules/.pnpm/@babel+helper-simple-access@7.22.5/node_modules/@babel/helper-simple-access/lib/index.js");
        const { assignmentExpression, callExpression, cloneNode, expressionStatement, getOuterBindingIdentifiers, identifier, isMemberExpression, isVariableDeclaration, jsxIdentifier, jsxMemberExpression, memberExpression, numericLiteral, sequenceExpression, stringLiteral, variableDeclaration, variableDeclarator } = _t;
        const rewriteBindingInitVisitor = { Scope(path3) {
          path3.skip();
        }, ClassDeclaration(path3) {
          const { requeueInParent, exported, metadata } = this, { id } = path3.node;
          if (!id)
            throw new Error("Expected class to have a name");
          const localName = id.name, exportNames = exported.get(localName) || [];
          if (exportNames.length > 0) {
            const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path3.scope));
            statement._blockHoist = path3.node._blockHoist, requeueInParent(path3.insertAfter(statement)[0]);
          }
        }, VariableDeclaration(path3) {
          const { requeueInParent, exported, metadata } = this;
          Object.keys(path3.getOuterBindingIdentifiers()).forEach((localName) => {
            const exportNames = exported.get(localName) || [];
            if (exportNames.length > 0) {
              const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path3.scope));
              statement._blockHoist = path3.node._blockHoist, requeueInParent(path3.insertAfter(statement)[0]);
            }
          });
        } }, buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {
          const exportsObjectName = metadata.exportName;
          for (let currentScope = scope; null != currentScope; currentScope = currentScope.parent)
            currentScope.hasOwnBinding(exportsObjectName) && currentScope.rename(exportsObjectName);
          return (exportNames || []).reduce((expr, exportName) => {
            const { stringSpecifiers } = metadata, computed = stringSpecifiers.has(exportName);
            return assignmentExpression("=", memberExpression(identifier(exportsObjectName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);
          }, localExpr);
        }, buildImportThrow = (localName) => _template.default.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `, rewriteReferencesVisitor = { ReferencedIdentifier(path3) {
          const { seen, buildImportReference, scope, imported, requeueInParent } = this;
          if (seen.has(path3.node))
            return;
          seen.add(path3.node);
          const localName = path3.node.name, importData = imported.get(localName);
          if (importData) {
            if (function(path4) {
              do {
                switch (path4.parent.type) {
                  case "TSTypeAnnotation":
                  case "TSTypeAliasDeclaration":
                  case "TSTypeReference":
                  case "TypeAnnotation":
                  case "TypeAlias":
                    return true;
                  case "ExportSpecifier":
                    return "type" === path4.parentPath.parent.exportKind;
                  default:
                    if (path4.parentPath.isStatement() || path4.parentPath.isExpression())
                      return false;
                }
              } while (path4 = path4.parentPath);
            }(path3))
              throw path3.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            const localBinding = path3.scope.getBinding(localName);
            if (scope.getBinding(localName) !== localBinding)
              return;
            const ref2 = buildImportReference(importData, path3.node);
            if (ref2.loc = path3.node.loc, (path3.parentPath.isCallExpression({ callee: path3.node }) || path3.parentPath.isOptionalCallExpression({ callee: path3.node }) || path3.parentPath.isTaggedTemplateExpression({ tag: path3.node })) && isMemberExpression(ref2))
              path3.replaceWith(sequenceExpression([numericLiteral(0), ref2]));
            else if (path3.isJSXIdentifier() && isMemberExpression(ref2)) {
              const { object, property } = ref2;
              path3.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
            } else
              path3.replaceWith(ref2);
            requeueInParent(path3), path3.skip();
          }
        }, UpdateExpression(path3) {
          const { scope, seen, imported, exported, requeueInParent, buildImportReference } = this;
          if (seen.has(path3.node))
            return;
          seen.add(path3.node);
          const arg = path3.get("argument");
          if (arg.isMemberExpression())
            return;
          const update = path3.node;
          if (arg.isIdentifier()) {
            const localName = arg.node.name;
            if (scope.getBinding(localName) !== path3.scope.getBinding(localName))
              return;
            const exportedNames = exported.get(localName), importData = imported.get(localName);
            if ((null == exportedNames ? void 0 : exportedNames.length) > 0 || importData)
              if (importData)
                path3.replaceWith(assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
              else if (update.prefix)
                path3.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update), path3.scope));
              else {
                const ref2 = scope.generateDeclaredUidIdentifier(localName);
                path3.replaceWith(sequenceExpression([assignmentExpression("=", cloneNode(ref2), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path3.scope), cloneNode(ref2)]));
              }
          }
          requeueInParent(path3), path3.skip();
        }, AssignmentExpression: { exit(path3) {
          const { scope, seen, imported, exported, requeueInParent, buildImportReference } = this;
          if (seen.has(path3.node))
            return;
          seen.add(path3.node);
          const left = path3.get("left");
          if (!left.isMemberExpression())
            if (left.isIdentifier()) {
              const localName = left.node.name;
              if (scope.getBinding(localName) !== path3.scope.getBinding(localName))
                return;
              const exportedNames = exported.get(localName), importData = imported.get(localName);
              if ((null == exportedNames ? void 0 : exportedNames.length) > 0 || importData) {
                _assert("=" === path3.node.operator, "Path was not simplified");
                const assignment = path3.node;
                importData && (assignment.left = buildImportReference(importData, left.node), assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)])), path3.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path3.scope)), requeueInParent(path3);
              }
            } else {
              const ids = left.getOuterBindingIdentifiers(), programScopeIds = Object.keys(ids).filter((localName) => scope.getBinding(localName) === path3.scope.getBinding(localName)), id = programScopeIds.find((localName) => imported.has(localName));
              id && (path3.node.right = sequenceExpression([path3.node.right, buildImportThrow(id)]));
              const items = [];
              if (programScopeIds.forEach((localName) => {
                const exportedNames = exported.get(localName) || [];
                exportedNames.length > 0 && items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path3.scope));
              }), items.length > 0) {
                let node = sequenceExpression(items);
                path3.parentPath.isExpressionStatement() && (node = expressionStatement(node), node._blockHoist = path3.parentPath.node._blockHoist);
                requeueInParent(path3.insertAfter(node)[0]);
              }
            }
        } }, "ForOfStatement|ForInStatement"(path3) {
          const { scope, node } = path3, { left } = node, { exported, imported, scope: programScope } = this;
          if (!isVariableDeclaration(left)) {
            let importConstViolationName, didTransformExport = false;
            const loopBodyScope = path3.get("body").scope;
            for (const name of Object.keys(getOuterBindingIdentifiers(left)))
              programScope.getBinding(name) === scope.getBinding(name) && (exported.has(name) && (didTransformExport = true, loopBodyScope.hasOwnBinding(name) && loopBodyScope.rename(name)), imported.has(name) && !importConstViolationName && (importConstViolationName = name));
            if (!didTransformExport && !importConstViolationName)
              return;
            path3.ensureBlock();
            const bodyPath = path3.get("body"), newLoopId = scope.generateUidIdentifierBasedOnNode(left);
            path3.get("left").replaceWith(variableDeclaration("let", [variableDeclarator(cloneNode(newLoopId))])), scope.registerDeclaration(path3.get("left")), didTransformExport && bodyPath.unshiftContainer("body", expressionStatement(assignmentExpression("=", left, newLoopId))), importConstViolationName && bodyPath.unshiftContainer("body", expressionStatement(buildImportThrow(importConstViolationName)));
          }
        } };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(programPath) {
          (0, _traverse.default)(programPath.node, Object.assign({}, rewriteThisVisitor, { noScope: true }));
        };
        var _helperEnvironmentVisitor = __webpack_require__2("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), _traverse = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { numericLiteral, unaryExpression } = _t, rewriteThisVisitor = _traverse.default.visitors.merge([_helperEnvironmentVisitor.default, { ThisExpression(path3) {
          path3.replaceWith(unaryExpression("void", numericLiteral(0), true));
        } }]);
      }, "./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.22.5/node_modules/@babel/helper-optimise-call-expression/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(callee, thisNode, args, optional) {
          return 1 === args.length && isSpreadElement(args[0]) && isIdentifier(args[0].argument, { name: "arguments" }) ? optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), false, true), [thisNode, args[0].argument], false) : callExpression(memberExpression(callee, identifier("apply")), [thisNode, args[0].argument]) : optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("call"), false, true), [thisNode, ...args], false) : callExpression(memberExpression(callee, identifier("call")), [thisNode, ...args]);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { callExpression, identifier, isIdentifier, isSpreadElement, memberExpression, optionalCallExpression, optionalMemberExpression } = _t;
      }, "./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.declare = declare, exports3.declarePreset = void 0;
        const apiPolyfills = { assertVersion: (api) => (range) => {
          !function(range2, version2) {
            if ("number" == typeof range2) {
              if (!Number.isInteger(range2))
                throw new Error("Expected string or integer value.");
              range2 = `^${range2}.0.0-0`;
            }
            if ("string" != typeof range2)
              throw new Error("Expected string or integer value.");
            const limit = Error.stackTraceLimit;
            "number" == typeof limit && limit < 25 && (Error.stackTraceLimit = 25);
            let err;
            err = "7." === version2.slice(0, 2) ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version2}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${range2}", but was loaded with "${version2}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
            "number" == typeof limit && (Error.stackTraceLimit = limit);
            throw Object.assign(err, { code: "BABEL_VERSION_UNSUPPORTED", version: version2, range: range2 });
          }(range, api.version);
        } };
        function declare(builder) {
          return (api, options, dirname3) => {
            var _clonedApi2;
            let clonedApi;
            for (const name of Object.keys(apiPolyfills)) {
              api[name] || (null != clonedApi || (clonedApi = copyApiObject(api)), clonedApi[name] = apiPolyfills[name](clonedApi));
            }
            return builder(null != (_clonedApi2 = clonedApi) ? _clonedApi2 : api, options || {}, dirname3);
          };
        }
        Object.assign(apiPolyfills, { targets: () => () => ({}), assumption: () => () => {
        } });
        const declarePreset = declare;
        function copyApiObject(api) {
          let proto = null;
          return "string" == typeof api.version && /^7\./.test(api.version) && (proto = Object.getPrototypeOf(api), !proto || has(proto, "version") && has(proto, "transform") && has(proto, "template") && has(proto, "types") || (proto = null)), Object.assign({}, proto, api);
        }
        function has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports3.declarePreset = declarePreset;
      }, "./node_modules/.pnpm/@babel+helper-replace-supers@7.22.5/node_modules/@babel/helper-replace-supers/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperEnvironmentVisitor = __webpack_require__2("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), _helperMemberExpressionToFunctions = __webpack_require__2("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.22.5/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), _helperOptimiseCallExpression = __webpack_require__2("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.22.5/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), _template = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js"), _traverse = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { assignmentExpression, booleanLiteral, callExpression, cloneNode, identifier, memberExpression, sequenceExpression, stringLiteral, thisExpression } = _t;
        {
          const ns = __webpack_require__2("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js");
          exports3.environmentVisitor = ns.default, exports3.skipAllButComputedKey = ns.skipAllButComputedKey;
        }
        function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
          objectRef = cloneNode(objectRef);
          const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
          return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
        }
        const visitor = _traverse.default.visitors.merge([_helperEnvironmentVisitor.default, { Super(path3, state) {
          const { node, parentPath } = path3;
          parentPath.isMemberExpression({ object: node }) && state.handle(parentPath);
        } }]), unshadowSuperBindingVisitor = _traverse.default.visitors.merge([_helperEnvironmentVisitor.default, { Scopable(path3, { refName }) {
          const binding = path3.scope.getOwnBinding(refName);
          binding && binding.identifier.name === refName && path3.scope.rename(refName);
        } }]), specHandlers = { memoise(superMember, count) {
          const { scope, node } = superMember, { computed, property } = node;
          if (!computed)
            return;
          const memo = scope.maybeGenerateMemoised(property);
          memo && this.memoiser.set(property, memo, count);
        }, prop(superMember) {
          const { computed, property } = superMember.node;
          return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : computed ? cloneNode(property) : stringLiteral(property.name);
        }, get(superMember) {
          return this._get(superMember, this._getThisRefs());
        }, _get(superMember, thisRefs) {
          const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return callExpression(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);
        }, _getThisRefs() {
          if (!this.isDerivedConstructor)
            return { this: thisExpression() };
          const thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
          return { memo: assignmentExpression("=", thisRef, thisExpression()), this: cloneNode(thisRef) };
        }, set(superMember, value2) {
          const thisRefs = this._getThisRefs(), proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return callExpression(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value2, thisRefs.this, booleanLiteral(superMember.isInStrictMode())]);
        }, destructureSet(superMember) {
          throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(superMember, args) {
          const thisRefs = this._getThisRefs();
          return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);
        }, optionalCall(superMember, args) {
          const thisRefs = this._getThisRefs();
          return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);
        }, delete(superMember) {
          return superMember.node.computed ? sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _template.default.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : _template.default.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        } }, looseHandlers = Object.assign({}, specHandlers, { prop(superMember) {
          const { property } = superMember.node;
          return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : cloneNode(property);
        }, get(superMember) {
          const { isStatic, getSuperRef } = this, { computed } = superMember.node, prop = this.prop(superMember);
          let object;
          var _getSuperRef, _getSuperRef2;
          isStatic ? object = null != (_getSuperRef = getSuperRef()) ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype")) : object = memberExpression(null != (_getSuperRef2 = getSuperRef()) ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
          return memberExpression(object, prop, computed);
        }, set(superMember, value2) {
          const { computed } = superMember.node, prop = this.prop(superMember);
          return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value2);
        }, destructureSet(superMember) {
          const { computed } = superMember.node, prop = this.prop(superMember);
          return memberExpression(thisExpression(), prop, computed);
        }, call(superMember, args) {
          return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);
        }, optionalCall(superMember, args) {
          return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);
        } });
        exports3.default = class {
          constructor(opts) {
            var _opts$constantSuper;
            const path3 = opts.methodPath;
            this.methodPath = path3, this.isDerivedConstructor = path3.isClassMethod({ kind: "constructor" }) && !!opts.superRef, this.isStatic = path3.isObjectMethod() || path3.node.static || (null == path3.isStaticBlock ? void 0 : path3.isStaticBlock()), this.isPrivateMethod = path3.isPrivate() && path3.isMethod(), this.file = opts.file, this.constantSuper = null != (_opts$constantSuper = opts.constantSuper) ? _opts$constantSuper : opts.isLoose, this.opts = opts;
          }
          getObjectRef() {
            return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
          }
          getSuperRef() {
            return this.opts.superRef ? cloneNode(this.opts.superRef) : this.opts.getSuperRef ? cloneNode(this.opts.getSuperRef()) : void 0;
          }
          replace() {
            this.opts.refToPreserve && this.methodPath.traverse(unshadowSuperBindingVisitor, { refName: this.opts.refToPreserve.name });
            const handler = this.constantSuper ? looseHandlers : specHandlers;
            (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: handler.get }, handler));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-simple-access@7.22.5/node_modules/@babel/helper-simple-access/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(path3, bindingNames) {
          var _arguments$;
          path3.traverse(simpleAssignmentVisitor, { scope: path3.scope, bindingNames, seen: /* @__PURE__ */ new WeakSet(), includeUpdateExpression: null == (_arguments$ = arguments[2]) || _arguments$ });
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { LOGICAL_OPERATORS, assignmentExpression, binaryExpression, cloneNode, identifier, logicalExpression, numericLiteral, sequenceExpression, unaryExpression } = _t, simpleAssignmentVisitor = { AssignmentExpression: { exit(path3) {
          const { scope, seen, bindingNames } = this;
          if ("=" === path3.node.operator)
            return;
          if (seen.has(path3.node))
            return;
          seen.add(path3.node);
          const left = path3.get("left");
          if (!left.isIdentifier())
            return;
          const localName = left.node.name;
          if (!bindingNames.has(localName))
            return;
          if (scope.getBinding(localName) !== path3.scope.getBinding(localName))
            return;
          const operator = path3.node.operator.slice(0, -1);
          LOGICAL_OPERATORS.includes(operator) ? path3.replaceWith(logicalExpression(operator, path3.node.left, assignmentExpression("=", cloneNode(path3.node.left), path3.node.right))) : (path3.node.right = binaryExpression(operator, cloneNode(path3.node.left), path3.node.right), path3.node.operator = "=");
        } } };
        simpleAssignmentVisitor.UpdateExpression = { exit(path3) {
          if (!this.includeUpdateExpression)
            return;
          const { scope, bindingNames } = this, arg = path3.get("argument");
          if (!arg.isIdentifier())
            return;
          const localName = arg.node.name;
          if (bindingNames.has(localName) && scope.getBinding(localName) === path3.scope.getBinding(localName))
            if (path3.parentPath.isExpressionStatement() && !path3.isCompletionRecord()) {
              const operator = "++" == path3.node.operator ? "+=" : "-=";
              path3.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));
            } else if (path3.node.prefix)
              path3.replaceWith(assignmentExpression("=", identifier(localName), binaryExpression(path3.node.operator[0], unaryExpression("+", arg.node), numericLiteral(1))));
            else {
              const old = path3.scope.generateUidIdentifierBasedOnNode(arg.node, "old"), varName = old.name;
              path3.scope.push({ id: old });
              const binary = binaryExpression(path3.node.operator[0], identifier(varName), numericLiteral(1));
              path3.replaceWith(sequenceExpression([assignmentExpression("=", identifier(varName), unaryExpression("+", arg.node)), assignmentExpression("=", cloneNode(arg.node), binary), identifier(varName)]));
            }
        } };
      }, "./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.22.5/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.isTransparentExprWrapper = isTransparentExprWrapper, exports3.skipTransparentExprWrapperNodes = function(node) {
          for (; isTransparentExprWrapper(node); )
            node = node.expression;
          return node;
        }, exports3.skipTransparentExprWrappers = function(path3) {
          for (; isTransparentExprWrapper(path3.node); )
            path3 = path3.get("expression");
          return path3;
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { isParenthesizedExpression, isTSAsExpression, isTSNonNullExpression, isTSSatisfiesExpression, isTSTypeAssertion, isTypeCastExpression } = _t;
        function isTransparentExprWrapper(node) {
          return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
        }
      }, "./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(exportDeclaration) {
          if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration())
            throw new Error("Only default and named export declarations can be split.");
          if (exportDeclaration.isExportDefaultDeclaration()) {
            const declaration2 = exportDeclaration.get("declaration"), standaloneDeclaration = declaration2.isFunctionDeclaration() || declaration2.isClassDeclaration(), exportExpr = declaration2.isFunctionExpression() || declaration2.isClassExpression(), scope = declaration2.isScope() ? declaration2.scope.parent : declaration2.scope;
            let id = declaration2.node.id, needBindingRegistration = false;
            id ? exportExpr && scope.hasBinding(id.name) && (needBindingRegistration = true, id = scope.generateUidIdentifier(id.name)) : (needBindingRegistration = true, id = scope.generateUidIdentifier("default"), (standaloneDeclaration || exportExpr) && (declaration2.node.id = cloneNode(id)));
            const updatedDeclaration = standaloneDeclaration ? declaration2.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration2.node)]), updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
            return exportDeclaration.insertAfter(updatedExportDeclaration), exportDeclaration.replaceWith(updatedDeclaration), needBindingRegistration && scope.registerDeclaration(exportDeclaration), exportDeclaration;
          }
          if (exportDeclaration.get("specifiers").length > 0)
            throw new Error("It doesn't make sense to split exported specifiers.");
          const declaration = exportDeclaration.get("declaration"), bindingIdentifiers = declaration.getOuterBindingIdentifiers(), specifiers = Object.keys(bindingIdentifiers).map((name) => exportSpecifier(identifier(name), identifier(name))), aliasDeclar = exportNamedDeclaration(null, specifiers);
          return exportDeclaration.insertAfter(aliasDeclar), exportDeclaration.replaceWith(declaration.node), exportDeclaration;
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { cloneNode, exportNamedDeclaration, exportSpecifier, identifier, variableDeclaration, variableDeclarator } = _t;
      }, "./node_modules/.pnpm/@babel+helper-string-parser@7.22.5/node_modules/@babel/helper-string-parser/lib/index.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.readCodePoint = readCodePoint, exports3.readInt = readInt, exports3.readStringContents = function(type, input, pos, lineStart, curLine, errors) {
          const initialPos = pos, initialLineStart = lineStart, initialCurLine = curLine;
          let out = "", firstInvalidLoc = null, chunkStart = pos;
          const { length } = input;
          for (; ; ) {
            if (pos >= length) {
              errors.unterminated(initialPos, initialLineStart, initialCurLine), out += input.slice(chunkStart, pos);
              break;
            }
            const ch = input.charCodeAt(pos);
            if (isStringEnd(type, ch, input, pos)) {
              out += input.slice(chunkStart, pos);
              break;
            }
            if (92 === ch) {
              out += input.slice(chunkStart, pos);
              const res = readEscapedChar(input, pos, lineStart, curLine, "template" === type, errors);
              null !== res.ch || firstInvalidLoc ? out += res.ch : firstInvalidLoc = { pos, lineStart, curLine }, { pos, lineStart, curLine } = res, chunkStart = pos;
            } else
              8232 === ch || 8233 === ch ? (++curLine, lineStart = ++pos) : 10 === ch || 13 === ch ? "template" === type ? (out += input.slice(chunkStart, pos) + "\n", ++pos, 13 === ch && 10 === input.charCodeAt(pos) && ++pos, ++curLine, chunkStart = lineStart = pos) : errors.unterminated(initialPos, initialLineStart, initialCurLine) : ++pos;
          }
          return { pos, str: out, firstInvalidLoc, lineStart, curLine, containsInvalid: !!firstInvalidLoc };
        };
        var _isDigit = function(code) {
          return code >= 48 && code <= 57;
        };
        const forbiddenNumericSeparatorSiblings = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, isAllowedNumericSeparatorSibling = { bin: (ch) => 48 === ch || 49 === ch, oct: (ch) => ch >= 48 && ch <= 55, dec: (ch) => ch >= 48 && ch <= 57, hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102 };
        function isStringEnd(type, ch, input, pos) {
          return "template" === type ? 96 === ch || 36 === ch && 123 === input.charCodeAt(pos + 1) : ch === ("double" === type ? 34 : 39);
        }
        function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
          const throwOnInvalid = !inTemplate;
          pos++;
          const res = (ch2) => ({ pos, ch: ch2, lineStart, curLine }), ch = input.charCodeAt(pos++);
          switch (ch) {
            case 110:
              return res("\n");
            case 114:
              return res("\r");
            case 120: {
              let code;
              return { code, pos } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors), res(null === code ? null : String.fromCharCode(code));
            }
            case 117: {
              let code;
              return { code, pos } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors), res(null === code ? null : String.fromCodePoint(code));
            }
            case 116:
              return res("	");
            case 98:
              return res("\b");
            case 118:
              return res("\v");
            case 102:
              return res("\f");
            case 13:
              10 === input.charCodeAt(pos) && ++pos;
            case 10:
              lineStart = pos, ++curLine;
            case 8232:
            case 8233:
              return res("");
            case 56:
            case 57:
              if (inTemplate)
                return res(null);
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            default:
              if (ch >= 48 && ch <= 55) {
                const startPos = pos - 1;
                let octalStr = input.slice(startPos, pos + 2).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
                octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), pos += octalStr.length - 1;
                const next = input.charCodeAt(pos);
                if ("0" !== octalStr || 56 === next || 57 === next) {
                  if (inTemplate)
                    return res(null);
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
                return res(String.fromCharCode(octal));
              }
              return res(String.fromCharCode(ch));
          }
        }
        function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
          const initialPos = pos;
          let n;
          return { n, pos } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid), null === n && (throwOnInvalid ? errors.invalidEscapeSequence(initialPos, lineStart, curLine) : pos = initialPos - 1), { code: n, pos };
        }
        function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
          const start = pos, forbiddenSiblings = 16 === radix ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, isAllowedSibling = 16 === radix ? isAllowedNumericSeparatorSibling.hex : 10 === radix ? isAllowedNumericSeparatorSibling.dec : 8 === radix ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
          let invalid = false, total = 0;
          for (let i = 0, e = null == len ? 1 / 0 : len; i < e; ++i) {
            const code = input.charCodeAt(pos);
            let val;
            if (95 !== code || "bail" === allowNumSeparator) {
              if (val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : _isDigit(code) ? code - 48 : 1 / 0, val >= radix) {
                if (val <= 9 && bailOnError)
                  return { n: null, pos };
                if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix))
                  val = 0;
                else {
                  if (!forceLen)
                    break;
                  val = 0, invalid = true;
                }
              }
              ++pos, total = total * radix + val;
            } else {
              const prev = input.charCodeAt(pos - 1), next = input.charCodeAt(pos + 1);
              if (allowNumSeparator) {
                if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                  if (bailOnError)
                    return { n: null, pos };
                  errors.unexpectedNumericSeparator(pos, lineStart, curLine);
                }
              } else {
                if (bailOnError)
                  return { n: null, pos };
                errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
              }
              ++pos;
            }
          }
          return pos === start || null != len && pos - start !== len || invalid ? { n: null, pos } : { n: total, pos };
        }
        function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
          let code;
          if (123 === input.charCodeAt(pos)) {
            if (++pos, { code, pos } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors), ++pos, null !== code && code > 1114111) {
              if (!throwOnInvalid)
                return { code: null, pos };
              errors.invalidCodePoint(pos, lineStart, curLine);
            }
          } else
            ({ code, pos } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
          return { code, pos };
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/identifier.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.isIdentifierChar = isIdentifierChar2, exports3.isIdentifierName = function(name) {
          let isFirst = true;
          for (let i = 0; i < name.length; i++) {
            let cp = name.charCodeAt(i);
            if (55296 == (64512 & cp) && i + 1 < name.length) {
              const trail = name.charCodeAt(++i);
              56320 == (64512 & trail) && (cp = 65536 + ((1023 & cp) << 10) + (1023 & trail));
            }
            if (isFirst) {
              if (isFirst = false, !isIdentifierStart2(cp))
                return false;
            } else if (!isIdentifierChar2(cp))
              return false;
          }
          return !isFirst;
        }, exports3.isIdentifierStart = isIdentifierStart2;
        let nonASCIIidentifierStartChars2 = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", nonASCIIidentifierChars2 = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
        const nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]"), nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
        nonASCIIidentifierStartChars2 = nonASCIIidentifierChars2 = null;
        const astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet2(code, set) {
          let pos = 65536;
          for (let i = 0, length = set.length; i < length; i += 2) {
            if (pos += set[i], pos > code)
              return false;
            if (pos += set[i + 1], pos >= code)
              return true;
          }
          return false;
        }
        function isIdentifierStart2(code) {
          return code < 65 ? 36 === code : code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code)) : isInAstralSet2(code, astralIdentifierStartCodes2)));
        }
        function isIdentifierChar2(code) {
          return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code)) : isInAstralSet2(code, astralIdentifierStartCodes2) || isInAstralSet2(code, astralIdentifierCodes2))));
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "isIdentifierChar", { enumerable: true, get: function() {
          return _identifier.isIdentifierChar;
        } }), Object.defineProperty(exports3, "isIdentifierName", { enumerable: true, get: function() {
          return _identifier.isIdentifierName;
        } }), Object.defineProperty(exports3, "isIdentifierStart", { enumerable: true, get: function() {
          return _identifier.isIdentifierStart;
        } }), Object.defineProperty(exports3, "isKeyword", { enumerable: true, get: function() {
          return _keyword.isKeyword;
        } }), Object.defineProperty(exports3, "isReservedWord", { enumerable: true, get: function() {
          return _keyword.isReservedWord;
        } }), Object.defineProperty(exports3, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
          return _keyword.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(exports3, "isStrictBindReservedWord", { enumerable: true, get: function() {
          return _keyword.isStrictBindReservedWord;
        } }), Object.defineProperty(exports3, "isStrictReservedWord", { enumerable: true, get: function() {
          return _keyword.isStrictReservedWord;
        } });
        var _identifier = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/identifier.js"), _keyword = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/keyword.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/keyword.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.isKeyword = function(word) {
          return keywords2.has(word);
        }, exports3.isReservedWord = isReservedWord, exports3.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord, exports3.isStrictBindReservedWord = function(word, inModule) {
          return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
        }, exports3.isStrictReservedWord = isStrictReservedWord;
        const reservedWords_strict = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], reservedWords_strictBind = ["eval", "arguments"], keywords2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
        function isReservedWord(word, inModule) {
          return inModule && "await" === word || "enum" === word;
        }
        function isStrictReservedWord(word, inModule) {
          return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
        }
        function isStrictBindOnlyReservedWord(word) {
          return reservedWordsStrictBindSet.has(word);
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.22.5/node_modules/@babel/helper-validator-option/lib/find-suggestion.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.findSuggestion = function(str, arr) {
          const distances = arr.map((el) => function(a, b) {
            let i, j, t = [], u = [];
            const m2 = a.length, n = b.length;
            if (!m2)
              return n;
            if (!n)
              return m2;
            for (j = 0; j <= n; j++)
              t[j] = j;
            for (i = 1; i <= m2; i++) {
              for (u = [i], j = 1; j <= n; j++)
                u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
              t = u;
            }
            return u[n];
          }(el, str));
          return arr[distances.indexOf(min(...distances))];
        };
        const { min } = Math;
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.22.5/node_modules/@babel/helper-validator-option/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "OptionValidator", { enumerable: true, get: function() {
          return _validator.OptionValidator;
        } }), Object.defineProperty(exports3, "findSuggestion", { enumerable: true, get: function() {
          return _findSuggestion.findSuggestion;
        } });
        var _validator = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-option@7.22.5/node_modules/@babel/helper-validator-option/lib/validator.js"), _findSuggestion = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-option@7.22.5/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.22.5/node_modules/@babel/helper-validator-option/lib/validator.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.OptionValidator = void 0;
        var _findSuggestion = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-option@7.22.5/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
        exports3.OptionValidator = class {
          constructor(descriptor) {
            this.descriptor = descriptor;
          }
          validateTopLevelOptions(options, TopLevelOptionShape) {
            const validOptionNames = Object.keys(TopLevelOptionShape);
            for (const option of Object.keys(options))
              if (!validOptionNames.includes(option))
                throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.
- Did you mean '${(0, _findSuggestion.findSuggestion)(option, validOptionNames)}'?`));
          }
          validateBooleanOption(name, value2, defaultValue) {
            return void 0 === value2 ? defaultValue : (this.invariant("boolean" == typeof value2, `'${name}' option must be a boolean.`), value2);
          }
          validateStringOption(name, value2, defaultValue) {
            return void 0 === value2 ? defaultValue : (this.invariant("string" == typeof value2, `'${name}' option must be a string.`), value2);
          }
          invariant(condition, message) {
            if (!condition)
              throw new Error(this.formatMessage(message));
          }
          formatMessage(message) {
            return `${this.descriptor}: ${message}`;
          }
        };
      }, "./node_modules/.pnpm/@babel+helpers@7.22.6/node_modules/@babel/helpers/lib/helpers-generated.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _template = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js");
        function helper(minVersion, source) {
          return Object.freeze({ minVersion, ast: () => _template.default.program.ast(source, { preserveComments: true }) });
        }
        var _default = Object.freeze({ AsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(gen){var front,back;function resume(key,arg){try{var result=gen[key](arg),value=result.value,overloaded=value instanceof OverloadYield;Promise.resolve(overloaded?value.v:value).then((function(arg){if(overloaded){var nextKey="return"===key?"return":"next";if(!value.k||arg.done)return resume(nextKey,arg);arg=gen[nextKey](arg).value}settle(result.done?"return":"normal",arg)}),(function(err){resume("throw",err)}))}catch(err){settle("throw",err)}}function settle(type,value){switch(type){case"return":front.resolve({value:value,done:!0});break;case"throw":front.reject(value);break;default:front.resolve({value:value,done:!1})}(front=front.next)?resume(front.key,front.arg):back=null}this._invoke=function(key,arg){return new Promise((function(resolve,reject){var request={key:key,arg:arg,resolve:resolve,reject:reject,next:null};back?back=back.next=request:(front=back=request,resume(key,arg))}))},"function"!=typeof gen.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(arg){return this._invoke("next",arg)},AsyncGenerator.prototype.throw=function(arg){return this._invoke("throw",arg)},AsyncGenerator.prototype.return=function(arg){return this._invoke("return",arg)};'), OverloadYield: helper("7.18.14", "export default function _OverloadYield(value,kind){this.v=value,this.k=kind}"), applyDecs: helper("7.17.8", 'function old_createMetadataMethodsForProperty(metadataMap,kind,property,decoratorFinishedRef){return{getMetadata:function(key){old_assertNotFinished(decoratorFinishedRef,"getMetadata"),old_assertMetadataKey(key);var metadataForKey=metadataMap[key];if(void 0!==metadataForKey)if(1===kind){var pub=metadataForKey.public;if(void 0!==pub)return pub[property]}else if(2===kind){var priv=metadataForKey.private;if(void 0!==priv)return priv.get(property)}else if(Object.hasOwnProperty.call(metadataForKey,"constructor"))return metadataForKey.constructor},setMetadata:function(key,value){old_assertNotFinished(decoratorFinishedRef,"setMetadata"),old_assertMetadataKey(key);var metadataForKey=metadataMap[key];if(void 0===metadataForKey&&(metadataForKey=metadataMap[key]={}),1===kind){var pub=metadataForKey.public;void 0===pub&&(pub=metadataForKey.public={}),pub[property]=value}else if(2===kind){var priv=metadataForKey.priv;void 0===priv&&(priv=metadataForKey.private=new Map),priv.set(property,value)}else metadataForKey.constructor=value}}}function old_convertMetadataMapToFinal(obj,metadataMap){var parentMetadataMap=obj[Symbol.metadata||Symbol.for("Symbol.metadata")],metadataKeys=Object.getOwnPropertySymbols(metadataMap);if(0!==metadataKeys.length){for(var i=0;i<metadataKeys.length;i++){var key=metadataKeys[i],metaForKey=metadataMap[key],parentMetaForKey=parentMetadataMap?parentMetadataMap[key]:null,pub=metaForKey.public,parentPub=parentMetaForKey?parentMetaForKey.public:null;pub&&parentPub&&Object.setPrototypeOf(pub,parentPub);var priv=metaForKey.private;if(priv){var privArr=Array.from(priv.values()),parentPriv=parentMetaForKey?parentMetaForKey.private:null;parentPriv&&(privArr=privArr.concat(parentPriv)),metaForKey.private=privArr}parentMetaForKey&&Object.setPrototypeOf(metaForKey,parentMetaForKey)}parentMetadataMap&&Object.setPrototypeOf(metadataMap,parentMetadataMap),obj[Symbol.metadata||Symbol.for("Symbol.metadata")]=metadataMap}}function old_createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){old_assertNotFinished(decoratorFinishedRef,"addInitializer"),old_assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function old_memberDec(dec,name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var metadataKind,metadataName,ctx={kind:kindStr,name:isPrivate?"#"+name:name,isStatic:isStatic,isPrivate:isPrivate},decoratorFinishedRef={v:!1};if(0!==kind&&(ctx.addInitializer=old_createAddInitializerMethod(initializers,decoratorFinishedRef)),isPrivate){metadataKind=2,metadataName=Symbol(name);var access={};0===kind?(access.get=desc.get,access.set=desc.set):2===kind?access.get=function(){return desc.value}:(1!==kind&&3!==kind||(access.get=function(){return desc.get.call(this)}),1!==kind&&4!==kind||(access.set=function(v){desc.set.call(this,v)})),ctx.access=access}else metadataKind=1,metadataName=name;try{return dec(value,Object.assign(ctx,old_createMetadataMethodsForProperty(metadataMap,metadataKind,metadataName,decoratorFinishedRef)))}finally{decoratorFinishedRef.v=!0}}function old_assertNotFinished(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}function old_assertMetadataKey(key){if("symbol"!=typeof key)throw new TypeError("Metadata keys must be symbols, received: "+key)}function old_assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function old_assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&old_assertCallable(value.get,"accessor.get"),void 0!==value.set&&old_assertCallable(value.set,"accessor.set"),void 0!==value.init&&old_assertCallable(value.init,"accessor.init"),void 0!==value.initializer&&old_assertCallable(value.initializer,"accessor.initializer")}else if("function"!==type){var hint;throw hint=0===kind?"field":10===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function old_getInit(desc){var initializer;return null==(initializer=desc.init)&&(initializer=desc.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),initializer}function old_applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers){var desc,initializer,value,newValue,get,set,decs=decInfo[0];if(isPrivate?desc=0===kind||1===kind?{get:decInfo[3],set:decInfo[4]}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set),"function"==typeof decs)void 0!==(newValue=old_memberDec(decs,name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value))&&(old_assertValidReturnValue(kind,newValue),0===kind?initializer=newValue:1===kind?(initializer=old_getInit(newValue),get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=old_memberDec(decs[i],name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value)))old_assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=old_getInit(newValue),get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===initializer?initializer=newInit:"function"==typeof initializer?initializer=[initializer,newInit]:initializer.push(newInit))}if(0===kind||1===kind){if(void 0===initializer)initializer=function(instance,init){return init};else if("function"!=typeof initializer){var ownInitializers=initializer;initializer=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=initializer;initializer=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(initializer)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function old_applyMemberDecs(ret,Class,protoMetadataMap,staticMetadataMap,decInfos){for(var protoInitializers,staticInitializers,existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,metadataMap,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5;if(isStatic?(base=Class,metadataMap=staticMetadataMap,0!==(kind-=5)&&(initializers=staticInitializers=staticInitializers||[])):(base=Class.prototype,metadataMap=protoMetadataMap,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}old_applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers)}}old_pushInitializers(ret,protoInitializers),old_pushInitializers(ret,staticInitializers)}function old_pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}function old_applyClassDecs(ret,targetClass,metadataMap,classDecs){if(classDecs.length>0){for(var initializers=[],newClass=targetClass,name=targetClass.name,i=classDecs.length-1;i>=0;i--){var decoratorFinishedRef={v:!1};try{var ctx=Object.assign({kind:"class",name:name,addInitializer:old_createAddInitializerMethod(initializers,decoratorFinishedRef)},old_createMetadataMethodsForProperty(metadataMap,0,name,decoratorFinishedRef)),nextNewClass=classDecs[i](newClass,ctx)}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(old_assertValidReturnValue(10,nextNewClass),newClass=nextNewClass)}ret.push(newClass,(function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}))}}export default function applyDecs(targetClass,memberDecs,classDecs){var ret=[],staticMetadataMap={},protoMetadataMap={};return old_applyMemberDecs(ret,targetClass,protoMetadataMap,staticMetadataMap,memberDecs),old_convertMetadataMapToFinal(targetClass.prototype,protoMetadataMap),old_applyClassDecs(ret,targetClass,staticMetadataMap,classDecs),old_convertMetadataMapToFinal(targetClass,staticMetadataMap),ret}'), applyDecs2203: helper("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){!function(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}(decoratorFinishedRef,"addInitializer"),assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function memberDec(dec,name,desc,initializers,kind,isStatic,isPrivate,value){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var get,set,ctx={kind:kindStr,name:isPrivate?"#"+name:name,static:isStatic,private:isPrivate},decoratorFinishedRef={v:!1};0!==kind&&(ctx.addInitializer=createAddInitializerMethod(initializers,decoratorFinishedRef)),0===kind?isPrivate?(get=desc.get,set=desc.set):(get=function(){return this[name]},set=function(v){this[name]=v}):2===kind?get=function(){return desc.value}:(1!==kind&&3!==kind||(get=function(){return desc.get.call(this)}),1!==kind&&4!==kind||(set=function(v){desc.set.call(this,v)})),ctx.access=get&&set?{get:get,set:set}:get?{get:get}:{set:set};try{return dec(value,ctx)}finally{decoratorFinishedRef.v=!0}}function assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&assertCallable(value.get,"accessor.get"),void 0!==value.set&&assertCallable(value.set,"accessor.set"),void 0!==value.init&&assertCallable(value.init,"accessor.init")}else if("function"!==type){var hint;throw hint=0===kind?"field":10===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers){var desc,init,value,newValue,get,set,decs=decInfo[0];if(isPrivate?desc=0===kind||1===kind?{get:decInfo[3],set:decInfo[4]}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set),"function"==typeof decs)void 0!==(newValue=memberDec(decs,name,desc,initializers,kind,isStatic,isPrivate,value))&&(assertValidReturnValue(kind,newValue),0===kind?init=newValue:1===kind?(init=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=memberDec(decs[i],name,desc,initializers,kind,isStatic,isPrivate,value)))assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===init?init=newInit:"function"==typeof init?init=[init,newInit]:init.push(newInit))}if(0===kind||1===kind){if(void 0===init)init=function(instance,init){return init};else if("function"!=typeof init){var ownInitializers=init;init=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=init;init=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(init)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}return function(targetClass,memberDecs,classDecs){var ret=[];return function(ret,Class,decInfos){for(var protoInitializers,staticInitializers,existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5;if(isStatic?(base=Class,0!=(kind-=5)&&(initializers=staticInitializers=staticInitializers||[])):(base=Class.prototype,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers)}}pushInitializers(ret,protoInitializers),pushInitializers(ret,staticInitializers)}(ret,targetClass,memberDecs),function(ret,targetClass,classDecs){if(classDecs.length>0){for(var initializers=[],newClass=targetClass,name=targetClass.name,i=classDecs.length-1;i>=0;i--){var decoratorFinishedRef={v:!1};try{var nextNewClass=classDecs[i](newClass,{kind:"class",name:name,addInitializer:createAddInitializerMethod(initializers,decoratorFinishedRef)})}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(assertValidReturnValue(10,nextNewClass),newClass=nextNewClass)}ret.push(newClass,(function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}))}}(ret,targetClass,classDecs),ret}}var applyDecs2203Impl;export default function applyDecs2203(targetClass,memberDecs,classDecs){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(targetClass,memberDecs,classDecs)}'), applyDecs2203R: helper("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){!function(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}(decoratorFinishedRef,"addInitializer"),assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function memberDec(dec,name,desc,initializers,kind,isStatic,isPrivate,value){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var get,set,ctx={kind:kindStr,name:isPrivate?"#"+name:name,static:isStatic,private:isPrivate},decoratorFinishedRef={v:!1};0!==kind&&(ctx.addInitializer=createAddInitializerMethod(initializers,decoratorFinishedRef)),0===kind?isPrivate?(get=desc.get,set=desc.set):(get=function(){return this[name]},set=function(v){this[name]=v}):2===kind?get=function(){return desc.value}:(1!==kind&&3!==kind||(get=function(){return desc.get.call(this)}),1!==kind&&4!==kind||(set=function(v){desc.set.call(this,v)})),ctx.access=get&&set?{get:get,set:set}:get?{get:get}:{set:set};try{return dec(value,ctx)}finally{decoratorFinishedRef.v=!0}}function assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&assertCallable(value.get,"accessor.get"),void 0!==value.set&&assertCallable(value.set,"accessor.set"),void 0!==value.init&&assertCallable(value.init,"accessor.init")}else if("function"!==type){var hint;throw hint=0===kind?"field":10===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers){var desc,init,value,newValue,get,set,decs=decInfo[0];if(isPrivate?desc=0===kind||1===kind?{get:decInfo[3],set:decInfo[4]}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set),"function"==typeof decs)void 0!==(newValue=memberDec(decs,name,desc,initializers,kind,isStatic,isPrivate,value))&&(assertValidReturnValue(kind,newValue),0===kind?init=newValue:1===kind?(init=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=memberDec(decs[i],name,desc,initializers,kind,isStatic,isPrivate,value)))assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===init?init=newInit:"function"==typeof init?init=[init,newInit]:init.push(newInit))}if(0===kind||1===kind){if(void 0===init)init=function(instance,init){return init};else if("function"!=typeof init){var ownInitializers=init;init=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=init;init=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(init)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function applyMemberDecs(Class,decInfos){for(var protoInitializers,staticInitializers,ret=[],existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5;if(isStatic?(base=Class,0!==(kind-=5)&&(initializers=staticInitializers=staticInitializers||[])):(base=Class.prototype,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers)}}return pushInitializers(ret,protoInitializers),pushInitializers(ret,staticInitializers),ret}function pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}return function(targetClass,memberDecs,classDecs){return{e:applyMemberDecs(targetClass,memberDecs),get c(){return function(targetClass,classDecs){if(classDecs.length>0){for(var initializers=[],newClass=targetClass,name=targetClass.name,i=classDecs.length-1;i>=0;i--){var decoratorFinishedRef={v:!1};try{var nextNewClass=classDecs[i](newClass,{kind:"class",name:name,addInitializer:createAddInitializerMethod(initializers,decoratorFinishedRef)})}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(assertValidReturnValue(10,nextNewClass),newClass=nextNewClass)}return[newClass,function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}]}}(targetClass,classDecs)}}}}export default function applyDecs2203R(targetClass,memberDecs,classDecs){return(applyDecs2203R=applyDecs2203RFactory())(targetClass,memberDecs,classDecs)}'), applyDecs2301: helper("7.21.0", 'import checkInRHS from"checkInRHS";function applyDecs2301Factory(){function createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){!function(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}(decoratorFinishedRef,"addInitializer"),assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function assertInstanceIfPrivate(has,target){if(!has(target))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(dec,name,desc,initializers,kind,isStatic,isPrivate,value,hasPrivateBrand){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var get,set,ctx={kind:kindStr,name:isPrivate?"#"+name:name,static:isStatic,private:isPrivate},decoratorFinishedRef={v:!1};if(0!==kind&&(ctx.addInitializer=createAddInitializerMethod(initializers,decoratorFinishedRef)),isPrivate||0!==kind&&2!==kind)if(2===kind)get=function(target){return assertInstanceIfPrivate(hasPrivateBrand,target),desc.value};else{var t=0===kind||1===kind;(t||3===kind)&&(get=isPrivate?function(target){return assertInstanceIfPrivate(hasPrivateBrand,target),desc.get.call(target)}:function(target){return desc.get.call(target)}),(t||4===kind)&&(set=isPrivate?function(target,value){assertInstanceIfPrivate(hasPrivateBrand,target),desc.set.call(target,value)}:function(target,value){desc.set.call(target,value)})}else get=function(target){return target[name]},0===kind&&(set=function(target,v){target[name]=v});var has=isPrivate?hasPrivateBrand.bind():function(target){return name in target};ctx.access=get&&set?{get:get,set:set,has:has}:get?{get:get,has:has}:{set:set,has:has};try{return dec(value,ctx)}finally{decoratorFinishedRef.v=!0}}function assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&assertCallable(value.get,"accessor.get"),void 0!==value.set&&assertCallable(value.set,"accessor.set"),void 0!==value.init&&assertCallable(value.init,"accessor.init")}else if("function"!==type){var hint;throw hint=0===kind?"field":10===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function curryThis2(fn){return function(value){fn(this,value)}}function applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers,hasPrivateBrand){var desc,init,value,fn,newValue,get,set,decs=decInfo[0];if(isPrivate?desc=0===kind||1===kind?{get:(fn=decInfo[3],function(){return fn(this)}),set:curryThis2(decInfo[4])}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set),"function"==typeof decs)void 0!==(newValue=memberDec(decs,name,desc,initializers,kind,isStatic,isPrivate,value,hasPrivateBrand))&&(assertValidReturnValue(kind,newValue),0===kind?init=newValue:1===kind?(init=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=memberDec(decs[i],name,desc,initializers,kind,isStatic,isPrivate,value,hasPrivateBrand)))assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===init?init=newInit:"function"==typeof init?init=[init,newInit]:init.push(newInit))}if(0===kind||1===kind){if(void 0===init)init=function(instance,init){return init};else if("function"!=typeof init){var ownInitializers=init;init=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=init;init=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(init)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function applyMemberDecs(Class,decInfos,instanceBrand){for(var protoInitializers,staticInitializers,staticBrand,ret=[],existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5,hasPrivateBrand=instanceBrand;if(isStatic?(base=Class,0!==(kind-=5)&&(initializers=staticInitializers=staticInitializers||[]),isPrivate&&!staticBrand&&(staticBrand=function(_){return checkInRHS(_)===Class}),hasPrivateBrand=staticBrand):(base=Class.prototype,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers,hasPrivateBrand)}}return pushInitializers(ret,protoInitializers),pushInitializers(ret,staticInitializers),ret}function pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}return function(targetClass,memberDecs,classDecs,instanceBrand){return{e:applyMemberDecs(targetClass,memberDecs,instanceBrand),get c(){return function(targetClass,classDecs){if(classDecs.length>0){for(var initializers=[],newClass=targetClass,name=targetClass.name,i=classDecs.length-1;i>=0;i--){var decoratorFinishedRef={v:!1};try{var nextNewClass=classDecs[i](newClass,{kind:"class",name:name,addInitializer:createAddInitializerMethod(initializers,decoratorFinishedRef)})}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(assertValidReturnValue(10,nextNewClass),newClass=nextNewClass)}return[newClass,function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}]}}(targetClass,classDecs)}}}}export default function applyDecs2301(targetClass,memberDecs,classDecs,instanceBrand){return(applyDecs2301=applyDecs2301Factory())(targetClass,memberDecs,classDecs,instanceBrand)}'), applyDecs2305: helper("7.21.0", 'import checkInRHS from"checkInRHS";function createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){assertNotFinished(decoratorFinishedRef,"addInitializer"),assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function assertInstanceIfPrivate(has,target){if(!has(target))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(dec,thisArg,name,desc,initializers,kind,isStatic,isPrivate,value,hasPrivateBrand){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var get,set,ctx={kind:kindStr,name:isPrivate?"#"+name:name,static:isStatic,private:isPrivate},decoratorFinishedRef={v:!1};if(0!==kind&&(ctx.addInitializer=createAddInitializerMethod(initializers,decoratorFinishedRef)),isPrivate||0!==kind&&2!==kind)if(2===kind)get=function(target){return assertInstanceIfPrivate(hasPrivateBrand,target),desc.value};else{var t=0===kind||1===kind;(t||3===kind)&&(get=isPrivate?function(target){return assertInstanceIfPrivate(hasPrivateBrand,target),desc.get.call(target)}:function(target){return desc.get.call(target)}),(t||4===kind)&&(set=isPrivate?function(target,value){assertInstanceIfPrivate(hasPrivateBrand,target),desc.set.call(target,value)}:function(target,value){desc.set.call(target,value)})}else get=function(target){return target[name]},0===kind&&(set=function(target,v){target[name]=v});var has=isPrivate?hasPrivateBrand.bind():function(target){return name in target};ctx.access=get&&set?{get:get,set:set,has:has}:get?{get:get,has:has}:{set:set,has:has};try{return dec.call(thisArg,value,ctx)}finally{decoratorFinishedRef.v=!0}}function assertNotFinished(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}function assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&assertCallable(value.get,"accessor.get"),void 0!==value.set&&assertCallable(value.set,"accessor.set"),void 0!==value.init&&assertCallable(value.init,"accessor.init")}else if("function"!==type){var hint;throw hint=0===kind?"field":5===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function curryThis1(fn){return function(){return fn(this)}}function curryThis2(fn){return function(value){fn(this,value)}}function applyMemberDec(ret,base,decInfo,decoratorsHaveThis,name,kind,isStatic,isPrivate,initializers,hasPrivateBrand){var desc,init,value,newValue,get,set,decs=decInfo[0];decoratorsHaveThis||Array.isArray(decs)||(decs=[decs]),isPrivate?desc=0===kind||1===kind?{get:curryThis1(decInfo[3]),set:curryThis2(decInfo[4])}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set);for(var inc=decoratorsHaveThis?2:1,i=decs.length-1;i>=0;i-=inc){var newInit;if(void 0!==(newValue=memberDec(decs[i],decoratorsHaveThis?decs[i-1]:void 0,name,desc,initializers,kind,isStatic,isPrivate,value,hasPrivateBrand)))assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===init?init=newInit:"function"==typeof init?init=[init,newInit]:init.push(newInit))}if(0===kind||1===kind){if(void 0===init)init=function(instance,init){return init};else if("function"!=typeof init){var ownInitializers=init;init=function(instance,init){for(var value=init,i=ownInitializers.length-1;i>=0;i--)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=init;init=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(init)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function applyMemberDecs(Class,decInfos,instanceBrand){for(var protoInitializers,staticInitializers,staticBrand,ret=[],existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,decoratorsHaveThis=16&kind,isStatic=!!(8&kind),hasPrivateBrand=instanceBrand;if(kind&=7,isStatic?(base=Class,0!==kind&&(initializers=staticInitializers=staticInitializers||[]),isPrivate&&!staticBrand&&(staticBrand=function(_){return checkInRHS(_)===Class}),hasPrivateBrand=staticBrand):(base=Class.prototype,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);existingNonFields.set(name,!(!existingKind&&kind>2)||kind)}applyMemberDec(ret,base,decInfo,decoratorsHaveThis,name,kind,isStatic,isPrivate,initializers,hasPrivateBrand)}}return pushInitializers(ret,protoInitializers),pushInitializers(ret,staticInitializers),ret}function pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}function applyClassDecs(targetClass,classDecs,decoratorsHaveThis){if(classDecs.length){for(var initializers=[],newClass=targetClass,name=targetClass.name,inc=decoratorsHaveThis?2:1,i=classDecs.length-1;i>=0;i-=inc){var decoratorFinishedRef={v:!1};try{var nextNewClass=classDecs[i].call(decoratorsHaveThis?classDecs[i-1]:void 0,newClass,{kind:"class",name:name,addInitializer:createAddInitializerMethod(initializers,decoratorFinishedRef)})}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(assertValidReturnValue(5,nextNewClass),newClass=nextNewClass)}return[newClass,function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}]}}export default function applyDecs2305(targetClass,memberDecs,classDecs,classDecsHaveThis,instanceBrand){return{e:applyMemberDecs(targetClass,memberDecs,instanceBrand),get c(){return applyClassDecs(targetClass,classDecs,classDecsHaveThis)}}}'), asyncGeneratorDelegate: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(inner){var iter={},waiting=!1;function pump(key,value){return waiting=!0,value=new Promise((function(resolve){resolve(inner[key](value))})),{done:!1,value:new OverloadYield(value,1)}}return iter["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},iter.next=function(value){return waiting?(waiting=!1,value):pump("next",value)},"function"==typeof inner.throw&&(iter.throw=function(value){if(waiting)throw waiting=!1,value;return pump("throw",value)}),"function"==typeof inner.return&&(iter.return=function(value){return waiting?(waiting=!1,value):pump("return",value)}),iter}'), asyncIterator: helper("7.15.9", 'export default function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then((function(value){return{value:value,done:done}}))}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments))},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments))}},new AsyncFromSyncIterator(s)}'), awaitAsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(value){return new OverloadYield(value,0)}'), checkInRHS: helper("7.20.5", `export default function _checkInRHS(value){if(Object(value)!==value)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==value?typeof value:"null"));return value}`), defineAccessor: helper("7.20.7", "export default function _defineAccessor(type,obj,key,fn){var desc={configurable:!0,enumerable:!0};return desc[type]=fn,Object.defineProperty(obj,key,desc)}"), dispose: helper("7.22.0", 'function dispose_SuppressedError(suppressed,error){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(suppressed,error){this.suppressed=suppressed,this.error=error,this.stack=(new Error).stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(suppressed,error)}export default function _dispose(stack,error,hasError){function next(){for(;stack.length>0;)try{var r=stack.pop(),p=r.d.call(r.v);if(r.a)return Promise.resolve(p).then(next,err)}catch(e){return err(e)}if(hasError)throw error}function err(e){return error=hasError?new dispose_SuppressedError(e,error):e,hasError=!0,next()}return next()}'), iterableToArrayLimit: helper("7.0.0-beta.0", 'export default function _iterableToArrayLimit(arr,i){var _i=null==arr?null:"undefined"!=typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_x,_r,_arr=[],_n=!0,_d=!1;try{if(_x=(_i=_i.call(arr)).next,0===i){if(Object(_i)!==_i)return;_n=!1}else for(;!(_n=(_s=_x.call(_i)).done)&&(_arr.push(_s.value),_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&null!=_i.return&&(_r=_i.return(),Object(_r)!==_r))return}finally{if(_d)throw _e}}return _arr}}'), iterableToArrayLimitLoose: helper("7.0.0-beta.0", 'export default function _iterableToArrayLimitLoose(arr,i){var _i=arr&&("undefined"!=typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"]);if(null!=_i){var _s,_arr=[];for(_i=_i.call(arr);arr.length<i&&!(_s=_i.next()).done;)_arr.push(_s.value);return _arr}}'), jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(type,props,key,children){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var defaultProps=type&&type.defaultProps,childrenLength=arguments.length-3;if(props||0===childrenLength||(props={children:void 0}),1===childrenLength)props.children=children;else if(childrenLength>1){for(var childArray=new Array(childrenLength),i=0;i<childrenLength;i++)childArray[i]=arguments[i+3];props.children=childArray}if(props&&defaultProps)for(var propName in defaultProps)void 0===props[propName]&&(props[propName]=defaultProps[propName]);else props||(props=defaultProps||{});return{$$typeof:REACT_ELEMENT_TYPE,type:type,key:void 0===key?null:""+key,ref:null,props:props,_owner:null}}'), objectSpread2: helper("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}export default function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}'), regeneratorRuntime: helper("7.18.0", `export default function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,defineProperty=Object.defineProperty||function(obj,key,desc){obj[key]=desc.value},$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return defineProperty(generator,"_invoke",{value:makeInvokeMethod(innerFn,self,context)}),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==typeof value&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;defineProperty(this,"_invoke",{value:function(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}function maybeInvokeDelegate(delegate,context){var methodName=context.method,method=delegate.iterator[methodName];if(undefined===method)return context.delegate=null,"throw"===methodName&&delegate.iterator.return&&(context.method="return",context.arg=undefined,maybeInvokeDelegate(delegate,context),"throw"===context.method)||"return"!==methodName&&(context.method="throw",context.arg=new TypeError("The iterator does not provide a '"+methodName+"' method")),ContinueSentinel;var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=undefined),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=undefined,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:undefined,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,defineProperty(Gp,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),defineProperty(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(val){var object=Object(val),keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=undefined,this.done=!1,this.delegate=null,this.method="next",this.arg=undefined,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=undefined)},stop:function(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=undefined),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=undefined),ContinueSentinel}},exports}`), typeof: helper("7.0.0-beta.0", 'export default function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}'), using: helper("7.22.0", 'export default function _using(stack,value,isAwait){if(null==value)return value;if("object"!=typeof value)throw new TypeError("using declarations can only be used with objects, null, or undefined.");if(isAwait)var dispose=value[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==dispose&&(dispose=value[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof dispose)throw new TypeError("Property [Symbol.dispose] is not a function.");return stack.push({v:value,d:dispose,a:isAwait}),value}'), wrapRegExp: helper("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(re,groups){return new BabelRegExp(re,void 0,groups)};var _super=RegExp.prototype,_groups=new WeakMap;function BabelRegExp(re,flags,groups){var _this=new RegExp(re,flags);return _groups.set(_this,groups||_groups.get(re)),setPrototypeOf(_this,BabelRegExp.prototype)}function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce((function(groups,name){var i=g[name];if("number"==typeof i)groups[name]=result[i];else{for(var k=0;void 0===result[i[k]]&&k+1<i.length;)k++;groups[name]=result[i[k]]}return groups}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);if(result){result.groups=buildGroups(result,this);var indices=result.indices;indices&&(indices.groups=buildGroups(indices,this))}return result},BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if("string"==typeof substitution){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\\$<([^>]+)>/g,(function(_,name){var group=groups[name];return"$"+(Array.isArray(group)?group.join("$"):group)})))}if("function"==typeof substitution){var _this=this;return _super[Symbol.replace].call(this,str,(function(){var args=arguments;return"object"!=typeof args[args.length-1]&&(args=[].slice.call(args)).push(buildGroups(args,_this)),substitution.apply(this,args)}))}return _super[Symbol.replace].call(this,str,substitution)},_wrapRegExp.apply(this,arguments)}') });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+helpers@7.22.6/node_modules/@babel/helpers/lib/helpers.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _template = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js"), _helpersGenerated = __webpack_require__2("./node_modules/.pnpm/@babel+helpers@7.22.6/node_modules/@babel/helpers/lib/helpers-generated.js");
        const helpers = Object.assign({ __proto__: null }, _helpersGenerated.default);
        var _default = helpers;
        exports3.default = _default;
        const helper = (minVersion) => (tpl) => ({ minVersion, ast: () => _template.default.program.ast(tpl) });
        helpers.AwaitValue = helper("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `, helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`, helpers.asyncToGenerator = helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`, helpers.classCallCheck = helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`, helpers.createClass = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`, helpers.defineEnumerableProperties = helper("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`, helpers.defaults = helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`, helpers.defineProperty = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`, helpers.extends = helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`, helpers.objectSpread = helper("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `, helpers.inherits = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`, helpers.inheritsLoose = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`, helpers.getPrototypeOf = helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`, helpers.setPrototypeOf = helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`, helpers.isNativeReflectConstruct = helper("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`, helpers.construct = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`, helpers.isNativeFunction = helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`, helpers.wrapNativeSuper = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`, helpers.instanceof = helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`, helpers.interopRequireDefault = helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`, helpers.interopRequireWildcard = helper("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`, helpers.newArrowCheck = helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`, helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`, helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`, helpers.objectWithoutProperties = helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`, helpers.assertThisInitialized = helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`, helpers.possibleConstructorReturn = helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`, helpers.createSuper = helper("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `, helpers.superPropBase = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`, helpers.get = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`, helpers.set = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`, helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`, helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`, helpers.readOnlyError = helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`, helpers.writeOnlyError = helper("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`, helpers.classNameTDZError = helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`, helpers.temporalUndefined = helper("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`, helpers.tdz = helper("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`, helpers.temporalRef = helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`, helpers.slicedToArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, helpers.slicedToArrayLoose = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, helpers.toArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`, helpers.toConsumableArray = helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`, helpers.arrayWithoutHoles = helper("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`, helpers.arrayWithHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`, helpers.maybeArrayLike = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`, helpers.iterableToArray = helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`, helpers.unsupportedIterableToArray = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`, helpers.arrayLikeToArray = helper("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`, helpers.nonIterableSpread = helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, helpers.nonIterableRest = helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, helpers.createForOfIteratorHelper = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`, helpers.createForOfIteratorHelperLoose = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`, helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`, helpers.toPrimitive = helper("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`, helpers.toPropertyKey = helper("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`, helpers.initializerWarningHelper = helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`, helpers.initializerDefineProperty = helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`, helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`, helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`, helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`, helpers.classPrivateFieldGet = helper("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, helpers.classPrivateFieldSet = helper("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, helpers.classPrivateFieldDestructureSet = helper("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, helpers.classExtractFieldDescriptor = helper("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`, helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, helpers.classStaticPrivateMethodGet = helper("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`, helpers.classStaticPrivateMethodSet = helper("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`, helpers.classApplyDescriptorGet = helper("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`, helpers.classApplyDescriptorSet = helper("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`, helpers.classApplyDescriptorDestructureSet = helper("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`, helpers.classStaticPrivateFieldDestructureSet = helper("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, helpers.classCheckPrivateStaticAccess = helper("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`, helpers.classCheckPrivateStaticFieldDescriptor = helper("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`, helpers.decorate = helper("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`, helpers.classPrivateMethodGet = helper("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`, helpers.checkPrivateRedeclaration = helper("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`, helpers.classPrivateFieldInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`, helpers.classPrivateMethodInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`, helpers.classPrivateMethodSet = helper("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `, helpers.identity = helper("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;
      }, "./node_modules/.pnpm/@babel+helpers@7.22.6/node_modules/@babel/helpers/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0, exports3.ensure = function(name, newFileClass) {
          FileClass || (FileClass = newFileClass), loadHelper(name);
        }, exports3.get = get, exports3.getDependencies = function(name) {
          return loadHelper(name).getDependencies();
        }, exports3.list = void 0, exports3.minVersion = function(name) {
          return loadHelper(name).minVersion;
        };
        var _traverse = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _helpers = __webpack_require__2("./node_modules/.pnpm/@babel+helpers@7.22.6/node_modules/@babel/helpers/lib/helpers.js");
        const { assignmentExpression, cloneNode, expressionStatement, file, identifier } = _t;
        function makePath(path3) {
          const parts = [];
          for (; path3.parentPath; path3 = path3.parentPath)
            parts.push(path3.key), path3.inList && parts.push(path3.listKey);
          return parts.reverse().join(".");
        }
        let FileClass;
        function getHelperMetadata(file2) {
          const globals = /* @__PURE__ */ new Set(), localBindingNames = /* @__PURE__ */ new Set(), dependencies = /* @__PURE__ */ new Map();
          let exportName, exportPath;
          const exportBindingAssignments = [], importPaths = [], importBindingsReferences = [], dependencyVisitor = { ImportDeclaration(child) {
            const name = child.node.source.value;
            if (!_helpers.default[name])
              throw child.buildCodeFrameError(`Unknown helper ${name}`);
            if (1 !== child.get("specifiers").length || !child.get("specifiers.0").isImportDefaultSpecifier())
              throw child.buildCodeFrameError("Helpers can only import a default value");
            const bindingIdentifier = child.node.specifiers[0].local;
            dependencies.set(bindingIdentifier, name), importPaths.push(makePath(child));
          }, ExportDefaultDeclaration(child) {
            const decl = child.get("declaration");
            if (!decl.isFunctionDeclaration() || !decl.node.id)
              throw decl.buildCodeFrameError("Helpers can only export named function declarations");
            exportName = decl.node.id.name, exportPath = makePath(child);
          }, ExportAllDeclaration(child) {
            throw child.buildCodeFrameError("Helpers can only export default");
          }, ExportNamedDeclaration(child) {
            throw child.buildCodeFrameError("Helpers can only export default");
          }, Statement(child) {
            child.isImportDeclaration() || child.isExportDeclaration() || child.skip();
          } }, referenceVisitor = { Program(path3) {
            const bindings = path3.scope.getAllBindings();
            Object.keys(bindings).forEach((name) => {
              name !== exportName && (dependencies.has(bindings[name].identifier) || localBindingNames.add(name));
            });
          }, ReferencedIdentifier(child) {
            const name = child.node.name, binding = child.scope.getBinding(name);
            binding ? dependencies.has(binding.identifier) && importBindingsReferences.push(makePath(child)) : globals.add(name);
          }, AssignmentExpression(child) {
            const left = child.get("left");
            if (!(exportName in left.getBindingIdentifiers()))
              return;
            if (!left.isIdentifier())
              throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
            const binding = child.scope.getBinding(exportName);
            null != binding && binding.scope.path.isProgram() && exportBindingAssignments.push(makePath(child));
          } };
          if ((0, _traverse.default)(file2.ast, dependencyVisitor, file2.scope), (0, _traverse.default)(file2.ast, referenceVisitor, file2.scope), !exportPath)
            throw new Error("Helpers must have a default export.");
          return exportBindingAssignments.reverse(), { globals: Array.from(globals), localBindingNames: Array.from(localBindingNames), dependencies, exportBindingAssignments, exportPath, exportName, importBindingsReferences, importPaths };
        }
        const helperData = /* @__PURE__ */ Object.create(null);
        function loadHelper(name) {
          if (!helperData[name]) {
            const helper = _helpers.default[name];
            if (!helper)
              throw Object.assign(new ReferenceError(`Unknown helper ${name}`), { code: "BABEL_HELPER_UNKNOWN", helper: name });
            const fn = () => {
              if (!FileClass) {
                const fakeFile = { ast: file(helper.ast()), path: null };
                return (0, _traverse.default)(fakeFile.ast, { Program: (path3) => (fakeFile.path = path3).stop() }), fakeFile;
              }
              return new FileClass({ filename: `babel-helper://${name}` }, { ast: file(helper.ast()), code: "[internal Babel helper code]", inputMap: null });
            };
            let metadata = null;
            helperData[name] = { minVersion: helper.minVersion, build(getDependency, id, localBindings) {
              const file2 = fn();
              return metadata || (metadata = getHelperMetadata(file2)), function(file3, metadata2, id2, localBindings2, getDependency2) {
                if (localBindings2 && !id2)
                  throw new Error("Unexpected local bindings for module-based helpers.");
                if (!id2)
                  return;
                const { localBindingNames, dependencies, exportBindingAssignments, exportPath, exportName, importBindingsReferences, importPaths } = metadata2, dependenciesRefs = {};
                dependencies.forEach((name2, id3) => {
                  dependenciesRefs[id3.name] = "function" == typeof getDependency2 && getDependency2(name2) || id3;
                });
                const toRename = {}, bindings = new Set(localBindings2 || []);
                localBindingNames.forEach((name2) => {
                  let newName = name2;
                  for (; bindings.has(newName); )
                    newName = "_" + newName;
                  newName !== name2 && (toRename[name2] = newName);
                }), "Identifier" === id2.type && exportName !== id2.name && (toRename[exportName] = id2.name);
                const { path: path3 } = file3, exp = path3.get(exportPath), imps = importPaths.map((p) => path3.get(p)), impsBindingRefs = importBindingsReferences.map((p) => path3.get(p)), decl = exp.get("declaration");
                if ("Identifier" === id2.type)
                  exp.replaceWith(decl);
                else {
                  if ("MemberExpression" !== id2.type)
                    throw new Error("Unexpected helper format.");
                  exportBindingAssignments.forEach((assignPath) => {
                    const assign = path3.get(assignPath);
                    assign.replaceWith(assignmentExpression("=", id2, assign.node));
                  }), exp.replaceWith(decl), path3.pushContainer("body", expressionStatement(assignmentExpression("=", id2, identifier(exportName))));
                }
                Object.keys(toRename).forEach((name2) => {
                  path3.scope.rename(name2, toRename[name2]);
                });
                for (const path4 of imps)
                  path4.remove();
                for (const path4 of impsBindingRefs) {
                  const node = cloneNode(dependenciesRefs[path4.node.name]);
                  path4.replaceWith(node);
                }
              }(file2, metadata, id, localBindings, getDependency), { nodes: file2.ast.program.body, globals: metadata.globals };
            }, getDependencies: () => (metadata || (metadata = getHelperMetadata(fn())), Array.from(metadata.dependencies.values())) };
          }
          return helperData[name];
        }
        function get(name, getDependency, id, localBindings) {
          return loadHelper(name).build(getDependency, id, localBindings);
        }
        const list = Object.keys(_helpers.default).map((name) => name.replace(/^_/, ""));
        exports3.list = list;
        var _default = get;
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+parser@7.22.6/node_modules/@babel/parser/lib/index.js": (__unused_webpack_module, exports3) => {
        "use strict";
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (null == source)
            return {};
          var key, i, target = {}, sourceKeys = Object.keys(source);
          for (i = 0; i < sourceKeys.length; i++)
            key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
          return target;
        }
        Object.defineProperty(exports3, "__esModule", { value: true });
        class Position3 {
          constructor(line, col, index2) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = line, this.column = col, this.index = index2;
          }
        }
        class SourceLocation3 {
          constructor(start, end) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = start, this.end = end;
          }
        }
        function createPositionWithColumnOffset(position, columnOffset) {
          const { line, column, index: index2 } = position;
          return new Position3(line, column + columnOffset, index2 + columnOffset);
        }
        var ParseErrorCode_SyntaxError = "BABEL_PARSER_SYNTAX_ERROR", ParseErrorCode_SourceTypeModuleError = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
        const reflect = (keys2, last = keys2.length - 1) => ({ get() {
          return keys2.reduce((object, key) => object[key], this);
        }, set(value2) {
          keys2.reduce((item, key, i) => i === last ? item[key] = value2 : item[key], this);
        } }), instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, "function" == typeof descriptor ? { value: descriptor, enumerable: false } : "string" == typeof descriptor.reflect ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({ configurable: true }, descriptor)), Object.assign(new constructor(), properties));
        var ModuleErrors = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: ParseErrorCode_SourceTypeModuleError }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: ParseErrorCode_SourceTypeModuleError } };
        const NodeDescriptions = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, toNodeDescription = ({ type, prefix }) => "UpdateExpression" === type ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];
        var StandardErrors = { AccessorIsGenerator: ({ kind }) => `A ${kind}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind }) => `Missing initializer in ${kind} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName, exportName }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type }) => `'${"ForInStatement" === type ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type }) => `Unsyntactic ${"BreakStatement" === type ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: importName2 }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName2}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount }) => `\`import()\` requires exactly ${1 === maxArgumentCount ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix }) => `Expected number in radix ${radix}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord }) => `Escape sequence in keyword ${reservedWord}.`, InvalidIdentifier: ({ identifierName }) => `Invalid identifier ${identifierName}.`, InvalidLhs: ({ ancestor }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`, InvalidLhsBinding: ({ ancestor }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected }) => `Unexpected character '${unexpected}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName }) => `Private name #${identifierName} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName }) => `Label '${labelName}' is already declared.`, LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key }) => `Duplicate key "${key}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`, ModuleExportUndefined: ({ localName }) => `Export '${localName}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`, PrivateNameRedeclaration: ({ identifierName }) => `Duplicate private name #${identifierName}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword }) => `Unexpected keyword '${keyword}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord }) => `Unexpected reserved word '${reservedWord}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected, unexpected }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target, onlyValidPropertyName }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName }) => `Identifier '${identifierName}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
        const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
        var PipelineOperatorErrors = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({ type })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
        const _excluded$1 = ["toMessage"], _excluded2$1 = ["message"];
        function toParseErrorConstructor(_ref) {
          let { toMessage } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
          return function constructor({ loc, details }) {
            return instantiate(SyntaxError, Object.assign({}, properties, { loc }), { clone(overrides = {}) {
              const loc2 = overrides.loc || {};
              return constructor({ loc: new Position3("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index), details: Object.assign({}, this.details, overrides.details) });
            }, details: { value: details, enumerable: false }, message: { get() {
              return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
            }, set(value2) {
              Object.defineProperty(this, "message", { value: value2 });
            } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in details && { reflect: "details.missingPlugin", enumerable: true } });
          };
        }
        function ParseErrorEnum(argument, syntaxPlugin) {
          if (Array.isArray(argument))
            return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
          const ParseErrorConstructors = {};
          for (const reasonCode of Object.keys(argument)) {
            const template2 = argument[reasonCode], _ref2 = "string" == typeof template2 ? { message: () => template2 } : "function" == typeof template2 ? { message: template2 } : template2, { message } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1), toMessage = "string" == typeof message ? () => message : message;
            ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({ code: ParseErrorCode_SyntaxError, reasonCode, toMessage }, syntaxPlugin ? { syntaxPlugin } : {}, rest));
          }
          return ParseErrorConstructors;
        }
        const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName }) => `Assigning to '${referenceName}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName }) => `Binding '${bindingName}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors)), { defineProperty: defineProperty2 } = Object, toUnenumerable = (object, key) => defineProperty2(object, key, { enumerable: false, value: object[key] });
        function toESTreeLocation(node) {
          return node.loc.start && toUnenumerable(node.loc.start, "index"), node.loc.end && toUnenumerable(node.loc.end, "index"), node;
        }
        class TokContext3 {
          constructor(token, preserveSpace) {
            this.token = void 0, this.preserveSpace = void 0, this.token = token, this.preserveSpace = !!preserveSpace;
          }
        }
        const types2 = { brace: new TokContext3("{"), j_oTag: new TokContext3("<tag"), j_cTag: new TokContext3("</tag"), j_expr: new TokContext3("<tag>...</tag>", true) };
        types2.template = new TokContext3("`", true);
        class ExportedTokenType {
          constructor(label, conf = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = label, this.keyword = conf.keyword, this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.rightAssociative = !!conf.rightAssociative, this.isLoop = !!conf.isLoop, this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, this.postfix = !!conf.postfix, this.binop = null != conf.binop ? conf.binop : null, this.updateContext = null;
          }
        }
        const keywords$12 = /* @__PURE__ */ new Map();
        function createKeyword(name, options = {}) {
          options.keyword = name;
          const token = createToken(name, options);
          return keywords$12.set(name, token), token;
        }
        function createBinop(name, binop2) {
          return createToken(name, { beforeExpr: true, binop: binop2 });
        }
        let tokenTypeCounter = -1;
        const tokenTypes = [], tokenLabels = [], tokenBinops = [], tokenBeforeExprs = [], tokenStartsExprs = [], tokenPrefixes = [];
        function createToken(name, options = {}) {
          var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
          return ++tokenTypeCounter, tokenLabels.push(name), tokenBinops.push(null != (_options$binop = options.binop) ? _options$binop : -1), tokenBeforeExprs.push(null != (_options$beforeExpr = options.beforeExpr) && _options$beforeExpr), tokenStartsExprs.push(null != (_options$startsExpr = options.startsExpr) && _options$startsExpr), tokenPrefixes.push(null != (_options$prefix = options.prefix) && _options$prefix), tokenTypes.push(new ExportedTokenType(name, options)), tokenTypeCounter;
        }
        function createKeywordLike(name, options = {}) {
          var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
          return ++tokenTypeCounter, keywords$12.set(name, tokenTypeCounter), tokenLabels.push(name), tokenBinops.push(null != (_options$binop2 = options.binop) ? _options$binop2 : -1), tokenBeforeExprs.push(null != (_options$beforeExpr2 = options.beforeExpr) && _options$beforeExpr2), tokenStartsExprs.push(null != (_options$startsExpr2 = options.startsExpr) && _options$startsExpr2), tokenPrefixes.push(null != (_options$prefix2 = options.prefix) && _options$prefix2), tokenTypes.push(new ExportedTokenType("name", options)), tokenTypeCounter;
        }
        const tt = { bracketL: createToken("[", { beforeExpr: true, startsExpr: true }), bracketHashL: createToken("#[", { beforeExpr: true, startsExpr: true }), bracketBarL: createToken("[|", { beforeExpr: true, startsExpr: true }), bracketR: createToken("]"), bracketBarR: createToken("|]"), braceL: createToken("{", { beforeExpr: true, startsExpr: true }), braceBarL: createToken("{|", { beforeExpr: true, startsExpr: true }), braceHashL: createToken("#{", { beforeExpr: true, startsExpr: true }), braceR: createToken("}"), braceBarR: createToken("|}"), parenL: createToken("(", { beforeExpr: true, startsExpr: true }), parenR: createToken(")"), comma: createToken(",", { beforeExpr: true }), semi: createToken(";", { beforeExpr: true }), colon: createToken(":", { beforeExpr: true }), doubleColon: createToken("::", { beforeExpr: true }), dot: createToken("."), question: createToken("?", { beforeExpr: true }), questionDot: createToken("?."), arrow: createToken("=>", { beforeExpr: true }), template: createToken("template"), ellipsis: createToken("...", { beforeExpr: true }), backQuote: createToken("`", { startsExpr: true }), dollarBraceL: createToken("${", { beforeExpr: true, startsExpr: true }), templateTail: createToken("...`", { startsExpr: true }), templateNonTail: createToken("...${", { beforeExpr: true, startsExpr: true }), at: createToken("@"), hash: createToken("#", { startsExpr: true }), interpreterDirective: createToken("#!..."), eq: createToken("=", { beforeExpr: true, isAssign: true }), assign: createToken("_=", { beforeExpr: true, isAssign: true }), slashAssign: createToken("_=", { beforeExpr: true, isAssign: true }), xorAssign: createToken("_=", { beforeExpr: true, isAssign: true }), moduloAssign: createToken("_=", { beforeExpr: true, isAssign: true }), incDec: createToken("++/--", { prefix: true, postfix: true, startsExpr: true }), bang: createToken("!", { beforeExpr: true, prefix: true, startsExpr: true }), tilde: createToken("~", { beforeExpr: true, prefix: true, startsExpr: true }), doubleCaret: createToken("^^", { startsExpr: true }), doubleAt: createToken("@@", { startsExpr: true }), pipeline: createBinop("|>", 0), nullishCoalescing: createBinop("??", 1), logicalOR: createBinop("||", 1), logicalAND: createBinop("&&", 2), bitwiseOR: createBinop("|", 3), bitwiseXOR: createBinop("^", 4), bitwiseAND: createBinop("&", 5), equality: createBinop("==/!=/===/!==", 6), lt: createBinop("</>/<=/>=", 7), gt: createBinop("</>/<=/>=", 7), relational: createBinop("</>/<=/>=", 7), bitShift: createBinop("<</>>/>>>", 8), bitShiftL: createBinop("<</>>/>>>", 8), bitShiftR: createBinop("<</>>/>>>", 8), plusMin: createToken("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: createToken("%", { binop: 10, startsExpr: true }), star: createToken("*", { binop: 10 }), slash: createBinop("/", 10), exponent: createToken("**", { beforeExpr: true, binop: 11, rightAssociative: true }), _in: createKeyword("in", { beforeExpr: true, binop: 7 }), _instanceof: createKeyword("instanceof", { beforeExpr: true, binop: 7 }), _break: createKeyword("break"), _case: createKeyword("case", { beforeExpr: true }), _catch: createKeyword("catch"), _continue: createKeyword("continue"), _debugger: createKeyword("debugger"), _default: createKeyword("default", { beforeExpr: true }), _else: createKeyword("else", { beforeExpr: true }), _finally: createKeyword("finally"), _function: createKeyword("function", { startsExpr: true }), _if: createKeyword("if"), _return: createKeyword("return", { beforeExpr: true }), _switch: createKeyword("switch"), _throw: createKeyword("throw", { beforeExpr: true, prefix: true, startsExpr: true }), _try: createKeyword("try"), _var: createKeyword("var"), _const: createKeyword("const"), _with: createKeyword("with"), _new: createKeyword("new", { beforeExpr: true, startsExpr: true }), _this: createKeyword("this", { startsExpr: true }), _super: createKeyword("super", { startsExpr: true }), _class: createKeyword("class", { startsExpr: true }), _extends: createKeyword("extends", { beforeExpr: true }), _export: createKeyword("export"), _import: createKeyword("import", { startsExpr: true }), _null: createKeyword("null", { startsExpr: true }), _true: createKeyword("true", { startsExpr: true }), _false: createKeyword("false", { startsExpr: true }), _typeof: createKeyword("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: createKeyword("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: createKeyword("delete", { beforeExpr: true, prefix: true, startsExpr: true }), _do: createKeyword("do", { isLoop: true, beforeExpr: true }), _for: createKeyword("for", { isLoop: true }), _while: createKeyword("while", { isLoop: true }), _as: createKeywordLike("as", { startsExpr: true }), _assert: createKeywordLike("assert", { startsExpr: true }), _async: createKeywordLike("async", { startsExpr: true }), _await: createKeywordLike("await", { startsExpr: true }), _from: createKeywordLike("from", { startsExpr: true }), _get: createKeywordLike("get", { startsExpr: true }), _let: createKeywordLike("let", { startsExpr: true }), _meta: createKeywordLike("meta", { startsExpr: true }), _of: createKeywordLike("of", { startsExpr: true }), _sent: createKeywordLike("sent", { startsExpr: true }), _set: createKeywordLike("set", { startsExpr: true }), _static: createKeywordLike("static", { startsExpr: true }), _using: createKeywordLike("using", { startsExpr: true }), _yield: createKeywordLike("yield", { startsExpr: true }), _asserts: createKeywordLike("asserts", { startsExpr: true }), _checks: createKeywordLike("checks", { startsExpr: true }), _exports: createKeywordLike("exports", { startsExpr: true }), _global: createKeywordLike("global", { startsExpr: true }), _implements: createKeywordLike("implements", { startsExpr: true }), _intrinsic: createKeywordLike("intrinsic", { startsExpr: true }), _infer: createKeywordLike("infer", { startsExpr: true }), _is: createKeywordLike("is", { startsExpr: true }), _mixins: createKeywordLike("mixins", { startsExpr: true }), _proto: createKeywordLike("proto", { startsExpr: true }), _require: createKeywordLike("require", { startsExpr: true }), _satisfies: createKeywordLike("satisfies", { startsExpr: true }), _keyof: createKeywordLike("keyof", { startsExpr: true }), _readonly: createKeywordLike("readonly", { startsExpr: true }), _unique: createKeywordLike("unique", { startsExpr: true }), _abstract: createKeywordLike("abstract", { startsExpr: true }), _declare: createKeywordLike("declare", { startsExpr: true }), _enum: createKeywordLike("enum", { startsExpr: true }), _module: createKeywordLike("module", { startsExpr: true }), _namespace: createKeywordLike("namespace", { startsExpr: true }), _interface: createKeywordLike("interface", { startsExpr: true }), _type: createKeywordLike("type", { startsExpr: true }), _opaque: createKeywordLike("opaque", { startsExpr: true }), name: createToken("name", { startsExpr: true }), string: createToken("string", { startsExpr: true }), num: createToken("num", { startsExpr: true }), bigint: createToken("bigint", { startsExpr: true }), decimal: createToken("decimal", { startsExpr: true }), regexp: createToken("regexp", { startsExpr: true }), privateName: createToken("#name", { startsExpr: true }), eof: createToken("eof"), jsxName: createToken("jsxName"), jsxText: createToken("jsxText", { beforeExpr: true }), jsxTagStart: createToken("jsxTagStart", { startsExpr: true }), jsxTagEnd: createToken("jsxTagEnd"), placeholder: createToken("%%", { startsExpr: true }) };
        function tokenIsIdentifier(token) {
          return token >= 93 && token <= 130;
        }
        function tokenIsKeywordOrIdentifier(token) {
          return token >= 58 && token <= 130;
        }
        function tokenIsLiteralPropertyName(token) {
          return token >= 58 && token <= 134;
        }
        function tokenCanStartExpression(token) {
          return tokenStartsExprs[token];
        }
        function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
          return token >= 127 && token <= 129;
        }
        function tokenIsKeyword(token) {
          return token >= 58 && token <= 92;
        }
        function tokenLabelName(token) {
          return tokenLabels[token];
        }
        function tokenOperatorPrecedence(token) {
          return tokenBinops[token];
        }
        function tokenIsTemplate(token) {
          return token >= 24 && token <= 25;
        }
        function getExportedToken(token) {
          return tokenTypes[token];
        }
        tokenTypes[8].updateContext = (context) => {
          context.pop();
        }, tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
          context.push(types2.brace);
        }, tokenTypes[22].updateContext = (context) => {
          context[context.length - 1] === types2.template ? context.pop() : context.push(types2.template);
        }, tokenTypes[140].updateContext = (context) => {
          context.push(types2.j_expr, types2.j_oTag);
        };
        let nonASCIIidentifierStartChars2 = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", nonASCIIidentifierChars2 = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
        const nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]"), nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
        nonASCIIidentifierStartChars2 = nonASCIIidentifierChars2 = null;
        const astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet2(code, set) {
          let pos = 65536;
          for (let i = 0, length = set.length; i < length; i += 2) {
            if (pos += set[i], pos > code)
              return false;
            if (pos += set[i + 1], pos >= code)
              return true;
          }
          return false;
        }
        function isIdentifierStart2(code) {
          return code < 65 ? 36 === code : code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code)) : isInAstralSet2(code, astralIdentifierStartCodes2)));
        }
        function isIdentifierChar2(code) {
          return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code)) : isInAstralSet2(code, astralIdentifierStartCodes2) || isInAstralSet2(code, astralIdentifierCodes2))));
        }
        const reservedWords_strict = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], reservedWords_strictBind = ["eval", "arguments"], keywords2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
        function isReservedWord(word, inModule) {
          return inModule && "await" === word || "enum" === word;
        }
        function isStrictReservedWord(word, inModule) {
          return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
        }
        function isStrictBindOnlyReservedWord(word) {
          return reservedWordsStrictBindSet.has(word);
        }
        function isStrictBindReservedWord(word, inModule) {
          return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
        }
        const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class Scope3 {
          constructor(flags) {
            this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = flags;
          }
        }
        class ScopeHandler {
          constructor(parser, inModule) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = parser, this.inModule = inModule;
          }
          get inTopLevel() {
            return (1 & this.currentScope().flags) > 0;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScopeFlags()) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const flags = this.currentThisScopeFlags();
            return (64 & flags) > 0 && 0 == (2 & flags);
          }
          get inStaticBlock() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags } = this.scopeStack[i];
              if (128 & flags)
                return true;
              if (451 & flags)
                return false;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(flags) {
            return new Scope3(flags);
          }
          enter(flags) {
            this.scopeStack.push(this.createScope(flags));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(scope) {
            return !!(130 & scope.flags || !this.parser.inModule && 1 & scope.flags);
          }
          declareName(name, bindingType, loc) {
            let scope = this.currentScope();
            if (8 & bindingType || 16 & bindingType)
              this.checkRedeclarationInScope(scope, name, bindingType, loc), 16 & bindingType ? scope.functions.add(name) : scope.lexical.add(name), 8 & bindingType && this.maybeExportDefined(scope, name);
            else if (4 & bindingType)
              for (let i = this.scopeStack.length - 1; i >= 0 && (scope = this.scopeStack[i], this.checkRedeclarationInScope(scope, name, bindingType, loc), scope.var.add(name), this.maybeExportDefined(scope, name), !(387 & scope.flags)); --i)
                ;
            this.parser.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
          }
          maybeExportDefined(scope, name) {
            this.parser.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
          }
          checkRedeclarationInScope(scope, name, bindingType, loc) {
            this.isRedeclaredInScope(scope, name, bindingType) && this.parser.raise(Errors.VarRedeclaration, { at: loc, identifierName: name });
          }
          isRedeclaredInScope(scope, name, bindingType) {
            return !!(1 & bindingType) && (8 & bindingType ? scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name) : 16 & bindingType ? scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name) : scope.lexical.has(name) && !(8 & scope.flags && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name));
          }
          checkLocalExport(id) {
            const { name } = id, topLevelScope = this.scopeStack[0];
            topLevelScope.lexical.has(name) || topLevelScope.var.has(name) || topLevelScope.functions.has(name) || this.undefinedExports.set(name, id.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags } = this.scopeStack[i];
              if (387 & flags)
                return flags;
            }
          }
          currentThisScopeFlags() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags } = this.scopeStack[i];
              if (451 & flags && !(4 & flags))
                return flags;
            }
          }
        }
        class FlowScope extends Scope3 {
          constructor(...args) {
            super(...args), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class FlowScopeHandler extends ScopeHandler {
          createScope(flags) {
            return new FlowScope(flags);
          }
          declareName(name, bindingType, loc) {
            const scope = this.currentScope();
            if (2048 & bindingType)
              return this.checkRedeclarationInScope(scope, name, bindingType, loc), this.maybeExportDefined(scope, name), void scope.declareFunctions.add(name);
            super.declareName(name, bindingType, loc);
          }
          isRedeclaredInScope(scope, name, bindingType) {
            return !!super.isRedeclaredInScope(scope, name, bindingType) || !!(2048 & bindingType) && (!scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name)));
          }
          checkLocalExport(id) {
            this.scopeStack[0].declareFunctions.has(id.name) || super.checkLocalExport(id);
          }
        }
        class BaseParser {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(pluginConfig) {
            if ("string" == typeof pluginConfig)
              return this.plugins.has(pluginConfig);
            {
              const [pluginName, pluginOptions] = pluginConfig;
              if (!this.hasPlugin(pluginName))
                return false;
              const actualOptions = this.plugins.get(pluginName);
              for (const key of Object.keys(pluginOptions))
                if ((null == actualOptions ? void 0 : actualOptions[key]) !== pluginOptions[key])
                  return false;
              return true;
            }
          }
          getPluginOption(plugin, name) {
            var _this$plugins$get;
            return null == (_this$plugins$get = this.plugins.get(plugin)) ? void 0 : _this$plugins$get[name];
          }
        }
        function setTrailingComments(node, comments) {
          void 0 === node.trailingComments ? node.trailingComments = comments : node.trailingComments.unshift(...comments);
        }
        function setInnerComments(node, comments) {
          void 0 === node.innerComments ? node.innerComments = comments : node.innerComments.unshift(...comments);
        }
        function adjustInnerComments(node, elements, commentWS) {
          let lastElement = null, i = elements.length;
          for (; null === lastElement && i > 0; )
            lastElement = elements[--i];
          null === lastElement || lastElement.start > commentWS.start ? setInnerComments(node, commentWS.comments) : setTrailingComments(lastElement, commentWS.comments);
        }
        class CommentsParser extends BaseParser {
          addComment(comment) {
            this.filename && (comment.loc.filename = this.filename), this.state.comments.push(comment);
          }
          processComment(node) {
            const { commentStack } = this.state, commentStackLength = commentStack.length;
            if (0 === commentStackLength)
              return;
            let i = commentStackLength - 1;
            const lastCommentWS = commentStack[i];
            lastCommentWS.start === node.end && (lastCommentWS.leadingNode = node, i--);
            const { start: nodeStart } = node;
            for (; i >= 0; i--) {
              const commentWS = commentStack[i], commentEnd = commentWS.end;
              if (!(commentEnd > nodeStart)) {
                commentEnd === nodeStart && (commentWS.trailingNode = node);
                break;
              }
              commentWS.containingNode = node, this.finalizeComment(commentWS), commentStack.splice(i, 1);
            }
          }
          finalizeComment(commentWS) {
            const { comments } = commentWS;
            if (null !== commentWS.leadingNode || null !== commentWS.trailingNode)
              null !== commentWS.leadingNode && setTrailingComments(commentWS.leadingNode, comments), null !== commentWS.trailingNode && function(node, comments2) {
                void 0 === node.leadingComments ? node.leadingComments = comments2 : node.leadingComments.unshift(...comments2);
              }(commentWS.trailingNode, comments);
            else {
              const { containingNode: node, start: commentStart } = commentWS;
              if (44 === this.input.charCodeAt(commentStart - 1))
                switch (node.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    adjustInnerComments(node, node.properties, commentWS);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    adjustInnerComments(node, node.arguments, commentWS);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    adjustInnerComments(node, node.params, commentWS);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    adjustInnerComments(node, node.elements, commentWS);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    adjustInnerComments(node, node.specifiers, commentWS);
                    break;
                  default:
                    setInnerComments(node, comments);
                }
              else
                setInnerComments(node, comments);
            }
          }
          finalizeRemainingComments() {
            const { commentStack } = this.state;
            for (let i = commentStack.length - 1; i >= 0; i--)
              this.finalizeComment(commentStack[i]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(node) {
            const { commentStack } = this.state, { length } = commentStack;
            if (0 === length)
              return;
            const commentWS = commentStack[length - 1];
            commentWS.leadingNode === node && (commentWS.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(node) {
            const { commentStack } = this.state, { length } = commentStack;
            0 !== length && (commentStack[length - 1].trailingNode === node ? commentStack[length - 1].trailingNode = null : length >= 2 && commentStack[length - 2].trailingNode === node && (commentStack[length - 2].trailingNode = null));
          }
          takeSurroundingComments(node, start, end) {
            const { commentStack } = this.state, commentStackLength = commentStack.length;
            if (0 === commentStackLength)
              return;
            let i = commentStackLength - 1;
            for (; i >= 0; i--) {
              const commentWS = commentStack[i], commentEnd = commentWS.end;
              if (commentWS.start === end)
                commentWS.leadingNode = node;
              else if (commentEnd === start)
                commentWS.trailingNode = node;
              else if (commentEnd < start)
                break;
            }
          }
        }
        const lineBreak2 = /\r\n?|[\n\u2028\u2029]/, lineBreakG2 = new RegExp(lineBreak2.source, "g");
        function isNewLine2(code) {
          switch (code) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        const skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function isWhitespace(code) {
          switch (code) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        class State {
          constructor() {
            this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [types2.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          init({ strictMode, sourceType, startLine, startColumn }) {
            this.strict = false !== strictMode && (true === strictMode || "module" === sourceType), this.curLine = startLine, this.lineStart = -startColumn, this.startLoc = this.endLoc = new Position3(startLine, startColumn, 0);
          }
          curPosition() {
            return new Position3(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone(skipArrays) {
            const state = new State(), keys2 = Object.keys(this);
            for (let i = 0, length = keys2.length; i < length; i++) {
              const key = keys2[i];
              let val = this[key];
              !skipArrays && Array.isArray(val) && (val = val.slice()), state[key] = val;
            }
            return state;
          }
        }
        var _isDigit = function(code) {
          return code >= 48 && code <= 57;
        };
        const forbiddenNumericSeparatorSiblings = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, isAllowedNumericSeparatorSibling = { bin: (ch) => 48 === ch || 49 === ch, oct: (ch) => ch >= 48 && ch <= 55, dec: (ch) => ch >= 48 && ch <= 57, hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102 };
        function readStringContents(type, input, pos, lineStart, curLine, errors) {
          const initialPos = pos, initialLineStart = lineStart, initialCurLine = curLine;
          let out = "", firstInvalidLoc = null, chunkStart = pos;
          const { length } = input;
          for (; ; ) {
            if (pos >= length) {
              errors.unterminated(initialPos, initialLineStart, initialCurLine), out += input.slice(chunkStart, pos);
              break;
            }
            const ch = input.charCodeAt(pos);
            if (isStringEnd(type, ch, input, pos)) {
              out += input.slice(chunkStart, pos);
              break;
            }
            if (92 === ch) {
              out += input.slice(chunkStart, pos);
              const res = readEscapedChar(input, pos, lineStart, curLine, "template" === type, errors);
              null !== res.ch || firstInvalidLoc ? out += res.ch : firstInvalidLoc = { pos, lineStart, curLine }, { pos, lineStart, curLine } = res, chunkStart = pos;
            } else
              8232 === ch || 8233 === ch ? (++curLine, lineStart = ++pos) : 10 === ch || 13 === ch ? "template" === type ? (out += input.slice(chunkStart, pos) + "\n", ++pos, 13 === ch && 10 === input.charCodeAt(pos) && ++pos, ++curLine, chunkStart = lineStart = pos) : errors.unterminated(initialPos, initialLineStart, initialCurLine) : ++pos;
          }
          return { pos, str: out, firstInvalidLoc, lineStart, curLine, containsInvalid: !!firstInvalidLoc };
        }
        function isStringEnd(type, ch, input, pos) {
          return "template" === type ? 96 === ch || 36 === ch && 123 === input.charCodeAt(pos + 1) : ch === ("double" === type ? 34 : 39);
        }
        function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
          const throwOnInvalid = !inTemplate;
          pos++;
          const res = (ch2) => ({ pos, ch: ch2, lineStart, curLine }), ch = input.charCodeAt(pos++);
          switch (ch) {
            case 110:
              return res("\n");
            case 114:
              return res("\r");
            case 120: {
              let code;
              return { code, pos } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors), res(null === code ? null : String.fromCharCode(code));
            }
            case 117: {
              let code;
              return { code, pos } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors), res(null === code ? null : String.fromCodePoint(code));
            }
            case 116:
              return res("	");
            case 98:
              return res("\b");
            case 118:
              return res("\v");
            case 102:
              return res("\f");
            case 13:
              10 === input.charCodeAt(pos) && ++pos;
            case 10:
              lineStart = pos, ++curLine;
            case 8232:
            case 8233:
              return res("");
            case 56:
            case 57:
              if (inTemplate)
                return res(null);
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            default:
              if (ch >= 48 && ch <= 55) {
                const startPos = pos - 1;
                let octalStr = input.slice(startPos, pos + 2).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
                octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), pos += octalStr.length - 1;
                const next = input.charCodeAt(pos);
                if ("0" !== octalStr || 56 === next || 57 === next) {
                  if (inTemplate)
                    return res(null);
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
                return res(String.fromCharCode(octal));
              }
              return res(String.fromCharCode(ch));
          }
        }
        function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
          const initialPos = pos;
          let n;
          return { n, pos } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid), null === n && (throwOnInvalid ? errors.invalidEscapeSequence(initialPos, lineStart, curLine) : pos = initialPos - 1), { code: n, pos };
        }
        function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
          const start = pos, forbiddenSiblings = 16 === radix ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, isAllowedSibling = 16 === radix ? isAllowedNumericSeparatorSibling.hex : 10 === radix ? isAllowedNumericSeparatorSibling.dec : 8 === radix ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
          let invalid = false, total = 0;
          for (let i = 0, e = null == len ? 1 / 0 : len; i < e; ++i) {
            const code = input.charCodeAt(pos);
            let val;
            if (95 !== code || "bail" === allowNumSeparator) {
              if (val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : _isDigit(code) ? code - 48 : 1 / 0, val >= radix) {
                if (val <= 9 && bailOnError)
                  return { n: null, pos };
                if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix))
                  val = 0;
                else {
                  if (!forceLen)
                    break;
                  val = 0, invalid = true;
                }
              }
              ++pos, total = total * radix + val;
            } else {
              const prev = input.charCodeAt(pos - 1), next = input.charCodeAt(pos + 1);
              if (allowNumSeparator) {
                if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                  if (bailOnError)
                    return { n: null, pos };
                  errors.unexpectedNumericSeparator(pos, lineStart, curLine);
                }
              } else {
                if (bailOnError)
                  return { n: null, pos };
                errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
              }
              ++pos;
            }
          }
          return pos === start || null != len && pos - start !== len || invalid ? { n: null, pos } : { n: total, pos };
        }
        function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
          let code;
          if (123 === input.charCodeAt(pos)) {
            if (++pos, { code, pos } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors), ++pos, null !== code && code > 1114111) {
              if (!throwOnInvalid)
                return { code: null, pos };
              errors.invalidCodePoint(pos, lineStart, curLine);
            }
          } else
            ({ code, pos } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
          return { code, pos };
        }
        const _excluded = ["at"], _excluded2 = ["at"];
        function buildPosition(pos, lineStart, curLine) {
          return new Position3(curLine, pos - lineStart, pos);
        }
        const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
        class Token3 {
          constructor(state) {
            this.type = state.type, this.value = state.value, this.start = state.start, this.end = state.end, this.loc = new SourceLocation3(state.startLoc, state.endLoc);
          }
        }
        class Tokenizer extends CommentsParser {
          constructor(options, input) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (pos, lineStart, curLine, radix) => !!this.options.errorRecovery && (this.raise(Errors.InvalidDigit, { at: buildPosition(pos, lineStart, curLine), radix }), true), numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (pos, lineStart, curLine) => {
              this.recordStrictModeErrors(Errors.StrictNumericEscape, { at: buildPosition(pos, lineStart, curLine) });
            }, unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedString, { at: buildPosition(pos - 1, lineStart, curLine) });
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape), unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedTemplate, { at: buildPosition(pos, lineStart, curLine) });
            } }), this.state = new State(), this.state.init(options), this.input = input, this.length = input.length, this.isLookahead = false;
          }
          pushToken(token) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(token), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token3(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(type) {
            return !!this.match(type) && (this.next(), true);
          }
          match(type) {
            return this.state.type === type;
          }
          createLookaheadState(state) {
            return { pos: state.pos, value: null, type: state.type, start: state.start, end: state.end, context: [this.curContext()], inType: state.inType, startLoc: state.startLoc, lastTokEndLoc: state.lastTokEndLoc, curLine: state.curLine, lineStart: state.lineStart, curPosition: state.curPosition };
          }
          lookahead() {
            const old = this.state;
            this.state = this.createLookaheadState(old), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            const curr = this.state;
            return this.state = old, curr;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(pos) {
            return skipWhiteSpace2.lastIndex = pos, skipWhiteSpace2.test(this.input) ? skipWhiteSpace2.lastIndex : pos;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(pos) {
            return skipWhiteSpaceInLine.lastIndex = pos, skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(pos) {
            let cp = this.input.charCodeAt(pos);
            if (55296 == (64512 & cp) && ++pos < this.input.length) {
              const trail = this.input.charCodeAt(pos);
              56320 == (64512 & trail) && (cp = 65536 + ((1023 & cp) << 10) + (1023 & trail));
            }
            return cp;
          }
          setStrict(strict) {
            this.state.strict = strict, strict && (this.state.strictErrors.forEach(([toParseError, at2]) => this.raise(toParseError, { at: at2 })), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(137) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(commentEnd) {
            let startLoc;
            this.isLookahead || (startLoc = this.state.curPosition());
            const start = this.state.pos, end = this.input.indexOf(commentEnd, start + 2);
            if (-1 === end)
              throw this.raise(Errors.UnterminatedComment, { at: this.state.curPosition() });
            for (this.state.pos = end + commentEnd.length, lineBreakG2.lastIndex = start + 2; lineBreakG2.test(this.input) && lineBreakG2.lastIndex <= end; )
              ++this.state.curLine, this.state.lineStart = lineBreakG2.lastIndex;
            if (this.isLookahead)
              return;
            const comment = { type: "CommentBlock", value: this.input.slice(start + 2, end), start, end: end + commentEnd.length, loc: new SourceLocation3(startLoc, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(comment), comment;
          }
          skipLineComment(startSkip) {
            const start = this.state.pos;
            let startLoc;
            this.isLookahead || (startLoc = this.state.curPosition());
            let ch = this.input.charCodeAt(this.state.pos += startSkip);
            if (this.state.pos < this.length)
              for (; !isNewLine2(ch) && ++this.state.pos < this.length; )
                ch = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead)
              return;
            const end = this.state.pos, comment = { type: "CommentLine", value: this.input.slice(start + startSkip, end), start, end, loc: new SourceLocation3(startLoc, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(comment), comment;
          }
          skipSpace() {
            const spaceStart = this.state.pos, comments = [];
            loop:
              for (; this.state.pos < this.length; ) {
                const ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        const comment = this.skipBlockComment("*/");
                        void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                        break;
                      }
                      case 47: {
                        const comment = this.skipLineComment(2);
                        void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                        break;
                      }
                      default:
                        break loop;
                    }
                    break;
                  default:
                    if (isWhitespace(ch))
                      ++this.state.pos;
                    else if (45 === ch && !this.inModule && this.options.annexB) {
                      const pos = this.state.pos;
                      if (45 !== this.input.charCodeAt(pos + 1) || 62 !== this.input.charCodeAt(pos + 2) || !(0 === spaceStart || this.state.lineStart > spaceStart))
                        break loop;
                      {
                        const comment = this.skipLineComment(3);
                        void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                      }
                    } else {
                      if (60 !== ch || this.inModule || !this.options.annexB)
                        break loop;
                      {
                        const pos = this.state.pos;
                        if (33 !== this.input.charCodeAt(pos + 1) || 45 !== this.input.charCodeAt(pos + 2) || 45 !== this.input.charCodeAt(pos + 3))
                          break loop;
                        {
                          const comment = this.skipLineComment(4);
                          void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                        }
                      }
                    }
                }
              }
            if (comments.length > 0) {
              const commentWhitespace = { start: spaceStart, end: this.state.pos, comments, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(commentWhitespace);
            }
          }
          finishToken(type, val) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const prevType = this.state.type;
            this.state.type = type, this.state.value = val, this.isLookahead || this.updateContext(prevType);
          }
          replaceToken(type) {
            this.state.type = type, this.updateContext();
          }
          readToken_numberSign() {
            if (0 === this.state.pos && this.readToken_interpreter())
              return;
            const nextPos = this.state.pos + 1, next = this.codePointAtPos(nextPos);
            if (next >= 48 && next <= 57)
              throw this.raise(Errors.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
            if (123 === next || 91 === next && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType"))
                throw this.raise(123 === next ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
              this.state.pos += 2, 123 === next ? this.finishToken(7) : this.finishToken(1);
            } else
              isIdentifierStart2(next) ? (++this.state.pos, this.finishToken(136, this.readWord1(next))) : 92 === next ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            const next = this.input.charCodeAt(this.state.pos + 1);
            next >= 48 && next <= 57 ? this.readNumber(true) : 46 === next && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (0 !== this.state.pos || this.length < 2)
              return false;
            let ch = this.input.charCodeAt(this.state.pos + 1);
            if (33 !== ch)
              return false;
            const start = this.state.pos;
            for (this.state.pos += 1; !isNewLine2(ch) && ++this.state.pos < this.length; )
              ch = this.input.charCodeAt(this.state.pos);
            const value2 = this.input.slice(start + 2, this.state.pos);
            return this.finishToken(28, value2), true;
          }
          readToken_mult_modulo(code) {
            let type = 42 === code ? 55 : 54, width = 1, next = this.input.charCodeAt(this.state.pos + 1);
            42 === code && 42 === next && (width++, next = this.input.charCodeAt(this.state.pos + 2), type = 57), 61 !== next || this.state.inType || (width++, type = 37 === code ? 33 : 30), this.finishOp(type, width);
          }
          readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next !== code) {
              if (124 === code) {
                if (62 === next)
                  return void this.finishOp(39, 2);
                if (this.hasPlugin("recordAndTuple") && 125 === next) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                    throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && 93 === next) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                    throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              61 !== next ? this.finishOp(124 === code ? 43 : 45, 1) : this.finishOp(30, 2);
            } else
              61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === code ? 41 : 42, 2);
          }
          readToken_caret() {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== next || this.state.inType)
              if (94 === next && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }])) {
                this.finishOp(37, 2);
                94 === this.input.codePointAt(this.state.pos) && this.unexpected();
              } else
                this.finishOp(44, 1);
            else
              this.finishOp(32, 2);
          }
          readToken_atSign() {
            64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            next !== code ? 61 === next ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
          }
          readToken_lt() {
            const { pos } = this.state, next = this.input.charCodeAt(pos + 1);
            if (60 === next)
              return 61 === this.input.charCodeAt(pos + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
            61 !== next ? this.finishOp(47, 1) : this.finishOp(49, 2);
          }
          readToken_gt() {
            const { pos } = this.state, next = this.input.charCodeAt(pos + 1);
            if (62 === next) {
              const size = 62 === this.input.charCodeAt(pos + 2) ? 3 : 2;
              return 61 === this.input.charCodeAt(pos + size) ? void this.finishOp(30, size + 1) : void this.finishOp(52, size);
            }
            61 !== next ? this.finishOp(48, 1) : this.finishOp(49, 2);
          }
          readToken_eq_excl(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== next)
              return 61 === code && 62 === next ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === code ? 29 : 35, 1);
            this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
          }
          readToken_question() {
            const next = this.input.charCodeAt(this.state.pos + 1), next2 = this.input.charCodeAt(this.state.pos + 2);
            63 === next ? 61 === next2 ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== next || next2 >= 48 && next2 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(code) {
            switch (code) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                    throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(2);
                } else
                  ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                    throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(6);
                } else
                  ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48: {
                const next = this.input.charCodeAt(this.state.pos + 1);
                if (120 === next || 88 === next)
                  return void this.readRadixNumber(16);
                if (111 === next || 79 === next)
                  return void this.readRadixNumber(8);
                if (98 === next || 66 === next)
                  return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(false);
              case 34:
              case 39:
                return void this.readString(code);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(code);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(code);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(code);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(code);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return void this.readToken_atSign();
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (isIdentifierStart2(code))
                  return void this.readWord(code);
            }
            throw this.raise(Errors.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(code) });
          }
          finishOp(type, size) {
            const str = this.input.slice(this.state.pos, this.state.pos + size);
            this.state.pos += size, this.finishToken(type, str);
          }
          readRegexp() {
            const startLoc = this.state.startLoc, start = this.state.start + 1;
            let escaped, inClass, { pos } = this.state;
            for (; ; ++pos) {
              if (pos >= this.length)
                throw this.raise(Errors.UnterminatedRegExp, { at: createPositionWithColumnOffset(startLoc, 1) });
              const ch = this.input.charCodeAt(pos);
              if (isNewLine2(ch))
                throw this.raise(Errors.UnterminatedRegExp, { at: createPositionWithColumnOffset(startLoc, 1) });
              if (escaped)
                escaped = false;
              else {
                if (91 === ch)
                  inClass = true;
                else if (93 === ch && inClass)
                  inClass = false;
                else if (47 === ch && !inClass)
                  break;
                escaped = 92 === ch;
              }
            }
            const content = this.input.slice(start, pos);
            ++pos;
            let mods = "";
            const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
            for (; pos < this.length; ) {
              const cp = this.codePointAtPos(pos), char = String.fromCharCode(cp);
              if (VALID_REGEX_FLAGS.has(cp))
                118 === cp ? mods.includes("u") && this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() }) : 117 === cp && mods.includes("v") && this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() }), mods.includes(char) && this.raise(Errors.DuplicateRegExpFlags, { at: nextPos() });
              else {
                if (!isIdentifierChar2(cp) && 92 !== cp)
                  break;
                this.raise(Errors.MalformedRegExpFlags, { at: nextPos() });
              }
              ++pos, mods += char;
            }
            this.state.pos = pos, this.finishToken(135, { pattern: content, flags: mods });
          }
          readInt(radix, len, forceLen = false, allowNumSeparator = true) {
            const { n, pos } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
            return this.state.pos = pos, n;
          }
          readRadixNumber(radix) {
            const startLoc = this.state.curPosition();
            let isBigInt = false;
            this.state.pos += 2;
            const val = this.readInt(radix);
            null == val && this.raise(Errors.InvalidDigit, { at: createPositionWithColumnOffset(startLoc, 2), radix });
            const next = this.input.charCodeAt(this.state.pos);
            if (110 === next)
              ++this.state.pos, isBigInt = true;
            else if (109 === next)
              throw this.raise(Errors.InvalidDecimal, { at: startLoc });
            if (isIdentifierStart2(this.codePointAtPos(this.state.pos)))
              throw this.raise(Errors.NumberIdentifier, { at: this.state.curPosition() });
            if (isBigInt) {
              const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(133, str);
            } else
              this.finishToken(132, val);
          }
          readNumber(startsWithDot) {
            const start = this.state.pos, startLoc = this.state.curPosition();
            let isFloat = false, isBigInt = false, isDecimal = false, hasExponent = false, isOctal = false;
            startsWithDot || null !== this.readInt(10) || this.raise(Errors.InvalidNumber, { at: this.state.curPosition() });
            const hasLeadingZero = this.state.pos - start >= 2 && 48 === this.input.charCodeAt(start);
            if (hasLeadingZero) {
              const integer = this.input.slice(start, this.state.pos);
              if (this.recordStrictModeErrors(Errors.StrictOctalLiteral, { at: startLoc }), !this.state.strict) {
                const underscorePos = integer.indexOf("_");
                underscorePos > 0 && this.raise(Errors.ZeroDigitNumericSeparator, { at: createPositionWithColumnOffset(startLoc, underscorePos) });
              }
              isOctal = hasLeadingZero && !/[89]/.test(integer);
            }
            let next = this.input.charCodeAt(this.state.pos);
            if (46 !== next || isOctal || (++this.state.pos, this.readInt(10), isFloat = true, next = this.input.charCodeAt(this.state.pos)), 69 !== next && 101 !== next || isOctal || (next = this.input.charCodeAt(++this.state.pos), 43 !== next && 45 !== next || ++this.state.pos, null === this.readInt(10) && this.raise(Errors.InvalidOrMissingExponent, { at: startLoc }), isFloat = true, hasExponent = true, next = this.input.charCodeAt(this.state.pos)), 110 === next && ((isFloat || hasLeadingZero) && this.raise(Errors.InvalidBigIntLiteral, { at: startLoc }), ++this.state.pos, isBigInt = true), 109 === next && (this.expectPlugin("decimal", this.state.curPosition()), (hasExponent || hasLeadingZero) && this.raise(Errors.InvalidDecimal, { at: startLoc }), ++this.state.pos, isDecimal = true), isIdentifierStart2(this.codePointAtPos(this.state.pos)))
              throw this.raise(Errors.NumberIdentifier, { at: this.state.curPosition() });
            const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
            if (isBigInt)
              return void this.finishToken(133, str);
            if (isDecimal)
              return void this.finishToken(134, str);
            const val = isOctal ? parseInt(str, 8) : parseFloat(str);
            this.finishToken(132, val);
          }
          readCodePoint(throwOnInvalid) {
            const { code, pos } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
            return this.state.pos = pos, code;
          }
          readString(quote) {
            const { str, pos, curLine, lineStart } = readStringContents(34 === quote ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = pos + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, this.finishToken(131, str);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            const opening = this.input[this.state.pos], { str, firstInvalidLoc, pos, curLine, lineStart } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = pos + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, firstInvalidLoc && (this.state.firstInvalidTemplateEscapePos = new Position3(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos)), 96 === this.input.codePointAt(pos) ? this.finishToken(24, firstInvalidLoc ? null : opening + str + "`") : (this.state.pos++, this.finishToken(25, firstInvalidLoc ? null : opening + str + "${"));
          }
          recordStrictModeErrors(toParseError, { at: at2 }) {
            const index2 = at2.index;
            this.state.strict && !this.state.strictErrors.has(index2) ? this.raise(toParseError, { at: at2 }) : this.state.strictErrors.set(index2, [toParseError, at2]);
          }
          readWord1(firstCode) {
            this.state.containsEsc = false;
            let word = "";
            const start = this.state.pos;
            let chunkStart = this.state.pos;
            for (void 0 !== firstCode && (this.state.pos += firstCode <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const ch = this.codePointAtPos(this.state.pos);
              if (isIdentifierChar2(ch))
                this.state.pos += ch <= 65535 ? 1 : 2;
              else {
                if (92 !== ch)
                  break;
                {
                  this.state.containsEsc = true, word += this.input.slice(chunkStart, this.state.pos);
                  const escStart = this.state.curPosition(), identifierCheck = this.state.pos === start ? isIdentifierStart2 : isIdentifierChar2;
                  if (117 !== this.input.charCodeAt(++this.state.pos)) {
                    this.raise(Errors.MissingUnicodeEscape, { at: this.state.curPosition() }), chunkStart = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const esc = this.readCodePoint(true);
                  null !== esc && (identifierCheck(esc) || this.raise(Errors.EscapedCharNotAnIdentifier, { at: escStart }), word += String.fromCodePoint(esc)), chunkStart = this.state.pos;
                }
              }
            }
            return word + this.input.slice(chunkStart, this.state.pos);
          }
          readWord(firstCode) {
            const word = this.readWord1(firstCode), type = keywords$12.get(word);
            void 0 !== type ? this.finishToken(type, tokenLabelName(type)) : this.finishToken(130, word);
          }
          checkKeywordEscapes() {
            const { type } = this.state;
            tokenIsKeyword(type) && this.state.containsEsc && this.raise(Errors.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: tokenLabelName(type) });
          }
          raise(toParseError, raiseProperties) {
            const { at: at2 } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded), error = toParseError({ loc: at2 instanceof Position3 ? at2 : at2.loc.start, details });
            if (!this.options.errorRecovery)
              throw error;
            return this.isLookahead || this.state.errors.push(error), error;
          }
          raiseOverwrite(toParseError, raiseProperties) {
            const { at: at2 } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2), loc = at2 instanceof Position3 ? at2 : at2.loc.start, pos = loc.index, errors = this.state.errors;
            for (let i = errors.length - 1; i >= 0; i--) {
              const error = errors[i];
              if (error.loc.index === pos)
                return errors[i] = toParseError({ loc, details });
              if (error.loc.index < pos)
                break;
            }
            return this.raise(toParseError, raiseProperties);
          }
          updateContext(prevType) {
          }
          unexpected(loc, type) {
            throw this.raise(Errors.UnexpectedToken, { expected: type ? tokenLabelName(type) : null, at: null != loc ? loc : this.state.startLoc });
          }
          expectPlugin(pluginName, loc) {
            if (this.hasPlugin(pluginName))
              return true;
            throw this.raise(Errors.MissingPlugin, { at: null != loc ? loc : this.state.startLoc, missingPlugin: [pluginName] });
          }
          expectOnePlugin(pluginNames) {
            if (!pluginNames.some((name) => this.hasPlugin(name)))
              throw this.raise(Errors.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: pluginNames });
          }
          errorBuilder(error) {
            return (pos, lineStart, curLine) => {
              this.raise(error, { at: buildPosition(pos, lineStart, curLine) });
            };
          }
        }
        class ClassScope {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class ClassScopeHandler {
          constructor(parser) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = parser;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new ClassScope());
          }
          exit() {
            const oldClassScope = this.stack.pop(), current2 = this.current();
            for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames))
              current2 ? current2.undefinedPrivateNames.has(name) || current2.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, { at: loc, identifierName: name });
          }
          declarePrivateName(name, elementType, loc) {
            const { privateNames, loneAccessors, undefinedPrivateNames } = this.current();
            let redefined = privateNames.has(name);
            if (3 & elementType) {
              const accessor = redefined && loneAccessors.get(name);
              if (accessor) {
                redefined = (3 & accessor) === (3 & elementType) || (4 & accessor) !== (4 & elementType), redefined || loneAccessors.delete(name);
              } else
                redefined || loneAccessors.set(name, elementType);
            }
            redefined && this.parser.raise(Errors.PrivateNameRedeclaration, { at: loc, identifierName: name }), privateNames.add(name), undefinedPrivateNames.delete(name);
          }
          usePrivateName(name, loc) {
            let classScope;
            for (classScope of this.stack)
              if (classScope.privateNames.has(name))
                return;
            classScope ? classScope.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, { at: loc, identifierName: name });
          }
        }
        class ExpressionScope {
          constructor(type = 0) {
            this.type = void 0, this.type = type;
          }
          canBeArrowParameterDeclaration() {
            return 2 === this.type || 1 === this.type;
          }
          isCertainlyParameterDeclaration() {
            return 3 === this.type;
          }
        }
        class ArrowHeadParsingScope extends ExpressionScope {
          constructor(type) {
            super(type), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(ParsingErrorClass, { at: at2 }) {
            const index2 = at2.index;
            this.declarationErrors.set(index2, [ParsingErrorClass, at2]);
          }
          clearDeclarationError(index2) {
            this.declarationErrors.delete(index2);
          }
          iterateErrors(iterator) {
            this.declarationErrors.forEach(iterator);
          }
        }
        class ExpressionScopeHandler {
          constructor(parser) {
            this.parser = void 0, this.stack = [new ExpressionScope()], this.parser = parser;
          }
          enter(scope) {
            this.stack.push(scope);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(toParseError, { at: node }) {
            const origin = { at: node.loc.start }, { stack } = this;
            let i = stack.length - 1, scope = stack[i];
            for (; !scope.isCertainlyParameterDeclaration(); ) {
              if (!scope.canBeArrowParameterDeclaration())
                return;
              scope.recordDeclarationError(toParseError, origin), scope = stack[--i];
            }
            this.parser.raise(toParseError, origin);
          }
          recordArrowParameterBindingError(error, { at: node }) {
            const { stack } = this, scope = stack[stack.length - 1], origin = { at: node.loc.start };
            if (scope.isCertainlyParameterDeclaration())
              this.parser.raise(error, origin);
            else {
              if (!scope.canBeArrowParameterDeclaration())
                return;
              scope.recordDeclarationError(error, origin);
            }
          }
          recordAsyncArrowParametersError({ at: at2 }) {
            const { stack } = this;
            let i = stack.length - 1, scope = stack[i];
            for (; scope.canBeArrowParameterDeclaration(); )
              2 === scope.type && scope.recordDeclarationError(Errors.AwaitBindingIdentifier, { at: at2 }), scope = stack[--i];
          }
          validateAsPattern() {
            const { stack } = this, currentScope = stack[stack.length - 1];
            currentScope.canBeArrowParameterDeclaration() && currentScope.iterateErrors(([toParseError, loc]) => {
              this.parser.raise(toParseError, { at: loc });
              let i = stack.length - 2, scope = stack[i];
              for (; scope.canBeArrowParameterDeclaration(); )
                scope.clearDeclarationError(loc.index), scope = stack[--i];
            });
          }
        }
        function newExpressionScope() {
          return new ExpressionScope();
        }
        class ProductionParameterHandler {
          constructor() {
            this.stacks = [];
          }
          enter(flags) {
            this.stacks.push(flags);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function functionFlags2(isAsync, isGenerator) {
          return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
        }
        class UtilParser extends Tokenizer {
          addExtra(node, key, value2, enumerable = true) {
            if (!node)
              return;
            const extra = node.extra = node.extra || {};
            enumerable ? extra[key] = value2 : Object.defineProperty(extra, key, { enumerable, value: value2 });
          }
          isContextual(token) {
            return this.state.type === token && !this.state.containsEsc;
          }
          isUnparsedContextual(nameStart, name) {
            const nameEnd = nameStart + name.length;
            if (this.input.slice(nameStart, nameEnd) === name) {
              const nextCh = this.input.charCodeAt(nameEnd);
              return !(isIdentifierChar2(nextCh) || 55296 == (64512 & nextCh));
            }
            return false;
          }
          isLookaheadContextual(name) {
            const next = this.nextTokenStart();
            return this.isUnparsedContextual(next, name);
          }
          eatContextual(token) {
            return !!this.isContextual(token) && (this.next(), true);
          }
          expectContextual(token, toParseError) {
            if (!this.eatContextual(token)) {
              if (null != toParseError)
                throw this.raise(toParseError, { at: this.state.startLoc });
              this.unexpected(null, token);
            }
          }
          canInsertSemicolon() {
            return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return lineBreak2.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return skipWhiteSpaceToLineBreak.lastIndex = this.state.end, skipWhiteSpaceToLineBreak.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(allowAsi = true) {
            (allowAsi ? this.isLineTerminator() : this.eat(13)) || this.raise(Errors.MissingSemicolon, { at: this.state.lastTokEndLoc });
          }
          expect(type, loc) {
            this.eat(type) || this.unexpected(loc, type);
          }
          tryParse(fn, oldState = this.state.clone()) {
            const abortSignal = { node: null };
            try {
              const node = fn((node2 = null) => {
                throw abortSignal.node = node2, abortSignal;
              });
              if (this.state.errors.length > oldState.errors.length) {
                const failState = this.state;
                return this.state = oldState, this.state.tokensLength = failState.tokensLength, { node, error: failState.errors[oldState.errors.length], thrown: false, aborted: false, failState };
              }
              return { node, error: null, thrown: false, aborted: false, failState: null };
            } catch (error) {
              const failState = this.state;
              if (this.state = oldState, error instanceof SyntaxError)
                return { node: null, error, thrown: true, aborted: false, failState };
              if (error === abortSignal)
                return { node: abortSignal.node, error: null, thrown: false, aborted: true, failState };
              throw error;
            }
          }
          checkExpressionErrors(refExpressionErrors, andThrow) {
            if (!refExpressionErrors)
              return false;
            const { shorthandAssignLoc, doubleProtoLoc, privateKeyLoc, optionalParametersLoc } = refExpressionErrors;
            if (!andThrow)
              return !!(shorthandAssignLoc || doubleProtoLoc || optionalParametersLoc || privateKeyLoc);
            null != shorthandAssignLoc && this.raise(Errors.InvalidCoverInitializedName, { at: shorthandAssignLoc }), null != doubleProtoLoc && this.raise(Errors.DuplicateProto, { at: doubleProtoLoc }), null != privateKeyLoc && this.raise(Errors.UnexpectedPrivateField, { at: privateKeyLoc }), null != optionalParametersLoc && this.unexpected(optionalParametersLoc);
          }
          isLiteralPropertyName() {
            return tokenIsLiteralPropertyName(this.state.type);
          }
          isPrivateName(node) {
            return "PrivateName" === node.type;
          }
          getPrivateNameSV(node) {
            return node.id.name;
          }
          hasPropertyAsPrivateName(node) {
            return ("MemberExpression" === node.type || "OptionalMemberExpression" === node.type) && this.isPrivateName(node.property);
          }
          isObjectProperty(node) {
            return "ObjectProperty" === node.type;
          }
          isObjectMethod(node) {
            return "ObjectMethod" === node.type;
          }
          initializeScopes(inModule = "module" === this.options.sourceType) {
            const oldLabels = this.state.labels;
            this.state.labels = [];
            const oldExportedIdentifiers = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const oldInModule = this.inModule;
            this.inModule = inModule;
            const oldScope = this.scope, ScopeHandler2 = this.getScopeHandler();
            this.scope = new ScopeHandler2(this, inModule);
            const oldProdParam = this.prodParam;
            this.prodParam = new ProductionParameterHandler();
            const oldClassScope = this.classScope;
            this.classScope = new ClassScopeHandler(this);
            const oldExpressionScope = this.expressionScope;
            return this.expressionScope = new ExpressionScopeHandler(this), () => {
              this.state.labels = oldLabels, this.exportedIdentifiers = oldExportedIdentifiers, this.inModule = oldInModule, this.scope = oldScope, this.prodParam = oldProdParam, this.classScope = oldClassScope, this.expressionScope = oldExpressionScope;
            };
          }
          enterInitialScopes() {
            let paramFlags = 0;
            this.inModule && (paramFlags |= 2), this.scope.enter(1), this.prodParam.enter(paramFlags);
          }
          checkDestructuringPrivate(refExpressionErrors) {
            const { privateKeyLoc } = refExpressionErrors;
            null !== privateKeyLoc && this.expectPlugin("destructuringPrivate", privateKeyLoc);
          }
        }
        class ExpressionErrors {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }
        class Node3 {
          constructor(parser, pos, loc) {
            this.type = "", this.start = pos, this.end = 0, this.loc = new SourceLocation3(loc), null != parser && parser.options.ranges && (this.range = [pos, 0]), null != parser && parser.filename && (this.loc.filename = parser.filename);
          }
        }
        const NodePrototype = Node3.prototype;
        function cloneIdentifier(node) {
          const { type, start, end, loc, range, extra, name } = node, cloned = Object.create(NodePrototype);
          return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range, cloned.extra = extra, cloned.name = name, "Placeholder" === type && (cloned.expectedNode = node.expectedNode), cloned;
        }
        function cloneStringLiteral(node) {
          const { type, start, end, loc, range, extra } = node;
          if ("Placeholder" === type)
            return function(node2) {
              return cloneIdentifier(node2);
            }(node);
          const cloned = Object.create(NodePrototype);
          return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range, void 0 !== node.raw ? cloned.raw = node.raw : cloned.extra = extra, cloned.value = node.value, cloned;
        }
        NodePrototype.__clone = function() {
          const newNode = new Node3(void 0, this.start, this.loc.start), keys2 = Object.keys(this);
          for (let i = 0, length = keys2.length; i < length; i++) {
            const key = keys2[i];
            "leadingComments" !== key && "trailingComments" !== key && "innerComments" !== key && (newNode[key] = this[key]);
          }
          return newNode;
        };
        class NodeUtils extends UtilParser {
          startNode() {
            return new Node3(this, this.state.start, this.state.startLoc);
          }
          startNodeAt(loc) {
            return new Node3(this, loc.index, loc);
          }
          startNodeAtNode(type) {
            return this.startNodeAt(type.loc.start);
          }
          finishNode(node, type) {
            return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
          }
          finishNodeAt(node, type, endLoc) {
            return node.type = type, node.end = endLoc.index, node.loc.end = endLoc, this.options.ranges && (node.range[1] = endLoc.index), this.options.attachComment && this.processComment(node), node;
          }
          resetStartLocation(node, startLoc) {
            node.start = startLoc.index, node.loc.start = startLoc, this.options.ranges && (node.range[0] = startLoc.index);
          }
          resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
            node.end = endLoc.index, node.loc.end = endLoc, this.options.ranges && (node.range[1] = endLoc.index);
          }
          resetStartLocationFromNode(node, locationNode) {
            this.resetStartLocation(node, locationNode.loc.start);
          }
        }
        const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), FlowErrors = ParseErrorEnum`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType }) => `Cannot overwrite reserved type ${reservedType}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName, enumName }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`, EnumDuplicateMemberName: ({ memberName, enumName }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`, EnumInconsistentMemberValues: ({ enumName }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType, enumName }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName, memberName, explicitType }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName, memberName }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName, memberName }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`, EnumInvalidMemberName: ({ enumName, memberName, suggestion }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`, EnumNumberMemberNotInitialized: ({ enumName, memberName }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`, EnumStringMemberInconsistentlyInitailized: ({ enumName }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType }) => `Unexpected reserved type ${reservedType}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind, suggestion }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function hasTypeImportKind(node) {
          return "type" === node.importKind || "typeof" === node.importKind;
        }
        const exportSuggestions = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
        const entities = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "", iexcl: "", cent: "", pound: "", curren: "", yen: "", brvbar: "", sect: "", uml: "", copy: "", ordf: "", laquo: "", not: "", shy: "", reg: "", macr: "", deg: "", plusmn: "", sup2: "", sup3: "", acute: "", micro: "", para: "", middot: "", cedil: "", sup1: "", ordm: "", raquo: "", frac14: "", frac12: "", frac34: "", iquest: "", Agrave: "", Aacute: "", Acirc: "", Atilde: "", Auml: "", Aring: "", AElig: "", Ccedil: "", Egrave: "", Eacute: "", Ecirc: "", Euml: "", Igrave: "", Iacute: "", Icirc: "", Iuml: "", ETH: "", Ntilde: "", Ograve: "", Oacute: "", Ocirc: "", Otilde: "", Ouml: "", times: "", Oslash: "", Ugrave: "", Uacute: "", Ucirc: "", Uuml: "", Yacute: "", THORN: "", szlig: "", agrave: "", aacute: "", acirc: "", atilde: "", auml: "", aring: "", aelig: "", ccedil: "", egrave: "", eacute: "", ecirc: "", euml: "", igrave: "", iacute: "", icirc: "", iuml: "", eth: "", ntilde: "", ograve: "", oacute: "", ocirc: "", otilde: "", ouml: "", divide: "", oslash: "", ugrave: "", uacute: "", ucirc: "", uuml: "", yacute: "", thorn: "", yuml: "", OElig: "", oelig: "", Scaron: "", scaron: "", Yuml: "", fnof: "", circ: "", tilde: "", Alpha: "", Beta: "", Gamma: "", Delta: "", Epsilon: "", Zeta: "", Eta: "", Theta: "", Iota: "", Kappa: "", Lambda: "", Mu: "", Nu: "", Xi: "", Omicron: "", Pi: "", Rho: "", Sigma: "", Tau: "", Upsilon: "", Phi: "", Chi: "", Psi: "", Omega: "", alpha: "", beta: "", gamma: "", delta: "", epsilon: "", zeta: "", eta: "", theta: "", iota: "", kappa: "", lambda: "", mu: "", nu: "", xi: "", omicron: "", pi: "", rho: "", sigmaf: "", sigma: "", tau: "", upsilon: "", phi: "", chi: "", psi: "", omega: "", thetasym: "", upsih: "", piv: "", ensp: "", emsp: "", thinsp: "", zwnj: "", zwj: "", lrm: "", rlm: "", ndash: "", mdash: "", lsquo: "", rsquo: "", sbquo: "", ldquo: "", rdquo: "", bdquo: "", dagger: "", Dagger: "", bull: "", hellip: "", permil: "", prime: "", Prime: "", lsaquo: "", rsaquo: "", oline: "", frasl: "", euro: "", image: "", weierp: "", real: "", trade: "", alefsym: "", larr: "", uarr: "", rarr: "", darr: "", harr: "", crarr: "", lArr: "", uArr: "", rArr: "", dArr: "", hArr: "", forall: "", part: "", exist: "", empty: "", nabla: "", isin: "", notin: "", ni: "", prod: "", sum: "", minus: "", lowast: "", radic: "", prop: "", infin: "", ang: "", and: "", or: "", cap: "", cup: "", int: "", there4: "", sim: "", cong: "", asymp: "", ne: "", equiv: "", le: "", ge: "", sub: "", sup: "", nsub: "", sube: "", supe: "", oplus: "", otimes: "", perp: "", sdot: "", lceil: "", rceil: "", lfloor: "", rfloor: "", lang: "", rang: "", loz: "", spades: "", clubs: "", hearts: "", diams: "" }, JsxErrors = ParseErrorEnum`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected, HTMLEntity }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function isFragment(object) {
          return !!object && ("JSXOpeningFragment" === object.type || "JSXClosingFragment" === object.type);
        }
        function getQualifiedJSXName(object) {
          if ("JSXIdentifier" === object.type)
            return object.name;
          if ("JSXNamespacedName" === object.type)
            return object.namespace.name + ":" + object.name.name;
          if ("JSXMemberExpression" === object.type)
            return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
          throw new Error("Node had unexpected type: " + object.type);
        }
        class TypeScriptScope extends Scope3 {
          constructor(...args) {
            super(...args), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
          }
        }
        class TypeScriptScopeHandler extends ScopeHandler {
          constructor(...args) {
            super(...args), this.importsStack = [];
          }
          createScope(flags) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new TypeScriptScope(flags);
          }
          enter(flags) {
            256 == flags && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(flags);
          }
          exit() {
            const flags = super.exit();
            return 256 == flags && this.importsStack.pop(), flags;
          }
          hasImport(name, allowShadow) {
            const len = this.importsStack.length;
            if (this.importsStack[len - 1].has(name))
              return true;
            if (!allowShadow && len > 1) {
              for (let i = 0; i < len - 1; i++)
                if (this.importsStack[i].has(name))
                  return true;
            }
            return false;
          }
          declareName(name, bindingType, loc) {
            if (4096 & bindingType)
              return this.hasImport(name, true) && this.parser.raise(Errors.VarRedeclaration, { at: loc, identifierName: name }), void this.importsStack[this.importsStack.length - 1].add(name);
            const scope = this.currentScope();
            if (1024 & bindingType)
              return this.maybeExportDefined(scope, name), void scope.exportOnlyBindings.add(name);
            super.declareName(name, bindingType, loc), 2 & bindingType && (1 & bindingType || (this.checkRedeclarationInScope(scope, name, bindingType, loc), this.maybeExportDefined(scope, name)), scope.types.add(name)), 256 & bindingType && scope.enums.add(name), 512 & bindingType && scope.constEnums.add(name), 128 & bindingType && scope.classes.add(name);
          }
          isRedeclaredInScope(scope, name, bindingType) {
            if (scope.enums.has(name)) {
              if (256 & bindingType) {
                return !!(512 & bindingType) !== scope.constEnums.has(name);
              }
              return true;
            }
            return 128 & bindingType && scope.classes.has(name) ? !!scope.lexical.has(name) && !!(1 & bindingType) : !!(2 & bindingType && scope.types.has(name)) || super.isRedeclaredInScope(scope, name, bindingType);
          }
          checkLocalExport(id) {
            const { name } = id;
            if (this.hasImport(name))
              return;
            for (let i = this.scopeStack.length - 1; i >= 0; i--) {
              const scope = this.scopeStack[i];
              if (scope.types.has(name) || scope.exportOnlyBindings.has(name))
                return;
            }
            super.checkLocalExport(id);
          }
        }
        const unwrapParenthesizedExpression = (node) => "ParenthesizedExpression" === node.type ? unwrapParenthesizedExpression(node.expression) : node;
        class LValParser extends NodeUtils {
          toAssignable(node, isLHS = false) {
            var _node$extra, _node$extra3;
            let parenthesized;
            switch (("ParenthesizedExpression" === node.type || null != (_node$extra = node.extra) && _node$extra.parenthesized) && (parenthesized = unwrapParenthesizedExpression(node), isLHS ? "Identifier" === parenthesized.type ? this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, { at: node }) : "MemberExpression" !== parenthesized.type && this.raise(Errors.InvalidParenthesizedAssignment, { at: node }) : this.raise(Errors.InvalidParenthesizedAssignment, { at: node })), node.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                node.type = "ObjectPattern";
                for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
                  var _node$extra2;
                  const prop = node.properties[i], isLast = i === last;
                  this.toAssignableObjectExpressionProp(prop, isLast, isLHS), isLast && "RestElement" === prop.type && null != (_node$extra2 = node.extra) && _node$extra2.trailingCommaLoc && this.raise(Errors.RestTrailingComma, { at: node.extra.trailingCommaLoc });
                }
                break;
              case "ObjectProperty": {
                const { key, value: value2 } = node;
                this.isPrivateName(key) && this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start), this.toAssignable(value2, isLHS);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                node.type = "ArrayPattern", this.toAssignableList(node.elements, null == (_node$extra3 = node.extra) ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
                break;
              case "AssignmentExpression":
                "=" !== node.operator && this.raise(Errors.MissingEqInAssignment, { at: node.left.loc.end }), node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isLHS);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(parenthesized, isLHS);
            }
          }
          toAssignableObjectExpressionProp(prop, isLast, isLHS) {
            if ("ObjectMethod" === prop.type)
              this.raise("get" === prop.kind || "set" === prop.kind ? Errors.PatternHasAccessor : Errors.PatternHasMethod, { at: prop.key });
            else if ("SpreadElement" === prop.type) {
              prop.type = "RestElement";
              const arg = prop.argument;
              this.checkToRestConversion(arg, false), this.toAssignable(arg, isLHS), isLast || this.raise(Errors.RestTrailingComma, { at: prop });
            } else
              this.toAssignable(prop, isLHS);
          }
          toAssignableList(exprList, trailingCommaLoc, isLHS) {
            const end = exprList.length - 1;
            for (let i = 0; i <= end; i++) {
              const elt = exprList[i];
              if (elt) {
                if ("SpreadElement" === elt.type) {
                  elt.type = "RestElement";
                  const arg = elt.argument;
                  this.checkToRestConversion(arg, true), this.toAssignable(arg, isLHS);
                } else
                  this.toAssignable(elt, isLHS);
                "RestElement" === elt.type && (i < end ? this.raise(Errors.RestTrailingComma, { at: elt }) : trailingCommaLoc && this.raise(Errors.RestTrailingComma, { at: trailingCommaLoc }));
              }
            }
          }
          isAssignable(node, isBinding) {
            switch (node.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                const last = node.properties.length - 1;
                return node.properties.every((prop, i) => "ObjectMethod" !== prop.type && (i === last || "SpreadElement" !== prop.type) && this.isAssignable(prop));
              }
              case "ObjectProperty":
                return this.isAssignable(node.value);
              case "SpreadElement":
                return this.isAssignable(node.argument);
              case "ArrayExpression":
                return node.elements.every((element) => null === element || this.isAssignable(element));
              case "AssignmentExpression":
                return "=" === node.operator;
              case "ParenthesizedExpression":
                return this.isAssignable(node.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !isBinding;
              default:
                return false;
            }
          }
          toReferencedList(exprList, isParenthesizedExpr) {
            return exprList;
          }
          toReferencedListDeep(exprList, isParenthesizedExpr) {
            this.toReferencedList(exprList, isParenthesizedExpr);
            for (const expr of exprList)
              "ArrayExpression" === (null == expr ? void 0 : expr.type) && this.toReferencedListDeep(expr.elements);
          }
          parseSpread(refExpressionErrors) {
            const node = this.startNode();
            return this.next(), node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0), this.finishNode(node, "SpreadElement");
          }
          parseRestBinding() {
            const node = this.startNode();
            return this.next(), node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const node = this.startNode();
                return this.next(), node.elements = this.parseBindingList(3, 93, 1), this.finishNode(node, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(close, closeCharCode, flags) {
            const allowEmpty = 1 & flags, elts = [];
            let first = true;
            for (; !this.eat(close); )
              if (first ? first = false : this.expect(12), allowEmpty && this.match(12))
                elts.push(null);
              else {
                if (this.eat(close))
                  break;
                if (this.match(21)) {
                  if (elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags)), !this.checkCommaAfterRest(closeCharCode)) {
                    this.expect(close);
                    break;
                  }
                } else {
                  const decorators = [];
                  for (this.match(26) && this.hasPlugin("decorators") && this.raise(Errors.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                    decorators.push(this.parseDecorator());
                  elts.push(this.parseAssignableListItem(flags, decorators));
                }
              }
            return elts;
          }
          parseBindingRestProperty(prop) {
            return this.next(), prop.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(prop, "RestElement");
          }
          parseBindingProperty() {
            const prop = this.startNode(), { type, startLoc } = this.state;
            return 21 === type ? this.parseBindingRestProperty(prop) : (136 === type ? (this.expectPlugin("destructuringPrivate", startLoc), this.classScope.usePrivateName(this.state.value, startLoc), prop.key = this.parsePrivateName()) : this.parsePropertyName(prop), prop.method = false, this.parseObjPropValue(prop, startLoc, false, false, true, false));
          }
          parseAssignableListItem(flags, decorators) {
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left, flags);
            const elt = this.parseMaybeDefault(left.loc.start, left);
            return decorators.length && (left.decorators = decorators), elt;
          }
          parseAssignableListItemTypes(param, flags) {
            return param;
          }
          parseMaybeDefault(startLoc, left) {
            var _left;
            if (null != startLoc || (startLoc = this.state.startLoc), left = null != (_left = left) ? _left : this.parseBindingAtom(), !this.eat(29))
              return left;
            const node = this.startNodeAt(startLoc);
            return node.left = left, node.right = this.parseMaybeAssignAllowIn(), this.finishNode(node, "AssignmentPattern");
          }
          isValidLVal(type, isUnparenthesizedInAssign, binding) {
            return object = { AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, key = type, Object.hasOwnProperty.call(object, key) && object[key];
            var object, key;
          }
          checkLVal(expression, { in: ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false }) {
            var _expression$extra;
            const type = expression.type;
            if (this.isObjectMethod(expression))
              return;
            if ("MemberExpression" === type)
              return void (64 !== binding && this.raise(Errors.InvalidPropertyBindingPattern, { at: expression }));
            if ("Identifier" === type) {
              this.checkIdentifier(expression, binding, strictModeChanged);
              const { name } = expression;
              return void (checkClashes && (checkClashes.has(name) ? this.raise(Errors.ParamDupe, { at: expression }) : checkClashes.add(name)));
            }
            const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || null != (_expression$extra = expression.extra) && _expression$extra.parenthesized) && "AssignmentExpression" === ancestor.type, binding);
            if (true === validity)
              return;
            if (false === validity) {
              const ParseErrorClass = 64 === binding ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
              return void this.raise(ParseErrorClass, { at: expression, ancestor });
            }
            const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, "ParenthesizedExpression" === type], nextAncestor = "ArrayPattern" === type || "ObjectPattern" === type || "ParenthesizedExpression" === type ? { type } : ancestor;
            for (const child of [].concat(expression[key]))
              child && this.checkLVal(child, { in: nextAncestor, binding, checkClashes, strictModeChanged, hasParenthesizedAncestor: isParenthesizedExpression });
          }
          checkIdentifier(at2, bindingType, strictModeChanged = false) {
            this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at2.name, this.inModule) : isStrictBindOnlyReservedWord(at2.name)) && (64 === bindingType ? this.raise(Errors.StrictEvalArguments, { at: at2, referenceName: at2.name }) : this.raise(Errors.StrictEvalArgumentsBinding, { at: at2, bindingName: at2.name })), 8192 & bindingType && "let" === at2.name && this.raise(Errors.LetInLexicalBinding, { at: at2 }), 64 & bindingType || this.declareNameFromIdentifier(at2, bindingType);
          }
          declareNameFromIdentifier(identifier, binding) {
            this.scope.declareName(identifier.name, binding, identifier.loc.start);
          }
          checkToRestConversion(node, allowPattern) {
            switch (node.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(node.expression, allowPattern);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (allowPattern)
                  break;
              default:
                this.raise(Errors.InvalidRestAssignmentPattern, { at: node });
            }
          }
          checkCommaAfterRest(close) {
            return !!this.match(12) && (this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, { at: this.state.startLoc }), true);
          }
        }
        function assert2(x) {
          if (!x)
            throw new Error("Assert fail");
        }
        const TSErrors = ParseErrorEnum`typescript`({ AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`, EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.` });
        function tsIsAccessModifier(modifier) {
          return "private" === modifier || "public" === modifier || "protected" === modifier;
        }
        function tsIsVarianceAnnotations(modifier) {
          return "in" === modifier || "out" === modifier;
        }
        function isPossiblyLiteralEnum(expression) {
          if ("MemberExpression" !== expression.type)
            return false;
          const { computed, property } = expression;
          return (!computed || "StringLiteral" === property.type || !("TemplateLiteral" !== property.type || property.expressions.length > 0)) && isUncomputedMemberExpressionChain(expression.object);
        }
        function isValidAmbientConstInitializer(expression, estree) {
          var _expression$extra;
          const { type } = expression;
          if (null != (_expression$extra = expression.extra) && _expression$extra.parenthesized)
            return false;
          if (estree) {
            if ("Literal" === type) {
              const { value: value2 } = expression;
              if ("string" == typeof value2 || "boolean" == typeof value2)
                return true;
            }
          } else if ("StringLiteral" === type || "BooleanLiteral" === type)
            return true;
          return !(!isNumber(expression, estree) && !function(expression2, estree2) {
            if ("UnaryExpression" === expression2.type) {
              const { operator, argument } = expression2;
              if ("-" === operator && isNumber(argument, estree2))
                return true;
            }
            return false;
          }(expression, estree)) || ("TemplateLiteral" === type && 0 === expression.expressions.length || !!isPossiblyLiteralEnum(expression));
        }
        function isNumber(expression, estree) {
          return estree ? "Literal" === expression.type && ("number" == typeof expression.value || "bigint" in expression) : "NumericLiteral" === expression.type || "BigIntLiteral" === expression.type;
        }
        function isUncomputedMemberExpressionChain(expression) {
          return "Identifier" === expression.type || "MemberExpression" === expression.type && !expression.computed && isUncomputedMemberExpressionChain(expression.object);
        }
        const PlaceholderErrors = ParseErrorEnum`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
        function hasPlugin(plugins, expectedConfig) {
          const [expectedName, expectedOptions] = "string" == typeof expectedConfig ? [expectedConfig, {}] : expectedConfig, expectedKeys = Object.keys(expectedOptions), expectedOptionsIsEmpty = 0 === expectedKeys.length;
          return plugins.some((p) => {
            if ("string" == typeof p)
              return expectedOptionsIsEmpty && p === expectedName;
            {
              const [pluginName, pluginOptions] = p;
              if (pluginName !== expectedName)
                return false;
              for (const key of expectedKeys)
                if (pluginOptions[key] !== expectedOptions[key])
                  return false;
              return true;
            }
          });
        }
        function getPluginOption(plugins, name, option) {
          const plugin = plugins.find((plugin2) => Array.isArray(plugin2) ? plugin2[0] === name : plugin2 === name);
          return plugin && Array.isArray(plugin) && plugin.length > 1 ? plugin[1][option] : null;
        }
        const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"], TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"], RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
        const mixinPlugins = { estree: (superClass) => class extends superClass {
          parse() {
            const file = toESTreeLocation(super.parse());
            return this.options.tokens && (file.tokens = file.tokens.map(toESTreeLocation)), file;
          }
          parseRegExpLiteral({ pattern, flags }) {
            let regex = null;
            try {
              regex = new RegExp(pattern, flags);
            } catch (e) {
            }
            const node = this.estreeParseLiteral(regex);
            return node.regex = { pattern, flags }, node;
          }
          parseBigIntLiteral(value2) {
            let bigInt;
            try {
              bigInt = BigInt(value2);
            } catch (_unused) {
              bigInt = null;
            }
            const node = this.estreeParseLiteral(bigInt);
            return node.bigint = String(node.value || value2), node;
          }
          parseDecimalLiteral(value2) {
            const node = this.estreeParseLiteral(null);
            return node.decimal = String(node.value || value2), node;
          }
          estreeParseLiteral(value2) {
            return this.parseLiteral(value2, "Literal");
          }
          parseStringLiteral(value2) {
            return this.estreeParseLiteral(value2);
          }
          parseNumericLiteral(value2) {
            return this.estreeParseLiteral(value2);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(value2) {
            return this.estreeParseLiteral(value2);
          }
          directiveToStmt(directive) {
            const expression = directive.value;
            delete directive.value, expression.type = "Literal", expression.raw = expression.extra.raw, expression.value = expression.extra.expressionValue;
            const stmt = directive;
            return stmt.type = "ExpressionStatement", stmt.expression = expression, stmt.directive = expression.extra.rawValue, delete expression.extra, stmt;
          }
          initFunction(node, isAsync) {
            super.initFunction(node, isAsync), node.expression = false;
          }
          checkDeclaration(node) {
            null != node && this.isObjectProperty(node) ? this.checkDeclaration(node.value) : super.checkDeclaration(node);
          }
          getObjectOrClassMethodParams(method) {
            return method.value.params;
          }
          isValidDirective(stmt) {
            var _stmt$expression$extr;
            return "ExpressionStatement" === stmt.type && "Literal" === stmt.expression.type && "string" == typeof stmt.expression.value && !(null != (_stmt$expression$extr = stmt.expression.extra) && _stmt$expression$extr.parenthesized);
          }
          parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
            super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
            const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
            node.body = directiveStatements.concat(node.body), delete node.directives;
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true), method.typeParameters && (method.value.typeParameters = method.typeParameters, delete method.typeParameters), classBody.body.push(method);
          }
          parsePrivateName() {
            const node = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(node) : node;
          }
          convertPrivateNameToPrivateIdentifier(node) {
            const name = super.getPrivateNameSV(node);
            return delete node.id, node.name = name, node.type = "PrivateIdentifier", node;
          }
          isPrivateName(node) {
            return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === node.type : super.isPrivateName(node);
          }
          getPrivateNameSV(node) {
            return this.getPluginOption("estree", "classFeatures") ? node.name : super.getPrivateNameSV(node);
          }
          parseLiteral(value2, type) {
            const node = super.parseLiteral(value2, type);
            return node.raw = node.extra.raw, delete node.extra, node;
          }
          parseFunctionBody(node, allowExpression, isMethod = false) {
            super.parseFunctionBody(node, allowExpression, isMethod), node.expression = "BlockStatement" !== node.body.type;
          }
          parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
            let funcNode = this.startNode();
            return funcNode.kind = node.kind, funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope), funcNode.type = "FunctionExpression", delete funcNode.kind, node.value = funcNode, "ClassPrivateMethod" === type && (node.computed = false), this.finishNode(node, "MethodDefinition");
          }
          parseClassProperty(...args) {
            const propertyNode = super.parseClassProperty(...args);
            return this.getPluginOption("estree", "classFeatures") ? (propertyNode.type = "PropertyDefinition", propertyNode) : propertyNode;
          }
          parseClassPrivateProperty(...args) {
            const propertyNode = super.parseClassPrivateProperty(...args);
            return this.getPluginOption("estree", "classFeatures") ? (propertyNode.type = "PropertyDefinition", propertyNode.computed = false, propertyNode) : propertyNode;
          }
          parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
            const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
            return node && (node.type = "Property", "method" === node.kind && (node.kind = "init"), node.shorthand = false), node;
          }
          parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
            const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
            return node && (node.kind = "init", node.type = "Property"), node;
          }
          isValidLVal(type, isUnparenthesizedInAssign, binding) {
            return "Property" === type ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
          }
          isAssignable(node, isBinding) {
            return null != node && this.isObjectProperty(node) ? this.isAssignable(node.value, isBinding) : super.isAssignable(node, isBinding);
          }
          toAssignable(node, isLHS = false) {
            if (null != node && this.isObjectProperty(node)) {
              const { key, value: value2 } = node;
              this.isPrivateName(key) && this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start), this.toAssignable(value2, isLHS);
            } else
              super.toAssignable(node, isLHS);
          }
          toAssignableObjectExpressionProp(prop, isLast, isLHS) {
            "get" === prop.kind || "set" === prop.kind ? this.raise(Errors.PatternHasAccessor, { at: prop.key }) : prop.method ? this.raise(Errors.PatternHasMethod, { at: prop.key }) : super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
          }
          finishCallExpression(unfinished, optional) {
            const node = super.finishCallExpression(unfinished, optional);
            if ("Import" === node.callee.type) {
              var _node$arguments$;
              if (node.type = "ImportExpression", node.source = node.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
                node.attributes = null != (_node$arguments$ = node.arguments[1]) ? _node$arguments$ : null;
              delete node.arguments, delete node.callee;
            }
            return node;
          }
          toReferencedArguments(node) {
            "ImportExpression" !== node.type && super.toReferencedArguments(node);
          }
          parseExport(unfinished, decorators) {
            const exportStartLoc = this.state.lastTokStartLoc, node = super.parseExport(unfinished, decorators);
            switch (node.type) {
              case "ExportAllDeclaration":
                node.exported = null;
                break;
              case "ExportNamedDeclaration":
                1 === node.specifiers.length && "ExportNamespaceSpecifier" === node.specifiers[0].type && (node.type = "ExportAllDeclaration", node.exported = node.specifiers[0].exported, delete node.specifiers);
              case "ExportDefaultDeclaration": {
                var _declaration$decorato;
                const { declaration } = node;
                "ClassDeclaration" === (null == declaration ? void 0 : declaration.type) && (null == (_declaration$decorato = declaration.decorators) ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start && this.resetStartLocation(node, exportStartLoc);
              }
            }
            return node;
          }
          parseSubscript(base, startLoc, noCalls, state) {
            const node = super.parseSubscript(base, startLoc, noCalls, state);
            if (state.optionalChainMember) {
              if ("OptionalMemberExpression" !== node.type && "OptionalCallExpression" !== node.type || (node.type = node.type.substring(8)), state.stop) {
                const chain = this.startNodeAtNode(node);
                return chain.expression = node, this.finishNode(chain, "ChainExpression");
              }
            } else
              "MemberExpression" !== node.type && "CallExpression" !== node.type || (node.optional = false);
            return node;
          }
          hasPropertyAsPrivateName(node) {
            return "ChainExpression" === node.type && (node = node.expression), super.hasPropertyAsPrivateName(node);
          }
          isObjectProperty(node) {
            return "Property" === node.type && "init" === node.kind && !node.method;
          }
          isObjectMethod(node) {
            return node.method || "get" === node.kind || "set" === node.kind;
          }
          finishNodeAt(node, type, endLoc) {
            return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
          }
          resetStartLocation(node, startLoc) {
            super.resetStartLocation(node, startLoc), toESTreeLocation(node);
          }
          resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
            super.resetEndLocation(node, endLoc), toESTreeLocation(node);
          }
        }, jsx: (superClass) => class extends superClass {
          jsxReadToken() {
            let out = "", chunkStart = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(JsxErrors.UnterminatedJsxContent, { at: this.state.startLoc });
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? void (60 === ch && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(ch)) : (out += this.input.slice(chunkStart, this.state.pos), void this.finishToken(139, out));
                case 38:
                  out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos;
                  break;
                default:
                  isNewLine2(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(true), chunkStart = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(normalizeCRLF) {
            const ch = this.input.charCodeAt(this.state.pos);
            let out;
            return ++this.state.pos, 13 === ch && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, out = normalizeCRLF ? "\n" : "\r\n") : out = String.fromCharCode(ch), ++this.state.curLine, this.state.lineStart = this.state.pos, out;
          }
          jsxReadString(quote) {
            let out = "", chunkStart = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(Errors.UnterminatedString, { at: this.state.startLoc });
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === quote)
                break;
              38 === ch ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos) : isNewLine2(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(false), chunkStart = this.state.pos) : ++this.state.pos;
            }
            out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(131, out);
          }
          jsxReadEntity() {
            const startPos = ++this.state.pos;
            if (35 === this.codePointAtPos(this.state.pos)) {
              ++this.state.pos;
              let radix = 10;
              120 === this.codePointAtPos(this.state.pos) && (radix = 16, ++this.state.pos);
              const codePoint = this.readInt(radix, void 0, false, "bail");
              if (null !== codePoint && 59 === this.codePointAtPos(this.state.pos))
                return ++this.state.pos, String.fromCodePoint(codePoint);
            } else {
              let count = 0, semi = false;
              for (; count++ < 10 && this.state.pos < this.length && !(semi = 59 == this.codePointAtPos(this.state.pos)); )
                ++this.state.pos;
              if (semi) {
                const desc = this.input.slice(startPos, this.state.pos), entity = entities[desc];
                if (++this.state.pos, entity)
                  return entity;
              }
            }
            return this.state.pos = startPos, "&";
          }
          jsxReadWord() {
            let ch;
            const start = this.state.pos;
            do {
              ch = this.input.charCodeAt(++this.state.pos);
            } while (isIdentifierChar2(ch) || 45 === ch);
            this.finishToken(138, this.input.slice(start, this.state.pos));
          }
          jsxParseIdentifier() {
            const node = this.startNode();
            return this.match(138) ? node.name = this.state.value : tokenIsKeyword(this.state.type) ? node.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(node, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const startLoc = this.state.startLoc, name = this.jsxParseIdentifier();
            if (!this.eat(14))
              return name;
            const node = this.startNodeAt(startLoc);
            return node.namespace = name, node.name = this.jsxParseIdentifier(), this.finishNode(node, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const startLoc = this.state.startLoc;
            let node = this.jsxParseNamespacedName();
            if ("JSXNamespacedName" === node.type)
              return node;
            for (; this.eat(16); ) {
              const newNode = this.startNodeAt(startLoc);
              newNode.object = node, newNode.property = this.jsxParseIdentifier(), node = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node;
          }
          jsxParseAttributeValue() {
            let node;
            switch (this.state.type) {
              case 5:
                return node = this.startNode(), this.setContext(types2.brace), this.next(), node = this.jsxParseExpressionContainer(node, types2.j_oTag), "JSXEmptyExpression" === node.expression.type && this.raise(JsxErrors.AttributeIsEmpty, { at: node }), node;
              case 140:
              case 131:
                return this.parseExprAtom();
              default:
                throw this.raise(JsxErrors.UnsupportedJsxValue, { at: this.state.startLoc });
            }
          }
          jsxParseEmptyExpression() {
            const node = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(node) {
            return this.next(), node.expression = this.parseExpression(), this.setContext(types2.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(node, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(node, previousContext) {
            if (this.match(8))
              node.expression = this.jsxParseEmptyExpression();
            else {
              const expression = this.parseExpression();
              node.expression = expression;
            }
            return this.setContext(previousContext), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(node, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const node = this.startNode();
            return this.match(5) ? (this.setContext(types2.brace), this.next(), this.expect(21), node.argument = this.parseMaybeAssignAllowIn(), this.setContext(types2.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(node, "JSXSpreadAttribute")) : (node.name = this.jsxParseNamespacedName(), node.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(node, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(startLoc) {
            const node = this.startNodeAt(startLoc);
            return this.eat(141) ? this.finishNode(node, "JSXOpeningFragment") : (node.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(node));
          }
          jsxParseOpeningElementAfterName(node) {
            const attributes = [];
            for (; !this.match(56) && !this.match(141); )
              attributes.push(this.jsxParseAttribute());
            return node.attributes = attributes, node.selfClosing = this.eat(56), this.expect(141), this.finishNode(node, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(startLoc) {
            const node = this.startNodeAt(startLoc);
            return this.eat(141) ? this.finishNode(node, "JSXClosingFragment") : (node.name = this.jsxParseElementName(), this.expect(141), this.finishNode(node, "JSXClosingElement"));
          }
          jsxParseElementAt(startLoc) {
            const node = this.startNodeAt(startLoc), children = [], openingElement = this.jsxParseOpeningElementAt(startLoc);
            let closingElement = null;
            if (!openingElement.selfClosing) {
              contents:
                for (; ; )
                  switch (this.state.type) {
                    case 140:
                      if (startLoc = this.state.startLoc, this.next(), this.eat(56)) {
                        closingElement = this.jsxParseClosingElementAt(startLoc);
                        break contents;
                      }
                      children.push(this.jsxParseElementAt(startLoc));
                      break;
                    case 139:
                      children.push(this.parseExprAtom());
                      break;
                    case 5: {
                      const node2 = this.startNode();
                      this.setContext(types2.brace), this.next(), this.match(21) ? children.push(this.jsxParseSpreadChild(node2)) : children.push(this.jsxParseExpressionContainer(node2, types2.j_expr));
                      break;
                    }
                    default:
                      this.unexpected();
                  }
              isFragment(openingElement) && !isFragment(closingElement) && null !== closingElement ? this.raise(JsxErrors.MissingClosingTagFragment, { at: closingElement }) : !isFragment(openingElement) && isFragment(closingElement) ? this.raise(JsxErrors.MissingClosingTagElement, { at: closingElement, openingTagName: getQualifiedJSXName(openingElement.name) }) : isFragment(openingElement) || isFragment(closingElement) || getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(JsxErrors.MissingClosingTagElement, { at: closingElement, openingTagName: getQualifiedJSXName(openingElement.name) });
            }
            if (isFragment(openingElement) ? (node.openingFragment = openingElement, node.closingFragment = closingElement) : (node.openingElement = openingElement, node.closingElement = closingElement), node.children = children, this.match(47))
              throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
            return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
          }
          jsxParseElement() {
            const startLoc = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(startLoc);
          }
          setContext(newContext) {
            const { context } = this.state;
            context[context.length - 1] = newContext;
          }
          parseExprAtom(refExpressionErrors) {
            return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(refExpressionErrors);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(code) {
            const context = this.curContext();
            if (context !== types2.j_expr) {
              if (context === types2.j_oTag || context === types2.j_cTag) {
                if (isIdentifierStart2(code))
                  return void this.jsxReadWord();
                if (62 === code)
                  return ++this.state.pos, void this.finishToken(141);
                if ((34 === code || 39 === code) && context === types2.j_oTag)
                  return void this.jsxReadString(code);
              }
              if (60 === code && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1))
                return ++this.state.pos, void this.finishToken(140);
              super.getTokenFromCode(code);
            } else
              this.jsxReadToken();
          }
          updateContext(prevType) {
            const { context, type } = this.state;
            if (56 === type && 140 === prevType)
              context.splice(-2, 2, types2.j_cTag), this.state.canStartJSXElement = false;
            else if (140 === type)
              context.push(types2.j_oTag);
            else if (141 === type) {
              const out = context[context.length - 1];
              out === types2.j_oTag && 56 === prevType || out === types2.j_cTag ? (context.pop(), this.state.canStartJSXElement = context[context.length - 1] === types2.j_expr) : (this.setContext(types2.j_expr), this.state.canStartJSXElement = true);
            } else
              this.state.canStartJSXElement = tokenBeforeExprs[type];
          }
        }, flow: (superClass) => class extends superClass {
          constructor(...args) {
            super(...args), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return FlowScopeHandler;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(type, val) {
            131 !== type && 13 !== type && 28 !== type && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(type, val);
          }
          addComment(comment) {
            if (void 0 === this.flowPragma) {
              const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
              if (matches)
                if ("flow" === matches[1])
                  this.flowPragma = "flow";
                else {
                  if ("noflow" !== matches[1])
                    throw new Error("Unexpected flow pragma");
                  this.flowPragma = "noflow";
                }
              else
                ;
            }
            super.addComment(comment);
          }
          flowParseTypeInitialiser(tok) {
            const oldInType = this.state.inType;
            this.state.inType = true, this.expect(tok || 14);
            const type = this.flowParseType();
            return this.state.inType = oldInType, type;
          }
          flowParsePredicate() {
            const node = this.startNode(), moduloLoc = this.state.startLoc;
            return this.next(), this.expectContextual(108), this.state.lastTokStart > moduloLoc.index + 1 && this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, { at: moduloLoc }), this.eat(10) ? (node.value = super.parseExpression(), this.expect(11), this.finishNode(node, "DeclaredPredicate")) : this.finishNode(node, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const oldInType = this.state.inType;
            this.state.inType = true, this.expect(14);
            let type = null, predicate = null;
            return this.match(54) ? (this.state.inType = oldInType, predicate = this.flowParsePredicate()) : (type = this.flowParseType(), this.state.inType = oldInType, this.match(54) && (predicate = this.flowParsePredicate())), [type, predicate];
          }
          flowParseDeclareClass(node) {
            return this.next(), this.flowParseInterfaceish(node, true), this.finishNode(node, "DeclareClass");
          }
          flowParseDeclareFunction(node) {
            this.next();
            const id = node.id = this.parseIdentifier(), typeNode = this.startNode(), typeContainer = this.startNode();
            this.match(47) ? typeNode.typeParameters = this.flowParseTypeParameterDeclaration() : typeNode.typeParameters = null, this.expect(10);
            const tmp = this.flowParseFunctionTypeParams();
            return typeNode.params = tmp.params, typeNode.rest = tmp.rest, typeNode.this = tmp._this, this.expect(11), [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"), id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"), this.resetEndLocation(id), this.semicolon(), this.scope.declareName(node.id.name, 2048, node.id.loc.start), this.finishNode(node, "DeclareFunction");
          }
          flowParseDeclare(node, insideModule) {
            return this.match(80) ? this.flowParseDeclareClass(node) : this.match(68) ? this.flowParseDeclareFunction(node) : this.match(74) ? this.flowParseDeclareVariable(node) : this.eatContextual(125) ? this.match(16) ? this.flowParseDeclareModuleExports(node) : (insideModule && this.raise(FlowErrors.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(node)) : this.isContextual(128) ? this.flowParseDeclareTypeAlias(node) : this.isContextual(129) ? this.flowParseDeclareOpaqueType(node) : this.isContextual(127) ? this.flowParseDeclareInterface(node) : this.match(82) ? this.flowParseDeclareExportDeclaration(node, insideModule) : void this.unexpected();
          }
          flowParseDeclareVariable(node) {
            return this.next(), node.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(node.id.name, 5, node.id.loc.start), this.semicolon(), this.finishNode(node, "DeclareVariable");
          }
          flowParseDeclareModule(node) {
            this.scope.enter(0), this.match(131) ? node.id = super.parseExprAtom() : node.id = this.parseIdentifier();
            const bodyNode = node.body = this.startNode(), body = bodyNode.body = [];
            for (this.expect(5); !this.match(8); ) {
              let bodyNode2 = this.startNode();
              this.match(83) ? (this.next(), this.isContextual(128) || this.match(87) || this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(bodyNode2)) : (this.expectContextual(123, FlowErrors.UnsupportedStatementInDeclareModule), bodyNode2 = this.flowParseDeclare(bodyNode2, true)), body.push(bodyNode2);
            }
            this.scope.exit(), this.expect(8), this.finishNode(bodyNode, "BlockStatement");
            let kind = null, hasModuleExport = false;
            return body.forEach((bodyElement) => {
              !function(bodyElement2) {
                return "DeclareExportAllDeclaration" === bodyElement2.type || "DeclareExportDeclaration" === bodyElement2.type && (!bodyElement2.declaration || "TypeAlias" !== bodyElement2.declaration.type && "InterfaceDeclaration" !== bodyElement2.declaration.type);
              }(bodyElement) ? "DeclareModuleExports" === bodyElement.type && (hasModuleExport && this.raise(FlowErrors.DuplicateDeclareModuleExports, { at: bodyElement }), "ES" === kind && this.raise(FlowErrors.AmbiguousDeclareModuleKind, { at: bodyElement }), kind = "CommonJS", hasModuleExport = true) : ("CommonJS" === kind && this.raise(FlowErrors.AmbiguousDeclareModuleKind, { at: bodyElement }), kind = "ES");
            }), node.kind = kind || "CommonJS", this.finishNode(node, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(node, insideModule) {
            if (this.expect(82), this.eat(65))
              return this.match(68) || this.match(80) ? node.declaration = this.flowParseDeclare(this.startNode()) : (node.declaration = this.flowParseType(), this.semicolon()), node.default = true, this.finishNode(node, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: label, suggestion: exportSuggestions[label] });
            }
            return this.match(74) || this.match(68) || this.match(80) || this.isContextual(129) ? (node.declaration = this.flowParseDeclare(this.startNode()), node.default = false, this.finishNode(node, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129) ? ("ExportNamedDeclaration" === (node = this.parseExport(node, null)).type && (node.type = "ExportDeclaration", node.default = false, delete node.exportKind), node.type = "Declare" + node.type, node) : void this.unexpected();
          }
          flowParseDeclareModuleExports(node) {
            return this.next(), this.expectContextual(109), node.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(node, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(node) {
            this.next();
            const finished = this.flowParseTypeAlias(node);
            return finished.type = "DeclareTypeAlias", finished;
          }
          flowParseDeclareOpaqueType(node) {
            this.next();
            const finished = this.flowParseOpaqueType(node, true);
            return finished.type = "DeclareOpaqueType", finished;
          }
          flowParseDeclareInterface(node) {
            return this.next(), this.flowParseInterfaceish(node, false), this.finishNode(node, "DeclareInterface");
          }
          flowParseInterfaceish(node, isClass) {
            if (node.id = this.flowParseRestrictedIdentifier(!isClass, true), this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.extends = [], this.eat(81))
              do {
                node.extends.push(this.flowParseInterfaceExtends());
              } while (!isClass && this.eat(12));
            if (isClass) {
              if (node.implements = [], node.mixins = [], this.eatContextual(115))
                do {
                  node.mixins.push(this.flowParseInterfaceExtends());
                } while (this.eat(12));
              if (this.eatContextual(111))
                do {
                  node.implements.push(this.flowParseInterfaceExtends());
                } while (this.eat(12));
            }
            node.body = this.flowParseObjectType({ allowStatic: isClass, allowExact: false, allowSpread: false, allowProto: isClass, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            const node = this.startNode();
            return node.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, this.finishNode(node, "InterfaceExtends");
          }
          flowParseInterface(node) {
            return this.flowParseInterfaceish(node, false), this.finishNode(node, "InterfaceDeclaration");
          }
          checkNotUnderscore(word) {
            "_" === word && this.raise(FlowErrors.UnexpectedReservedUnderscore, { at: this.state.startLoc });
          }
          checkReservedType(word, startLoc, declaration) {
            reservedTypes.has(word) && this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, { at: startLoc, reservedType: word });
          }
          flowParseRestrictedIdentifier(liberal, declaration) {
            return this.checkReservedType(this.state.value, this.state.startLoc, declaration), this.parseIdentifier(liberal);
          }
          flowParseTypeAlias(node) {
            return node.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(node.id.name, 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(node, "TypeAlias");
          }
          flowParseOpaqueType(node, declare) {
            return this.expectContextual(128), node.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(node.id.name, 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.supertype = null, this.match(14) && (node.supertype = this.flowParseTypeInitialiser(14)), node.impltype = null, declare || (node.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(node, "OpaqueType");
          }
          flowParseTypeParameter(requireDefault = false) {
            const nodeStartLoc = this.state.startLoc, node = this.startNode(), variance = this.flowParseVariance(), ident = this.flowParseTypeAnnotatableIdentifier();
            return node.name = ident.name, node.variance = variance, node.bound = ident.typeAnnotation, this.match(29) ? (this.eat(29), node.default = this.flowParseType()) : requireDefault && this.raise(FlowErrors.MissingTypeParamDefault, { at: nodeStartLoc }), this.finishNode(node, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const oldInType = this.state.inType, node = this.startNode();
            node.params = [], this.state.inType = true, this.match(47) || this.match(140) ? this.next() : this.unexpected();
            let defaultRequired = false;
            do {
              const typeParameter = this.flowParseTypeParameter(defaultRequired);
              node.params.push(typeParameter), typeParameter.default && (defaultRequired = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const node = this.startNode(), oldInType = this.state.inType;
            node.params = [], this.state.inType = true, this.expect(47);
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(48); )
              node.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = oldNoAnonFunctionType, this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const node = this.startNode(), oldInType = this.state.inType;
            for (node.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
              node.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const node = this.startNode();
            if (this.expectContextual(127), node.extends = [], this.eat(81))
              do {
                node.extends.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            return node.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(node, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(node, isStatic, variance) {
            return node.static = isStatic, 14 === this.lookahead().type ? (node.id = this.flowParseObjectPropertyKey(), node.key = this.flowParseTypeInitialiser()) : (node.id = null, node.key = this.flowParseType()), this.expect(3), node.value = this.flowParseTypeInitialiser(), node.variance = variance, this.finishNode(node, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(node, isStatic) {
            return node.static = isStatic, node.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (node.method = true, node.optional = false, node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start))) : (node.method = false, this.eat(17) && (node.optional = true), node.value = this.flowParseTypeInitialiser()), this.finishNode(node, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(node) {
            for (node.params = [], node.rest = null, node.typeParameters = null, node.this = null, this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (node.this = this.flowParseFunctionTypeParam(true), node.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              node.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (node.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), node.returnType = this.flowParseTypeInitialiser(), this.finishNode(node, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(node, isStatic) {
            const valueNode = this.startNode();
            return node.static = isStatic, node.value = this.flowParseObjectTypeMethodish(valueNode), this.finishNode(node, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic, allowExact, allowSpread, allowProto, allowInexact }) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const nodeStart = this.startNode();
            let endDelim, exact;
            nodeStart.callProperties = [], nodeStart.properties = [], nodeStart.indexers = [], nodeStart.internalSlots = [];
            let inexact = false;
            for (allowExact && this.match(6) ? (this.expect(6), endDelim = 9, exact = true) : (this.expect(5), endDelim = 8, exact = false), nodeStart.exact = exact; !this.match(endDelim); ) {
              let isStatic = false, protoStartLoc = null, inexactStartLoc = null;
              const node = this.startNode();
              if (allowProto && this.isContextual(116)) {
                const lookahead2 = this.lookahead();
                14 !== lookahead2.type && 17 !== lookahead2.type && (this.next(), protoStartLoc = this.state.startLoc, allowStatic = false);
              }
              if (allowStatic && this.isContextual(104)) {
                const lookahead2 = this.lookahead();
                14 !== lookahead2.type && 17 !== lookahead2.type && (this.next(), isStatic = true);
              }
              const variance = this.flowParseVariance();
              if (this.eat(0))
                null != protoStartLoc && this.unexpected(protoStartLoc), this.eat(0) ? (variance && this.unexpected(variance.loc.start), nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic))) : nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              else if (this.match(10) || this.match(47))
                null != protoStartLoc && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
              else {
                let kind = "init";
                if (this.isContextual(98) || this.isContextual(103)) {
                  tokenIsLiteralPropertyName(this.lookahead().type) && (kind = this.state.value, this.next());
                }
                const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, null != allowInexact ? allowInexact : !exact);
                null === propOrInexact ? (inexact = true, inexactStartLoc = this.state.lastTokStartLoc) : nodeStart.properties.push(propOrInexact);
              }
              this.flowObjectTypeSemicolon(), !inexactStartLoc || this.match(8) || this.match(9) || this.raise(FlowErrors.UnexpectedExplicitInexactInObject, { at: inexactStartLoc });
            }
            this.expect(endDelim), allowSpread && (nodeStart.inexact = inexact);
            const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
            return this.state.inType = oldInType, out;
          }
          flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
            if (this.eat(21)) {
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (allowSpread ? allowInexact || this.raise(FlowErrors.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(FlowErrors.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), variance && this.raise(FlowErrors.InexactVariance, { at: variance }), null) : (allowSpread || this.raise(FlowErrors.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), null != protoStartLoc && this.unexpected(protoStartLoc), variance && this.raise(FlowErrors.SpreadVariance, { at: variance }), node.argument = this.flowParseType(), this.finishNode(node, "ObjectTypeSpreadProperty"));
            }
            {
              node.key = this.flowParseObjectPropertyKey(), node.static = isStatic, node.proto = null != protoStartLoc, node.kind = kind;
              let optional = false;
              return this.match(47) || this.match(10) ? (node.method = true, null != protoStartLoc && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start)), "get" !== kind && "set" !== kind || this.flowCheckGetterSetterParams(node), !allowSpread && "constructor" === node.key.name && node.value.this && this.raise(FlowErrors.ThisParamBannedInConstructor, { at: node.value.this })) : ("init" !== kind && this.unexpected(), node.method = false, this.eat(17) && (optional = true), node.value = this.flowParseTypeInitialiser(), node.variance = variance), node.optional = optional, this.finishNode(node, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(property) {
            const paramCount = "get" === property.kind ? 0 : 1, length = property.value.params.length + (property.value.rest ? 1 : 0);
            property.value.this && this.raise("get" === property.kind ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, { at: property.value.this }), length !== paramCount && this.raise("get" === property.kind ? Errors.BadGetterArity : Errors.BadSetterArity, { at: property }), "set" === property.kind && property.value.rest && this.raise(Errors.BadSetterRestParameter, { at: property });
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(startLoc, id) {
            null != startLoc || (startLoc = this.state.startLoc);
            let node = id || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              const node2 = this.startNodeAt(startLoc);
              node2.qualification = node, node2.id = this.flowParseRestrictedIdentifier(true), node = this.finishNode(node2, "QualifiedTypeIdentifier");
            }
            return node;
          }
          flowParseGenericType(startLoc, id) {
            const node = this.startNodeAt(startLoc);
            return node.typeParameters = null, node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id), this.match(47) && (node.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(node, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const node = this.startNode();
            return this.expect(87), node.argument = this.flowParsePrimaryType(), this.finishNode(node, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const node = this.startNode();
            for (node.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (node.types.push(this.flowParseType()), !this.match(3)); )
              this.expect(12);
            return this.expect(3), this.finishNode(node, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(first) {
            let name = null, optional = false, typeAnnotation = null;
            const node = this.startNode(), lh = this.lookahead(), isThis = 78 === this.state.type;
            return 14 === lh.type || 17 === lh.type ? (isThis && !first && this.raise(FlowErrors.ThisParamMustBeFirst, { at: node }), name = this.parseIdentifier(isThis), this.eat(17) && (optional = true, isThis && this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: node })), typeAnnotation = this.flowParseTypeInitialiser()) : typeAnnotation = this.flowParseType(), node.name = name, node.optional = optional, node.typeAnnotation = typeAnnotation, this.finishNode(node, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(type) {
            const node = this.startNodeAt(type.loc.start);
            return node.name = null, node.optional = false, node.typeAnnotation = type, this.finishNode(node, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(params = []) {
            let rest = null, _this = null;
            for (this.match(78) && (_this = this.flowParseFunctionTypeParam(true), _this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (rest = this.flowParseFunctionTypeParam(false)), { params, rest, _this };
          }
          flowIdentToTypeAnnotation(startLoc, node, id) {
            switch (id.name) {
              case "any":
                return this.finishNode(node, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(node, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(node, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(node, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(node, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(node, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(node, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(id.name), this.flowParseGenericType(startLoc, id);
            }
          }
          flowParsePrimaryType() {
            const startLoc = this.state.startLoc, node = this.startNode();
            let tmp, type, isGroupedType = false;
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, type = this.flowParseTupleType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, type;
              case 47:
                return node.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), tmp = this.flowParseFunctionTypeParams(), node.params = tmp.params, node.rest = tmp.rest, node.this = tmp._this, this.expect(11), this.expect(19), node.returnType = this.flowParseType(), this.finishNode(node, "FunctionTypeAnnotation");
              case 10:
                if (this.next(), !this.match(11) && !this.match(21))
                  if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                    const token = this.lookahead().type;
                    isGroupedType = 17 !== token && 14 !== token;
                  } else
                    isGroupedType = true;
                if (isGroupedType) {
                  if (this.state.noAnonFunctionType = false, type = this.flowParseType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type))
                    return this.expect(11), type;
                  this.eat(12);
                }
                return tmp = type ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]) : this.flowParseFunctionTypeParams(), node.params = tmp.params, node.rest = tmp.rest, node.this = tmp._this, this.expect(11), this.expect(19), node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");
              case 131:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return node.value = this.match(85), this.next(), this.finishNode(node, "BooleanLiteralTypeAnnotation");
              case 53:
                if ("-" === this.state.value) {
                  if (this.next(), this.match(132))
                    return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                  if (this.match(133))
                    return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                  throw this.raise(FlowErrors.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                }
                return void this.unexpected();
              case 132:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 133:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(node, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(node, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(node, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(node, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (tokenIsKeyword(this.state.type)) {
                  const label = tokenLabelName(this.state.type);
                  return this.next(), super.createIdentifier(node, label);
                }
                if (tokenIsIdentifier(this.state.type))
                  return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            const startLoc = this.state.startLoc;
            let type = this.flowParsePrimaryType(), seenOptionalIndexedAccess = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const node = this.startNodeAt(startLoc), optional = this.eat(18);
              seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional, this.expect(0), !optional && this.match(3) ? (node.elementType = type, this.next(), type = this.finishNode(node, "ArrayTypeAnnotation")) : (node.objectType = type, node.indexType = this.flowParseType(), this.expect(3), seenOptionalIndexedAccess ? (node.optional = optional, type = this.finishNode(node, "OptionalIndexedAccessType")) : type = this.finishNode(node, "IndexedAccessType"));
            }
            return type;
          }
          flowParsePrefixType() {
            const node = this.startNode();
            return this.eat(17) ? (node.typeAnnotation = this.flowParsePrefixType(), this.finishNode(node, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const param = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const node = this.startNodeAt(param.loc.start);
              return node.params = [this.reinterpretTypeAsFunctionTypeParam(param)], node.rest = null, node.this = null, node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");
            }
            return param;
          }
          flowParseIntersectionType() {
            const node = this.startNode();
            this.eat(45);
            const type = this.flowParseAnonFunctionWithoutParens();
            for (node.types = [type]; this.eat(45); )
              node.types.push(this.flowParseAnonFunctionWithoutParens());
            return 1 === node.types.length ? type : this.finishNode(node, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const node = this.startNode();
            this.eat(43);
            const type = this.flowParseIntersectionType();
            for (node.types = [type]; this.eat(43); )
              node.types.push(this.flowParseIntersectionType());
            return 1 === node.types.length ? type : this.finishNode(node, "UnionTypeAnnotation");
          }
          flowParseType() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const type = this.flowParseUnionType();
            return this.state.inType = oldInType, type;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (130 === this.state.type && "_" === this.state.value) {
              const startLoc = this.state.startLoc, node = this.parseIdentifier();
              return this.flowParseGenericType(startLoc, node);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const node = this.startNode();
            return node.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(node, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
            const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (ident.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(ident)), ident;
          }
          typeCastToParameter(node) {
            return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
          }
          flowParseVariance() {
            let variance = null;
            return this.match(53) ? (variance = this.startNode(), "+" === this.state.value ? variance.kind = "plus" : variance.kind = "minus", this.next(), this.finishNode(variance, "Variance")) : variance;
          }
          parseFunctionBody(node, allowExpressionBody, isMethod = false) {
            allowExpressionBody ? this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod)) : super.parseFunctionBody(node, false, isMethod);
          }
          parseFunctionBodyAndFinish(node, type, isMethod = false) {
            if (this.match(14)) {
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(node, type, isMethod);
          }
          parseStatementLike(flags) {
            if (this.state.strict && this.isContextual(127)) {
              if (tokenIsKeywordOrIdentifier(this.lookahead().type)) {
                const node = this.startNode();
                return this.next(), this.flowParseInterface(node);
              }
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
              const node = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(node);
            }
            const stmt = super.parseStatementLike(flags);
            return void 0 !== this.flowPragma || this.isValidDirective(stmt) || (this.flowPragma = null), stmt;
          }
          parseExpressionStatement(node, expr, decorators) {
            if ("Identifier" === expr.type) {
              if ("declare" === expr.name) {
                if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                  return this.flowParseDeclare(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                if ("interface" === expr.name)
                  return this.flowParseInterface(node);
                if ("type" === expr.name)
                  return this.flowParseTypeAlias(node);
                if ("opaque" === expr.name)
                  return this.flowParseOpaqueType(node, false);
              }
            }
            return super.parseExpressionStatement(node, expr, decorators);
          }
          shouldParseExportDeclaration() {
            const { type } = this.state;
            return tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && 124 === type ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type } = this.state;
            return tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && 124 === type ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(124)) {
              const node = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(node);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(expr, startLoc, refExpressionErrors) {
            if (!this.match(17))
              return expr;
            if (this.state.maybeInArrowParameters) {
              const nextCh = this.lookaheadCharCode();
              if (44 === nextCh || 61 === nextCh || 58 === nextCh || 41 === nextCh)
                return this.setOptionalParametersError(refExpressionErrors), expr;
            }
            this.expect(17);
            const state = this.state.clone(), originalNoArrowAt = this.state.noArrowAt, node = this.startNodeAt(startLoc);
            let { consequent, failed } = this.tryParseConditionalConsequent(), [valid, invalid] = this.getArrowLikeExpressions(consequent);
            if (failed || invalid.length > 0) {
              const noArrowAt = [...originalNoArrowAt];
              if (invalid.length > 0) {
                this.state = state, this.state.noArrowAt = noArrowAt;
                for (let i = 0; i < invalid.length; i++)
                  noArrowAt.push(invalid[i].start);
                ({ consequent, failed } = this.tryParseConditionalConsequent()), [valid, invalid] = this.getArrowLikeExpressions(consequent);
              }
              failed && valid.length > 1 && this.raise(FlowErrors.AmbiguousConditionalArrow, { at: state.startLoc }), failed && 1 === valid.length && (this.state = state, noArrowAt.push(valid[0].start), this.state.noArrowAt = noArrowAt, { consequent, failed } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(consequent, true), this.state.noArrowAt = originalNoArrowAt, this.expect(14), node.test = expr, node.consequent = consequent, node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(node, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const consequent = this.parseMaybeAssignAllowIn(), failed = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent, failed };
          }
          getArrowLikeExpressions(node, disallowInvalid) {
            const stack = [node], arrows = [];
            for (; 0 !== stack.length; ) {
              const node2 = stack.pop();
              "ArrowFunctionExpression" === node2.type ? (node2.typeParameters || !node2.returnType ? this.finishArrowValidation(node2) : arrows.push(node2), stack.push(node2.body)) : "ConditionalExpression" === node2.type && (stack.push(node2.consequent), stack.push(node2.alternate));
            }
            return disallowInvalid ? (arrows.forEach((node2) => this.finishArrowValidation(node2)), [arrows, []]) : function(list, test) {
              const list1 = [], list2 = [];
              for (let i = 0; i < list.length; i++)
                (test(list[i], i, list) ? list1 : list2).push(list[i]);
              return [list1, list2];
            }(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
          }
          finishArrowValidation(node) {
            var _node$extra;
            this.toAssignableList(node.params, null == (_node$extra = node.extra) ? void 0 : _node$extra.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(node, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(node, parse5) {
            let result;
            return -1 !== this.state.noArrowParamsConversionAt.indexOf(node.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), result = parse5(), this.state.noArrowParamsConversionAt.pop()) : result = parse5(), result;
          }
          parseParenItem(node, startLoc) {
            if (node = super.parseParenItem(node, startLoc), this.eat(17) && (node.optional = true, this.resetEndLocation(node)), this.match(14)) {
              const typeCastNode = this.startNodeAt(startLoc);
              return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(typeCastNode, "TypeCastExpression");
            }
            return node;
          }
          assertModuleNodeAllowed(node) {
            "ImportDeclaration" === node.type && ("type" === node.importKind || "typeof" === node.importKind) || "ExportNamedDeclaration" === node.type && "type" === node.exportKind || "ExportAllDeclaration" === node.type && "type" === node.exportKind || super.assertModuleNodeAllowed(node);
          }
          parseExportDeclaration(node) {
            if (this.isContextual(128)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.match(5) ? (node.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(node), null) : this.flowParseTypeAlias(declarationNode);
            }
            if (this.isContextual(129)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseOpaqueType(declarationNode, false);
            }
            if (this.isContextual(127)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseInterface(declarationNode);
            }
            if (this.shouldParseEnums() && this.isContextual(124)) {
              node.exportKind = "value";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(declarationNode);
            }
            return super.parseExportDeclaration(node);
          }
          eatExportStar(node) {
            return !!super.eatExportStar(node) || !(!this.isContextual(128) || 55 !== this.lookahead().type) && (node.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(node) {
            const { startLoc } = this.state, hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
            return hasNamespace && "type" === node.exportKind && this.unexpected(startLoc), hasNamespace;
          }
          parseClassId(node, isStatement, optionalId) {
            super.parseClassId(node, isStatement, optionalId), this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(classBody, member, state) {
            const { startLoc } = this.state;
            if (this.isContextual(123)) {
              if (super.parseClassMemberFromModifier(classBody, member))
                return;
              member.declare = true;
            }
            super.parseClassMember(classBody, member, state), member.declare && ("ClassProperty" !== member.type && "ClassPrivateProperty" !== member.type && "PropertyDefinition" !== member.type ? this.raise(FlowErrors.DeclareClassElement, { at: startLoc }) : member.value && this.raise(FlowErrors.DeclareClassFieldInitializer, { at: member.value }));
          }
          isIterator(word) {
            return "iterator" === word || "asyncIterator" === word;
          }
          readIterator() {
            const word = super.readWord1(), fullWord = "@@" + word;
            this.isIterator(word) && this.state.inType || this.raise(Errors.InvalidIdentifier, { at: this.state.curPosition(), identifierName: fullWord }), this.finishToken(130, fullWord);
          }
          getTokenFromCode(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            123 === code && 124 === next ? this.finishOp(6, 2) : !this.state.inType || 62 !== code && 60 !== code ? this.state.inType && 63 === code ? 46 === next ? this.finishOp(18, 2) : this.finishOp(17, 1) : !function(current2, next2, next22) {
              return 64 === current2 && 64 === next2 && isIdentifierStart2(next22);
            }(code, next, this.input.charCodeAt(this.state.pos + 2)) ? super.getTokenFromCode(code) : (this.state.pos += 2, this.readIterator()) : this.finishOp(62 === code ? 48 : 47, 1);
          }
          isAssignable(node, isBinding) {
            return "TypeCastExpression" === node.type ? this.isAssignable(node.expression, isBinding) : super.isAssignable(node, isBinding);
          }
          toAssignable(node, isLHS = false) {
            isLHS || "AssignmentExpression" !== node.type || "TypeCastExpression" !== node.left.type || (node.left = this.typeCastToParameter(node.left)), super.toAssignable(node, isLHS);
          }
          toAssignableList(exprList, trailingCommaLoc, isLHS) {
            for (let i = 0; i < exprList.length; i++) {
              const expr = exprList[i];
              "TypeCastExpression" === (null == expr ? void 0 : expr.type) && (exprList[i] = this.typeCastToParameter(expr));
            }
            super.toAssignableList(exprList, trailingCommaLoc, isLHS);
          }
          toReferencedList(exprList, isParenthesizedExpr) {
            for (let i = 0; i < exprList.length; i++) {
              var _expr$extra;
              const expr = exprList[i];
              !expr || "TypeCastExpression" !== expr.type || null != (_expr$extra = expr.extra) && _expr$extra.parenthesized || !(exprList.length > 1) && isParenthesizedExpr || this.raise(FlowErrors.TypeCastInPattern, { at: expr.typeAnnotation });
            }
            return exprList;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
            return canBePattern && !this.state.maybeInArrowParameters && this.toReferencedList(node.elements), node;
          }
          isValidLVal(type, isParenthesized, binding) {
            return "TypeCastExpression" === type || super.isValidLVal(type, isParenthesized, binding);
          }
          parseClassProperty(node) {
            return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(node);
          }
          parseClassPrivateProperty(node) {
            return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(node);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(method) {
            return !this.match(14) && super.isNonstaticConstructor(method);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            if (method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper), method.params && isConstructor) {
              const params = method.params;
              params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });
            } else if ("MethodDefinition" === method.type && isConstructor && method.value.params) {
              const params = method.value.params;
              params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });
            }
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          parseClassSuper(node) {
            if (super.parseClassSuper(node), node.superClass && this.match(47) && (node.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
              this.next();
              const implemented = node.implements = [];
              do {
                const node2 = this.startNode();
                node2.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? node2.typeParameters = this.flowParseTypeParameterInstantiation() : node2.typeParameters = null, implemented.push(this.finishNode(node2, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(method) {
            super.checkGetterSetterParams(method);
            const params = this.getObjectOrClassMethodParams(method);
            if (params.length > 0) {
              const param = params[0];
              this.isThisParam(param) && "get" === method.kind ? this.raise(FlowErrors.GetterMayNotHaveThisParam, { at: param }) : this.isThisParam(param) && this.raise(FlowErrors.SetterMayNotHaveThisParam, { at: param });
            }
          }
          parsePropertyNamePrefixOperator(node) {
            node.variance = this.flowParseVariance();
          }
          parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            let typeParameters;
            prop.variance && this.unexpected(prop.variance.loc.start), delete prop.variance, this.match(47) && !isAccessor && (typeParameters = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
            return typeParameters && ((result.value || result).typeParameters = typeParameters), result;
          }
          parseAssignableListItemTypes(param) {
            return this.eat(17) && ("Identifier" !== param.type && this.raise(FlowErrors.PatternIsOptional, { at: param }), this.isThisParam(param) && this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: param }), param.optional = true), this.match(14) ? param.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(param) && this.raise(FlowErrors.ThisParamAnnotationRequired, { at: param }), this.match(29) && this.isThisParam(param) && this.raise(FlowErrors.ThisParamNoDefault, { at: param }), this.resetEndLocation(param), param;
          }
          parseMaybeDefault(startLoc, left) {
            const node = super.parseMaybeDefault(startLoc, left);
            return "AssignmentPattern" === node.type && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(FlowErrors.TypeBeforeInitializer, { at: node.typeAnnotation }), node;
          }
          checkImportReflection(node) {
            super.checkImportReflection(node), node.module && "value" !== node.importKind && this.raise(FlowErrors.ImportReflectionHasImportType, { at: node.specifiers[0].loc.start });
          }
          parseImportSpecifierLocal(node, specifier, type) {
            specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), node.specifiers.push(this.finishImportSpecifier(specifier, type));
          }
          isPotentialImportPhase(isExport) {
            if (super.isPotentialImportPhase(isExport))
              return true;
            if (this.isContextual(128)) {
              if (!isExport)
                return true;
              const ch = this.lookaheadCharCode();
              return 123 === ch || 42 === ch;
            }
            return !isExport && this.isContextual(87);
          }
          applyImportPhase(node, isExport, phase, loc) {
            if (super.applyImportPhase(node, isExport, phase, loc), isExport) {
              if (!phase && this.match(65))
                return;
              node.exportKind = "type" === phase ? phase : "value";
            } else
              "type" === phase && this.match(55) && this.unexpected(), node.importKind = "type" === phase || "typeof" === phase ? phase : "value";
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
            const firstIdent = specifier.imported;
            let specifierTypeKind = null;
            "Identifier" === firstIdent.type && ("type" === firstIdent.name ? specifierTypeKind = "type" : "typeof" === firstIdent.name && (specifierTypeKind = "typeof"));
            let isBinding = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              const as_ident = this.parseIdentifier(true);
              null === specifierTypeKind || tokenIsKeywordOrIdentifier(this.state.type) ? (specifier.imported = firstIdent, specifier.importKind = null, specifier.local = this.parseIdentifier()) : (specifier.imported = as_ident, specifier.importKind = specifierTypeKind, specifier.local = cloneIdentifier(as_ident));
            } else {
              if (null !== specifierTypeKind && tokenIsKeywordOrIdentifier(this.state.type))
                specifier.imported = this.parseIdentifier(true), specifier.importKind = specifierTypeKind;
              else {
                if (importedIsString)
                  throw this.raise(Errors.ImportBindingIsString, { at: specifier, importName: firstIdent.value });
                specifier.imported = firstIdent, specifier.importKind = null;
              }
              this.eatContextual(93) ? specifier.local = this.parseIdentifier() : (isBinding = true, specifier.local = cloneIdentifier(specifier.imported));
            }
            const specifierIsTypeImport = hasTypeImportKind(specifier);
            return isInTypeOnlyImport && specifierIsTypeImport && this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, { at: specifier }), (isInTypeOnlyImport || specifierIsTypeImport) && this.checkReservedType(specifier.local.name, specifier.local.loc.start, true), !isBinding || isInTypeOnlyImport || specifierIsTypeImport || this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true), this.finishImportSpecifier(specifier, "ImportSpecifier");
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseFunctionParams(node, isConstructor) {
            const kind = node.kind;
            "get" !== kind && "set" !== kind && this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(node, isConstructor);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind), this.match(14) && (decl.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(decl.id));
          }
          parseAsyncArrowFromCallExpression(node, call) {
            if (this.match(14)) {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, node.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = oldNoAnonFunctionType;
            }
            return super.parseAsyncArrowFromCallExpression(node, call);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            var _jsx;
            let jsx, state = null;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
              if (state = this.state.clone(), jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !jsx.error)
                return jsx.node;
              const { context } = this.state, currentContext = context[context.length - 1];
              currentContext !== types2.j_oTag && currentContext !== types2.j_expr || context.pop();
            }
            if (null != (_jsx = jsx) && _jsx.error || this.match(47)) {
              var _jsx2, _jsx3;
              let typeParameters;
              state = state || this.state.clone();
              const arrow = this.tryParse((abort) => {
                var _arrowExpression$extr;
                typeParameters = this.flowParseTypeParameterDeclaration();
                const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                  const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                  return this.resetStartLocationFromNode(result, typeParameters), result;
                });
                null != (_arrowExpression$extr = arrowExpression2.extra) && _arrowExpression$extr.parenthesized && abort();
                const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
                return "ArrowFunctionExpression" !== expr.type && abort(), expr.typeParameters = typeParameters, this.resetStartLocationFromNode(expr, typeParameters), arrowExpression2;
              }, state);
              let arrowExpression = null;
              if (arrow.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(arrow.node).type) {
                if (!arrow.error && !arrow.aborted)
                  return arrow.node.async && this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: typeParameters }), arrow.node;
                arrowExpression = arrow.node;
              }
              if (null != (_jsx2 = jsx) && _jsx2.node)
                return this.state = jsx.failState, jsx.node;
              if (arrowExpression)
                return this.state = arrow.failState, arrowExpression;
              if (null != (_jsx3 = jsx) && _jsx3.thrown)
                throw jsx.error;
              if (arrow.thrown)
                throw arrow.error;
              throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, { at: typeParameters });
            }
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          parseArrow(node) {
            if (this.match(14)) {
              const result = this.tryParse(() => {
                const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const typeNode = this.startNode();
                return [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), typeNode;
              });
              if (result.thrown)
                return null;
              result.error && (this.state = result.failState), node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(node);
          }
          shouldParseArrow(params) {
            return this.match(14) || super.shouldParseArrow(params);
          }
          setArrowFunctionParameters(node, params) {
            -1 !== this.state.noArrowParamsConversionAt.indexOf(node.start) ? node.params = params : super.setArrowFunctionParameters(node, params);
          }
          checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
            if (!isArrowFunction || -1 === this.state.noArrowParamsConversionAt.indexOf(node.start)) {
              for (let i = 0; i < node.params.length; i++)
                this.isThisParam(node.params[i]) && i > 0 && this.raise(FlowErrors.ThisParamMustBeFirst, { at: node.params[i] });
              super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
            }
          }
          parseParenAndDistinguishExpression(canBeArrow) {
            return super.parseParenAndDistinguishExpression(canBeArrow && -1 === this.state.noArrowAt.indexOf(this.state.start));
          }
          parseSubscripts(base, startLoc, noCalls) {
            if ("Identifier" === base.type && "async" === base.name && -1 !== this.state.noArrowAt.indexOf(startLoc.index)) {
              this.next();
              const node = this.startNodeAt(startLoc);
              node.callee = base, node.arguments = super.parseCallExpressionArguments(11, false), base = this.finishNode(node, "CallExpression");
            } else if ("Identifier" === base.type && "async" === base.name && this.match(47)) {
              const state = this.state.clone(), arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
              if (!arrow.error && !arrow.aborted)
                return arrow.node;
              const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
              if (result.node && !result.error)
                return result.node;
              if (arrow.node)
                return this.state = arrow.failState, arrow.node;
              if (result.node)
                return this.state = result.failState, result.node;
              throw arrow.error || result.error;
            }
            return super.parseSubscripts(base, startLoc, noCalls);
          }
          parseSubscript(base, startLoc, noCalls, subscriptState) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (subscriptState.optionalChainMember = true, noCalls)
                return subscriptState.stop = true, base;
              this.next();
              const node = this.startNodeAt(startLoc);
              return node.callee = base, node.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), node.arguments = this.parseCallExpressionArguments(11, false), node.optional = true, this.finishCallExpression(node, true);
            }
            if (!noCalls && this.shouldParseTypes() && this.match(47)) {
              const node = this.startNodeAt(startLoc);
              node.callee = base;
              const result = this.tryParse(() => (node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), node.arguments = super.parseCallExpressionArguments(11, false), subscriptState.optionalChainMember && (node.optional = false), this.finishCallExpression(node, subscriptState.optionalChainMember)));
              if (result.node)
                return result.error && (this.state = result.failState), result.node;
            }
            return super.parseSubscript(base, startLoc, noCalls, subscriptState);
          }
          parseNewCallee(node) {
            super.parseNewCallee(node);
            let targs = null;
            this.shouldParseTypes() && this.match(47) && (targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), node.typeArguments = targs;
          }
          parseAsyncArrowWithTypeParameters(startLoc) {
            const node = this.startNodeAt(startLoc);
            if (this.parseFunctionParams(node, false), this.parseArrow(node))
              return super.parseArrowExpression(node, void 0, true);
          }
          readToken_mult_modulo(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (42 === code && 47 === next && this.state.hasFlowComment)
              return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(code);
          }
          readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            124 !== code || 125 !== next ? super.readToken_pipe_amp(code) : this.finishOp(9, 2);
          }
          parseTopLevel(file, program) {
            const fileNode = super.parseTopLevel(file, program);
            return this.state.hasFlowComment && this.raise(FlowErrors.UnterminatedFlowComment, { at: this.state.curPosition() }), fileNode;
          }
          skipBlockComment() {
            if (!this.hasPlugin("flowComments") || !this.skipFlowComment())
              return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            {
              if (this.state.hasFlowComment)
                throw this.raise(FlowErrors.NestedFlowComment, { at: this.state.startLoc });
              this.hasFlowCommentCompletion();
              const commentSkip = this.skipFlowComment();
              commentSkip && (this.state.pos += commentSkip, this.state.hasFlowComment = true);
            }
          }
          skipFlowComment() {
            const { pos } = this.state;
            let shiftToFirstNonWhiteSpace = 2;
            for (; [32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)); )
              shiftToFirstNonWhiteSpace++;
            const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos), ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
            return 58 === ch2 && 58 === ch3 ? shiftToFirstNonWhiteSpace + 2 : "flow-include" === this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) ? shiftToFirstNonWhiteSpace + 12 : 58 === ch2 && 58 !== ch3 && shiftToFirstNonWhiteSpace;
          }
          hasFlowCommentCompletion() {
            if (-1 === this.input.indexOf("*/", this.state.pos))
              throw this.raise(Errors.UnterminatedComment, { at: this.state.curPosition() });
          }
          flowEnumErrorBooleanMemberNotInitialized(loc, { enumName, memberName }) {
            this.raise(FlowErrors.EnumBooleanMemberNotInitialized, { at: loc, memberName, enumName });
          }
          flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
            return this.raise(enumContext.explicitType ? "symbol" === enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType : FlowErrors.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: loc }, enumContext));
          }
          flowEnumErrorNumberMemberNotInitialized(loc, { enumName, memberName }) {
            this.raise(FlowErrors.EnumNumberMemberNotInitialized, { at: loc, enumName, memberName });
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(node, { enumName }) {
            this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, { at: node, enumName });
          }
          flowEnumMemberInit() {
            const startLoc = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 132: {
                const literal2 = this.parseNumericLiteral(this.state.value);
                return endOfInit() ? { type: "number", loc: literal2.loc.start, value: literal2 } : { type: "invalid", loc: startLoc };
              }
              case 131: {
                const literal2 = this.parseStringLiteral(this.state.value);
                return endOfInit() ? { type: "string", loc: literal2.loc.start, value: literal2 } : { type: "invalid", loc: startLoc };
              }
              case 85:
              case 86: {
                const literal2 = this.parseBooleanLiteral(this.match(85));
                return endOfInit() ? { type: "boolean", loc: literal2.loc.start, value: literal2 } : { type: "invalid", loc: startLoc };
              }
              default:
                return { type: "invalid", loc: startLoc };
            }
          }
          flowEnumMemberRaw() {
            const loc = this.state.startLoc;
            return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc } };
          }
          flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
            const { explicitType } = context;
            null !== explicitType && explicitType !== expectedType && this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
          flowEnumMembers({ enumName, explicitType }) {
            const seenNames = /* @__PURE__ */ new Set(), members = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let hasUnknownMembers = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                hasUnknownMembers = true;
                break;
              }
              const memberNode = this.startNode(), { id, init } = this.flowEnumMemberRaw(), memberName = id.name;
              if ("" === memberName)
                continue;
              /^[a-z]/.test(memberName) && this.raise(FlowErrors.EnumInvalidMemberName, { at: id, memberName, suggestion: memberName[0].toUpperCase() + memberName.slice(1), enumName }), seenNames.has(memberName) && this.raise(FlowErrors.EnumDuplicateMemberName, { at: id, memberName, enumName }), seenNames.add(memberName);
              const context = { enumName, explicitType, memberName };
              switch (memberNode.id = id, init.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean"), memberNode.init = init.value, members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number"), memberNode.init = init.value, members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string"), memberNode.init = init.value, members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
                case "none":
                  switch (explicitType) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                      break;
                    default:
                      members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members, hasUnknownMembers };
          }
          flowEnumStringMembers(initializedMembers, defaultedMembers, { enumName }) {
            if (0 === initializedMembers.length)
              return defaultedMembers;
            if (0 === defaultedMembers.length)
              return initializedMembers;
            if (defaultedMembers.length > initializedMembers.length) {
              for (const member of initializedMembers)
                this.flowEnumErrorStringMemberInconsistentlyInitailized(member, { enumName });
              return defaultedMembers;
            }
            for (const member of defaultedMembers)
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, { enumName });
            return initializedMembers;
          }
          flowEnumParseExplicitType({ enumName }) {
            if (!this.eatContextual(101))
              return null;
            if (!tokenIsIdentifier(this.state.type))
              throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName });
            const { value: value2 } = this.state;
            return this.next(), "boolean" !== value2 && "number" !== value2 && "string" !== value2 && "symbol" !== value2 && this.raise(FlowErrors.EnumInvalidExplicitType, { at: this.state.startLoc, enumName, invalidEnumType: value2 }), value2;
          }
          flowEnumBody(node, id) {
            const enumName = id.name, nameLoc = id.loc.start, explicitType = this.flowEnumParseExplicitType({ enumName });
            this.expect(5);
            const { members, hasUnknownMembers } = this.flowEnumMembers({ enumName, explicitType });
            switch (node.hasUnknownMembers = hasUnknownMembers, explicitType) {
              case "boolean":
                return node.explicitType = true, node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
              case "number":
                return node.explicitType = true, node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
              case "string":
                return node.explicitType = true, node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, { enumName }), this.expect(8), this.finishNode(node, "EnumStringBody");
              case "symbol":
                return node.members = members.defaultedMembers, this.expect(8), this.finishNode(node, "EnumSymbolBody");
              default: {
                const empty2 = () => (node.members = [], this.expect(8), this.finishNode(node, "EnumStringBody"));
                node.explicitType = false;
                const boolsLen = members.booleanMembers.length, numsLen = members.numberMembers.length, strsLen = members.stringMembers.length, defaultedLen = members.defaultedMembers.length;
                if (boolsLen || numsLen || strsLen || defaultedLen) {
                  if (boolsLen || numsLen) {
                    if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                      for (const member of members.defaultedMembers)
                        this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, { enumName, memberName: member.id.name });
                      return node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
                    }
                    if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                      for (const member of members.defaultedMembers)
                        this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, { enumName, memberName: member.id.name });
                      return node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
                    }
                    return this.raise(FlowErrors.EnumInconsistentMemberValues, { at: nameLoc, enumName }), empty2();
                  }
                  return node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, { enumName }), this.expect(8), this.finishNode(node, "EnumStringBody");
                }
                return empty2();
              }
            }
          }
          flowParseEnumDeclaration(node) {
            const id = this.parseIdentifier();
            return node.id = id, node.body = this.flowEnumBody(this.startNode(), id), this.finishNode(node, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const next = this.nextTokenStart();
            if (60 === this.input.charCodeAt(next)) {
              const afterNext = this.input.charCodeAt(next + 1);
              return 60 !== afterNext && 61 !== afterNext;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(node) {
            return "TypeCastExpression" === node.type ? node.expression : node;
          }
        }, typescript: (superClass) => class extends superClass {
          constructor(...args) {
            super(...args), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: TSErrors.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: TSErrors.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return TypeScriptScopeHandler;
          }
          tsIsIdentifier() {
            return tokenIsIdentifier(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
            if (!tokenIsIdentifier(this.state.type) && 58 !== this.state.type && 75 !== this.state.type)
              return;
            const modifier = this.state.value;
            if (-1 !== allowedModifiers.indexOf(modifier)) {
              if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks())
                return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                return modifier;
            }
          }
          tsParseModifiers({ allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock, errorTemplate = TSErrors.InvalidModifierOnTypeMember }, modified) {
            const enforceOrder = (loc, modifier, before, after) => {
              modifier === before && modified[after] && this.raise(TSErrors.InvalidModifiersOrder, { at: loc, orderedModifiers: [before, after] });
            }, incompatible = (loc, modifier, mod1, mod2) => {
              (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) && this.raise(TSErrors.IncompatibleModifiers, { at: loc, modifiers: [mod1, mod2] });
            };
            for (; ; ) {
              const { startLoc } = this.state, modifier = this.tsParseModifier(allowedModifiers.concat(null != disallowedModifiers ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
              if (!modifier)
                break;
              tsIsAccessModifier(modifier) ? modified.accessibility ? this.raise(TSErrors.DuplicateAccessibilityModifier, { at: startLoc, modifier }) : (enforceOrder(startLoc, modifier, modifier, "override"), enforceOrder(startLoc, modifier, modifier, "static"), enforceOrder(startLoc, modifier, modifier, "readonly"), modified.accessibility = modifier) : tsIsVarianceAnnotations(modifier) ? (modified[modifier] && this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier }), modified[modifier] = true, enforceOrder(startLoc, modifier, "in", "out")) : (Object.hasOwnProperty.call(modified, modifier) ? this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier }) : (enforceOrder(startLoc, modifier, "static", "readonly"), enforceOrder(startLoc, modifier, "static", "override"), enforceOrder(startLoc, modifier, "override", "readonly"), enforceOrder(startLoc, modifier, "abstract", "override"), incompatible(startLoc, modifier, "declare", "override"), incompatible(startLoc, modifier, "static", "abstract")), modified[modifier] = true), null != disallowedModifiers && disallowedModifiers.includes(modifier) && this.raise(errorTemplate, { at: startLoc, modifier });
            }
          }
          tsIsListTerminator(kind) {
            switch (kind) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(kind, parseElement) {
            const result = [];
            for (; !this.tsIsListTerminator(kind); )
              result.push(parseElement());
            return result;
          }
          tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
            return function(x) {
              if (null == x)
                throw new Error(`Unexpected ${x} value.`);
              return x;
            }(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
          }
          tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
            const result = [];
            let trailingCommaPos = -1;
            for (; !this.tsIsListTerminator(kind); ) {
              trailingCommaPos = -1;
              const element = parseElement();
              if (null == element)
                return;
              if (result.push(element), !this.eat(12)) {
                if (this.tsIsListTerminator(kind))
                  break;
                return void (expectSuccess && this.expect(12));
              }
              trailingCommaPos = this.state.lastTokStart;
            }
            return refTrailingCommaPos && (refTrailingCommaPos.value = trailingCommaPos), result;
          }
          tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
            skipFirstToken || (bracket ? this.expect(0) : this.expect(47));
            const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
            return bracket ? this.expect(3) : this.expect(48), result;
          }
          tsParseImportType() {
            const node = this.startNode();
            return this.expect(83), this.expect(10), this.match(131) || this.raise(TSErrors.UnsupportedImportTypeArgument, { at: this.state.startLoc }), node.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (node.qualifier = this.tsParseEntityName()), this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSImportType");
          }
          tsParseEntityName(allowReservedWords = true) {
            let entity = this.parseIdentifier(allowReservedWords);
            for (; this.eat(16); ) {
              const node = this.startNodeAtNode(entity);
              node.left = entity, node.right = this.parseIdentifier(allowReservedWords), entity = this.finishNode(node, "TSQualifiedName");
            }
            return entity;
          }
          tsParseTypeReference() {
            const node = this.startNode();
            return node.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSTypeReference");
          }
          tsParseThisTypePredicate(lhs) {
            this.next();
            const node = this.startNodeAtNode(lhs);
            return node.parameterName = lhs, node.typeAnnotation = this.tsParseTypeAnnotation(false), node.asserts = false, this.finishNode(node, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const node = this.startNode();
            return this.next(), this.finishNode(node, "TSThisType");
          }
          tsParseTypeQuery() {
            const node = this.startNode();
            return this.expect(87), this.match(83) ? node.exprName = this.tsParseImportType() : node.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSTypeQuery");
          }
          tsParseTypeParameter(parseModifiers) {
            const node = this.startNode();
            return parseModifiers(node), node.name = this.tsParseTypeParameterName(), node.constraint = this.tsEatThenParseType(81), node.default = this.tsEatThenParseType(29), this.finishNode(node, "TSTypeParameter");
          }
          tsTryParseTypeParameters(parseModifiers) {
            if (this.match(47))
              return this.tsParseTypeParameters(parseModifiers);
          }
          tsParseTypeParameters(parseModifiers) {
            const node = this.startNode();
            this.match(47) || this.match(140) ? this.next() : this.unexpected();
            const refTrailingCommaPos = { value: -1 };
            return node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos), 0 === node.params.length && this.raise(TSErrors.EmptyTypeParameters, { at: node }), -1 !== refTrailingCommaPos.value && this.addExtra(node, "trailingComma", refTrailingCommaPos.value), this.finishNode(node, "TSTypeParameterDeclaration");
          }
          tsFillSignature(returnToken, signature) {
            const returnTokenRequired = 19 === returnToken;
            signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), signature.parameters = this.tsParseBindingListForSignature(), (returnTokenRequired || this.match(returnToken)) && (signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken));
          }
          tsParseBindingListForSignature() {
            const list = super.parseBindingList(11, 41, 2);
            for (const pattern of list) {
              const { type } = pattern;
              "AssignmentPattern" !== type && "TSParameterProperty" !== type || this.raise(TSErrors.UnsupportedSignatureParameterKind, { at: pattern, type });
            }
            return list;
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(kind, node) {
            return this.tsFillSignature(14, node), this.tsParseTypeMemberSemicolon(), this.finishNode(node, kind);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!tokenIsIdentifier(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(node) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
              return;
            this.expect(0);
            const id = this.parseIdentifier();
            id.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(id), this.expect(3), node.parameters = [id];
            const type = this.tsTryParseTypeAnnotation();
            return type && (node.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), this.finishNode(node, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(node, readonly) {
            this.eat(17) && (node.optional = true);
            const nodeAny = node;
            if (this.match(10) || this.match(47)) {
              readonly && this.raise(TSErrors.ReadonlyForMethodSignature, { at: node });
              const method = nodeAny;
              method.kind && this.match(47) && this.raise(TSErrors.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, method), this.tsParseTypeMemberSemicolon();
              const paramsKey = "parameters", returnTypeKey = "typeAnnotation";
              if ("get" === method.kind)
                method[paramsKey].length > 0 && (this.raise(Errors.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(method[paramsKey][0]) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
              else if ("set" === method.kind) {
                if (1 !== method[paramsKey].length)
                  this.raise(Errors.BadSetterArity, { at: this.state.curPosition() });
                else {
                  const firstParameter = method[paramsKey][0];
                  this.isThisParam(firstParameter) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), "Identifier" === firstParameter.type && firstParameter.optional && this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), "RestElement" === firstParameter.type && this.raise(TSErrors.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                }
                method[returnTypeKey] && this.raise(TSErrors.SetAccesorCannotHaveReturnType, { at: method[returnTypeKey] });
              } else
                method.kind = "method";
              return this.finishNode(method, "TSMethodSignature");
            }
            {
              const property = nodeAny;
              readonly && (property.readonly = true);
              const type = this.tsTryParseTypeAnnotation();
              return type && (property.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), this.finishNode(property, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const node = this.startNode();
            if (this.match(10) || this.match(47))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
            if (this.match(77)) {
              const id = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", node) : (node.key = this.createIdentifier(id, "new"), this.tsParsePropertyOrMethodSignature(node, false));
            }
            this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, node);
            const idx = this.tsTryParseIndexSignature(node);
            return idx || (super.parsePropertyName(node), node.computed || "Identifier" !== node.key.type || "get" !== node.key.name && "set" !== node.key.name || !this.tsTokenCanFollowModifier() || (node.kind = node.key.name, super.parsePropertyName(node)), this.tsParsePropertyOrMethodSignature(node, !!node.readonly));
          }
          tsParseTypeLiteral() {
            const node = this.startNode();
            return node.members = this.tsParseObjectTypeMembers(), this.finishNode(node, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), members;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
          }
          tsParseMappedTypeParameter() {
            const node = this.startNode();
            return node.name = this.tsParseTypeParameterName(), node.constraint = this.tsExpectThenParseType(58), this.finishNode(node, "TSTypeParameter");
          }
          tsParseMappedType() {
            const node = this.startNode();
            return this.expect(5), this.match(53) ? (node.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (node.readonly = true), this.expect(0), node.typeParameter = this.tsParseMappedTypeParameter(), node.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (node.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (node.optional = true), node.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(node, "TSMappedType");
          }
          tsParseTupleType() {
            const node = this.startNode();
            node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let seenOptionalElement = false, labeledElements = null;
            return node.elementTypes.forEach((elementNode) => {
              const { type } = elementNode;
              !seenOptionalElement || "TSRestType" === type || "TSOptionalType" === type || "TSNamedTupleMember" === type && elementNode.optional || this.raise(TSErrors.OptionalTypeBeforeRequired, { at: elementNode }), seenOptionalElement || (seenOptionalElement = "TSNamedTupleMember" === type && elementNode.optional || "TSOptionalType" === type);
              let checkType = type;
              "TSRestType" === type && (checkType = (elementNode = elementNode.typeAnnotation).type);
              const isLabeled = "TSNamedTupleMember" === checkType;
              null != labeledElements || (labeledElements = isLabeled), labeledElements !== isLabeled && this.raise(TSErrors.MixedLabeledAndUnlabeledElements, { at: elementNode });
            }), this.finishNode(node, "TSTupleType");
          }
          tsParseTupleElementType() {
            const { startLoc } = this.state, rest = this.eat(21);
            let labeled, label, optional, type;
            const chAfterWord = tokenIsKeywordOrIdentifier(this.state.type) ? this.lookaheadCharCode() : null;
            if (58 === chAfterWord)
              labeled = true, optional = false, label = this.parseIdentifier(true), this.expect(14), type = this.tsParseType();
            else if (63 === chAfterWord) {
              optional = true;
              const startLoc2 = this.state.startLoc, wordName = this.state.value, typeOrLabel = this.tsParseNonArrayType();
              58 === this.lookaheadCharCode() ? (labeled = true, label = this.createIdentifier(this.startNodeAt(startLoc2), wordName), this.expect(17), this.expect(14), type = this.tsParseType()) : (labeled = false, type = typeOrLabel, this.expect(17));
            } else
              type = this.tsParseType(), optional = this.eat(17), labeled = this.eat(14);
            if (labeled) {
              let labeledNode;
              label ? (labeledNode = this.startNodeAtNode(label), labeledNode.optional = optional, labeledNode.label = label, labeledNode.elementType = type, this.eat(17) && (labeledNode.optional = true, this.raise(TSErrors.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : (labeledNode = this.startNodeAtNode(type), labeledNode.optional = optional, this.raise(TSErrors.InvalidTupleMemberLabel, { at: type }), labeledNode.label = type, labeledNode.elementType = this.tsParseType()), type = this.finishNode(labeledNode, "TSNamedTupleMember");
            } else if (optional) {
              const optionalTypeNode = this.startNodeAtNode(type);
              optionalTypeNode.typeAnnotation = type, type = this.finishNode(optionalTypeNode, "TSOptionalType");
            }
            if (rest) {
              const restNode = this.startNodeAt(startLoc);
              restNode.typeAnnotation = type, type = this.finishNode(restNode, "TSRestType");
            }
            return type;
          }
          tsParseParenthesizedType() {
            const node = this.startNode();
            return this.expect(10), node.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(node, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(type, abstract) {
            const node = this.startNode();
            return "TSConstructorType" === type && (node.abstract = !!abstract, abstract && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node)), this.finishNode(node, type);
          }
          tsParseLiteralTypeNode() {
            const node = this.startNode();
            switch (this.state.type) {
              case 132:
              case 133:
              case 131:
              case 85:
              case 86:
                node.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(node, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const node = this.startNode();
            return node.literal = super.parseTemplate(false), this.finishNode(node, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const thisKeyword = this.tsParseThisTypeNode();
            return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(thisKeyword) : thisKeyword;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 131:
              case 132:
              case 133:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if ("-" === this.state.value) {
                  const node = this.startNode(), nextToken = this.lookahead();
                  return 132 !== nextToken.type && 133 !== nextToken.type && this.unexpected(), node.literal = this.parseMaybeUnary(), this.finishNode(node, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type } = this.state;
                if (tokenIsIdentifier(type) || 88 === type || 84 === type) {
                  const nodeType = 88 === type ? "TSVoidKeyword" : 84 === type ? "TSNullKeyword" : function(value2) {
                    switch (value2) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  }(this.state.value);
                  if (void 0 !== nodeType && 46 !== this.lookaheadCharCode()) {
                    const node = this.startNode();
                    return this.next(), this.finishNode(node, nodeType);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let type = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); )
              if (this.match(3)) {
                const node = this.startNodeAtNode(type);
                node.elementType = type, this.expect(3), type = this.finishNode(node, "TSArrayType");
              } else {
                const node = this.startNodeAtNode(type);
                node.objectType = type, node.indexType = this.tsParseType(), this.expect(3), type = this.finishNode(node, "TSIndexedAccessType");
              }
            return type;
          }
          tsParseTypeOperator() {
            const node = this.startNode(), operator = this.state.value;
            return this.next(), node.operator = operator, node.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === operator && this.tsCheckTypeAnnotationForReadOnly(node), this.finishNode(node, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(node) {
            switch (node.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(TSErrors.UnexpectedReadonly, { at: node });
            }
          }
          tsParseInferType() {
            const node = this.startNode();
            this.expectContextual(113);
            const typeParameter = this.startNode();
            return typeParameter.name = this.tsParseTypeParameterName(), typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter"), this.finishNode(node, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                return constraint;
            }
          }
          tsParseTypeOperatorOrHigher() {
            var token;
            return (token = this.state.type) >= 119 && token <= 121 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
            const node = this.startNode(), hasLeadingOperator = this.eat(operator), types3 = [];
            do {
              types3.push(parseConstituentType());
            } while (this.eat(operator));
            return 1 !== types3.length || hasLeadingOperator ? (node.types = types3, this.finishNode(node, kind)) : types3[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (tokenIsIdentifier(this.state.type) || this.match(78))
              return this.next(), true;
            if (this.match(5)) {
              const { errors } = this.state, previousErrorCount = errors.length;
              try {
                return this.parseObjectLike(8, true), errors.length === previousErrorCount;
              } catch (_unused) {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              const { errors } = this.state, previousErrorCount = errors.length;
              try {
                return super.parseBindingList(3, 93, 1), errors.length === previousErrorCount;
              } catch (_unused2) {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(11) || this.match(21))
              return true;
            if (this.tsSkipParameterStart()) {
              if (this.match(14) || this.match(12) || this.match(17) || this.match(29))
                return true;
              if (this.match(11) && (this.next(), this.match(19)))
                return true;
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(returnToken) {
            return this.tsInType(() => {
              const t = this.startNode();
              this.expect(returnToken);
              const node = this.startNode(), asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (asserts && this.match(78)) {
                let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                return "TSThisType" === thisTypePredicate.type ? (node.parameterName = thisTypePredicate, node.asserts = true, node.typeAnnotation = null, thisTypePredicate = this.finishNode(node, "TSTypePredicate")) : (this.resetStartLocationFromNode(thisTypePredicate, node), thisTypePredicate.asserts = true), t.typeAnnotation = thisTypePredicate, this.finishNode(t, "TSTypeAnnotation");
              }
              const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!typePredicateVariable)
                return asserts ? (node.parameterName = this.parseIdentifier(), node.asserts = asserts, node.typeAnnotation = null, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t);
              const type = this.tsParseTypeAnnotation(false);
              return node.parameterName = typePredicateVariable, node.typeAnnotation = type, node.asserts = asserts, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14))
              return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14))
              return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const id = this.parseIdentifier();
            if (this.isContextual(114) && !this.hasPrecedingLineBreak())
              return this.next(), id;
          }
          tsParseTypePredicateAsserts() {
            if (107 !== this.state.type)
              return false;
            const containsEsc = this.state.containsEsc;
            return this.next(), !(!tokenIsIdentifier(this.state.type) && !this.match(78)) && (containsEsc && this.raise(Errors.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
          }
          tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
            return this.tsInType(() => {
              eatColon && this.expect(14), t.typeAnnotation = this.tsParseType();
            }), this.finishNode(t, "TSTypeAnnotation");
          }
          tsParseType() {
            assert2(this.state.inType);
            const type = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
              return type;
            const node = this.startNodeAtNode(type);
            return node.checkType = type, node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(node, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(122) && 77 === this.lookahead().type;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedTypeAssertion, { at: this.state.startLoc });
            const node = this.startNode();
            return node.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), node.expression = this.parseMaybeUnary(), this.finishNode(node, "TSTypeAssertion");
          }
          tsParseHeritageClause(token) {
            const originalStartLoc = this.state.startLoc, delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
              const node = this.startNode();
              return node.expression = this.tsParseEntityName(), this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSExpressionWithTypeArguments");
            });
            return delimitedList.length || this.raise(TSErrors.EmptyHeritageClauseType, { at: originalStartLoc, token }), delimitedList;
          }
          tsParseInterfaceDeclaration(node, properties = {}) {
            if (this.hasFollowingLineBreak())
              return null;
            this.expectContextual(127), properties.declare && (node.declare = true), tokenIsIdentifier(this.state.type) ? (node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 130)) : (node.id = null, this.raise(TSErrors.MissingInterfaceName, { at: this.state.startLoc })), node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (node.extends = this.tsParseHeritageClause("extends"));
            const body = this.startNode();
            return body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), node.body = this.finishNode(body, "TSInterfaceBody"), this.finishNode(node, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(node) {
            return node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 2), node.typeAnnotation = this.tsInType(() => {
              if (node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && 16 !== this.lookahead().type) {
                const node2 = this.startNode();
                return this.next(), this.finishNode(node2, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(node, "TSTypeAliasDeclaration");
          }
          tsInNoContext(cb) {
            const oldContext = this.state.context;
            this.state.context = [oldContext[0]];
            try {
              return cb();
            } finally {
              this.state.context = oldContext;
            }
          }
          tsInType(cb) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            try {
              return cb();
            } finally {
              this.state.inType = oldInType;
            }
          }
          tsInDisallowConditionalTypesContext(cb) {
            const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return cb();
            } finally {
              this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
            }
          }
          tsInAllowConditionalTypesContext(cb) {
            const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return cb();
            } finally {
              this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
            }
          }
          tsEatThenParseType(token) {
            if (this.match(token))
              return this.tsNextThenParseType();
          }
          tsExpectThenParseType(token) {
            return this.tsInType(() => (this.expect(token), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const node = this.startNode();
            return node.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (node.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(node, "TSEnumMember");
          }
          tsParseEnumDeclaration(node, properties = {}) {
            return properties.const && (node.const = true), properties.declare && (node.declare = true), this.expectContextual(124), node.id = this.parseIdentifier(), this.checkIdentifier(node.id, node.const ? 8971 : 8459), this.expect(5), node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(node, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const node = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(node, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(node, nested = false) {
            if (node.id = this.parseIdentifier(), nested || this.checkIdentifier(node.id, 1024), this.eat(16)) {
              const inner = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(inner, true), node.body = inner;
            } else
              this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(node, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(node) {
            return this.isContextual(110) ? (node.global = true, node.id = this.parseIdentifier()) : this.match(131) ? node.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(node, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
            node.isExport = isExport || false, node.id = maybeDefaultIdentifier || this.parseIdentifier(), this.checkIdentifier(node.id, 4096), this.expect(29);
            const moduleReference = this.tsParseModuleReference();
            return "type" === node.importKind && "TSExternalModuleReference" !== moduleReference.type && this.raise(TSErrors.ImportAliasHasImportType, { at: moduleReference }), node.moduleReference = moduleReference, this.semicolon(), this.finishNode(node, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(117) && 40 === this.lookaheadCharCode();
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const node = this.startNode();
            return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), node.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(node, "TSExternalModuleReference");
          }
          tsLookAhead(f) {
            const state = this.state.clone(), res = f();
            return this.state = state, res;
          }
          tsTryParseAndCatch(f) {
            const result = this.tryParse((abort) => f() || abort());
            if (!result.aborted && result.node)
              return result.error && (this.state = result.failState), result.node;
          }
          tsTryParse(f) {
            const state = this.state.clone(), result = f();
            if (void 0 !== result && false !== result)
              return result;
            this.state = state;
          }
          tsTryParseDeclare(nany) {
            if (this.isLineTerminator())
              return;
            let kind, startType = this.state.type;
            return this.isContextual(99) && (startType = 74, kind = "let"), this.tsInAmbientContext(() => {
              switch (startType) {
                case 68:
                  return nany.declare = true, super.parseFunctionStatement(nany, false, false);
                case 80:
                  return nany.declare = true, this.parseClass(nany, true, false);
                case 124:
                  return this.tsParseEnumDeclaration(nany, { declare: true });
                case 110:
                  return this.tsParseAmbientExternalModuleDeclaration(nany);
                case 75:
                case 74:
                  return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(nany, { const: true, declare: true })) : (nany.declare = true, this.parseVarStatement(nany, kind || this.state.value, true));
                case 127: {
                  const result = this.tsParseInterfaceDeclaration(nany, { declare: true });
                  if (result)
                    return result;
                }
                default:
                  if (tokenIsIdentifier(startType))
                    return this.tsParseDeclaration(nany, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(node, expr, decorators) {
            switch (expr.name) {
              case "declare": {
                const declaration = this.tsTryParseDeclare(node);
                return declaration && (declaration.declare = true), declaration;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  const mod = node;
                  return mod.global = true, mod.id = expr, mod.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(mod, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(node, expr.name, false, decorators);
            }
          }
          tsParseDeclaration(node, value2, next, decorators) {
            switch (value2) {
              case "abstract":
                if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type)))
                  return this.tsParseAbstractDeclaration(node, decorators);
                break;
              case "module":
                if (this.tsCheckLineTerminator(next)) {
                  if (this.match(131))
                    return this.tsParseAmbientExternalModuleDeclaration(node);
                  if (tokenIsIdentifier(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(node);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                break;
              case "type":
                if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
                  return this.tsParseTypeAliasDeclaration(node);
            }
          }
          tsCheckLineTerminator(next) {
            return next ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(startLoc) {
            if (!this.match(47))
              return;
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const res = this.tsTryParseAndCatch(() => {
              const node = this.startNodeAt(startLoc);
              return node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(node), node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), node;
            });
            return this.state.maybeInArrowParameters = oldMaybeInArrowParameters, res ? super.parseArrowExpression(res, null, true) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
            if (47 === this.reScan_lt())
              return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const node = this.startNode();
            return node.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === node.params.length ? this.raise(TSErrors.EmptyTypeArguments, { at: node }) : this.state.inType || this.curContext() !== types2.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(node, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (token = this.state.type) >= 122 && token <= 128;
            var token;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(flags, decorators) {
            const startLoc = this.state.startLoc, modified = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, modified);
            const accessibility = modified.accessibility, override = modified.override, readonly = modified.readonly;
            4 & flags || !(accessibility || readonly || override) || this.raise(TSErrors.UnexpectedParameterModifier, { at: startLoc });
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left, flags);
            const elt = this.parseMaybeDefault(left.loc.start, left);
            if (accessibility || readonly || override) {
              const pp2 = this.startNodeAt(startLoc);
              return decorators.length && (pp2.decorators = decorators), accessibility && (pp2.accessibility = accessibility), readonly && (pp2.readonly = readonly), override && (pp2.override = override), "Identifier" !== elt.type && "AssignmentPattern" !== elt.type && this.raise(TSErrors.UnsupportedParameterPropertyKind, { at: pp2 }), pp2.parameter = elt, this.finishNode(pp2, "TSParameterProperty");
            }
            return decorators.length && (left.decorators = decorators), elt;
          }
          isSimpleParameter(node) {
            return "TSParameterProperty" === node.type && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
          }
          tsDisallowOptionalPattern(node) {
            for (const param of node.params)
              "Identifier" !== param.type && param.optional && !this.state.isAmbientContext && this.raise(TSErrors.PatternIsOptional, { at: param });
          }
          setArrowFunctionParameters(node, params, trailingCommaLoc) {
            super.setArrowFunctionParameters(node, params, trailingCommaLoc), this.tsDisallowOptionalPattern(node);
          }
          parseFunctionBodyAndFinish(node, type, isMethod = false) {
            this.match(14) && (node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const bodilessType = "FunctionDeclaration" === type ? "TSDeclareFunction" : "ClassMethod" === type || "ClassPrivateMethod" === type ? "TSDeclareMethod" : void 0;
            return bodilessType && !this.match(5) && this.isLineTerminator() ? this.finishNode(node, bodilessType) : "TSDeclareFunction" === bodilessType && this.state.isAmbientContext && (this.raise(TSErrors.DeclareFunctionHasImplementation, { at: node }), node.declare) ? super.parseFunctionBodyAndFinish(node, bodilessType, isMethod) : (this.tsDisallowOptionalPattern(node), super.parseFunctionBodyAndFinish(node, type, isMethod));
          }
          registerFunctionStatementId(node) {
            !node.body && node.id ? this.checkIdentifier(node.id, 1024) : super.registerFunctionStatementId(node);
          }
          tsCheckForInvalidTypeCasts(items) {
            items.forEach((node) => {
              "TSTypeCastExpression" === (null == node ? void 0 : node.type) && this.raise(TSErrors.UnexpectedTypeAnnotation, { at: node.typeAnnotation });
            });
          }
          toReferencedList(exprList, isInParens) {
            return this.tsCheckForInvalidTypeCasts(exprList), exprList;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
            return "ArrayExpression" === node.type && this.tsCheckForInvalidTypeCasts(node.elements), node;
          }
          parseSubscript(base, startLoc, noCalls, state) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              const nonNullExpression = this.startNodeAt(startLoc);
              return nonNullExpression.expression = base, this.finishNode(nonNullExpression, "TSNonNullExpression");
            }
            let isOptionalCall = false;
            if (this.match(18) && 60 === this.lookaheadCharCode()) {
              if (noCalls)
                return state.stop = true, base;
              state.optionalChainMember = isOptionalCall = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let missingParenErrorLoc;
              const result = this.tsTryParseAndCatch(() => {
                if (!noCalls && this.atPossibleAsyncArrow(base)) {
                  const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
                  if (asyncArrowFn)
                    return asyncArrowFn;
                }
                const typeArguments = this.tsParseTypeArgumentsInExpression();
                if (!typeArguments)
                  return;
                if (isOptionalCall && !this.match(10))
                  return void (missingParenErrorLoc = this.state.curPosition());
                if (tokenIsTemplate(this.state.type)) {
                  const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
                  return result2.typeParameters = typeArguments, result2;
                }
                if (!noCalls && this.eat(10)) {
                  const node2 = this.startNodeAt(startLoc);
                  return node2.callee = base, node2.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(node2.arguments), node2.typeParameters = typeArguments, state.optionalChainMember && (node2.optional = isOptionalCall), this.finishCallExpression(node2, state.optionalChainMember);
                }
                const tokenType = this.state.type;
                if (48 === tokenType || 52 === tokenType || 10 !== tokenType && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak())
                  return;
                const node = this.startNodeAt(startLoc);
                return node.expression = base, node.typeParameters = typeArguments, this.finishNode(node, "TSInstantiationExpression");
              });
              if (missingParenErrorLoc && this.unexpected(missingParenErrorLoc, 10), result)
                return "TSInstantiationExpression" === result.type && (this.match(16) || this.match(18) && 40 !== this.lookaheadCharCode()) && this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), result;
            }
            return super.parseSubscript(base, startLoc, noCalls, state);
          }
          parseNewCallee(node) {
            var _callee$extra;
            super.parseNewCallee(node);
            const { callee } = node;
            "TSInstantiationExpression" !== callee.type || null != (_callee$extra = callee.extra) && _callee$extra.parenthesized || (node.typeParameters = callee.typeParameters, node.callee = callee.expression);
          }
          parseExprOp(left, leftStartLoc, minPrec) {
            let isSatisfies;
            if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(118)))) {
              const node = this.startNodeAt(leftStartLoc);
              return node.expression = left, node.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (isSatisfies && this.raise(Errors.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(node, leftStartLoc, minPrec);
            }
            return super.parseExprOp(left, leftStartLoc, minPrec);
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            this.state.isAmbientContext || super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
          checkImportReflection(node) {
            super.checkImportReflection(node), node.module && "value" !== node.importKind && this.raise(TSErrors.ImportReflectionHasImportType, { at: node.specifiers[0].loc.start });
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(isExport) {
            if (super.isPotentialImportPhase(isExport))
              return true;
            if (this.isContextual(128)) {
              const ch = this.lookaheadCharCode();
              return isExport ? 123 === ch || 42 === ch : 61 !== ch;
            }
            return !isExport && this.isContextual(87);
          }
          applyImportPhase(node, isExport, phase, loc) {
            super.applyImportPhase(node, isExport, phase, loc), isExport ? node.exportKind = "type" === phase ? "type" : "value" : node.importKind = "type" === phase || "typeof" === phase ? phase : "value";
          }
          parseImport(node) {
            if (this.match(131))
              return node.importKind = "value", super.parseImport(node);
            let importNode;
            if (tokenIsIdentifier(this.state.type) && 61 === this.lookaheadCharCode())
              return node.importKind = "value", this.tsParseImportEqualsDeclaration(node);
            if (this.isContextual(128)) {
              const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
              if (61 === this.lookaheadCharCode())
                return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
              importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
            } else
              importNode = super.parseImport(node);
            return "type" === importNode.importKind && importNode.specifiers.length > 1 && "ImportDefaultSpecifier" === importNode.specifiers[0].type && this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, { at: importNode }), importNode;
          }
          parseExport(node, decorators) {
            if (this.match(83)) {
              this.next();
              let maybeDefaultIdentifier = null;
              return this.isContextual(128) && this.isPotentialImportPhase(false) ? maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false) : node.importKind = "value", this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);
            }
            if (this.eat(29)) {
              const assign = node;
              return assign.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(assign, "TSExportAssignment");
            }
            if (this.eatContextual(93)) {
              const decl = node;
              return this.expectContextual(126), decl.id = this.parseIdentifier(), this.semicolon(), this.finishNode(decl, "TSNamespaceExportDeclaration");
            }
            return super.parseExport(node, decorators);
          }
          isAbstractClass() {
            return this.isContextual(122) && 80 === this.lookahead().type;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const cls = this.startNode();
              return this.next(), cls.abstract = true, this.parseClass(cls, true, true);
            }
            if (this.match(127)) {
              const result = this.tsParseInterfaceDeclaration(this.startNode());
              if (result)
                return result;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(node, kind, allowMissingInitializer = false) {
            const { isAmbientContext } = this.state, declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
            if (!isAmbientContext)
              return declaration;
            for (const { id, init } of declaration.declarations)
              init && ("const" !== kind || id.typeAnnotation ? this.raise(TSErrors.InitializerNotAllowedInAmbientContext, { at: init }) : isValidAmbientConstInitializer(init, this.hasPlugin("estree")) || this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: init }));
            return declaration;
          }
          parseStatementContent(flags, decorators) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              const node = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(node, { const: true });
            }
            if (this.isContextual(124))
              return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(127)) {
              const result = this.tsParseInterfaceDeclaration(this.startNode());
              if (result)
                return result;
            }
            return super.parseStatementContent(flags, decorators);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(member, modifiers) {
            return modifiers.some((modifier) => tsIsAccessModifier(modifier) ? member.accessibility === modifier : !!member[modifier]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(104) && 123 === this.lookaheadCharCode();
          }
          parseClassMember(classBody, member, state) {
            const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: modifiers, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions }, member);
            const callParseClassMemberWithIsStatic = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(member, modifiers) && this.raise(TSErrors.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(classBody, member)) : this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            };
            member.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
          }
          parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const idx = this.tsTryParseIndexSignature(member);
            if (idx)
              return classBody.body.push(idx), member.abstract && this.raise(TSErrors.IndexSignatureHasAbstract, { at: member }), member.accessibility && this.raise(TSErrors.IndexSignatureHasAccessibility, { at: member, modifier: member.accessibility }), member.declare && this.raise(TSErrors.IndexSignatureHasDeclare, { at: member }), void (member.override && this.raise(TSErrors.IndexSignatureHasOverride, { at: member }));
            !this.state.inAbstractClass && member.abstract && this.raise(TSErrors.NonAbstractClassHasAbstractMethod, { at: member }), member.override && (state.hadSuperClass || this.raise(TSErrors.OverrideNotInSubClass, { at: member })), super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
          parsePostMemberNameModifiers(methodOrProp) {
            this.eat(17) && (methodOrProp.optional = true), methodOrProp.readonly && this.match(10) && this.raise(TSErrors.ClassMethodHasReadonly, { at: methodOrProp }), methodOrProp.declare && this.match(10) && this.raise(TSErrors.ClassMethodHasDeclare, { at: methodOrProp });
          }
          parseExpressionStatement(node, expr, decorators) {
            return ("Identifier" === expr.type ? this.tsParseExpressionStatement(node, expr, decorators) : void 0) || super.parseExpressionStatement(node, expr, decorators);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(expr, startLoc, refExpressionErrors) {
            if (!this.state.maybeInArrowParameters || !this.match(17))
              return super.parseConditional(expr, startLoc, refExpressionErrors);
            const result = this.tryParse(() => super.parseConditional(expr, startLoc));
            return result.node ? (result.error && (this.state = result.failState), result.node) : (result.error && super.setOptionalParametersError(refExpressionErrors, result.error), expr);
          }
          parseParenItem(node, startLoc) {
            if (node = super.parseParenItem(node, startLoc), this.eat(17) && (node.optional = true, this.resetEndLocation(node)), this.match(14)) {
              const typeCastNode = this.startNodeAt(startLoc);
              return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(typeCastNode, "TSTypeCastExpression");
            }
            return node;
          }
          parseExportDeclaration(node) {
            if (!this.state.isAmbientContext && this.isContextual(123))
              return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
            const startLoc = this.state.startLoc, isDeclare = this.eatContextual(123);
            if (isDeclare && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
              throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
            const declaration = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
            return declaration ? (("TSInterfaceDeclaration" === declaration.type || "TSTypeAliasDeclaration" === declaration.type || isDeclare) && (node.exportKind = "type"), isDeclare && (this.resetStartLocation(declaration, startLoc), declaration.declare = true), declaration) : null;
          }
          parseClassId(node, isStatement, optionalId, bindingType) {
            if ((!isStatement || optionalId) && this.isContextual(111))
              return;
            super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            typeParameters && (node.typeParameters = typeParameters);
          }
          parseClassPropertyAnnotation(node) {
            node.optional || (this.eat(35) ? node.definite = true : this.eat(17) && (node.optional = true));
            const type = this.tsTryParseTypeAnnotation();
            type && (node.typeAnnotation = type);
          }
          parseClassProperty(node) {
            if (this.parseClassPropertyAnnotation(node), this.state.isAmbientContext && (!node.readonly || node.typeAnnotation) && this.match(29) && this.raise(TSErrors.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), node.abstract && this.match(29)) {
              const { key } = node;
              this.raise(TSErrors.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: "Identifier" !== key.type || node.computed ? `[${this.input.slice(key.start, key.end)}]` : key.name });
            }
            return super.parseClassProperty(node);
          }
          parseClassPrivateProperty(node) {
            return node.abstract && this.raise(TSErrors.PrivateElementHasAbstract, { at: node }), node.accessibility && this.raise(TSErrors.PrivateElementHasAccessibility, { at: node, modifier: node.accessibility }), this.parseClassPropertyAnnotation(node), super.parseClassPrivateProperty(node);
          }
          parseClassAccessorProperty(node) {
            return this.parseClassPropertyAnnotation(node), node.optional && this.raise(TSErrors.AccessorCannotBeOptional, { at: node }), super.parseClassAccessorProperty(node);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            typeParameters && isConstructor && this.raise(TSErrors.ConstructorHasTypeParameters, { at: typeParameters });
            const { declare = false, kind } = method;
            !declare || "get" !== kind && "set" !== kind || this.raise(TSErrors.DeclareAccessor, { at: method, kind }), typeParameters && (method.typeParameters = typeParameters), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            typeParameters && (method.typeParameters = typeParameters), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          declareClassPrivateMethodInScope(node, kind) {
            "TSDeclareMethod" !== node.type && ("MethodDefinition" !== node.type || node.value.body) && super.declareClassPrivateMethodInScope(node, kind);
          }
          parseClassSuper(node) {
            super.parseClassSuper(node), node.superClass && (this.match(47) || this.match(51)) && (node.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (node.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return typeParameters && (prop.typeParameters = typeParameters), super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
          }
          parseFunctionParams(node, isConstructor) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            typeParameters && (node.typeParameters = typeParameters), super.parseFunctionParams(node, isConstructor);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind), "Identifier" === decl.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (decl.definite = true);
            const type = this.tsTryParseTypeAnnotation();
            type && (decl.id.typeAnnotation = type, this.resetEndLocation(decl.id));
          }
          parseAsyncArrowFromCallExpression(node, call) {
            return this.match(14) && (node.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(node, call);
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
            let state, jsx, typeCast, typeParameters;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
              if (state = this.state.clone(), jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !jsx.error)
                return jsx.node;
              const { context } = this.state, currentContext = context[context.length - 1];
              currentContext !== types2.j_oTag && currentContext !== types2.j_expr || context.pop();
            }
            if (!(null != (_jsx = jsx) && _jsx.error || this.match(47)))
              return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            state && state !== this.state || (state = this.state.clone());
            const arrow = this.tryParse((abort) => {
              var _expr$extra, _typeParameters;
              typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
              const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              return ("ArrowFunctionExpression" !== expr.type || null != (_expr$extra = expr.extra) && _expr$extra.parenthesized) && abort(), 0 !== (null == (_typeParameters = typeParameters) ? void 0 : _typeParameters.params.length) && this.resetStartLocationFromNode(expr, typeParameters), expr.typeParameters = typeParameters, expr;
            }, state);
            if (!arrow.error && !arrow.aborted)
              return typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow.node;
            if (!jsx && (assert2(!this.hasPlugin("jsx")), typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !typeCast.error))
              return typeCast.node;
            if (null != (_jsx2 = jsx) && _jsx2.node)
              return this.state = jsx.failState, jsx.node;
            if (arrow.node)
              return this.state = arrow.failState, typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow.node;
            if (null != (_typeCast = typeCast) && _typeCast.node)
              return this.state = typeCast.failState, typeCast.node;
            throw (null == (_jsx3 = jsx) ? void 0 : _jsx3.error) || arrow.error || (null == (_typeCast2 = typeCast) ? void 0 : _typeCast2.error);
          }
          reportReservedArrowTypeParam(node) {
            var _node$extra;
            1 !== node.params.length || node.params[0].constraint || null != (_node$extra = node.extra) && _node$extra.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(TSErrors.ReservedArrowTypeParam, { at: node });
          }
          parseMaybeUnary(refExpressionErrors, sawUnary) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(refExpressionErrors, sawUnary);
          }
          parseArrow(node) {
            if (this.match(14)) {
              const result = this.tryParse((abort) => {
                const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || abort(), returnType;
              });
              if (result.aborted)
                return;
              result.thrown || (result.error && (this.state = result.failState), node.returnType = result.node);
            }
            return super.parseArrow(node);
          }
          parseAssignableListItemTypes(param, flags) {
            if (!(2 & flags))
              return param;
            this.eat(17) && (param.optional = true);
            const type = this.tsTryParseTypeAnnotation();
            return type && (param.typeAnnotation = type), this.resetEndLocation(param), param;
          }
          isAssignable(node, isBinding) {
            switch (node.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(node.expression, isBinding);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(node, isBinding);
            }
          }
          toAssignable(node, isLHS = false) {
            switch (node.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(node, isLHS);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                isLHS ? this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, { at: node }) : this.raise(TSErrors.UnexpectedTypeCastInParameter, { at: node }), this.toAssignable(node.expression, isLHS);
                break;
              case "AssignmentExpression":
                isLHS || "TSTypeCastExpression" !== node.left.type || (node.left = this.typeCastToParameter(node.left));
              default:
                super.toAssignable(node, isLHS);
            }
          }
          toAssignableParenthesizedExpression(node, isLHS) {
            switch (node.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(node.expression, isLHS);
                break;
              default:
                super.toAssignable(node, isLHS);
            }
          }
          checkToRestConversion(node, allowPattern) {
            switch (node.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(node.expression, false);
                break;
              default:
                super.checkToRestConversion(node, allowPattern);
            }
          }
          isValidLVal(type, isUnparenthesizedInAssign, binding) {
            return object = { TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (64 !== binding || !isUnparenthesizedInAssign) && ["expression", true], TSSatisfiesExpression: (64 !== binding || !isUnparenthesizedInAssign) && ["expression", true], TSTypeAssertion: (64 !== binding || !isUnparenthesizedInAssign) && ["expression", true] }, key = type, Object.hasOwnProperty.call(object, key) && object[key] || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
            var object, key;
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(expr) {
            if (this.match(47) || this.match(51)) {
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const call = super.parseMaybeDecoratorArguments(expr);
                return call.typeParameters = typeArguments, call;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(expr);
          }
          checkCommaAfterRest(close) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close ? (this.next(), false) : super.checkCommaAfterRest(close);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(startLoc, left) {
            const node = super.parseMaybeDefault(startLoc, left);
            return "AssignmentPattern" === node.type && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(TSErrors.TypeAnnotationAfterAssign, { at: node.typeAnnotation }), node;
          }
          getTokenFromCode(code) {
            if (this.state.inType) {
              if (62 === code)
                return void this.finishOp(48, 1);
              if (60 === code)
                return void this.finishOp(47, 1);
            }
            super.getTokenFromCode(code);
          }
          reScan_lt_gt() {
            const { type } = this.state;
            47 === type ? (this.state.pos -= 1, this.readToken_lt()) : 48 === type && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            const { type } = this.state;
            return 51 === type ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : type;
          }
          toAssignableList(exprList, trailingCommaLoc, isLHS) {
            for (let i = 0; i < exprList.length; i++) {
              const expr = exprList[i];
              "TSTypeCastExpression" === (null == expr ? void 0 : expr.type) && (exprList[i] = this.typeCastToParameter(expr));
            }
            super.toAssignableList(exprList, trailingCommaLoc, isLHS);
          }
          typeCastToParameter(node) {
            return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
          }
          shouldParseArrow(params) {
            return this.match(14) ? params.every((expr) => this.isAssignable(expr, true)) : super.shouldParseArrow(params);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(node) {
            if (this.match(47) || this.match(51)) {
              const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              typeArguments && (node.typeParameters = typeArguments);
            }
            return super.jsxParseOpeningElementAfterName(node);
          }
          getGetterSetterExpectedParamCount(method) {
            const baseCount = super.getGetterSetterExpectedParamCount(method), firstParam = this.getObjectOrClassMethodParams(method)[0];
            return firstParam && this.isThisParam(firstParam) ? baseCount + 1 : baseCount;
          }
          parseCatchClauseParam() {
            const param = super.parseCatchClauseParam(), type = this.tsTryParseTypeAnnotation();
            return type && (param.typeAnnotation = type, this.resetEndLocation(param)), param;
          }
          tsInAmbientContext(cb) {
            const oldIsAmbientContext = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
              return cb();
            } finally {
              this.state.isAmbientContext = oldIsAmbientContext;
            }
          }
          parseClass(node, isStatement, optionalId) {
            const oldInAbstractClass = this.state.inAbstractClass;
            this.state.inAbstractClass = !!node.abstract;
            try {
              return super.parseClass(node, isStatement, optionalId);
            } finally {
              this.state.inAbstractClass = oldInAbstractClass;
            }
          }
          tsParseAbstractDeclaration(node, decorators) {
            if (this.match(80))
              return node.abstract = true, this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
            if (this.isContextual(127)) {
              if (!this.hasFollowingLineBreak())
                return node.abstract = true, this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, { at: node }), this.tsParseInterfaceDeclaration(node);
            } else
              this.unexpected(null, 80);
          }
          parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
            const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
            if (method.abstract) {
              if (this.hasPlugin("estree") ? !!method.value.body : !!method.body) {
                const { key } = method;
                this.raise(TSErrors.AbstractMethodHasImplementation, { at: method, methodName: "Identifier" !== key.type || method.computed ? `[${this.input.slice(key.start, key.end)}]` : key.name });
              }
            }
            return method;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
            return !isString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport), this.finishNode(node, "ExportSpecifier")) : (node.exportKind = "value", super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
            return !importedIsString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport), this.finishNode(specifier, "ImportSpecifier")) : (specifier.importKind = "value", super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
            const leftOfAsKey = isImport ? "imported" : "local", rightOfAsKey = isImport ? "local" : "exported";
            let rightOfAs, leftOfAs = node[leftOfAsKey], hasTypeSpecifier = false, canParseAsKeyword = true;
            const loc = leftOfAs.loc.start;
            if (this.isContextual(93)) {
              const firstAs = this.parseIdentifier();
              if (this.isContextual(93)) {
                const secondAs = this.parseIdentifier();
                tokenIsKeywordOrIdentifier(this.state.type) ? (hasTypeSpecifier = true, leftOfAs = firstAs, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName(), canParseAsKeyword = false) : (rightOfAs = secondAs, canParseAsKeyword = false);
              } else
                tokenIsKeywordOrIdentifier(this.state.type) ? (canParseAsKeyword = false, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName()) : (hasTypeSpecifier = true, leftOfAs = firstAs);
            } else
              tokenIsKeywordOrIdentifier(this.state.type) && (hasTypeSpecifier = true, isImport ? (leftOfAs = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true)) : leftOfAs = this.parseModuleExportName());
            hasTypeSpecifier && isInTypeOnlyImportExport && this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, { at: loc }), node[leftOfAsKey] = leftOfAs, node[rightOfAsKey] = rightOfAs;
            node[isImport ? "importKind" : "exportKind"] = hasTypeSpecifier ? "type" : "value", canParseAsKeyword && this.eatContextual(93) && (node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName()), node[rightOfAsKey] || (node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey])), isImport && this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
          }
        }, v8intrinsic: (superClass) => class extends superClass {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const v8IntrinsicStartLoc = this.state.startLoc, node = this.startNode();
              if (this.next(), tokenIsIdentifier(this.state.type)) {
                const name = this.parseIdentifierName(), identifier = this.createIdentifier(node, name);
                if (identifier.type = "V8IntrinsicIdentifier", this.match(10))
                  return identifier;
              }
              this.unexpected(v8IntrinsicStartLoc);
            }
          }
          parseExprAtom(refExpressionErrors) {
            return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
          }
        }, placeholders: (superClass) => class extends superClass {
          parsePlaceholder(expectedNode) {
            if (this.match(142)) {
              const node = this.startNode();
              return this.next(), this.assertNoSpace(), node.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(node, expectedNode);
            }
          }
          finishPlaceholder(node, expectedNode) {
            const isFinished = !(!node.expectedNode || "Placeholder" !== node.type);
            return node.expectedNode = expectedNode, isFinished ? node : this.finishNode(node, "Placeholder");
          }
          getTokenFromCode(code) {
            37 === code && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(142, 2) : super.getTokenFromCode(code);
          }
          parseExprAtom(refExpressionErrors) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
          }
          parseIdentifier(liberal) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            void 0 !== word && super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(type, isParenthesized, binding) {
            return "Placeholder" === type || super.isValidLVal(type, isParenthesized, binding);
          }
          toAssignable(node, isLHS) {
            node && "Placeholder" === node.type && "Expression" === node.expectedNode ? node.expectedNode = "Pattern" : super.toAssignable(node, isLHS);
          }
          chStartsBindingIdentifier(ch, pos) {
            if (super.chStartsBindingIdentifier(ch, pos))
              return true;
            return 142 === this.lookahead().type;
          }
          verifyBreakContinue(node, isBreak) {
            node.label && "Placeholder" === node.label.type || super.verifyBreakContinue(node, isBreak);
          }
          parseExpressionStatement(node, expr) {
            if ("Placeholder" !== expr.type || expr.extra && expr.extra.parenthesized)
              return super.parseExpressionStatement(node, expr);
            if (this.match(14)) {
              const stmt = node;
              return stmt.label = this.finishPlaceholder(expr, "Identifier"), this.next(), stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(stmt, "LabeledStatement");
            }
            return this.semicolon(), node.name = expr.name, this.finishPlaceholder(node, "Statement");
          }
          parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
          }
          parseFunctionId(requireId) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
          }
          parseClass(node, isStatement, optionalId) {
            const type = isStatement ? "ClassDeclaration" : "ClassExpression";
            this.next();
            const oldStrict = this.state.strict, placeholder = this.parsePlaceholder("Identifier");
            if (placeholder) {
              if (!(this.match(81) || this.match(142) || this.match(5))) {
                if (optionalId || !isStatement)
                  return node.id = null, node.body = this.finishPlaceholder(placeholder, "ClassBody"), this.finishNode(node, type);
                throw this.raise(PlaceholderErrors.ClassNameIsRequired, { at: this.state.startLoc });
              }
              node.id = placeholder;
            } else
              this.parseClassId(node, isStatement, optionalId);
            return super.parseClassSuper(node), node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, type);
          }
          parseExport(node, decorators) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder)
              return super.parseExport(node, decorators);
            if (!this.isContextual(97) && !this.match(12))
              return node.specifiers = [], node.source = null, node.declaration = this.finishPlaceholder(placeholder, "Declaration"), this.finishNode(node, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            return specifier.exported = placeholder, node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], super.parseExport(node, decorators);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const next = this.nextTokenStart();
              if (this.isUnparsedContextual(next, "from") && this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(next + 4)))
                return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
            var _specifiers;
            return !(null == (_specifiers = node.specifiers) || !_specifiers.length) || super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
          }
          checkExport(node) {
            const { specifiers } = node;
            null != specifiers && specifiers.length && (node.specifiers = specifiers.filter((node2) => "Placeholder" === node2.exported.type)), super.checkExport(node), node.specifiers = specifiers;
          }
          parseImport(node) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder)
              return super.parseImport(node);
            if (node.specifiers = [], !this.isContextual(97) && !this.match(12))
              return node.source = this.finishPlaceholder(placeholder, "StringLiteral"), this.semicolon(), this.finishNode(node, "ImportDeclaration");
            const specifier = this.startNodeAtNode(placeholder);
            if (specifier.local = placeholder, node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier")), this.eat(12)) {
              this.maybeParseStarImportSpecifier(node) || this.parseNamedImportSpecifiers(node);
            }
            return this.expectContextual(97), node.source = this.parseImportSource(), this.semicolon(), this.finishNode(node, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(PlaceholderErrors.UnexpectedSpace, { at: this.state.lastTokEndLoc });
          }
        } }, mixinPluginNames = Object.keys(mixinPlugins), defaultOptions2 = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
        class ExpressionParser extends LValParser {
          checkProto(prop, isRecord, protoRef, refExpressionErrors) {
            if ("SpreadElement" === prop.type || this.isObjectMethod(prop) || prop.computed || prop.shorthand)
              return;
            const key = prop.key;
            if ("__proto__" === ("Identifier" === key.type ? key.name : key.value)) {
              if (isRecord)
                return void this.raise(Errors.RecordNoProto, { at: key });
              protoRef.used && (refExpressionErrors ? null === refExpressionErrors.doubleProtoLoc && (refExpressionErrors.doubleProtoLoc = key.loc.start) : this.raise(Errors.DuplicateProto, { at: key })), protoRef.used = true;
            }
          }
          shouldExitDescending(expr, potentialArrowAt) {
            return "ArrowFunctionExpression" === expr.type && expr.start === potentialArrowAt;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            const expr = this.parseExpression();
            return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), expr.comments = this.state.comments, expr.errors = this.state.errors, this.options.tokens && (expr.tokens = this.tokens), expr;
          }
          parseExpression(disallowIn, refExpressionErrors) {
            return disallowIn ? this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors)) : this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          parseExpressionBase(refExpressionErrors) {
            const startLoc = this.state.startLoc, expr = this.parseMaybeAssign(refExpressionErrors);
            if (this.match(12)) {
              const node = this.startNodeAt(startLoc);
              for (node.expressions = [expr]; this.eat(12); )
                node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
              return this.toReferencedList(node.expressions), this.finishNode(node, "SequenceExpression");
            }
            return expr;
          }
          parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
            return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
          }
          parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
            return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
          }
          setOptionalParametersError(refExpressionErrors, resultError) {
            var _resultError$loc;
            refExpressionErrors.optionalParametersLoc = null != (_resultError$loc = null == resultError ? void 0 : resultError.loc) ? _resultError$loc : this.state.startLoc;
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            const startLoc = this.state.startLoc;
            if (this.isContextual(106) && this.prodParam.hasYield) {
              let left2 = this.parseYield();
              return afterLeftParse && (left2 = afterLeftParse.call(this, left2, startLoc)), left2;
            }
            let ownExpressionErrors;
            refExpressionErrors ? ownExpressionErrors = false : (refExpressionErrors = new ExpressionErrors(), ownExpressionErrors = true);
            const { type } = this.state;
            (10 === type || tokenIsIdentifier(type)) && (this.state.potentialArrowAt = this.state.start);
            let left = this.parseMaybeConditional(refExpressionErrors);
            if (afterLeftParse && (left = afterLeftParse.call(this, left, startLoc)), (token = this.state.type) >= 29 && token <= 33) {
              const node = this.startNodeAt(startLoc), operator = this.state.value;
              if (node.operator = operator, this.match(29)) {
                this.toAssignable(left, true), node.left = left;
                const startIndex = startLoc.index;
                null != refExpressionErrors.doubleProtoLoc && refExpressionErrors.doubleProtoLoc.index >= startIndex && (refExpressionErrors.doubleProtoLoc = null), null != refExpressionErrors.shorthandAssignLoc && refExpressionErrors.shorthandAssignLoc.index >= startIndex && (refExpressionErrors.shorthandAssignLoc = null), null != refExpressionErrors.privateKeyLoc && refExpressionErrors.privateKeyLoc.index >= startIndex && (this.checkDestructuringPrivate(refExpressionErrors), refExpressionErrors.privateKeyLoc = null);
              } else
                node.left = left;
              return this.next(), node.right = this.parseMaybeAssign(), this.checkLVal(left, { in: this.finishNode(node, "AssignmentExpression") }), node;
            }
            var token;
            return ownExpressionErrors && this.checkExpressionErrors(refExpressionErrors, true), left;
          }
          parseMaybeConditional(refExpressionErrors) {
            const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprOps(refExpressionErrors);
            return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseConditional(expr, startLoc, refExpressionErrors);
          }
          parseConditional(expr, startLoc, refExpressionErrors) {
            if (this.eat(17)) {
              const node = this.startNodeAt(startLoc);
              return node.test = expr, node.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), node.alternate = this.parseMaybeAssign(), this.finishNode(node, "ConditionalExpression");
            }
            return expr;
          }
          parseMaybeUnaryOrPrivate(refExpressionErrors) {
            return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
          }
          parseExprOps(refExpressionErrors) {
            const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
            return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseExprOp(expr, startLoc, -1);
          }
          parseExprOp(left, leftStartLoc, minPrec) {
            if (this.isPrivateName(left)) {
              const value2 = this.getPrivateNameSV(left);
              (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Errors.PrivateInExpectedIn, { at: left, identifierName: value2 }), this.classScope.usePrivateName(value2, left.loc.start);
            }
            const op = this.state.type;
            if ((token = op) >= 39 && token <= 59 && (this.prodParam.hasIn || !this.match(58))) {
              let prec = tokenOperatorPrecedence(op);
              if (prec > minPrec) {
                if (39 === op) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                    return left;
                  this.checkPipelineAtInfixOperator(left, leftStartLoc);
                }
                const node = this.startNodeAt(leftStartLoc);
                node.left = left, node.operator = this.state.value;
                const logical = 41 === op || 42 === op, coalesce = 40 === op;
                if (coalesce && (prec = tokenOperatorPrecedence(42)), this.next(), 39 === op && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && 96 === this.state.type && this.prodParam.hasAwait)
                  throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                node.right = this.parseExprOpRightExpr(op, prec);
                const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression"), nextOp = this.state.type;
                if (coalesce && (41 === nextOp || 42 === nextOp) || logical && 40 === nextOp)
                  throw this.raise(Errors.MixingCoalesceWithLogical, { at: this.state.startLoc });
                return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
              }
            }
            var token;
            return left;
          }
          parseExprOpRightExpr(op, prec) {
            const startLoc = this.state.startLoc;
            if (39 === op)
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => this.parseHackPipeBody());
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(106))
                      throw this.raise(Errors.PipeBodyIsTighter, { at: this.state.startLoc });
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(prec));
              }
            return this.parseExprOpBaseRightExpr(op, prec);
          }
          parseExprOpBaseRightExpr(op, prec) {
            const startLoc = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, 57 === op ? prec - 1 : prec);
          }
          parseHackPipeBody() {
            var _body$extra;
            const { startLoc } = this.state, body = this.parseMaybeAssign();
            return !UnparenthesizedPipeBodyDescriptions.has(body.type) || null != (_body$extra = body.extra) && _body$extra.parenthesized || this.raise(Errors.PipeUnparenthesizedBody, { at: startLoc, type: body.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipeTopicUnused, { at: startLoc }), body;
          }
          checkExponentialAfterUnary(node) {
            this.match(57) && this.raise(Errors.UnexpectedTokenUnaryExponentiation, { at: node.argument });
          }
          parseMaybeUnary(refExpressionErrors, sawUnary) {
            const startLoc = this.state.startLoc, isAwait = this.isContextual(96);
            if (isAwait && this.isAwaitAllowed()) {
              this.next();
              const expr2 = this.parseAwait(startLoc);
              return sawUnary || this.checkExponentialAfterUnary(expr2), expr2;
            }
            const update = this.match(34), node = this.startNode();
            if (token = this.state.type, tokenPrefixes[token]) {
              node.operator = this.state.value, node.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              const isDelete = this.match(89);
              if (this.next(), node.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(refExpressionErrors, true), this.state.strict && isDelete) {
                const arg = node.argument;
                "Identifier" === arg.type ? this.raise(Errors.StrictDelete, { at: node }) : this.hasPropertyAsPrivateName(arg) && this.raise(Errors.DeletePrivateField, { at: node });
              }
              if (!update)
                return sawUnary || this.checkExponentialAfterUnary(node), this.finishNode(node, "UnaryExpression");
            }
            var token;
            const expr = this.parseUpdate(node, update, refExpressionErrors);
            if (isAwait) {
              const { type } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54)) && !this.isAmbiguousAwait())
                return this.raiseOverwrite(Errors.AwaitNotInAsyncContext, { at: startLoc }), this.parseAwait(startLoc);
            }
            return expr;
          }
          parseUpdate(node, update, refExpressionErrors) {
            if (update) {
              const updateExpressionNode = node;
              return this.checkLVal(updateExpressionNode.argument, { in: this.finishNode(updateExpressionNode, "UpdateExpression") }), node;
            }
            const startLoc = this.state.startLoc;
            let expr = this.parseExprSubscripts(refExpressionErrors);
            if (this.checkExpressionErrors(refExpressionErrors, false))
              return expr;
            for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
              const node2 = this.startNodeAt(startLoc);
              node2.operator = this.state.value, node2.prefix = false, node2.argument = expr, this.next(), this.checkLVal(expr, { in: expr = this.finishNode(node2, "UpdateExpression") });
            }
            return expr;
          }
          parseExprSubscripts(refExpressionErrors) {
            const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprAtom(refExpressionErrors);
            return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseSubscripts(expr, startLoc);
          }
          parseSubscripts(base, startLoc, noCalls) {
            const state = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(base), stop: false };
            do {
              base = this.parseSubscript(base, startLoc, noCalls, state), state.maybeAsyncArrow = false;
            } while (!state.stop);
            return base;
          }
          parseSubscript(base, startLoc, noCalls, state) {
            const { type } = this.state;
            if (!noCalls && 15 === type)
              return this.parseBind(base, startLoc, noCalls, state);
            if (tokenIsTemplate(type))
              return this.parseTaggedTemplateExpression(base, startLoc, state);
            let optional = false;
            if (18 === type) {
              if (noCalls && (this.raise(Errors.OptionalChainingNoNew, { at: this.state.startLoc }), 40 === this.lookaheadCharCode()))
                return state.stop = true, base;
              state.optionalChainMember = optional = true, this.next();
            }
            if (!noCalls && this.match(10))
              return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
            {
              const computed = this.eat(0);
              return computed || optional || this.eat(16) ? this.parseMember(base, startLoc, state, computed, optional) : (state.stop = true, base);
            }
          }
          parseMember(base, startLoc, state, computed, optional) {
            const node = this.startNodeAt(startLoc);
            return node.object = base, node.computed = computed, computed ? (node.property = this.parseExpression(), this.expect(3)) : this.match(136) ? ("Super" === base.type && this.raise(Errors.SuperPrivateField, { at: startLoc }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), node.property = this.parsePrivateName()) : node.property = this.parseIdentifier(true), state.optionalChainMember ? (node.optional = optional, this.finishNode(node, "OptionalMemberExpression")) : this.finishNode(node, "MemberExpression");
          }
          parseBind(base, startLoc, noCalls, state) {
            const node = this.startNodeAt(startLoc);
            return node.object = base, this.next(), node.callee = this.parseNoCallExpr(), state.stop = true, this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
          }
          parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            let refExpressionErrors = null;
            this.state.maybeInArrowParameters = true, this.next();
            const node = this.startNodeAt(startLoc);
            node.callee = base;
            const { maybeAsyncArrow, optionalChainMember } = state;
            maybeAsyncArrow && (this.expressionScope.enter(new ArrowHeadParsingScope(2)), refExpressionErrors = new ExpressionErrors()), optionalChainMember && (node.optional = optional), node.arguments = optional ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === base.type, "Super" !== base.type, node, refExpressionErrors);
            let finishedNode = this.finishCallExpression(node, optionalChainMember);
            return maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional ? (state.stop = true, this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode)) : (maybeAsyncArrow && (this.checkExpressionErrors(refExpressionErrors, true), this.expressionScope.exit()), this.toReferencedArguments(finishedNode)), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, finishedNode;
          }
          toReferencedArguments(node, isParenthesizedExpr) {
            this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
          }
          parseTaggedTemplateExpression(base, startLoc, state) {
            const node = this.startNodeAt(startLoc);
            return node.tag = base, node.quasi = this.parseTemplate(true), state.optionalChainMember && this.raise(Errors.OptionalChainingNoTemplate, { at: startLoc }), this.finishNode(node, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(base) {
            return "Identifier" === base.type && "async" === base.name && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start == 5 && base.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(node, optional) {
            if ("Import" === node.callee.type)
              if (2 === node.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), 0 === node.arguments.length || node.arguments.length > 2)
                this.raise(Errors.ImportCallArity, { at: node, maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
              else
                for (const arg of node.arguments)
                  "SpreadElement" === arg.type && this.raise(Errors.ImportCallSpreadArgument, { at: arg });
            return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
            const elts = [];
            let first = true;
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(close); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.match(close)) {
                !dynamicImport || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(Errors.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
                break;
              }
              elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
            }
            return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, elts;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(node, call) {
            var _call$extra;
            return this.resetPreviousNodeTrailingComments(call), this.expect(19), this.parseArrowExpression(node, call.arguments, true, null == (_call$extra = call.extra) ? void 0 : _call$extra.trailingCommaLoc), call.innerComments && setInnerComments(node, call.innerComments), call.callee.trailingComments && setInnerComments(node, call.callee.trailingComments), node;
          }
          parseNoCallExpr() {
            const startLoc = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
          }
          parseExprAtom(refExpressionErrors) {
            let node, decorators = null;
            const { type } = this.state;
            switch (type) {
              case 79:
                return this.parseSuper();
              case 83:
                return node = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(node) : (this.match(10) || this.raise(Errors.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(node, "Import"));
              case 78:
                return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 132:
                return this.parseNumericLiteral(this.state.value);
              case 133:
                return this.parseBigIntLiteral(this.state.value);
              case 134:
                return this.parseDecimalLiteral(this.state.value);
              case 131:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(canBeArrow);
              }
              case 2:
              case 1:
                return this.parseArrayLike(2 === this.state.type ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, refExpressionErrors);
              case 6:
              case 7:
                return this.parseObjectLike(6 === this.state.type ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, refExpressionErrors);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                decorators = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                node = this.startNode(), this.next(), node.object = null;
                const callee = node.callee = this.parseNoCallExpr();
                if ("MemberExpression" === callee.type)
                  return this.finishNode(node, "BindExpression");
                throw this.raise(Errors.UnsupportedBind, { at: callee });
              }
              case 136:
                return this.raise(Errors.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                if (pipeProposal)
                  return this.parseTopicReference(pipeProposal);
                this.unexpected();
                break;
              }
              case 47: {
                const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                isIdentifierStart2(lookaheadCh) || 62 === lookaheadCh ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (tokenIsIdentifier(type)) {
                  if (this.isContextual(125) && 123 === this.lookaheadInLineCharCode())
                    return this.parseModuleExpression();
                  const canBeArrow = this.state.potentialArrowAt === this.state.start, containsEsc = this.state.containsEsc, id = this.parseIdentifier();
                  if (!containsEsc && "async" === id.name && !this.canInsertSemicolon()) {
                    const { type: type2 } = this.state;
                    if (68 === type2)
                      return this.resetPreviousNodeTrailingComments(id), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                    if (tokenIsIdentifier(type2))
                      return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)) : id;
                    if (90 === type2)
                      return this.resetPreviousNodeTrailingComments(id), this.parseDo(this.startNodeAtNode(id), true);
                  }
                  return canBeArrow && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(id), [id], false)) : id;
                }
                this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal)
              return this.state.type = topicTokenType, this.state.value = topicTokenValue, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(pipeProposal);
            this.unexpected();
          }
          parseTopicReference(pipeProposal) {
            const node = this.startNode(), startLoc = this.state.startLoc, tokenType = this.state.type;
            return this.next(), this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
          }
          finishTopicReference(node, startLoc, pipeProposal, tokenType) {
            if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
              const nodeType = "smart" === pipeProposal ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === pipeProposal ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, { at: startLoc }), this.registerTopicReference(), this.finishNode(node, nodeType);
            }
            throw this.raise(Errors.PipeTopicUnconfiguredToken, { at: startLoc, token: tokenLabelName(tokenType) });
          }
          testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
            switch (pipeProposal) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: tokenLabelName(tokenType) }]);
              case "smart":
                return 27 === tokenType;
              default:
                throw this.raise(Errors.PipeTopicRequiresHackPipes, { at: startLoc });
            }
          }
          parseAsyncArrowUnaryFunction(node) {
            this.prodParam.enter(functionFlags2(true, this.prodParam.hasYield));
            const params = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Errors.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(node, params, true);
          }
          parseDo(node, isAsync) {
            this.expectPlugin("doExpressions"), isAsync && this.expectPlugin("asyncDoExpressions"), node.async = isAsync, this.next();
            const oldLabels = this.state.labels;
            return this.state.labels = [], isAsync ? (this.prodParam.enter(2), node.body = this.parseBlock(), this.prodParam.exit()) : node.body = this.parseBlock(), this.state.labels = oldLabels, this.finishNode(node, "DoExpression");
          }
          parseSuper() {
            const node = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(Errors.UnexpectedSuper, { at: node }) : this.raise(Errors.SuperNotAllowed, { at: node }), this.match(10) || this.match(0) || this.match(16) || this.raise(Errors.UnsupportedSuper, { at: node }), this.finishNode(node, "Super");
          }
          parsePrivateName() {
            const node = this.startNode(), id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1)), name = this.state.value;
            return this.next(), node.id = this.createIdentifier(id, name), this.finishNode(node, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const node = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
              return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(node, meta, "sent");
            }
            return this.parseFunction(node);
          }
          parseMetaProperty(node, meta, propertyName) {
            node.meta = meta;
            const containsEsc = this.state.containsEsc;
            return node.property = this.parseIdentifier(true), (node.property.name !== propertyName || containsEsc) && this.raise(Errors.UnsupportedMetaProperty, { at: node.property, target: meta.name, onlyValidPropertyName: propertyName }), this.finishNode(node, "MetaProperty");
          }
          parseImportMetaProperty(node) {
            const id = this.createIdentifier(this.startNodeAtNode(node), "import");
            return this.next(), this.isContextual(100) && (this.inModule || this.raise(Errors.ImportMetaOutsideModule, { at: id }), this.sawUnambiguousESM = true), this.parseMetaProperty(node, id, "meta");
          }
          parseLiteralAtNode(value2, type, node) {
            return this.addExtra(node, "rawValue", value2), this.addExtra(node, "raw", this.input.slice(node.start, this.state.end)), node.value = value2, this.next(), this.finishNode(node, type);
          }
          parseLiteral(value2, type) {
            const node = this.startNode();
            return this.parseLiteralAtNode(value2, type, node);
          }
          parseStringLiteral(value2) {
            return this.parseLiteral(value2, "StringLiteral");
          }
          parseNumericLiteral(value2) {
            return this.parseLiteral(value2, "NumericLiteral");
          }
          parseBigIntLiteral(value2) {
            return this.parseLiteral(value2, "BigIntLiteral");
          }
          parseDecimalLiteral(value2) {
            return this.parseLiteral(value2, "DecimalLiteral");
          }
          parseRegExpLiteral(value2) {
            const node = this.parseLiteral(value2.value, "RegExpLiteral");
            return node.pattern = value2.pattern, node.flags = value2.flags, node;
          }
          parseBooleanLiteral(value2) {
            const node = this.startNode();
            return node.value = value2, this.next(), this.finishNode(node, "BooleanLiteral");
          }
          parseNullLiteral() {
            const node = this.startNode();
            return this.next(), this.finishNode(node, "NullLiteral");
          }
          parseParenAndDistinguishExpression(canBeArrow) {
            const startLoc = this.state.startLoc;
            let val;
            this.next(), this.expressionScope.enter(new ArrowHeadParsingScope(1));
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            const innerStartLoc = this.state.startLoc, exprList = [], refExpressionErrors = new ExpressionErrors();
            let spreadStartLoc, optionalCommaStartLoc, first = true;
            for (; !this.match(11); ) {
              if (first)
                first = false;
              else if (this.expect(12, null === refExpressionErrors.optionalParametersLoc ? null : refExpressionErrors.optionalParametersLoc), this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                const spreadNodeStartLoc = this.state.startLoc;
                if (spreadStartLoc = this.state.startLoc, exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc)), !this.checkCommaAfterRest(41))
                  break;
              } else
                exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
            const innerEndLoc = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            let arrowNode = this.startNodeAt(startLoc);
            return canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode)) ? (this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(arrowNode, exprList, false), arrowNode) : (this.expressionScope.exit(), exprList.length || this.unexpected(this.state.lastTokStartLoc), optionalCommaStartLoc && this.unexpected(optionalCommaStartLoc), spreadStartLoc && this.unexpected(spreadStartLoc), this.checkExpressionErrors(refExpressionErrors, true), this.toReferencedListDeep(exprList, true), exprList.length > 1 ? (val = this.startNodeAt(innerStartLoc), val.expressions = exprList, this.finishNode(val, "SequenceExpression"), this.resetEndLocation(val, innerEndLoc)) : val = exprList[0], this.wrapParenthesis(startLoc, val));
          }
          wrapParenthesis(startLoc, expression) {
            if (!this.options.createParenthesizedExpressions)
              return this.addExtra(expression, "parenthesized", true), this.addExtra(expression, "parenStart", startLoc.index), this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index), expression;
            const parenExpression = this.startNodeAt(startLoc);
            return parenExpression.expression = expression, this.finishNode(parenExpression, "ParenthesizedExpression");
          }
          shouldParseArrow(params) {
            return !this.canInsertSemicolon();
          }
          parseArrow(node) {
            if (this.eat(19))
              return node;
          }
          parseParenItem(node, startLoc) {
            return node;
          }
          parseNewOrNewTarget() {
            const node = this.startNode();
            if (this.next(), this.match(16)) {
              const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
              this.next();
              const metaProp = this.parseMetaProperty(node, meta, "target");
              return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(Errors.UnexpectedNewTarget, { at: metaProp }), metaProp;
            }
            return this.parseNew(node);
          }
          parseNew(node) {
            if (this.parseNewCallee(node), this.eat(10)) {
              const args = this.parseExprList(11);
              this.toReferencedList(args), node.arguments = args;
            } else
              node.arguments = [];
            return this.finishNode(node, "NewExpression");
          }
          parseNewCallee(node) {
            node.callee = this.parseNoCallExpr(), "Import" === node.callee.type && this.raise(Errors.ImportCallNotNewExpression, { at: node.callee });
          }
          parseTemplateElement(isTagged) {
            const { start, startLoc, end, value: value2 } = this.state, elemStart = start + 1, elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
            null === value2 && (isTagged || this.raise(Errors.InvalidEscapeSequenceTemplate, { at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1) }));
            const isTail = this.match(24), endOffset = isTail ? -1 : -2, elemEnd = end + endOffset;
            elem.value = { raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"), cooked: null === value2 ? null : value2.slice(1, endOffset) }, elem.tail = isTail, this.next();
            const finishedNode = this.finishNode(elem, "TemplateElement");
            return this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset)), finishedNode;
          }
          parseTemplate(isTagged) {
            const node = this.startNode();
            node.expressions = [];
            let curElt = this.parseTemplateElement(isTagged);
            for (node.quasis = [curElt]; !curElt.tail; )
              node.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), node.quasis.push(curElt = this.parseTemplateElement(isTagged));
            return this.finishNode(node, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
            isRecord && this.expectPlugin("recordAndTuple");
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const propHash = /* @__PURE__ */ Object.create(null);
            let first = true;
            const node = this.startNode();
            for (node.properties = [], this.next(); !this.match(close); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.match(close)) {
                this.addTrailingCommaExtraToNode(node);
                break;
              }
              let prop;
              isPattern ? prop = this.parseBindingProperty() : (prop = this.parsePropertyDefinition(refExpressionErrors), this.checkProto(prop, isRecord, propHash, refExpressionErrors)), isRecord && !this.isObjectProperty(prop) && "SpreadElement" !== prop.type && this.raise(Errors.InvalidRecordProperty, { at: prop }), prop.shorthand && this.addExtra(prop, "shorthand", true), node.properties.push(prop);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            let type = "ObjectExpression";
            return isPattern ? type = "ObjectPattern" : isRecord && (type = "RecordExpression"), this.finishNode(node, type);
          }
          addTrailingCommaExtraToNode(node) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart), this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(prop) {
            return !prop.computed && "Identifier" === prop.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(refExpressionErrors) {
            let decorators = [];
            if (this.match(26))
              for (this.hasPlugin("decorators") && this.raise(Errors.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
                decorators.push(this.parseDecorator());
            const prop = this.startNode();
            let startLoc, isAsync = false, isAccessor = false;
            if (this.match(21))
              return decorators.length && this.unexpected(), this.parseSpread();
            decorators.length && (prop.decorators = decorators, decorators = []), prop.method = false, refExpressionErrors && (startLoc = this.state.startLoc);
            let isGenerator = this.eat(55);
            this.parsePropertyNamePrefixOperator(prop);
            const containsEsc = this.state.containsEsc, key = this.parsePropertyName(prop, refExpressionErrors);
            if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
              const keyName = key.name;
              "async" !== keyName || this.hasPrecedingLineBreak() || (isAsync = true, this.resetPreviousNodeTrailingComments(key), isGenerator = this.eat(55), this.parsePropertyName(prop)), "get" !== keyName && "set" !== keyName || (isAccessor = true, this.resetPreviousNodeTrailingComments(key), prop.kind = keyName, this.match(55) && (isGenerator = true, this.raise(Errors.AccessorIsGenerator, { at: this.state.curPosition(), kind: keyName }), this.next()), this.parsePropertyName(prop));
            }
            return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
          }
          getGetterSetterExpectedParamCount(method) {
            return "get" === method.kind ? 0 : 1;
          }
          getObjectOrClassMethodParams(method) {
            return method.params;
          }
          checkGetterSetterParams(method) {
            var _params;
            const paramCount = this.getGetterSetterExpectedParamCount(method), params = this.getObjectOrClassMethodParams(method);
            params.length !== paramCount && this.raise("get" === method.kind ? Errors.BadGetterArity : Errors.BadSetterArity, { at: method }), "set" === method.kind && "RestElement" === (null == (_params = params[params.length - 1]) ? void 0 : _params.type) && this.raise(Errors.BadSetterRestParameter, { at: method });
          }
          parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
            if (isAccessor) {
              const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(finishedProp), finishedProp;
            }
            if (isAsync || isGenerator || this.match(10))
              return isPattern && this.unexpected(), prop.kind = "method", prop.method = true, this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
          }
          parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
            if (prop.shorthand = false, this.eat(14))
              return prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors), this.finishNode(prop, "ObjectProperty");
            if (!prop.computed && "Identifier" === prop.key.type) {
              if (this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false), isPattern)
                prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
              else if (this.match(29)) {
                const shorthandAssignLoc = this.state.startLoc;
                null != refExpressionErrors ? null === refExpressionErrors.shorthandAssignLoc && (refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc) : this.raise(Errors.InvalidCoverInitializedName, { at: shorthandAssignLoc }), prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
              } else
                prop.value = cloneIdentifier(prop.key);
              return prop.shorthand = true, this.finishNode(prop, "ObjectProperty");
            }
          }
          parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
            return node || this.unexpected(), node;
          }
          parsePropertyName(prop, refExpressionErrors) {
            if (this.eat(0))
              prop.computed = true, prop.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type, value: value2 } = this.state;
              let key;
              if (tokenIsKeywordOrIdentifier(type))
                key = this.parseIdentifier(true);
              else
                switch (type) {
                  case 132:
                    key = this.parseNumericLiteral(value2);
                    break;
                  case 131:
                    key = this.parseStringLiteral(value2);
                    break;
                  case 133:
                    key = this.parseBigIntLiteral(value2);
                    break;
                  case 134:
                    key = this.parseDecimalLiteral(value2);
                    break;
                  case 136: {
                    const privateKeyLoc = this.state.startLoc;
                    null != refExpressionErrors ? null === refExpressionErrors.privateKeyLoc && (refExpressionErrors.privateKeyLoc = privateKeyLoc) : this.raise(Errors.UnexpectedPrivateField, { at: privateKeyLoc }), key = this.parsePrivateName();
                    break;
                  }
                  default:
                    this.unexpected();
                }
              prop.key = key, 136 !== type && (prop.computed = false);
            }
            return prop.key;
          }
          initFunction(node, isAsync) {
            node.id = null, node.generator = false, node.async = isAsync;
          }
          parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
            this.initFunction(node, isAsync), node.generator = isGenerator, this.scope.enter(18 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0)), this.prodParam.enter(functionFlags2(isAsync, node.generator)), this.parseFunctionParams(node, isConstructor);
            const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
            return this.prodParam.exit(), this.scope.exit(), finishedNode;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            isTuple && this.expectPlugin("recordAndTuple");
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const node = this.startNode();
            return this.next(), node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
            this.scope.enter(6);
            let flags = functionFlags2(isAsync, false);
            !this.match(5) && this.prodParam.hasIn && (flags |= 8), this.prodParam.enter(flags), this.initFunction(node, isAsync);
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            return params && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(node, params, trailingCommaLoc)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(node, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.finishNode(node, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(node, params, trailingCommaLoc) {
            this.toAssignableList(params, trailingCommaLoc, false), node.params = params;
          }
          parseFunctionBodyAndFinish(node, type, isMethod = false) {
            return this.parseFunctionBody(node, false, isMethod), this.finishNode(node, type);
          }
          parseFunctionBody(node, allowExpression, isMethod = false) {
            const isExpression = allowExpression && !this.match(5);
            if (this.expressionScope.enter(newExpressionScope()), isExpression)
              node.body = this.parseMaybeAssign(), this.checkParams(node, false, allowExpression, false);
            else {
              const oldStrict = this.state.strict, oldLabels = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
                const nonSimple = !this.isSimpleParamList(node.params);
                hasStrictModeDirective && nonSimple && this.raise(Errors.IllegalLanguageModeDirective, { at: "method" !== node.kind && "constructor" !== node.kind || !node.key ? node : node.key.loc.end });
                const strictModeChanged = !oldStrict && this.state.strict;
                this.checkParams(node, !(this.state.strict || allowExpression || isMethod || nonSimple), allowExpression, strictModeChanged), this.state.strict && node.id && this.checkIdentifier(node.id, 65, strictModeChanged);
              }), this.prodParam.exit(), this.state.labels = oldLabels;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(node) {
            return "Identifier" === node.type;
          }
          isSimpleParamList(params) {
            for (let i = 0, len = params.length; i < len; i++)
              if (!this.isSimpleParameter(params[i]))
                return false;
            return true;
          }
          checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
            const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set(), formalParameters = { type: "FormalParameters" };
            for (const param of node.params)
              this.checkLVal(param, { in: formalParameters, binding: 5, checkClashes, strictModeChanged });
          }
          parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
            const elts = [];
            let first = true;
            for (; !this.eat(close); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.match(close)) {
                nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
                break;
              }
              elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
            }
            return elts;
          }
          parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
            let elt;
            if (this.match(12))
              allowEmpty || this.raise(Errors.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), elt = null;
            else if (this.match(21)) {
              const spreadNodeStartLoc = this.state.startLoc;
              elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), allowPlaceholder || this.raise(Errors.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
              const node = this.startNode();
              this.next(), elt = this.finishNode(node, "ArgumentPlaceholder");
            } else
              elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
            return elt;
          }
          parseIdentifier(liberal) {
            const node = this.startNode(), name = this.parseIdentifierName(liberal);
            return this.createIdentifier(node, name);
          }
          createIdentifier(node, name) {
            return node.name = name, node.loc.identifierName = name, this.finishNode(node, "Identifier");
          }
          parseIdentifierName(liberal) {
            let name;
            const { startLoc, type } = this.state;
            tokenIsKeywordOrIdentifier(type) ? name = this.state.value : this.unexpected();
            const tokenIsKeyword2 = type <= 92;
            return liberal ? tokenIsKeyword2 && this.replaceToken(130) : this.checkReservedWord(name, startLoc, tokenIsKeyword2, false), this.next(), name;
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            if (word.length > 10)
              return;
            if (!function(word2) {
              return reservedWordLikeSet.has(word2);
            }(word))
              return;
            if (checkKeywords && function(word2) {
              return keywords2.has(word2);
            }(word))
              return void this.raise(Errors.UnexpectedKeyword, { at: startLoc, keyword: word });
            if ((this.state.strict ? isBinding ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(word, this.inModule))
              this.raise(Errors.UnexpectedReservedWord, { at: startLoc, reservedWord: word });
            else if ("yield" === word) {
              if (this.prodParam.hasYield)
                return void this.raise(Errors.YieldBindingIdentifier, { at: startLoc });
            } else if ("await" === word) {
              if (this.prodParam.hasAwait)
                return void this.raise(Errors.AwaitBindingIdentifier, { at: startLoc });
              if (this.scope.inStaticBlock)
                return void this.raise(Errors.AwaitBindingIdentifierInStaticBlock, { at: startLoc });
              this.expressionScope.recordAsyncArrowParametersError({ at: startLoc });
            } else if ("arguments" === word && this.scope.inClassAndNotInNonArrowFunction)
              return void this.raise(Errors.ArgumentsInClass, { at: startLoc });
          }
          isAwaitAllowed() {
            return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
          }
          parseAwait(startLoc) {
            const node = this.startNodeAt(startLoc);
            return this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, { at: node }), this.eat(55) && this.raise(Errors.ObsoleteAwaitStar, { at: node }), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (node.argument = this.parseMaybeUnary(null, true)), this.finishNode(node, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak())
              return true;
            const { type } = this.state;
            return 53 === type || 10 === type || 0 === type || tokenIsTemplate(type) || 101 === type && !this.state.containsEsc || 135 === type || 56 === type || this.hasPlugin("v8intrinsic") && 54 === type;
          }
          parseYield() {
            const node = this.startNode();
            this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, { at: node }), this.next();
            let delegating = false, argument = null;
            if (!this.hasPrecedingLineBreak())
              switch (delegating = this.eat(55), this.state.type) {
                case 13:
                case 137:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!delegating)
                    break;
                default:
                  argument = this.parseMaybeAssign();
              }
            return node.delegate = delegating, node.argument = argument, this.finishNode(node, "YieldExpression");
          }
          checkPipelineAtInfixOperator(left, leftStartLoc) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && "SequenceExpression" === left.type && this.raise(Errors.PipelineHeadSequenceExpression, { at: leftStartLoc });
          }
          parseSmartPipelineBodyInStyle(childExpr, startLoc) {
            if (this.isSimpleReference(childExpr)) {
              const bodyNode = this.startNodeAt(startLoc);
              return bodyNode.callee = childExpr, this.finishNode(bodyNode, "PipelineBareFunction");
            }
            {
              const bodyNode = this.startNodeAt(startLoc);
              return this.checkSmartPipeTopicBodyEarlyErrors(startLoc), bodyNode.expression = childExpr, this.finishNode(bodyNode, "PipelineTopicExpression");
            }
          }
          isSimpleReference(expression) {
            switch (expression.type) {
              case "MemberExpression":
                return !expression.computed && this.isSimpleReference(expression.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(startLoc) {
            if (this.match(19))
              throw this.raise(Errors.PipelineBodyNoArrow, { at: this.state.startLoc });
            this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipelineTopicUnused, { at: startLoc });
          }
          withTopicBindingContext(callback) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          }
          withSmartMixTopicForbiddingContext(callback) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }]))
              return callback();
            {
              const outerContextTopicState = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return callback();
              } finally {
                this.state.topicContext = outerContextTopicState;
              }
            }
          }
          withSoloAwaitPermittingContext(callback) {
            const outerContextSoloAwaitState = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return callback();
            } finally {
              this.state.soloAwait = outerContextSoloAwaitState;
            }
          }
          allowInAnd(callback) {
            const flags = this.prodParam.currentFlags();
            if (8 & ~flags) {
              this.prodParam.enter(8 | flags);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
          disallowInAnd(callback) {
            const flags = this.prodParam.currentFlags();
            if (8 & flags) {
              this.prodParam.enter(-9 & flags);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(prec) {
            const startLoc = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
            return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const node = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            const program = this.startNodeAt(this.state.endLoc);
            this.next();
            const revertScopes = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              node.body = this.parseProgram(program, 8, "module");
            } finally {
              revertScopes();
            }
            return this.finishNode(node, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(prop) {
          }
        }
        const loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" }, loneSurrogate2 = /[\uD800-\uDFFF]/u, keywordRelationalOperator2 = /in(?:stanceof)?/y;
        class StatementParser extends ExpressionParser {
          parseTopLevel(file, program) {
            return file.program = this.parseProgram(program), file.comments = this.state.comments, this.options.tokens && (file.tokens = function(tokens, input) {
              for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i], { type } = token;
                if ("number" == typeof type) {
                  if (136 === type) {
                    const { loc, start, value: value2, end } = token, hashEndPos = start + 1, hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                    tokens.splice(i, 1, new Token3({ type: getExportedToken(27), value: "#", start, end: hashEndPos, startLoc: loc.start, endLoc: hashEndLoc }), new Token3({ type: getExportedToken(130), value: value2, start: hashEndPos, end, startLoc: hashEndLoc, endLoc: loc.end })), i++;
                    continue;
                  }
                  if (tokenIsTemplate(type)) {
                    const { loc, start, value: value2, end } = token, backquoteEnd = start + 1, backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                    let startToken, templateValue, templateElementEnd, templateElementEndLoc, endToken;
                    startToken = 96 === input.charCodeAt(start) ? new Token3({ type: getExportedToken(22), value: "`", start, end: backquoteEnd, startLoc: loc.start, endLoc: backquoteEndLoc }) : new Token3({ type: getExportedToken(8), value: "}", start, end: backquoteEnd, startLoc: loc.start, endLoc: backquoteEndLoc }), 24 === type ? (templateElementEnd = end - 1, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1), templateValue = null === value2 ? null : value2.slice(1, -1), endToken = new Token3({ type: getExportedToken(22), value: "`", start: templateElementEnd, end, startLoc: templateElementEndLoc, endLoc: loc.end })) : (templateElementEnd = end - 2, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2), templateValue = null === value2 ? null : value2.slice(1, -2), endToken = new Token3({ type: getExportedToken(23), value: "${", start: templateElementEnd, end, startLoc: templateElementEndLoc, endLoc: loc.end })), tokens.splice(i, 1, startToken, new Token3({ type: getExportedToken(20), value: templateValue, start: backquoteEnd, end: templateElementEnd, startLoc: backquoteEndLoc, endLoc: templateElementEndLoc }), endToken), i += 2;
                    continue;
                  }
                  token.type = getExportedToken(type);
                }
              }
              return tokens;
            }(this.tokens, this.input)), this.finishNode(file, "File");
          }
          parseProgram(program, end = 137, sourceType = this.options.sourceType) {
            if (program.sourceType = sourceType, program.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(program, true, true, end), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
              for (const [localName, at2] of Array.from(this.scope.undefinedExports))
                this.raise(Errors.ModuleExportUndefined, { at: at2, localName });
            let finishedProgram;
            return finishedProgram = 137 === end ? this.finishNode(program, "Program") : this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1)), finishedProgram;
          }
          stmtToDirective(stmt) {
            const directive = stmt;
            directive.type = "Directive", directive.value = directive.expression, delete directive.expression;
            const directiveLiteral = directive.value, expressionValue = directiveLiteral.value, raw = this.input.slice(directiveLiteral.start, directiveLiteral.end), val = directiveLiteral.value = raw.slice(1, -1);
            return this.addExtra(directiveLiteral, "raw", raw), this.addExtra(directiveLiteral, "rawValue", val), this.addExtra(directiveLiteral, "expressionValue", expressionValue), directiveLiteral.type = "DirectiveLiteral", directive;
          }
          parseInterpreterDirective() {
            if (!this.match(28))
              return null;
            const node = this.startNode();
            return node.value = this.state.value, this.next(), this.finishNode(node, "InterpreterDirective");
          }
          isLet() {
            return !!this.isContextual(99) && this.hasFollowingBindingAtom();
          }
          chStartsBindingIdentifier(ch, pos) {
            if (isIdentifierStart2(ch)) {
              if (keywordRelationalOperator2.lastIndex = pos, keywordRelationalOperator2.test(this.input)) {
                const endCh = this.codePointAtPos(keywordRelationalOperator2.lastIndex);
                if (!isIdentifierChar2(endCh) && 92 !== endCh)
                  return false;
              }
              return true;
            }
            return 92 === ch;
          }
          chStartsBindingPattern(ch) {
            return 91 === ch || 123 === ch;
          }
          hasFollowingBindingAtom() {
            const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
            return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
          }
          hasInLineFollowingBindingIdentifier() {
            const next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
            return this.chStartsBindingIdentifier(nextCh, next);
          }
          startsUsingForOf() {
            const { type, containsEsc } = this.lookahead();
            return !(101 === type && !containsEsc) && (tokenIsIdentifier(type) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), true) : void 0);
          }
          startsAwaitUsing() {
            let next = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(next, "using")) {
              next = this.nextTokenInLineStartSince(next + 5);
              const nextCh = this.codePointAtPos(next);
              if (this.chStartsBindingIdentifier(nextCh, next))
                return this.expectPlugin("explicitResourceManagement"), true;
            }
            return false;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
            let flags = 0;
            return this.options.annexB && !this.state.strict && (flags |= 4, allowLabeledFunction && (flags |= 8)), this.parseStatementLike(flags);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(flags) {
            let decorators = null;
            return this.match(26) && (decorators = this.parseDecorators(true)), this.parseStatementContent(flags, decorators);
          }
          parseStatementContent(flags, decorators) {
            const starttype = this.state.type, node = this.startNode(), allowDeclaration = !!(2 & flags), allowFunctionDeclaration = !!(4 & flags), topLevel = 1 & flags;
            switch (starttype) {
              case 60:
                return this.parseBreakContinueStatement(node, true);
              case 63:
                return this.parseBreakContinueStatement(node, false);
              case 64:
                return this.parseDebuggerStatement(node);
              case 90:
                return this.parseDoWhileStatement(node);
              case 91:
                return this.parseForStatement(node);
              case 68:
                if (46 === this.lookaheadCharCode())
                  break;
                return allowFunctionDeclaration || this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
              case 80:
                return allowDeclaration || this.unexpected(), this.parseClass(this.maybeTakeDecorators(decorators, node), true);
              case 69:
                return this.parseIfStatement(node);
              case 70:
                return this.parseReturnStatement(node);
              case 71:
                return this.parseSwitchStatement(node);
              case 72:
                return this.parseThrowStatement(node);
              case 73:
                return this.parseTryStatement(node);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing())
                  return this.isAwaitAllowed() ? allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, { at: node }) : this.raise(Errors.AwaitUsingNotInAsyncContext, { at: node }), this.next(), this.parseVarStatement(node, "await using");
                break;
              case 105:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
                  break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(Errors.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(node, "using");
              case 99: {
                if (this.state.containsEsc)
                  break;
                const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
                if (91 !== nextCh) {
                  if (!allowDeclaration && this.hasFollowingLineBreak())
                    break;
                  if (!this.chStartsBindingIdentifier(nextCh, next) && 123 !== nextCh)
                    break;
                }
              }
              case 75:
                allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
              case 74: {
                const kind = this.state.value;
                return this.parseVarStatement(node, kind);
              }
              case 92:
                return this.parseWhileStatement(node);
              case 76:
                return this.parseWithStatement(node);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(node);
              case 83: {
                const nextTokenCharCode = this.lookaheadCharCode();
                if (40 === nextTokenCharCode || 46 === nextTokenCharCode)
                  break;
              }
              case 82: {
                let result;
                return this.options.allowImportExportEverywhere || topLevel || this.raise(Errors.UnexpectedImportExport, { at: this.state.startLoc }), this.next(), 83 === starttype ? (result = this.parseImport(node), "ImportDeclaration" !== result.type || result.importKind && "value" !== result.importKind || (this.sawUnambiguousESM = true)) : (result = this.parseExport(node, decorators), ("ExportNamedDeclaration" !== result.type || result.exportKind && "value" !== result.exportKind) && ("ExportAllDeclaration" !== result.type || result.exportKind && "value" !== result.exportKind) && "ExportDefaultDeclaration" !== result.type || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(result), result;
              }
              default:
                if (this.isAsyncFunction())
                  return allowDeclaration || this.raise(Errors.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
            const maybeName = this.state.value, expr = this.parseExpression();
            return tokenIsIdentifier(starttype) && "Identifier" === expr.type && this.eat(14) ? this.parseLabeledStatement(node, maybeName, expr, flags) : this.parseExpressionStatement(node, expr, decorators);
          }
          assertModuleNodeAllowed(node) {
            this.options.allowImportExportEverywhere || this.inModule || this.raise(Errors.ImportOutsideModule, { at: node });
          }
          decoratorsEnabledBeforeExport() {
            return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && false !== this.getPluginOption("decorators", "decoratorsBeforeExport");
          }
          maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
            return maybeDecorators && (classNode.decorators && classNode.decorators.length > 0 ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(Errors.DecoratorsBeforeAfterExport, { at: classNode.decorators[0] }), classNode.decorators.unshift(...maybeDecorators)) : classNode.decorators = maybeDecorators, this.resetStartLocationFromNode(classNode, maybeDecorators[0]), exportNode && this.resetStartLocationFromNode(exportNode, classNode)), classNode;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(allowExport) {
            const decorators = [];
            do {
              decorators.push(this.parseDecorator());
            } while (this.match(26));
            if (this.match(82))
              allowExport || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Errors.DecoratorExportClass, { at: this.state.startLoc });
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(Errors.UnexpectedLeadingDecorator, { at: this.state.startLoc });
            return decorators;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            const node = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              const startLoc = this.state.startLoc;
              let expr;
              if (this.match(10)) {
                const startLoc2 = this.state.startLoc;
                this.next(), expr = this.parseExpression(), this.expect(11), expr = this.wrapParenthesis(startLoc2, expr);
                const paramsStartLoc = this.state.startLoc;
                node.expression = this.parseMaybeDecoratorArguments(expr), false === this.getPluginOption("decorators", "allowCallParenthesized") && node.expression !== expr && this.raise(Errors.DecoratorArgumentsOutsideParentheses, { at: paramsStartLoc });
              } else {
                for (expr = this.parseIdentifier(false); this.eat(16); ) {
                  const node2 = this.startNodeAt(startLoc);
                  node2.object = expr, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), node2.property = this.parsePrivateName()) : node2.property = this.parseIdentifier(true), node2.computed = false, expr = this.finishNode(node2, "MemberExpression");
                }
                node.expression = this.parseMaybeDecoratorArguments(expr);
              }
            } else
              node.expression = this.parseExprSubscripts();
            return this.finishNode(node, "Decorator");
          }
          parseMaybeDecoratorArguments(expr) {
            if (this.eat(10)) {
              const node = this.startNodeAtNode(expr);
              return node.callee = expr, node.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(node.arguments), this.finishNode(node, "CallExpression");
            }
            return expr;
          }
          parseBreakContinueStatement(node, isBreak) {
            return this.next(), this.isLineTerminator() ? node.label = null : (node.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(node, isBreak), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(node, isBreak) {
            let i;
            for (i = 0; i < this.state.labels.length; ++i) {
              const lab = this.state.labels[i];
              if (null == node.label || lab.name === node.label.name) {
                if (null != lab.kind && (isBreak || "loop" === lab.kind))
                  break;
                if (node.label && isBreak)
                  break;
              }
            }
            if (i === this.state.labels.length) {
              const type = isBreak ? "BreakStatement" : "ContinueStatement";
              this.raise(Errors.IllegalBreakContinue, { at: node, type });
            }
          }
          parseDebuggerStatement(node) {
            return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const val = this.parseExpression();
            return this.expect(11), val;
          }
          parseDoWhileStatement(node) {
            return this.next(), this.state.labels.push(loopLabel2), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), node.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(node, "DoWhileStatement");
          }
          parseForStatement(node) {
            this.next(), this.state.labels.push(loopLabel2);
            let awaitAt = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (awaitAt = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
              return null !== awaitAt && this.unexpected(awaitAt), this.parseFor(node, null);
            const startsWithLet = this.isContextual(99);
            {
              const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing(), starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(105) && this.startsUsingForOf(), isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
              if (this.match(74) || this.match(75) || isLetOrUsing) {
                const initNode = this.startNode();
                let kind;
                startsWithAwaitUsing ? (kind = "await using", this.isAwaitAllowed() || this.raise(Errors.AwaitUsingNotInAsyncContext, { at: this.state.startLoc }), this.next()) : kind = this.state.value, this.next(), this.parseVar(initNode, true, kind);
                const init2 = this.finishNode(initNode, "VariableDeclaration"), isForIn = this.match(58);
                return isForIn && starsWithUsingDeclaration && this.raise(Errors.ForInUsing, { at: init2 }), (isForIn || this.isContextual(101)) && 1 === init2.declarations.length ? this.parseForIn(node, init2, awaitAt) : (null !== awaitAt && this.unexpected(awaitAt), this.parseFor(node, init2));
              }
            }
            const startsWithAsync = this.isContextual(95), refExpressionErrors = new ExpressionErrors(), init = this.parseExpression(true, refExpressionErrors), isForOf = this.isContextual(101);
            if (isForOf && (startsWithLet && this.raise(Errors.ForOfLet, { at: init }), null === awaitAt && startsWithAsync && "Identifier" === init.type && this.raise(Errors.ForOfAsync, { at: init })), isForOf || this.match(58)) {
              this.checkDestructuringPrivate(refExpressionErrors), this.toAssignable(init, true);
              const type = isForOf ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(init, { in: { type } }), this.parseForIn(node, init, awaitAt);
            }
            return this.checkExpressionErrors(refExpressionErrors, true), null !== awaitAt && this.unexpected(awaitAt), this.parseFor(node, init);
          }
          parseFunctionStatement(node, isAsync, isHangingDeclaration) {
            return this.next(), this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
          }
          parseIfStatement(node) {
            return this.next(), node.test = this.parseHeaderExpression(), node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(node, "IfStatement");
          }
          parseReturnStatement(node) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(Errors.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? node.argument = null : (node.argument = this.parseExpression(), this.semicolon()), this.finishNode(node, "ReturnStatement");
          }
          parseSwitchStatement(node) {
            this.next(), node.discriminant = this.parseHeaderExpression();
            const cases = node.cases = [];
            let cur;
            this.expect(5), this.state.labels.push(switchLabel2), this.scope.enter(0);
            for (let sawDefault; !this.match(8); )
              if (this.match(61) || this.match(65)) {
                const isCase = this.match(61);
                cur && this.finishNode(cur, "SwitchCase"), cases.push(cur = this.startNode()), cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raise(Errors.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), sawDefault = true, cur.test = null), this.expect(14);
              } else
                cur ? cur.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), cur && this.finishNode(cur, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(node, "SwitchStatement");
          }
          parseThrowStatement(node) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(Errors.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const param = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && "Identifier" === param.type ? 8 : 0), this.checkLVal(param, { in: { type: "CatchClause" }, binding: 9 }), param;
          }
          parseTryStatement(node) {
            if (this.next(), node.block = this.parseBlock(), node.handler = null, this.match(62)) {
              const clause = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), clause.param = this.parseCatchClauseParam(), this.expect(11)) : (clause.param = null, this.scope.enter(0)), clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), node.handler = this.finishNode(clause, "CatchClause");
            }
            return node.finalizer = this.eat(67) ? this.parseBlock() : null, node.handler || node.finalizer || this.raise(Errors.NoCatchOrFinally, { at: node }), this.finishNode(node, "TryStatement");
          }
          parseVarStatement(node, kind, allowMissingInitializer = false) {
            return this.next(), this.parseVar(node, false, kind, allowMissingInitializer), this.semicolon(), this.finishNode(node, "VariableDeclaration");
          }
          parseWhileStatement(node) {
            return this.next(), node.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel2), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(node, "WhileStatement");
          }
          parseWithStatement(node) {
            return this.state.strict && this.raise(Errors.StrictWith, { at: this.state.startLoc }), this.next(), node.object = this.parseHeaderExpression(), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(node, "WithStatement");
          }
          parseEmptyStatement(node) {
            return this.next(), this.finishNode(node, "EmptyStatement");
          }
          parseLabeledStatement(node, maybeName, expr, flags) {
            for (const label of this.state.labels)
              label.name === maybeName && this.raise(Errors.LabelRedeclaration, { at: expr, labelName: maybeName });
            const kind = (token = this.state.type) >= 90 && token <= 92 ? "loop" : this.match(71) ? "switch" : null;
            var token;
            for (let i = this.state.labels.length - 1; i >= 0; i--) {
              const label = this.state.labels[i];
              if (label.statementStart !== node.start)
                break;
              label.statementStart = this.state.start, label.kind = kind;
            }
            return this.state.labels.push({ name: maybeName, kind, statementStart: this.state.start }), node.body = 8 & flags ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
          }
          parseExpressionStatement(node, expr, decorators) {
            return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
          }
          parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
            const node = this.startNode();
            return allowDirectives && this.state.strictErrors.clear(), this.expect(5), createNewLexicalScope && this.scope.enter(0), this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse), createNewLexicalScope && this.scope.exit(), this.finishNode(node, "BlockStatement");
          }
          isValidDirective(stmt) {
            return "ExpressionStatement" === stmt.type && "StringLiteral" === stmt.expression.type && !stmt.expression.extra.parenthesized;
          }
          parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
            const body = node.body = [], directives = node.directives = [];
            this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
          }
          parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
            const oldStrict = this.state.strict;
            let hasStrictModeDirective = false, parsedNonDirective = false;
            for (; !this.match(end); ) {
              const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
              if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                  const directive = this.stmtToDirective(stmt);
                  directives.push(directive), hasStrictModeDirective || "use strict" !== directive.value.value || (hasStrictModeDirective = true, this.setStrict(true));
                  continue;
                }
                parsedNonDirective = true, this.state.strictErrors.clear();
              }
              body.push(stmt);
            }
            null == afterBlockParse || afterBlockParse.call(this, hasStrictModeDirective), oldStrict || this.setStrict(false), this.next();
          }
          parseFor(node, init) {
            return node.init = init, this.semicolon(false), node.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), node.update = this.match(11) ? null : this.parseExpression(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, "ForStatement");
          }
          parseForIn(node, init, awaitAt) {
            const isForIn = this.match(58);
            return this.next(), isForIn ? null !== awaitAt && this.unexpected(awaitAt) : node.await = null !== awaitAt, "VariableDeclaration" !== init.type || null == init.declarations[0].init || isForIn && this.options.annexB && !this.state.strict && "var" === init.kind && "Identifier" === init.declarations[0].id.type || this.raise(Errors.ForInOfLoopInitializer, { at: init, type: isForIn ? "ForInStatement" : "ForOfStatement" }), "AssignmentPattern" === init.type && this.raise(Errors.InvalidLhs, { at: init, ancestor: { type: "ForStatement" } }), node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(node, isFor, kind, allowMissingInitializer = false) {
            const declarations = node.declarations = [];
            for (node.kind = kind; ; ) {
              const decl = this.startNode();
              if (this.parseVarId(decl, kind), decl.init = this.eat(29) ? isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, null !== decl.init || allowMissingInitializer || ("Identifier" === decl.id.type || isFor && (this.match(58) || this.isContextual(101)) ? "const" !== kind || this.match(58) || this.isContextual(101) || this.raise(Errors.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" }) : this.raise(Errors.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" })), declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(12))
                break;
            }
            return node;
          }
          parseVarId(decl, kind) {
            const id = this.parseBindingAtom();
            this.checkLVal(id, { in: { type: "VariableDeclarator" }, binding: "var" === kind ? 5 : 8201 }), decl.id = id;
          }
          parseAsyncFunctionExpression(node) {
            return this.parseFunction(node, 8);
          }
          parseFunction(node, flags = 0) {
            const hangingDeclaration = 2 & flags, isDeclaration = !!(1 & flags), requireId = isDeclaration && !(4 & flags), isAsync = !!(8 & flags);
            this.initFunction(node, isAsync), this.match(55) && (hangingDeclaration && this.raise(Errors.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), node.generator = true), isDeclaration && (node.id = this.parseFunctionId(requireId));
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(functionFlags2(isAsync, node.generator)), isDeclaration || (node.id = this.parseFunctionId()), this.parseFunctionParams(node, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), isDeclaration && !hangingDeclaration && this.registerFunctionStatementId(node), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node;
          }
          parseFunctionId(requireId) {
            return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(node, isConstructor) {
            this.expect(10), this.expressionScope.enter(new ExpressionScope(3)), node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(node) {
            node.id && this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
          }
          parseClass(node, isStatement, optionalId) {
            this.next();
            const oldStrict = this.state.strict;
            return this.state.strict = true, this.parseClassId(node, isStatement, optionalId), this.parseClassSuper(node), node.body = this.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          isNonstaticConstructor(method) {
            return !(method.computed || method.static || "constructor" !== method.key.name && "constructor" !== method.key.value);
          }
          parseClassBody(hadSuperClass, oldStrict) {
            this.classScope.enter();
            const state = { hadConstructor: false, hadSuperClass };
            let decorators = [];
            const classBody = this.startNode();
            if (classBody.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (decorators.length > 0)
                    throw this.raise(Errors.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                  continue;
                }
                if (this.match(26)) {
                  decorators.push(this.parseDecorator());
                  continue;
                }
                const member = this.startNode();
                decorators.length && (member.decorators = decorators, this.resetStartLocationFromNode(member, decorators[0]), decorators = []), this.parseClassMember(classBody, member, state), "constructor" === member.kind && member.decorators && member.decorators.length > 0 && this.raise(Errors.DecoratorConstructor, { at: member });
              }
            }), this.state.strict = oldStrict, this.next(), decorators.length)
              throw this.raise(Errors.TrailingDecorator, { at: this.state.startLoc });
            return this.classScope.exit(), this.finishNode(classBody, "ClassBody");
          }
          parseClassMemberFromModifier(classBody, member) {
            const key = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const method = member;
              return method.kind = "method", method.computed = false, method.key = key, method.static = false, this.pushClassMethod(classBody, method, false, false, false, false), true;
            }
            if (this.isClassProperty()) {
              const prop = member;
              return prop.computed = false, prop.key = key, prop.static = false, classBody.body.push(this.parseClassProperty(prop)), true;
            }
            return this.resetPreviousNodeTrailingComments(key), false;
          }
          parseClassMember(classBody, member, state) {
            const isStatic = this.isContextual(104);
            if (isStatic) {
              if (this.parseClassMemberFromModifier(classBody, member))
                return;
              if (this.eat(5))
                return void this.parseClassStaticBlock(classBody, member);
            }
            this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
          parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const publicMethod = member, privateMethod = member, publicProp = member, privateProp = member, accessorProp = member, method = publicMethod, publicMember = publicMethod;
            if (member.static = isStatic, this.parsePropertyNamePrefixOperator(member), this.eat(55)) {
              method.kind = "method";
              const isPrivateName = this.match(136);
              return this.parseClassElementName(method), isPrivateName ? void this.pushClassPrivateMethod(classBody, privateMethod, true, false) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsGenerator, { at: publicMethod.key }), void this.pushClassMethod(classBody, publicMethod, true, false, false, false));
            }
            const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc, isPrivate = this.match(136), key = this.parseClassElementName(member), maybeQuestionTokenStartLoc = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(publicMember), this.isClassMethod()) {
              if (method.kind = "method", isPrivate)
                return void this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              const isConstructor = this.isNonstaticConstructor(publicMethod);
              let allowsDirectSuper = false;
              isConstructor && (publicMethod.kind = "constructor", state.hadConstructor && !this.hasPlugin("typescript") && this.raise(Errors.DuplicateConstructor, { at: key }), isConstructor && this.hasPlugin("typescript") && member.override && this.raise(Errors.OverrideOnConstructor, { at: key }), state.hadConstructor = true, allowsDirectSuper = state.hadSuperClass), this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
            } else if (this.isClassProperty())
              isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp);
            else if (isContextual && "async" === key.name && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(key);
              const isGenerator = this.eat(55);
              publicMember.optional && this.unexpected(maybeQuestionTokenStartLoc), method.kind = "method";
              const isPrivate2 = this.match(136);
              this.parseClassElementName(method), this.parsePostMemberNameModifiers(publicMember), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAsync, { at: publicMethod.key }), this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false));
            } else if (!isContextual || "get" !== key.name && "set" !== key.name || this.match(55) && this.isLineTerminator())
              if (isContextual && "accessor" === key.name && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(key);
                const isPrivate2 = this.match(136);
                this.parseClassElementName(publicProp), this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
              } else
                this.isLineTerminator() ? isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp) : this.unexpected();
            else {
              this.resetPreviousNodeTrailingComments(key), method.kind = key.name;
              const isPrivate2 = this.match(136);
              this.parseClassElementName(publicMethod), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, false, false) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAccessor, { at: publicMethod.key }), this.pushClassMethod(classBody, publicMethod, false, false, false, false)), this.checkGetterSetterParams(publicMethod);
            }
          }
          parseClassElementName(member) {
            const { type, value: value2 } = this.state;
            if (130 !== type && 131 !== type || !member.static || "prototype" !== value2 || this.raise(Errors.StaticPrototype, { at: this.state.startLoc }), 136 === type) {
              "constructor" === value2 && this.raise(Errors.ConstructorClassPrivateField, { at: this.state.startLoc });
              const key = this.parsePrivateName();
              return member.key = key, key;
            }
            return this.parsePropertyName(member);
          }
          parseClassStaticBlock(classBody, member) {
            var _member$decorators;
            this.scope.enter(208);
            const oldLabels = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const body = member.body = [];
            this.parseBlockOrModuleBlockBody(body, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = oldLabels, classBody.body.push(this.finishNode(member, "StaticBlock")), null != (_member$decorators = member.decorators) && _member$decorators.length && this.raise(Errors.DecoratorStaticBlock, { at: member });
          }
          pushClassProperty(classBody, prop) {
            prop.computed || "constructor" !== prop.key.name && "constructor" !== prop.key.value || this.raise(Errors.ConstructorClassField, { at: prop.key }), classBody.body.push(this.parseClassProperty(prop));
          }
          pushClassPrivateProperty(classBody, prop) {
            const node = this.parseClassPrivateProperty(prop);
            classBody.body.push(node), this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
          }
          pushClassAccessorProperty(classBody, prop, isPrivate) {
            if (!isPrivate && !prop.computed) {
              const key = prop.key;
              "constructor" !== key.name && "constructor" !== key.value || this.raise(Errors.ConstructorClassField, { at: key });
            }
            const node = this.parseClassAccessorProperty(prop);
            classBody.body.push(node), isPrivate && this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
            classBody.body.push(node);
            const kind = "get" === node.kind ? node.static ? 6 : 2 : "set" === node.kind ? node.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(node, kind);
          }
          declareClassPrivateMethodInScope(node, kind) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
          }
          parsePostMemberNameModifiers(methodOrProp) {
          }
          parseClassPrivateProperty(node) {
            return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassPrivateProperty");
          }
          parseClassProperty(node) {
            return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassProperty");
          }
          parseClassAccessorProperty(node) {
            return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassAccessorProperty");
          }
          parseInitializer(node) {
            this.scope.enter(80), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(node, isStatement, optionalId, bindingType = 8331) {
            if (tokenIsIdentifier(this.state.type))
              node.id = this.parseIdentifier(), isStatement && this.declareNameFromIdentifier(node.id, bindingType);
            else {
              if (!optionalId && isStatement)
                throw this.raise(Errors.MissingClassName, { at: this.state.startLoc });
              node.id = null;
            }
          }
          parseClassSuper(node) {
            node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(node, decorators) {
            const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true), hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier), parseAfterDefault = !hasDefault || this.eat(12), hasStar = parseAfterDefault && this.eatExportStar(node), hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node), parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12)), isFromRequired = hasDefault || hasStar;
            if (hasStar && !hasNamespace) {
              if (hasDefault && this.unexpected(), decorators)
                throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });
              return this.parseExportFrom(node, true), this.finishNode(node, "ExportAllDeclaration");
            }
            const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
            let hasDeclaration;
            if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers && this.unexpected(null, 5), hasNamespace && parseAfterNamespace && this.unexpected(null, 97), isFromRequired || hasSpecifiers) {
              if (hasDeclaration = false, decorators)
                throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });
              this.parseExportFrom(node, isFromRequired);
            } else
              hasDeclaration = this.maybeParseExportDeclaration(node);
            if (isFromRequired || hasSpecifiers || hasDeclaration) {
              var _node2$declaration;
              const node2 = node;
              if (this.checkExport(node2, true, false, !!node2.source), "ClassDeclaration" === (null == (_node2$declaration = node2.declaration) ? void 0 : _node2$declaration.type))
                this.maybeTakeDecorators(decorators, node2.declaration, node2);
              else if (decorators)
                throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });
              return this.finishNode(node2, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              const node2 = node, decl = this.parseExportDefaultExpression();
              if (node2.declaration = decl, "ClassDeclaration" === decl.type)
                this.maybeTakeDecorators(decorators, decl, node2);
              else if (decorators)
                throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });
              return this.checkExport(node2, true, true), this.finishNode(node2, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(node) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
            if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", null == maybeDefaultIdentifier ? void 0 : maybeDefaultIdentifier.loc.start);
              const id = maybeDefaultIdentifier || this.parseIdentifier(true), specifier = this.startNodeAtNode(id);
              return specifier.exported = id, node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(node) {
            if (this.isContextual(93)) {
              node.specifiers || (node.specifiers = []);
              const specifier = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), specifier.exported = this.parseModuleExportName(), node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(node) {
            if (this.match(5)) {
              node.specifiers || (node.specifiers = []);
              const isTypeExport = "type" === node.exportKind;
              return node.specifiers.push(...this.parseExportSpecifiers(isTypeExport)), node.source = null, node.declaration = null, this.hasPlugin("importAssertions") && (node.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(node) {
            return !!this.shouldParseExportDeclaration() && (node.specifiers = [], node.source = null, this.hasPlugin("importAssertions") && (node.assertions = []), node.declaration = this.parseExportDeclaration(node), true);
          }
          isAsyncFunction() {
            if (!this.isContextual(95))
              return false;
            const next = this.nextTokenInLineStart();
            return this.isUnparsedContextual(next, "function");
          }
          parseExportDefaultExpression() {
            const expr = this.startNode();
            if (this.match(68))
              return this.next(), this.parseFunction(expr, 5);
            if (this.isAsyncFunction())
              return this.next(), this.next(), this.parseFunction(expr, 13);
            if (this.match(80))
              return this.parseClass(expr, true, true);
            if (this.match(26))
              return this.hasPlugin("decorators") && true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(Errors.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet())
              throw this.raise(Errors.UnsupportedDefaultExport, { at: this.state.startLoc });
            const res = this.parseMaybeAssignAllowIn();
            return this.semicolon(), res;
          }
          parseExportDeclaration(node) {
            if (this.match(80)) {
              return this.parseClass(this.startNode(), true, false);
            }
            return this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            const { type } = this.state;
            if (tokenIsIdentifier(type)) {
              if (95 === type && !this.state.containsEsc || 99 === type)
                return false;
              if ((128 === type || 127 === type) && !this.state.containsEsc) {
                const { type: nextType } = this.lookahead();
                if (tokenIsIdentifier(nextType) && 97 !== nextType || 5 === nextType)
                  return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65))
              return false;
            const next = this.nextTokenStart(), hasFrom = this.isUnparsedContextual(next, "from");
            if (44 === this.input.charCodeAt(next) || tokenIsIdentifier(this.state.type) && hasFrom)
              return true;
            if (this.match(65) && hasFrom) {
              const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
              return 34 === nextAfterFrom || 39 === nextAfterFrom;
            }
            return false;
          }
          parseExportFrom(node, expect) {
            this.eatContextual(97) ? (node.source = this.parseImportSource(), this.checkExport(node), this.maybeParseImportAttributes(node), this.checkJSONModuleImport(node)) : expect && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type } = this.state;
            return 26 === type && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(Errors.DecoratorBeforeExport, { at: this.state.startLoc }), true) : 74 === type || 75 === type || 68 === type || 80 === type || this.isLet() || this.isAsyncFunction();
          }
          checkExport(node, checkNames, isDefault, isFrom) {
            if (checkNames) {
              if (isDefault) {
                if (this.checkDuplicateExports(node, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var _declaration$extra;
                  const declaration = node.declaration;
                  "Identifier" !== declaration.type || "from" !== declaration.name || declaration.end - declaration.start != 4 || null != (_declaration$extra = declaration.extra) && _declaration$extra.parenthesized || this.raise(Errors.ExportDefaultFromAsIdentifier, { at: declaration });
                }
              } else if (node.specifiers && node.specifiers.length)
                for (const specifier of node.specifiers) {
                  const { exported } = specifier, exportName = "Identifier" === exported.type ? exported.name : exported.value;
                  if (this.checkDuplicateExports(specifier, exportName), !isFrom && specifier.local) {
                    const { local } = specifier;
                    "Identifier" !== local.type ? this.raise(Errors.ExportBindingIsString, { at: specifier, localName: local.value, exportName }) : (this.checkReservedWord(local.name, local.loc.start, true, false), this.scope.checkLocalExport(local));
                  }
                }
              else if (node.declaration) {
                if ("FunctionDeclaration" === node.declaration.type || "ClassDeclaration" === node.declaration.type) {
                  const id = node.declaration.id;
                  if (!id)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(node, id.name);
                } else if ("VariableDeclaration" === node.declaration.type)
                  for (const declaration of node.declaration.declarations)
                    this.checkDeclaration(declaration.id);
              }
            }
          }
          checkDeclaration(node) {
            if ("Identifier" === node.type)
              this.checkDuplicateExports(node, node.name);
            else if ("ObjectPattern" === node.type)
              for (const prop of node.properties)
                this.checkDeclaration(prop);
            else if ("ArrayPattern" === node.type)
              for (const elem of node.elements)
                elem && this.checkDeclaration(elem);
            else
              "ObjectProperty" === node.type ? this.checkDeclaration(node.value) : "RestElement" === node.type ? this.checkDeclaration(node.argument) : "AssignmentPattern" === node.type && this.checkDeclaration(node.left);
          }
          checkDuplicateExports(node, exportName) {
            this.exportedIdentifiers.has(exportName) && ("default" === exportName ? this.raise(Errors.DuplicateDefaultExport, { at: node }) : this.raise(Errors.DuplicateExport, { at: node, exportName })), this.exportedIdentifiers.add(exportName);
          }
          parseExportSpecifiers(isInTypeExport) {
            const nodes = [];
            let first = true;
            for (this.expect(5); !this.eat(8); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.eat(8))
                break;
              const isMaybeTypeOnly = this.isContextual(128), isString = this.match(131), node = this.startNode();
              node.local = this.parseModuleExportName(), nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
            }
            return nodes;
          }
          parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
            return this.eatContextual(93) ? node.exported = this.parseModuleExportName() : isString ? node.exported = cloneStringLiteral(node.local) : node.exported || (node.exported = cloneIdentifier(node.local)), this.finishNode(node, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(131)) {
              const result = this.parseStringLiteral(this.state.value), surrogate = result.value.match(loneSurrogate2);
              return surrogate && this.raise(Errors.ModuleExportNameHasLoneSurrogate, { at: result, surrogateCharCode: surrogate[0].charCodeAt(0) }), result;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(node) {
            return null != node.assertions && node.assertions.some(({ key, value: value2 }) => "json" === value2.value && ("Identifier" === key.type ? "type" === key.name : "type" === key.value));
          }
          checkImportReflection(node) {
            var _node$assertions;
            node.module && (1 === node.specifiers.length && "ImportDefaultSpecifier" === node.specifiers[0].type || this.raise(Errors.ImportReflectionNotBinding, { at: node.specifiers[0].loc.start }), (null == (_node$assertions = node.assertions) ? void 0 : _node$assertions.length) > 0 && this.raise(Errors.ImportReflectionHasAssertion, { at: node.specifiers[0].loc.start }));
          }
          checkJSONModuleImport(node) {
            if (this.isJSONModuleImport(node) && "ExportAllDeclaration" !== node.type) {
              const { specifiers } = node;
              if (null != specifiers) {
                const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                  let imported;
                  if ("ExportSpecifier" === specifier.type ? imported = specifier.local : "ImportSpecifier" === specifier.type && (imported = specifier.imported), void 0 !== imported)
                    return "Identifier" === imported.type ? "default" !== imported.name : "default" !== imported.value;
                });
                void 0 !== nonDefaultNamedSpecifier && this.raise(Errors.ImportJSONBindingNotDefault, { at: nonDefaultNamedSpecifier.loc.start });
              }
            }
          }
          isPotentialImportPhase(isExport) {
            return !isExport && this.isContextual(125);
          }
          applyImportPhase(node, isExport, phase, loc) {
            isExport || ("module" === phase ? (this.expectPlugin("importReflection", loc), node.module = true) : this.hasPlugin("importReflection") && (node.module = false));
          }
          parseMaybeImportPhase(node, isExport) {
            if (!this.isPotentialImportPhase(isExport))
              return this.applyImportPhase(node, isExport, null), null;
            const phaseIdentifier = this.parseIdentifier(true), { type } = this.state;
            return (tokenIsKeywordOrIdentifier(type) ? 97 !== type || 102 === this.lookaheadCharCode() : 12 !== type) ? (this.resetPreviousIdentifierLeadingComments(phaseIdentifier), this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start), null) : (this.applyImportPhase(node, isExport, null), phaseIdentifier);
          }
          isPrecedingIdImportPhase(phase) {
            const { type } = this.state;
            return tokenIsIdentifier(type) ? 97 !== type || 102 === this.lookaheadCharCode() : 12 !== type;
          }
          parseImport(node) {
            return this.match(131) ? this.parseImportSourceAndAttributes(node) : this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
          }
          parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
            node.specifiers = [];
            const parseNext = !this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) || this.eat(12), hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
            return parseNext && !hasStar && this.parseNamedImportSpecifiers(node), this.expectContextual(97), this.parseImportSourceAndAttributes(node);
          }
          parseImportSourceAndAttributes(node) {
            return null != node.specifiers || (node.specifiers = []), node.source = this.parseImportSource(), this.maybeParseImportAttributes(node), this.checkImportReflection(node), this.checkJSONModuleImport(node), this.semicolon(), this.finishNode(node, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(131) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(node, specifier, type) {
            specifier.local = this.parseIdentifier(), node.specifiers.push(this.finishImportSpecifier(specifier, type));
          }
          finishImportSpecifier(specifier, type, bindingType = 8201) {
            return this.checkLVal(specifier.local, { in: { type }, binding: bindingType }), this.finishNode(specifier, type);
          }
          parseImportAttributes() {
            this.expect(5);
            const attrs = [], attrNames = /* @__PURE__ */ new Set();
            do {
              if (this.match(8))
                break;
              const node = this.startNode(), keyName = this.state.value;
              if (attrNames.has(keyName) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: keyName }), attrNames.add(keyName), this.match(131) ? node.key = this.parseStringLiteral(keyName) : node.key = this.parseIdentifier(true), this.expect(14), !this.match(131))
                throw this.raise(Errors.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              node.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), attrs;
          }
          parseModuleAttributes() {
            const attrs = [], attributes = /* @__PURE__ */ new Set();
            do {
              const node = this.startNode();
              if (node.key = this.parseIdentifier(true), "type" !== node.key.name && this.raise(Errors.ModuleAttributeDifferentFromType, { at: node.key }), attributes.has(node.key.name) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, { at: node.key, key: node.key.name }), attributes.add(node.key.name), this.expect(14), !this.match(131))
                throw this.raise(Errors.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              node.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node, "ImportAttribute"));
            } while (this.eat(12));
            return attrs;
          }
          maybeParseImportAttributes(node) {
            let attributes, useWith = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode())
                return;
              this.next(), this.hasPlugin("moduleAttributes") ? attributes = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), attributes = this.parseImportAttributes()), useWith = true;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
              this.hasPlugin("importAttributes") ? (true !== this.getPluginOption("importAttributes", "deprecatedAssertSyntax") && this.raise(Errors.ImportAttributesUseAssert, { at: this.state.startLoc }), this.addExtra(node, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), attributes = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
              attributes = [];
            else {
              if (!this.hasPlugin("moduleAttributes"))
                return;
              attributes = [];
            }
            !useWith && this.hasPlugin("importAssertions") ? node.assertions = attributes : node.attributes = attributes;
          }
          maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
            if (maybeDefaultIdentifier) {
              const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
              return specifier.local = maybeDefaultIdentifier, node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier")), true;
            }
            return !!tokenIsKeywordOrIdentifier(this.state.type) && (this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier"), true);
          }
          maybeParseStarImportSpecifier(node) {
            if (this.match(55)) {
              const specifier = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(node) {
            let first = true;
            for (this.expect(5); !this.eat(8); ) {
              if (first)
                first = false;
              else {
                if (this.eat(14))
                  throw this.raise(Errors.DestructureNamedImport, { at: this.state.startLoc });
                if (this.expect(12), this.eat(8))
                  break;
              }
              const specifier = this.startNode(), importedIsString = this.match(131), isMaybeTypeOnly = this.isContextual(128);
              specifier.imported = this.parseModuleExportName();
              const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, "type" === node.importKind || "typeof" === node.importKind, isMaybeTypeOnly, void 0);
              node.specifiers.push(importSpecifier);
            }
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
            if (this.eatContextual(93))
              specifier.local = this.parseIdentifier();
            else {
              const { imported } = specifier;
              if (importedIsString)
                throw this.raise(Errors.ImportBindingIsString, { at: specifier, importName: imported.value });
              this.checkReservedWord(imported.name, specifier.loc.start, true, true), specifier.local || (specifier.local = cloneIdentifier(imported));
            }
            return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
          }
          isThisParam(param) {
            return "Identifier" === param.type && "this" === param.name;
          }
        }
        class Parser3 extends StatementParser {
          constructor(options, input) {
            super(options = function(opts) {
              if (opts && null != opts.annexB && false !== opts.annexB)
                throw new Error("The `annexB` option can only be set to `false`.");
              const options2 = {};
              for (const key of Object.keys(defaultOptions2))
                options2[key] = opts && null != opts[key] ? opts[key] : defaultOptions2[key];
              return options2;
            }(options), input), this.options = options, this.initializeScopes(), this.plugins = function(plugins) {
              const pluginMap = /* @__PURE__ */ new Map();
              for (const plugin of plugins) {
                const [name, options2] = Array.isArray(plugin) ? plugin : [plugin, {}];
                pluginMap.has(name) || pluginMap.set(name, options2 || {});
              }
              return pluginMap;
            }(this.options.plugins), this.filename = options.sourceFilename;
          }
          getScopeHandler() {
            return ScopeHandler;
          }
          parse() {
            this.enterInitialScopes();
            const file = this.startNode(), program = this.startNode();
            return this.nextToken(), file.errors = null, this.parseTopLevel(file, program), file.errors = this.state.errors, file;
          }
        }
        const tokTypes = function(internalTokenTypes) {
          const tokenTypes2 = {};
          for (const typeName of Object.keys(internalTokenTypes))
            tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
          return tokenTypes2;
        }(tt);
        function getParser(options, input) {
          let cls = Parser3;
          return null != options && options.plugins && (!function(plugins) {
            if (hasPlugin(plugins, "decorators")) {
              if (hasPlugin(plugins, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
              if (null != decoratorsBeforeExport && "boolean" != typeof decoratorsBeforeExport)
                throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
              const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
              if (null != allowCallParenthesized && "boolean" != typeof allowCallParenthesized)
                throw new Error("'allowCallParenthesized' must be a boolean.");
            }
            if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (hasPlugin(plugins, "pipelineOperator")) {
              const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
              if (!PIPELINE_PROPOSALS.includes(proposal)) {
                const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
              }
              const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", { syntaxType: "hash" }]);
              if ("hack" === proposal) {
                if (hasPlugin(plugins, "placeholders"))
                  throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (hasPlugin(plugins, "v8intrinsic"))
                  throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
                if (!TOPIC_TOKENS.includes(topicToken)) {
                  const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
                }
                if ("#" === topicToken && tupleSyntaxIsHash)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if ("smart" === proposal && tupleSyntaxIsHash)
                throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (hasPlugin(plugins, "moduleAttributes")) {
              if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes"))
                throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
              if ("may-2020" !== getPluginOption(plugins, "moduleAttributes", "version"))
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes"))
              throw new Error("Cannot combine importAssertions and importAttributes plugins.");
            if (hasPlugin(plugins, "recordAndTuple") && null != getPluginOption(plugins, "recordAndTuple", "syntaxType") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType")))
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
              const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw error.missingPlugins = "doExpressions", error;
            }
          }(options.plugins), cls = function(pluginsFromOptions) {
            const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name)), key = pluginList.join("/");
            let cls2 = parserClassCache[key];
            if (!cls2) {
              cls2 = Parser3;
              for (const plugin of pluginList)
                cls2 = mixinPlugins[plugin](cls2);
              parserClassCache[key] = cls2;
            }
            return cls2;
          }(options.plugins)), new cls(options, input);
        }
        const parserClassCache = {};
        exports3.parse = function(input, options) {
          var _options;
          if ("unambiguous" !== (null == (_options = options) ? void 0 : _options.sourceType))
            return getParser(options, input).parse();
          options = Object.assign({}, options);
          try {
            options.sourceType = "module";
            const parser = getParser(options, input), ast = parser.parse();
            if (parser.sawUnambiguousESM)
              return ast;
            if (parser.ambiguousScriptDifferentAst)
              try {
                return options.sourceType = "script", getParser(options, input).parse();
              } catch (_unused) {
              }
            else
              ast.program.sourceType = "script";
            return ast;
          } catch (moduleError) {
            try {
              return options.sourceType = "script", getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        }, exports3.parseExpression = function(input, options) {
          const parser = getParser(options, input);
          return parser.options.strictMode && (parser.state.strict = true), parser.getExpression();
        }, exports3.tokTypes = tokTypes;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-decorators/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), _pluginSyntaxDecorators = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-decorators/lib/index.js"), _helperCreateClassFeaturesPlugin = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), _transformerLegacy = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js"), _transformer = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-decorators/lib/transformer-2023-05.js"), _default = (0, _helperPluginUtils.declare)((api, options) => {
          api.assertVersion(7);
          var { legacy } = options;
          const { version: version2 } = options;
          return legacy || "legacy" === version2 ? { name: "proposal-decorators", inherits: _pluginSyntaxDecorators.default, visitor: _transformerLegacy.default } : "2021-12" === version2 || "2022-03" === version2 || "2023-01" === version2 || "2023-05" === version2 ? (0, _transformer.default)(api, options, version2) : (api.assertVersion("^7.0.2"), (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({ name: "proposal-decorators", api, feature: _helperCreateClassFeaturesPlugin.FEATURES.decorators, inherits: _pluginSyntaxDecorators.default }));
        });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-decorators/lib/transformer-2023-05.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function({ assertVersion, assumption }, { loose }, version2) {
          var _assumption;
          assertVersion("2023-05" === version2 || "2023-01" === version2 ? "^7.21.0" : "2021-12" === version2 ? "^7.16.0" : "^7.19.0");
          const VISITED = /* @__PURE__ */ new WeakSet(), constantSuper = null != (_assumption = assumption("constantSuper")) ? _assumption : loose;
          return { name: "proposal-decorators", inherits: _pluginSyntaxDecorators.default, visitor: { "ExportNamedDeclaration|ExportDefaultDeclaration"(path3) {
            var _declaration$decorato;
            const { declaration } = path3.node;
            "ClassDeclaration" === (null == declaration ? void 0 : declaration.type) && (null == (_declaration$decorato = declaration.decorators) ? void 0 : _declaration$decorato.length) > 0 && (0, _helperSplitExportDeclaration.default)(path3);
          }, Class(path3, state) {
            if (VISITED.has(path3))
              return;
            const newPath = function(path4, state2, constantSuper2, version3) {
              const body = path4.get("body.body"), classDecorators = path4.node.decorators;
              let hasElementDecorators = false;
              const generateClassPrivateUid = function(classPath) {
                let generator;
                return () => (generator || (generator = function(classPath2) {
                  const currentPrivateId = [], privateNames = /* @__PURE__ */ new Set();
                  return classPath2.traverse({ PrivateName(path5) {
                    privateNames.add(path5.node.id.name);
                  } }), () => {
                    let reifiedId;
                    do {
                      incrementId(currentPrivateId), reifiedId = String.fromCharCode(...currentPrivateId);
                    } while (privateNames.has(reifiedId));
                    return _core.types.privateName(_core.types.identifier(reifiedId));
                  };
                }(classPath)), generator());
              }(path4);
              for (const element of body)
                if (isClassDecoratableElementPath(element)) {
                  if (element.node.decorators && element.node.decorators.length > 0)
                    hasElementDecorators = true;
                  else if ("ClassAccessorProperty" === element.node.type) {
                    const { key, value: value2, static: isStatic, computed } = element.node, newId = generateClassPrivateUid(), newField = generateClassProperty(newId, value2 ? _core.types.cloneNode(value2) : void 0, isStatic), [newPath2] = element.replaceWith(newField);
                    addProxyAccessorsFor(path4.node.id, newPath2, key, newId, version3, computed);
                  }
                }
              if (!classDecorators && !hasElementDecorators)
                return;
              const elementDecoratorInfo = [];
              let firstFieldPath, constructorPath, requiresProtoInit = false, requiresStaticInit = false;
              const decoratedPrivateMethods = /* @__PURE__ */ new Set();
              let protoInitLocal, staticInitLocal, classInitLocal, classIdLocal;
              const assignments = [], scopeParent = path4.scope.parent, memoiseExpression = (expression, hint) => {
                const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);
                return assignments.push(_core.types.assignmentExpression("=", localEvaluatedId, expression)), _core.types.cloneNode(localEvaluatedId);
              }, decoratorsThis = /* @__PURE__ */ new Map(), maybeExtractDecorator = (decorator) => {
                const { expression } = decorator;
                if ("2023-05" === version3 && _core.types.isMemberExpression(expression)) {
                  let object;
                  _core.types.isSuper(expression.object) || _core.types.isThisExpression(expression.object) ? object = memoiseExpression(_core.types.thisExpression(), "obj") : scopeParent.isStatic(expression.object) ? object = expression.object : (object = memoiseExpression(expression.object, "obj"), expression.object = object), decoratorsThis.set(decorator, _core.types.cloneNode(object));
                }
                scopeParent.isStatic(expression) || (decorator.expression = memoiseExpression(expression, "dec"));
              };
              if (classDecorators) {
                classInitLocal = scopeParent.generateDeclaredUidIdentifier("initClass");
                const [classId, classPath] = function(path5) {
                  if ("ClassDeclaration" === path5.type) {
                    const varId = path5.scope.generateUidIdentifierBasedOnNode(path5.node.id), classId2 = _core.types.identifier(path5.node.id.name);
                    return path5.scope.rename(classId2.name, varId.name), path5.insertBefore(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(varId)])), path5.get("id").replaceWith(classId2), [_core.types.cloneNode(varId), path5];
                  }
                  {
                    let className, varId;
                    path5.node.id ? (className = path5.node.id.name, varId = path5.scope.parent.generateDeclaredUidIdentifier(className), path5.scope.rename(className, varId.name)) : "VariableDeclarator" === path5.parentPath.node.type && "Identifier" === path5.parentPath.node.id.type ? (className = path5.parentPath.node.id.name, varId = path5.scope.parent.generateDeclaredUidIdentifier(className)) : varId = path5.scope.parent.generateDeclaredUidIdentifier("decorated_class");
                    const newClassExpr = _core.types.classExpression(className && _core.types.identifier(className), path5.node.superClass, path5.node.body), [newPath2] = path5.replaceWith(_core.types.sequenceExpression([newClassExpr, varId]));
                    return [_core.types.cloneNode(varId), newPath2.get("expressions.0")];
                  }
                }(path4);
                classIdLocal = classId, (path4 = classPath).node.decorators = null;
                for (const classDecorator of classDecorators)
                  maybeExtractDecorator(classDecorator);
              } else
                path4.node.id || (path4.node.id = path4.scope.generateUidIdentifier("Class")), classIdLocal = _core.types.cloneNode(path4.node.id);
              let lastInstancePrivateName, needsInstancePrivateBrandCheck = false;
              if (hasElementDecorators)
                for (const element of body) {
                  if (!isClassDecoratableElementPath(element))
                    continue;
                  const { node } = element, decorators = element.get("decorators"), hasDecorators = Array.isArray(decorators) && decorators.length > 0;
                  if (hasDecorators)
                    for (const decoratorPath of decorators)
                      maybeExtractDecorator(decoratorPath.node);
                  const isComputed = "computed" in element.node && true === element.node.computed;
                  isComputed && (scopeParent.isStatic(node.key) || (node.key = memoiseExpression(node.key, "computedKey")));
                  const kind = getElementKind(element), { key } = node, isPrivate = "PrivateName" === key.type, isStatic = !!element.node.static;
                  let name = "computedKey";
                  if (isPrivate ? name = key.id.name : isComputed || "Identifier" !== key.type || (name = key.name), isPrivate && !isStatic && (hasDecorators && (needsInstancePrivateBrandCheck = true), !_core.types.isClassPrivateProperty(node) && lastInstancePrivateName || (lastInstancePrivateName = key)), element.isClassMethod({ kind: "constructor" }) && (constructorPath = element), hasDecorators) {
                    let locals, privateMethods, nameExpr;
                    if (kind === ACCESSOR) {
                      const { value: value2 } = element.node, params = [_core.types.thisExpression()];
                      value2 && params.push(_core.types.cloneNode(value2));
                      const newId = generateClassPrivateUid(), newFieldInitId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`), newField = generateClassProperty(newId, _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params), isStatic), [newPath2] = element.replaceWith(newField);
                      if (isPrivate) {
                        privateMethods = extractProxyAccessorsFor(newId, version3);
                        const getId = newPath2.scope.parent.generateDeclaredUidIdentifier(`get_${name}`), setId = newPath2.scope.parent.generateDeclaredUidIdentifier(`set_${name}`);
                        addCallAccessorsFor(newPath2, key, getId, setId), locals = [newFieldInitId, getId, setId];
                      } else
                        addProxyAccessorsFor(path4.node.id, newPath2, key, newId, version3, isComputed), locals = newFieldInitId;
                    } else if (kind === FIELD) {
                      const initId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`), valuePath = element.get("value");
                      valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), [_core.types.thisExpression(), valuePath.node].filter((v) => v))), locals = initId, isPrivate && (privateMethods = extractProxyAccessorsFor(key, version3));
                    } else if (isPrivate) {
                      locals = element.scope.parent.generateDeclaredUidIdentifier(`call_${name}`);
                      new _helperReplaceSupers.default({ constantSuper: constantSuper2, methodPath: element, objectRef: classIdLocal, superRef: path4.node.superClass, file: state2.file, refToPreserve: classIdLocal }).replace();
                      const { params, body: body2, async: isAsync } = element.node;
                      if (privateMethods = [_core.types.functionExpression(void 0, params.filter(isNotTsParameter), body2, isAsync)], kind === GETTER || kind === SETTER)
                        movePrivateAccessor(element, _core.types.cloneNode(key), _core.types.cloneNode(locals), isStatic);
                      else {
                        const node2 = element.node;
                        path4.node.body.body.unshift(_core.types.classPrivateProperty(key, _core.types.cloneNode(locals), [], node2.static)), decoratedPrivateMethods.add(key.id.name), element.remove();
                      }
                    }
                    nameExpr = isComputed ? _core.types.cloneNode(key) : "PrivateName" === key.type ? _core.types.stringLiteral(key.id.name) : "Identifier" === key.type ? _core.types.stringLiteral(key.name) : _core.types.cloneNode(key), elementDecoratorInfo.push({ kind, decorators: decorators.map((d) => d.node.expression), decoratorsThis: decorators.map((d) => decoratorsThis.get(d.node)), name: nameExpr, isStatic, privateMethods, locals }), kind !== FIELD && (isStatic ? requiresStaticInit = true : requiresProtoInit = true), element.node && (element.node.decorators = null), firstFieldPath || isStatic || kind !== FIELD && kind !== ACCESSOR || (firstFieldPath = element);
                  }
                }
              const elementDecorations = function(info, version4) {
                return _core.types.arrayExpression(filteredOrderedDecoratorInfo(info).map((el) => {
                  const { decs, hasThis } = generateDecorationList(el.decorators, el.decoratorsThis, version4);
                  let flag = el.kind;
                  return el.isStatic && (flag += "2023-05" === version4 ? STATIC : STATIC_OLD_VERSION), hasThis && (flag += DECORATORS_HAVE_THIS), _core.types.arrayExpression([1 === decs.length ? decs[0] : _core.types.arrayExpression(decs), _core.types.numericLiteral(flag), el.name, ...el.privateMethods || []]);
                }));
              }(elementDecoratorInfo, version3);
              let classDecorationsFlag = 0, classDecorations = [];
              if (classDecorators) {
                const { hasThis, decs } = generateDecorationList(classDecorators.map((el) => el.expression), classDecorators.map((dec) => decoratorsThis.get(dec)), version3);
                classDecorationsFlag = hasThis ? 1 : 0, classDecorations = decs;
              }
              const elementLocals = function(decorationInfo) {
                const localIds = [];
                for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {
                  const { locals } = el;
                  Array.isArray(locals) ? localIds.push(...locals) : void 0 !== locals && localIds.push(locals);
                }
                return localIds;
              }(elementDecoratorInfo);
              if (requiresProtoInit) {
                protoInitLocal = scopeParent.generateDeclaredUidIdentifier("initProto"), elementLocals.push(protoInitLocal);
                const protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);
                if (firstFieldPath) {
                  const value2 = firstFieldPath.get("value"), body2 = [protoInitCall];
                  value2.node && body2.push(value2.node), value2.replaceWith(_core.types.sequenceExpression(body2));
                } else if (constructorPath)
                  path4.node.superClass ? path4.traverse({ CallExpression: { exit(path5) {
                    path5.get("callee").isSuper() && (path5.replaceWith(_core.types.callExpression(_core.types.cloneNode(protoInitLocal), [path5.node])), path5.skip());
                  } } }) : constructorPath.node.body.body.unshift(_core.types.expressionStatement(protoInitCall));
                else {
                  const body2 = [_core.types.expressionStatement(protoInitCall)];
                  path4.node.superClass && body2.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(), [_core.types.spreadElement(_core.types.identifier("args"))]))), path4.node.body.body.unshift(_core.types.classMethod("constructor", _core.types.identifier("constructor"), [_core.types.restElement(_core.types.identifier("args"))], _core.types.blockStatement(body2)));
                }
              }
              requiresStaticInit && (staticInitLocal = scopeParent.generateDeclaredUidIdentifier("initStatic"), elementLocals.push(staticInitLocal));
              decoratedPrivateMethods.size > 0 && path4.traverse({ PrivateName(path5) {
                if (!decoratedPrivateMethods.has(path5.node.id.name))
                  return;
                const parentPath = path5.parentPath, parentParentPath = parentPath.parentPath;
                if ("AssignmentExpression" === parentParentPath.node.type && parentParentPath.node.left === parentPath.node || "UpdateExpression" === parentParentPath.node.type || "RestElement" === parentParentPath.node.type || "ArrayPattern" === parentParentPath.node.type || "ObjectProperty" === parentParentPath.node.type && parentParentPath.node.value === parentPath.node && "ObjectPattern" === parentParentPath.parentPath.type || "ForOfStatement" === parentParentPath.node.type && parentParentPath.node.left === parentPath.node)
                  throw path5.buildCodeFrameError(`Decorated private methods are not updatable, but "#${path5.node.id.name}" is updated via this expression.`);
              } });
              const classLocals = [];
              let classInitInjected = false;
              const classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []), originalClass = path4.node;
              if (classDecorators) {
                classLocals.push(classIdLocal, classInitLocal);
                const statics = [];
                let staticBlocks = [];
                if (path4.get("body.body").forEach((element) => {
                  if (element.isStaticBlock())
                    return staticBlocks.push(element.node), void element.remove();
                  const isProperty = element.isClassProperty() || element.isClassPrivateProperty();
                  if ((isProperty || element.isClassPrivateMethod()) && element.node.static) {
                    if (isProperty && staticBlocks.length > 0) {
                      const allValues = staticBlocks.map(staticBlockToIIFE);
                      element.node.value && allValues.push(element.node.value), element.node.value = 0 === (exprs = allValues).length ? _core.types.unaryExpression("void", _core.types.numericLiteral(0)) : 1 === exprs.length ? exprs[0] : _core.types.sequenceExpression(exprs), staticBlocks = [];
                    }
                    element.node.static = false, statics.push(element.node), element.remove();
                  }
                  var exprs;
                }), statics.length > 0 || staticBlocks.length > 0) {
                  const staticsClass = _core.template.expression.ast`
        class extends ${state2.addHelper("identity")} {}
      `;
                  staticsClass.body.body = [_core.types.staticBlock([_core.types.toStatement(originalClass, true) || _core.types.expressionStatement(originalClass)]), ...statics];
                  const constructorBody = [], newExpr = _core.types.newExpression(staticsClass, []);
                  staticBlocks.length > 0 && constructorBody.push(...staticBlocks.map(staticBlockToIIFE)), classInitCall && (classInitInjected = true, constructorBody.push(classInitCall)), constructorBody.length > 0 ? (constructorBody.unshift(_core.types.callExpression(_core.types.super(), [_core.types.cloneNode(classIdLocal)])), staticsClass.body.body.push(_core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([_core.types.expressionStatement(_core.types.sequenceExpression(constructorBody))])))) : newExpr.arguments.push(_core.types.cloneNode(classIdLocal)), path4.replaceWith(newExpr);
                }
              }
              !classInitInjected && classInitCall && path4.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));
              return originalClass.body.body.unshift(_core.types.staticBlock([_core.types.expressionStatement(createLocalsAssignment(elementLocals, classLocals, elementDecorations, _core.types.arrayExpression(classDecorations), _core.types.numericLiteral(classDecorationsFlag), needsInstancePrivateBrandCheck ? lastInstancePrivateName : null, state2, version3)), requiresStaticInit && _core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()]))].filter(Boolean))), path4.insertBefore(assignments.map((expr) => _core.types.expressionStatement(expr))), path4.scope.crawl(), path4;
            }(path3, state, constantSuper, version2);
            newPath && VISITED.add(newPath);
          } } };
        };
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _pluginSyntaxDecorators = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-decorators/lib/index.js"), _helperReplaceSupers = __webpack_require__2("./node_modules/.pnpm/@babel+helper-replace-supers@7.22.5/node_modules/@babel/helper-replace-supers/lib/index.js"), _helperSplitExportDeclaration = __webpack_require__2("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js");
        function incrementId(id, idx = id.length - 1) {
          if (-1 === idx)
            return void id.unshift(65);
          const current2 = id[idx];
          90 === current2 ? id[idx] = 97 : 122 === current2 ? (id[idx] = 65, incrementId(id, idx - 1)) : id[idx] = current2 + 1;
        }
        function generateClassProperty(key, value2, isStatic) {
          return "PrivateName" === key.type ? _core.types.classPrivateProperty(key, value2, void 0, isStatic) : _core.types.classProperty(key, value2, void 0, void 0, isStatic);
        }
        function addProxyAccessorsFor(className, element, originalKey, targetKey, version2, isComputed = false) {
          const { static: isStatic } = element.node, thisArg = "2023-05" === version2 && isStatic ? className : _core.types.thisExpression(), getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)))]), setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)), _core.types.identifier("v")))]);
          let getter, setter;
          "PrivateName" === originalKey.type ? (getter = _core.types.classPrivateMethod("get", _core.types.cloneNode(originalKey), [], getterBody, isStatic), setter = _core.types.classPrivateMethod("set", _core.types.cloneNode(originalKey), [_core.types.identifier("v")], setterBody, isStatic)) : (getter = _core.types.classMethod("get", _core.types.cloneNode(originalKey), [], getterBody, isComputed, isStatic), setter = _core.types.classMethod("set", _core.types.cloneNode(originalKey), [_core.types.identifier("v")], setterBody, isComputed, isStatic)), element.insertAfter(setter), element.insertAfter(getter);
        }
        function extractProxyAccessorsFor(targetKey, version2) {
          return "2023-05" !== version2 && "2023-01" !== version2 ? [_core.template.expression.ast`
        function () {
          return this.${_core.types.cloneNode(targetKey)};
        }
      `, _core.template.expression.ast`
        function (value) {
          this.${_core.types.cloneNode(targetKey)} = value;
        }
      `] : [_core.template.expression.ast`
      o => o.${_core.types.cloneNode(targetKey)}
    `, _core.template.expression.ast`
      (o, v) => o.${_core.types.cloneNode(targetKey)} = v
    `];
        }
        const FIELD = 0, ACCESSOR = 1, METHOD = 2, GETTER = 3, SETTER = 4, STATIC_OLD_VERSION = 5, STATIC = 8, DECORATORS_HAVE_THIS = 16;
        function getElementKind(element) {
          switch (element.node.type) {
            case "ClassProperty":
            case "ClassPrivateProperty":
              return FIELD;
            case "ClassAccessorProperty":
              return ACCESSOR;
            case "ClassMethod":
            case "ClassPrivateMethod":
              return "get" === element.node.kind ? GETTER : "set" === element.node.kind ? SETTER : METHOD;
          }
        }
        function isDecoratorInfo(info) {
          return "decorators" in info;
        }
        function filteredOrderedDecoratorInfo(info) {
          const filtered = info.filter(isDecoratorInfo);
          return [...filtered.filter((el) => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter((el) => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter((el) => el.isStatic && el.kind === FIELD), ...filtered.filter((el) => !el.isStatic && el.kind === FIELD)];
        }
        function generateDecorationList(decorators, decoratorsThis, version2) {
          const decsCount = decorators.length, hasOneThis = decoratorsThis.some(Boolean), decs = [];
          for (let i = 0; i < decsCount; i++)
            "2023-05" === version2 && hasOneThis && decs.push(decoratorsThis[i] || _core.types.unaryExpression("void", _core.types.numericLiteral(0))), decs.push(decorators[i]);
          return { hasThis: hasOneThis, decs };
        }
        function addCallAccessorsFor(element, key, getId, setId) {
          element.insertAfter(_core.types.classPrivateMethod("get", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), [_core.types.thisExpression()]))]))), element.insertAfter(_core.types.classPrivateMethod("set", _core.types.cloneNode(key), [_core.types.identifier("v")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), [_core.types.thisExpression(), _core.types.identifier("v")]))])));
        }
        function isNotTsParameter(node) {
          return "TSParameterProperty" !== node.type;
        }
        function movePrivateAccessor(element, key, methodLocalVar, isStatic) {
          let params, block;
          "set" === element.node.kind ? (params = [_core.types.identifier("v")], block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier("v")]))]) : (params = [], block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))]), element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));
        }
        function isClassDecoratableElementPath(path3) {
          const { type } = path3;
          return "TSDeclareMethod" !== type && "TSIndexSignature" !== type && "StaticBlock" !== type;
        }
        function staticBlockToIIFE(block) {
          return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);
        }
        function createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorations, classDecorationsFlag, maybePrivateBranName, state, version2) {
          let lhs, rhs;
          const args = [_core.types.thisExpression(), elementDecorations, classDecorations];
          if ("2021-12" === version2 || "2022-03" === version2 && !state.availableHelper("applyDecs2203R")) {
            const lhs2 = _core.types.arrayPattern([...elementLocals, ...classLocals]), rhs2 = _core.types.callExpression(state.addHelper("2021-12" === version2 ? "applyDecs" : "applyDecs2203"), args);
            return _core.types.assignmentExpression("=", lhs2, rhs2);
          }
          return "2023-05" === version2 ? ((maybePrivateBranName || 0 !== classDecorationsFlag.value) && args.push(classDecorationsFlag), maybePrivateBranName && args.push(_core.template.expression.ast`
            _ => ${_core.types.cloneNode(maybePrivateBranName)} in _
          `), rhs = _core.types.callExpression(state.addHelper("applyDecs2305"), args)) : "2023-01" === version2 ? (maybePrivateBranName && args.push(_core.template.expression.ast`
            _ => ${_core.types.cloneNode(maybePrivateBranName)} in _
          `), rhs = _core.types.callExpression(state.addHelper("applyDecs2301"), args)) : rhs = _core.types.callExpression(state.addHelper("applyDecs2203R"), args), elementLocals.length > 0 ? classLocals.length > 0 ? lhs = _core.types.objectPattern([_core.types.objectProperty(_core.types.identifier("e"), _core.types.arrayPattern(elementLocals)), _core.types.objectProperty(_core.types.identifier("c"), _core.types.arrayPattern(classLocals))]) : (lhs = _core.types.arrayPattern(elementLocals), rhs = _core.types.memberExpression(rhs, _core.types.identifier("e"), false, false)) : (lhs = _core.types.arrayPattern(classLocals), rhs = _core.types.memberExpression(rhs, _core.types.identifier("c"), false, false)), _core.types.assignmentExpression("=", lhs, rhs);
        }
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js");
        const buildClassDecorator = _core.template.statement("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n"), buildClassPrototype = (0, _core.template)("\n  CLASS_REF.prototype;\n"), buildGetDescriptor = (0, _core.template)("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n"), buildGetObjectInitializer = (0, _core.template)("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n"), WARNING_CALLS = /* @__PURE__ */ new WeakSet();
        function applyEnsureOrdering(path3) {
          const identDecorators = (path3.isClass() ? [path3, ...path3.get("body.body")] : path3.get("properties")).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []).filter((decorator) => !_core.types.isIdentifier(decorator.expression));
          if (0 !== identDecorators.length)
            return _core.types.sequenceExpression(identDecorators.map((decorator) => {
              const expression = decorator.expression, id = decorator.expression = path3.scope.generateDeclaredUidIdentifier("dec");
              return _core.types.assignmentExpression("=", id, expression);
            }).concat([path3.node]));
        }
        function hasClassDecorators(classNode) {
          return !(!classNode.decorators || !classNode.decorators.length);
        }
        function hasMethodDecorators(body) {
          return body.some((node) => {
            var _node$decorators;
            return null == (_node$decorators = node.decorators) ? void 0 : _node$decorators.length;
          });
        }
        function applyTargetDecorators(path3, state, decoratedProps) {
          const name = path3.scope.generateDeclaredUidIdentifier(path3.isClass() ? "class" : "obj"), exprs = decoratedProps.reduce(function(acc, node) {
            let decorators = [];
            if (null != node.decorators && (decorators = node.decorators, node.decorators = null), 0 === decorators.length)
              return acc;
            if (node.computed)
              throw path3.buildCodeFrameError("Computed method/property decorators are not yet supported.");
            const property = _core.types.isLiteral(node.key) ? node.key : _core.types.stringLiteral(node.key.name), target = path3.isClass() && !node.static ? buildClassPrototype({ CLASS_REF: name }).expression : name;
            if (_core.types.isClassProperty(node, { static: false })) {
              const descriptor = path3.scope.generateDeclaredUidIdentifier("descriptor"), initializer = node.value ? _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(node.value)])) : _core.types.nullLiteral();
              node.value = _core.types.callExpression(state.addHelper("initializerWarningHelper"), [descriptor, _core.types.thisExpression()]), WARNING_CALLS.add(node.value), acc.push(_core.types.assignmentExpression("=", _core.types.cloneNode(descriptor), _core.types.callExpression(state.addHelper("applyDecoratedDescriptor"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map((dec) => _core.types.cloneNode(dec.expression))), _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("configurable"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier("enumerable"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier("writable"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier("initializer"), initializer)])])));
            } else
              acc.push(_core.types.callExpression(state.addHelper("applyDecoratedDescriptor"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map((dec) => _core.types.cloneNode(dec.expression))), _core.types.isObjectProperty(node) || _core.types.isClassProperty(node, { static: true }) ? buildGetObjectInitializer({ TEMP: path3.scope.generateDeclaredUidIdentifier("init"), TARGET: _core.types.cloneNode(target), PROPERTY: _core.types.cloneNode(property) }).expression : buildGetDescriptor({ TARGET: _core.types.cloneNode(target), PROPERTY: _core.types.cloneNode(property) }).expression, _core.types.cloneNode(target)]));
            return acc;
          }, []);
          return _core.types.sequenceExpression([_core.types.assignmentExpression("=", _core.types.cloneNode(name), path3.node), _core.types.sequenceExpression(exprs), _core.types.cloneNode(name)]);
        }
        function decoratedClassToExpression({ node, scope }) {
          if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body))
            return;
          const ref2 = node.id ? _core.types.cloneNode(node.id) : scope.generateUidIdentifier("class");
          return _core.types.variableDeclaration("let", [_core.types.variableDeclarator(ref2, _core.types.toExpression(node))]);
        }
        var _default = { ExportDefaultDeclaration(path3) {
          const decl = path3.get("declaration");
          if (!decl.isClassDeclaration())
            return;
          const replacement = decoratedClassToExpression(decl);
          if (replacement) {
            const [varDeclPath] = path3.replaceWithMultiple([replacement, _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id), _core.types.identifier("default"))])]);
            decl.node.id || path3.scope.registerDeclaration(varDeclPath);
          }
        }, ClassDeclaration(path3) {
          const replacement = decoratedClassToExpression(path3);
          if (replacement) {
            const [newPath] = path3.replaceWith(replacement), decl = newPath.get("declarations.0"), id = decl.node.id, binding = path3.scope.getOwnBinding(id.name);
            binding.identifier = id, binding.path = decl;
          }
        }, ClassExpression(path3, state) {
          const decoratedClass = applyEnsureOrdering(path3) || function(classPath) {
            if (!hasClassDecorators(classPath.node))
              return;
            const decorators = classPath.node.decorators || [];
            classPath.node.decorators = null;
            const name = classPath.scope.generateDeclaredUidIdentifier("class");
            return decorators.map((dec) => dec.expression).reverse().reduce(function(acc, decorator) {
              return buildClassDecorator({ CLASS_REF: _core.types.cloneNode(name), DECORATOR: _core.types.cloneNode(decorator), INNER: acc }).expression;
            }, classPath.node);
          }(path3) || function(path4, state2) {
            if (hasMethodDecorators(path4.node.body.body))
              return applyTargetDecorators(path4, state2, path4.node.body.body);
          }(path3, state);
          decoratedClass && path3.replaceWith(decoratedClass);
        }, ObjectExpression(path3, state) {
          const decoratedObject = applyEnsureOrdering(path3) || function(path4, state2) {
            if (hasMethodDecorators(path4.node.properties))
              return applyTargetDecorators(path4, state2, path4.node.properties.filter((prop) => "SpreadElement" !== prop.type));
          }(path3, state);
          decoratedObject && path3.replaceWith(decoratedObject);
        }, AssignmentExpression(path3, state) {
          WARNING_CALLS.has(path3.node.right) && path3.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"), [_core.types.cloneNode(path3.get("left.object").node), _core.types.stringLiteral(path3.get("left.property").node.name || path3.get("left.property").node.value), _core.types.cloneNode(path3.get("right.arguments")[0].node), _core.types.cloneNode(path3.get("right.arguments")[1].node)]));
        }, CallExpression(path3, state) {
          3 === path3.node.arguments.length && WARNING_CALLS.has(path3.node.arguments[2]) && path3.node.callee.name === state.addHelper("defineProperty").name && path3.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"), [_core.types.cloneNode(path3.get("arguments")[0].node), _core.types.cloneNode(path3.get("arguments")[1].node), _core.types.cloneNode(path3.get("arguments.2.arguments")[0].node), _core.types.cloneNode(path3.get("arguments.2.arguments")[1].node)]));
        } };
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-export-namespace-from@7.18.9_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-export-namespace-from/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), _pluginSyntaxExportNamespaceFrom = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-syntax-export-namespace-from@7.8.3_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-export-namespace-from/lib/index.js"), _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _default = (0, _helperPluginUtils.declare)((api) => (api.assertVersion(7), { name: "proposal-export-namespace-from", inherits: _pluginSyntaxExportNamespaceFrom.default, visitor: { ExportNamedDeclaration(path3) {
          var _exported$name;
          const { node, scope } = path3, { specifiers } = node, index2 = _core.types.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
          if (!_core.types.isExportNamespaceSpecifier(specifiers[index2]))
            return;
          const nodes = [];
          1 === index2 && nodes.push(_core.types.exportNamedDeclaration(null, [specifiers.shift()], node.source));
          const specifier = specifiers.shift(), { exported } = specifier, uid = scope.generateUidIdentifier(null != (_exported$name = exported.name) ? _exported$name : exported.value);
          nodes.push(_core.types.importDeclaration([_core.types.importNamespaceSpecifier(uid)], _core.types.cloneNode(node.source)), _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(uid), exported)])), node.specifiers.length >= 1 && nodes.push(node);
          const [importDeclaration] = path3.replaceWithMultiple(nodes);
          path3.scope.registerDeclaration(importDeclaration);
        } } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-nullish-coalescing-operator@7.18.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), _pluginSyntaxNullishCoalescingOperator = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-syntax-nullish-coalescing-operator@7.8.3_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js"), _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _default = (0, _helperPluginUtils.declare)((api, { loose = false }) => {
          var _api$assumption;
          api.assertVersion(7);
          const noDocumentAll = null != (_api$assumption = api.assumption("noDocumentAll")) ? _api$assumption : loose;
          return { name: "proposal-nullish-coalescing-operator", inherits: _pluginSyntaxNullishCoalescingOperator.default, visitor: { LogicalExpression(path3) {
            const { node, scope } = path3;
            if ("??" !== node.operator)
              return;
            let ref2, assignment;
            if (scope.isStatic(node.left))
              ref2 = node.left, assignment = _core.types.cloneNode(node.left);
            else {
              if (scope.path.isPattern())
                return void path3.replaceWith(_core.template.statement.ast`(() => ${path3.node})()`);
              ref2 = scope.generateUidIdentifierBasedOnNode(node.left), scope.push({ id: _core.types.cloneNode(ref2) }), assignment = _core.types.assignmentExpression("=", ref2, node.left);
            }
            path3.replaceWith(_core.types.conditionalExpression(noDocumentAll ? _core.types.binaryExpression("!=", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression("&&", _core.types.binaryExpression("!==", assignment, _core.types.nullLiteral()), _core.types.binaryExpression("!==", _core.types.cloneNode(ref2), scope.buildUndefinedNode())), _core.types.cloneNode(ref2), node.right));
          } } };
        });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-optional-chaining@7.21.0_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), syntaxOptionalChaining = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-syntax-optional-chaining@7.8.3_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js"), core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), helperSkipTransparentExpressionWrappers = __webpack_require__2("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.22.5/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");
        function willPathCastToBoolean(path3) {
          const maybeWrapped = findOutermostTransparentParent(path3), { node, parentPath } = maybeWrapped;
          if (parentPath.isLogicalExpression()) {
            const { operator, right } = parentPath.node;
            if ("&&" === operator || "||" === operator || "??" === operator && node === right)
              return willPathCastToBoolean(parentPath);
          }
          if (parentPath.isSequenceExpression()) {
            const { expressions } = parentPath.node;
            return expressions[expressions.length - 1] !== node || willPathCastToBoolean(parentPath);
          }
          return parentPath.isConditional({ test: node }) || parentPath.isUnaryExpression({ operator: "!" }) || parentPath.isLoop({ test: node });
        }
        function findOutermostTransparentParent(path3) {
          let maybeWrapped = path3;
          return path3.findParent((p) => {
            if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node))
              return true;
            maybeWrapped = p;
          }), maybeWrapped;
        }
        const { ast } = core.template.expression;
        function isSimpleMemberExpression(expression) {
          return expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression), core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
        }
        function transform(path3, { pureGetters, noDocumentAll }) {
          const { scope } = path3, maybeWrapped = findOutermostTransparentParent(path3), { parentPath } = maybeWrapped, willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);
          let isDeleteOperation = false;
          const parentIsCall = parentPath.isCallExpression({ callee: maybeWrapped.node }) && path3.isOptionalMemberExpression(), optionals = [];
          let optionalPath = path3;
          if (scope.path.isPattern() && function(path4) {
            let optionalPath2 = path4;
            const { scope: scope2 } = path4;
            for (; optionalPath2.isOptionalMemberExpression() || optionalPath2.isOptionalCallExpression(); ) {
              const { node } = optionalPath2, childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath2.isOptionalMemberExpression() ? optionalPath2.get("object") : optionalPath2.get("callee"));
              if (node.optional)
                return !scope2.isStatic(childPath.node);
              optionalPath2 = childPath;
            }
          }(optionalPath))
            return void path3.replaceWith(core.template.ast`(() => ${path3.node})()`);
          for (; optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression(); ) {
            const { node } = optionalPath;
            node.optional && optionals.push(node), optionalPath.isOptionalMemberExpression() ? (optionalPath.node.type = "MemberExpression", optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"))) : optionalPath.isOptionalCallExpression() && (optionalPath.node.type = "CallExpression", optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee")));
          }
          let replacementPath = path3;
          parentPath.isUnaryExpression({ operator: "delete" }) && (replacementPath = parentPath, isDeleteOperation = true);
          for (let i = optionals.length - 1; i >= 0; i--) {
            const node = optionals[i], isCall = core.types.isCallExpression(node), chainWithTypes = isCall ? node.callee : node.object, chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);
            let ref2, check;
            if (isCall && core.types.isIdentifier(chain, { name: "eval" }) ? (check = ref2 = chain, node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref2])) : pureGetters && isCall && isSimpleMemberExpression(chain) ? check = ref2 = node.callee : (ref2 = scope.maybeGenerateMemoised(chain), ref2 ? (check = core.types.assignmentExpression("=", core.types.cloneNode(ref2), chainWithTypes), isCall ? node.callee = ref2 : node.object = ref2) : check = ref2 = chainWithTypes), isCall && core.types.isMemberExpression(chain))
              if (pureGetters && isSimpleMemberExpression(chain))
                node.callee = chainWithTypes;
              else {
                const { object } = chain;
                let context;
                if (core.types.isSuper(object))
                  context = core.types.thisExpression();
                else {
                  const memoized = scope.maybeGenerateMemoised(object);
                  memoized ? (context = memoized, chain.object = core.types.assignmentExpression("=", memoized, object)) : context = object;
                }
                node.arguments.unshift(core.types.cloneNode(context)), node.callee = core.types.memberExpression(node.callee, core.types.identifier("call"));
              }
            let replacement = replacementPath.node;
            if (0 === i && parentIsCall) {
              var _baseRef;
              const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);
              let baseRef;
              pureGetters && isSimpleMemberExpression(object) || (baseRef = scope.maybeGenerateMemoised(object), baseRef && (replacement.object = core.types.assignmentExpression("=", baseRef, object))), replacement = core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier("bind")), [core.types.cloneNode(null != (_baseRef = baseRef) ? _baseRef : object)]);
            }
            if (willReplacementCastToBoolean) {
              const nonNullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} != null` : ast`
            ${core.types.cloneNode(check)} !== null && ${core.types.cloneNode(ref2)} !== void 0`;
              replacementPath.replaceWith(core.types.logicalExpression("&&", nonNullishCheck, replacement)), replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("right"));
            } else {
              const nullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} == null` : ast`
            ${core.types.cloneNode(check)} === null || ${core.types.cloneNode(ref2)} === void 0`, returnValue = isDeleteOperation ? ast`true` : ast`void 0`;
              replacementPath.replaceWith(core.types.conditionalExpression(nullishCheck, returnValue, replacement)), replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("alternate"));
            }
          }
        }
        var index2 = helperPluginUtils.declare((api, options) => {
          var _api$assumption, _api$assumption2;
          api.assertVersion(7);
          const { loose = false } = options, noDocumentAll = null != (_api$assumption = api.assumption("noDocumentAll")) ? _api$assumption : loose, pureGetters = null != (_api$assumption2 = api.assumption("pureGetters")) ? _api$assumption2 : loose;
          return { name: "proposal-optional-chaining", inherits: syntaxOptionalChaining.default, visitor: { "OptionalCallExpression|OptionalMemberExpression"(path3) {
            transform(path3, { noDocumentAll, pureGetters });
          } } };
        });
        exports3.default = index2, exports3.transform = transform;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-decorators/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api, options) => {
          api.assertVersion(7);
          let { version: version2 } = options;
          {
            const { legacy } = options;
            if (void 0 !== legacy) {
              if ("boolean" != typeof legacy)
                throw new Error(".legacy must be a boolean.");
              if (void 0 !== version2)
                throw new Error("You can either use the .legacy or the .version option, not both.");
            }
            if (void 0 === version2)
              version2 = legacy ? "legacy" : "2018-09";
            else if ("2023-05" !== version2 && "2023-01" !== version2 && "2022-03" !== version2 && "2021-12" !== version2 && "2018-09" !== version2 && "legacy" !== version2)
              throw new Error("Unsupported decorators version: " + version2);
            var { decoratorsBeforeExport } = options;
            if (void 0 === decoratorsBeforeExport) {
              if ("2021-12" === version2 || "2022-03" === version2)
                decoratorsBeforeExport = false;
              else if ("2018-09" === version2)
                throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.");
            } else {
              if ("legacy" === version2 || "2022-03" === version2 || "2023-01" === version2)
                throw new Error(`'decoratorsBeforeExport' can't be used with ${version2} decorators.`);
              if ("boolean" != typeof decoratorsBeforeExport)
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
          }
          return { name: "syntax-decorators", manipulateOptions({ generatorOpts }, parserOpts) {
            "legacy" === version2 ? parserOpts.plugins.push("decorators-legacy") : "2023-01" === version2 || "2023-05" === version2 ? parserOpts.plugins.push(["decorators", { allowCallParenthesized: false }], "decoratorAutoAccessors") : "2022-03" === version2 ? parserOpts.plugins.push(["decorators", { decoratorsBeforeExport: false, allowCallParenthesized: false }], "decoratorAutoAccessors") : "2021-12" === version2 ? (parserOpts.plugins.push(["decorators", { decoratorsBeforeExport }], "decoratorAutoAccessors"), generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport) : "2018-09" === version2 && (parserOpts.plugins.push(["decorators", { decoratorsBeforeExport }]), generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport);
          } };
        });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-import-assertions", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("importAssertions");
        } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-jsx/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-jsx", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.some((p) => "typescript" === (Array.isArray(p) ? p[0] : p)) || parserOpts.plugins.push("jsx");
        } }));
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-typescript/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), removePlugin = function(plugins, name) {
          const indices = [];
          plugins.forEach((plugin, i) => {
            (Array.isArray(plugin) ? plugin[0] : plugin) === name && indices.unshift(i);
          });
          for (const i of indices)
            plugins.splice(i, 1);
        }, _default = (0, _helperPluginUtils.declare)((api, opts) => {
          api.assertVersion(7);
          const { disallowAmbiguousJSXLike, dts } = opts;
          var { isTSX } = opts;
          return { name: "syntax-typescript", manipulateOptions(opts2, parserOpts) {
            {
              const { plugins } = parserOpts;
              removePlugin(plugins, "flow"), removePlugin(plugins, "jsx"), plugins.push("objectRestSpread", "classProperties"), isTSX && plugins.push("jsx");
            }
            parserOpts.plugins.push(["typescript", { disallowAmbiguousJSXLike, dts }]);
          } };
        });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.transformDynamicImport = function(path3, noInterop, file) {
          const buildRequire = noInterop ? requireNoInterop : requireInterop;
          path3.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path3.node, true, false, (specifier) => buildRequire(specifier, file)));
        };
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _helperModuleTransforms = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/index.js");
        const requireNoInterop = (source) => _core.template.expression.ast`require(${source})`, requireInterop = (source, file) => _core.types.callExpression(file.addHelper("interopRequireWildcard"), [requireNoInterop(source)]);
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), _helperModuleTransforms = __webpack_require__2("./node_modules/.pnpm/@babel+helper-module-transforms@7.22.5/node_modules/@babel/helper-module-transforms/lib/index.js"), _helperSimpleAccess = __webpack_require__2("./node_modules/.pnpm/@babel+helper-simple-access@7.22.5/node_modules/@babel/helper-simple-access/lib/index.js"), _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _dynamicImport = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js"), _default = (0, _helperPluginUtils.declare)((api, options) => {
          var _api$assumption, _api$assumption2, _api$assumption3;
          api.assertVersion(7);
          const { strictNamespace = false, mjsStrictNamespace = strictNamespace, allowTopLevelThis, strict, strictMode, noInterop, importInterop, lazy = false, allowCommonJSExports = true, loose = false } = options, constantReexports = null != (_api$assumption = api.assumption("constantReexports")) ? _api$assumption : loose, enumerableModuleMeta = null != (_api$assumption2 = api.assumption("enumerableModuleMeta")) ? _api$assumption2 : loose, noIncompleteNsImportDetection = null != (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) && _api$assumption3;
          if (!("boolean" == typeof lazy || "function" == typeof lazy || Array.isArray(lazy) && lazy.every((item) => "string" == typeof item)))
            throw new Error(".lazy must be a boolean, array of strings, or a function");
          if ("boolean" != typeof strictNamespace)
            throw new Error(".strictNamespace must be a boolean, or undefined");
          if ("boolean" != typeof mjsStrictNamespace)
            throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
          const getAssertion = (localName) => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, moduleExportsVisitor = { ReferencedIdentifier(path3) {
            const localName = path3.node.name;
            if ("module" !== localName && "exports" !== localName)
              return;
            const localBinding = path3.scope.getBinding(localName);
            this.scope.getBinding(localName) !== localBinding || path3.parentPath.isObjectProperty({ value: path3.node }) && path3.parentPath.parentPath.isObjectPattern() || path3.parentPath.isAssignmentExpression({ left: path3.node }) || path3.isAssignmentExpression({ left: path3.node }) || path3.replaceWith(getAssertion(localName));
          }, UpdateExpression(path3) {
            const arg = path3.get("argument");
            if (!arg.isIdentifier())
              return;
            const localName = arg.node.name;
            if ("module" !== localName && "exports" !== localName)
              return;
            const localBinding = path3.scope.getBinding(localName);
            this.scope.getBinding(localName) === localBinding && path3.replaceWith(_core.types.assignmentExpression(path3.node.operator[0] + "=", arg.node, getAssertion(localName)));
          }, AssignmentExpression(path3) {
            const left = path3.get("left");
            if (left.isIdentifier()) {
              const localName = left.node.name;
              if ("module" !== localName && "exports" !== localName)
                return;
              const localBinding = path3.scope.getBinding(localName);
              if (this.scope.getBinding(localName) !== localBinding)
                return;
              const right = path3.get("right");
              right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
            } else if (left.isPattern()) {
              const ids = left.getOuterBindingIdentifiers(), localName = Object.keys(ids).filter((localName2) => ("module" === localName2 || "exports" === localName2) && this.scope.getBinding(localName2) === path3.scope.getBinding(localName2))[0];
              if (localName) {
                const right = path3.get("right");
                right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
              }
            }
          } };
          return { name: "transform-modules-commonjs", pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs");
          }, visitor: { CallExpression(path3) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import"))
              return;
            if (!_core.types.isImport(path3.node.callee))
              return;
            let { scope } = path3;
            do {
              scope.rename("require");
            } while (scope = scope.parent);
            (0, _dynamicImport.transformDynamicImport)(path3, noInterop, this.file);
          }, Program: { exit(path3, state) {
            if (!(0, _helperModuleTransforms.isModule)(path3))
              return;
            path3.scope.rename("exports"), path3.scope.rename("module"), path3.scope.rename("require"), path3.scope.rename("__filename"), path3.scope.rename("__dirname"), allowCommonJSExports || ((0, _helperSimpleAccess.default)(path3, /* @__PURE__ */ new Set(["module", "exports"]), false), path3.traverse(moduleExportsVisitor, { scope: path3.scope }));
            let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
            moduleName && (moduleName = _core.types.stringLiteral(moduleName));
            const { meta, headers } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path3, { exportName: "exports", constantReexports, enumerableModuleMeta, strict, strictMode, allowTopLevelThis, noInterop, importInterop, lazy, esNamespaceOnly: "string" == typeof state.filename && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace, noIncompleteNsImportDetection, filename: this.file.opts.filename });
            for (const [source, metadata] of meta.source) {
              const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]);
              let header;
              if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                if (metadata.lazy)
                  throw new Error("Assertion failure");
                header = _core.types.expressionStatement(loadExpr);
              } else {
                if (metadata.lazy && !metadata.referenced)
                  continue;
                const init = (0, _helperModuleTransforms.wrapInterop)(path3, loadExpr, metadata.interop) || loadExpr;
                header = metadata.lazy ? _core.template.statement.ast`
                  function ${metadata.name}() {
                    const data = ${init};
                    ${metadata.name} = function(){ return data; };
                    return data;
                  }
                ` : _core.template.statement.ast`
                  var ${metadata.name} = ${init};
                `;
              }
              header.loc = metadata.loc, headers.push(header), headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
            }
            (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path3.unshiftContainer("body", headers), path3.get("body").forEach((path4) => {
              -1 !== headers.indexOf(path4.node) && path4.isVariableDeclaration() && path4.scope.registerDeclaration(path4);
            });
          } } } };
        });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(path3, t) {
          const { name } = path3.node.id, parentIsExport = path3.parentPath.isExportNamedDeclaration();
          let isExported = parentIsExport;
          !isExported && t.isProgram(path3.parent) && (isExported = path3.parent.body.some((stmt) => t.isExportNamedDeclaration(stmt) && "type" !== stmt.exportKind && !stmt.source && stmt.specifiers.some((spec) => t.isExportSpecifier(spec) && "type" !== spec.exportKind && spec.local.name === name)));
          const { enumValues: entries } = (0, _enum.translateEnumValues)(path3, t);
          if (isExported) {
            const obj = t.objectExpression(entries.map(([name2, value2]) => t.objectProperty(t.isValidIdentifier(name2) ? t.identifier(name2) : t.stringLiteral(name2), value2)));
            return void (path3.scope.hasOwnBinding(name) ? (parentIsExport ? path3.parentPath : path3).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [path3.node.id, obj]))) : (path3.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(path3.node.id, obj)])), path3.scope.registerDeclaration(path3)));
          }
          const entriesMap = new Map(entries);
          path3.scope.path.traverse({ Scope(path4) {
            path4.scope.hasOwnBinding(name) && path4.skip();
          }, MemberExpression(path4) {
            if (!t.isIdentifier(path4.node.object, { name }))
              return;
            let key;
            if (path4.node.computed) {
              if (!t.isStringLiteral(path4.node.property))
                return;
              key = path4.node.property.value;
            } else {
              if (!t.isIdentifier(path4.node.property))
                return;
              key = path4.node.property.name;
            }
            entriesMap.has(key) && path4.replaceWith(t.cloneNode(entriesMap.get(key)));
          } }), path3.remove();
        };
        var _enum = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/enum.js");
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/enum.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(path3, t) {
          const { node, parentPath } = path3;
          if (node.declare)
            return void path3.remove();
          const name = node.id.name, { fill, data: data2, isPure } = function(path4, t2, id) {
            const { enumValues: x, data: data3, isPure: isPure2 } = translateEnumValues(path4, t2), assignments = x.map(([memberName, memberValue]) => buildEnumMember(t2.isStringLiteral(memberValue), { ENUM: t2.cloneNode(id), NAME: memberName, VALUE: memberValue }));
            return { fill: { ID: t2.cloneNode(id), ASSIGNMENTS: assignments }, data: data3, isPure: isPure2 };
          }(path3, t, node.id);
          switch (parentPath.type) {
            case "BlockStatement":
            case "ExportNamedDeclaration":
            case "Program": {
              const isGlobal = t.isProgram(path3.parent), isSeen = function seen(parentPath2) {
                if (parentPath2.isExportDeclaration())
                  return seen(parentPath2.parentPath);
                return !!parentPath2.getData(name) || (parentPath2.setData(name, true), false);
              }(parentPath);
              let init = t.objectExpression([]);
              (isSeen || isGlobal) && (init = t.logicalExpression("||", t.cloneNode(fill.ID), init));
              const enumIIFE = buildEnumWrapper(Object.assign({}, fill, { INIT: init }));
              if (isPure && (0, _helperAnnotateAsPure.default)(enumIIFE), isSeen) {
                (parentPath.isExportDeclaration() ? parentPath : path3).replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(node.id), enumIIFE)));
              } else
                path3.scope.registerDeclaration(path3.replaceWith(t.variableDeclaration(isGlobal ? "var" : "let", [t.variableDeclarator(node.id, enumIIFE)]))[0]);
              ENUMS.set(path3.scope.getBindingIdentifier(name), data2);
              break;
            }
            default:
              throw new Error(`Unexpected enum parent '${path3.parent.type}`);
          }
        }, exports3.translateEnumValues = translateEnumValues;
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), _assert = __webpack_require__2("assert"), _helperAnnotateAsPure = __webpack_require__2("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.22.5/node_modules/@babel/helper-annotate-as-pure/lib/index.js");
        const ENUMS = /* @__PURE__ */ new WeakMap(), buildEnumWrapper = _core.template.expression("\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  ");
        const buildStringAssignment = (0, _core.template)('\n  ENUM["NAME"] = VALUE;\n'), buildNumericAssignment = (0, _core.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n'), buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);
        function ReferencedIdentifier(expr, state) {
          const { seen, path: path3, t } = state, name = expr.node.name;
          seen.has(name) && !expr.scope.hasOwnBinding(name) && (expr.replaceWith(t.memberExpression(t.cloneNode(path3.node.id), t.cloneNode(expr.node))), expr.skip());
        }
        const enumSelfReferenceVisitor = { ReferencedIdentifier };
        function translateEnumValues(path3, t) {
          const seen = /* @__PURE__ */ new Map();
          let lastName, constValue = -1, isPure = true;
          const enumValues = path3.get("members").map((memberPath) => {
            const member = memberPath.node, name = t.isIdentifier(member.id) ? member.id.name : member.id.value, initializerPath = memberPath.get("initializer");
            let value2;
            if (member.initializer)
              constValue = computeConstantValue(initializerPath, seen), void 0 !== constValue ? (seen.set(name, constValue), "number" == typeof constValue ? value2 = t.numericLiteral(constValue) : (_assert("string" == typeof constValue), value2 = t.stringLiteral(constValue))) : (isPure && (isPure = initializerPath.isPure()), initializerPath.isReferencedIdentifier() ? ReferencedIdentifier(initializerPath, { t, seen, path: path3 }) : initializerPath.traverse(enumSelfReferenceVisitor, { t, seen, path: path3 }), value2 = initializerPath.node, seen.set(name, void 0));
            else if ("number" == typeof constValue)
              constValue += 1, value2 = t.numericLiteral(constValue), seen.set(name, constValue);
            else {
              if ("string" == typeof constValue)
                throw path3.buildCodeFrameError("Enum member must have initializer.");
              {
                const lastRef = t.memberExpression(t.cloneNode(path3.node.id), t.stringLiteral(lastName), true);
                value2 = t.binaryExpression("+", t.numericLiteral(1), lastRef), seen.set(name, void 0);
              }
            }
            return lastName = name, [name, value2];
          });
          return { isPure, data: seen, enumValues };
        }
        function computeConstantValue(path3, prevMembers, seen = /* @__PURE__ */ new Set()) {
          return evaluate(path3);
          function evaluate(path4) {
            const expr = path4.node;
            switch (expr.type) {
              case "MemberExpression":
              case "Identifier":
                return evaluateRef(path4, prevMembers, seen);
              case "StringLiteral":
              case "NumericLiteral":
                return expr.value;
              case "UnaryExpression":
                return function(path5) {
                  const value2 = evaluate(path5.get("argument"));
                  if (void 0 === value2)
                    return;
                  switch (path5.node.operator) {
                    case "+":
                      return value2;
                    case "-":
                      return -value2;
                    case "~":
                      return ~value2;
                    default:
                      return;
                  }
                }(path4);
              case "BinaryExpression":
                return function(path5) {
                  const left = evaluate(path5.get("left"));
                  if (void 0 === left)
                    return;
                  const right = evaluate(path5.get("right"));
                  if (void 0 === right)
                    return;
                  switch (path5.node.operator) {
                    case "|":
                      return left | right;
                    case "&":
                      return left & right;
                    case ">>":
                      return left >> right;
                    case ">>>":
                      return left >>> right;
                    case "<<":
                      return left << right;
                    case "^":
                      return left ^ right;
                    case "*":
                      return left * right;
                    case "/":
                      return left / right;
                    case "+":
                      return left + right;
                    case "-":
                      return left - right;
                    case "%":
                      return left % right;
                    case "**":
                      return Math.pow(left, right);
                    default:
                      return;
                  }
                }(path4);
              case "ParenthesizedExpression":
                return evaluate(path4.get("expression"));
              case "TemplateLiteral": {
                if (1 === expr.quasis.length)
                  return expr.quasis[0].value.cooked;
                const paths = path4.get("expressions"), quasis = expr.quasis;
                let str = "";
                for (let i = 0; i < quasis.length; i++)
                  if (str += quasis[i].value.cooked, i + 1 < quasis.length) {
                    const value2 = evaluateRef(paths[i], prevMembers, seen);
                    if (void 0 === value2)
                      return;
                    str += value2;
                  }
                return str;
              }
              default:
                return;
            }
          }
          function evaluateRef(path4, prevMembers2, seen2) {
            if (path4.isMemberExpression()) {
              const expr = path4.node, obj = expr.object, prop = expr.property;
              if (!_core.types.isIdentifier(obj) || (expr.computed ? !_core.types.isStringLiteral(prop) : !_core.types.isIdentifier(prop)))
                return;
              const bindingIdentifier = path4.scope.getBindingIdentifier(obj.name), data2 = ENUMS.get(bindingIdentifier);
              if (!data2)
                return;
              return data2.get(prop.computed ? prop.value : prop.name);
            }
            if (path4.isIdentifier()) {
              const name = path4.node.name;
              let value2 = null == prevMembers2 ? void 0 : prevMembers2.get(name);
              if (void 0 !== value2)
                return value2;
              if (seen2.has(path4.node))
                return;
              const bindingInitPath = path4.resolve();
              if (bindingInitPath)
                return seen2.add(path4.node), value2 = computeConstantValue(bindingInitPath, void 0, seen2), null == prevMembers2 || prevMembers2.set(name, value2), value2;
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), _pluginSyntaxTypescript = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-typescript/lib/index.js"), _helperCreateClassFeaturesPlugin = __webpack_require__2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.22.6_@babel+core@7.22.6/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), _constEnum = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"), _enum = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/enum.js"), _namespace = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/namespace.js");
        function isInType(path3) {
          switch (path3.parent.type) {
            case "TSTypeReference":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            case "TSQualifiedName":
              return "TSImportEqualsDeclaration" !== path3.parentPath.findParent((path4) => "TSQualifiedName" !== path4.type).type;
            case "ExportSpecifier":
              return "type" === path3.parent.exportKind || "type" === path3.parentPath.parent.exportKind;
            default:
              return false;
          }
        }
        const GLOBAL_TYPES = /* @__PURE__ */ new WeakMap(), NEEDS_EXPLICIT_ESM = /* @__PURE__ */ new WeakMap(), PARSED_PARAMS = /* @__PURE__ */ new WeakSet();
        function isGlobalType({ scope }, name) {
          return !scope.hasBinding(name) && (!!GLOBAL_TYPES.get(scope).has(name) || (console.warn(`The exported identifier "${name}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${name}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), false));
        }
        function registerGlobalType(programScope, name) {
          GLOBAL_TYPES.get(programScope).add(name);
        }
        function safeRemove(path3) {
          const ids = path3.getBindingIdentifiers();
          for (const name of Object.keys(ids)) {
            const binding = path3.scope.getBinding(name);
            binding && binding.identifier === ids[name] && binding.scope.removeBinding(name);
          }
          path3.opts.noScope = true, path3.remove(), path3.opts.noScope = false;
        }
        function assertCjsTransformEnabled(path3, pass, wrong, suggestion, extra = "") {
          if ("commonjs" !== pass.file.get("@babel/plugin-transform-modules-*"))
            throw path3.buildCodeFrameError(`\`${wrong}\` is only supported when compiling modules to CommonJS.
Please consider using \`${suggestion}\`${extra}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
        }
        var _default = (0, _helperPluginUtils.declare)((api, opts) => {
          const { types: t, template: template2 } = api;
          api.assertVersion(7);
          const JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, { allowNamespaces = true, jsxPragma = "React.createElement", jsxPragmaFrag = "React.Fragment", onlyRemoveTypeImports = false, optimizeConstEnums = false } = opts;
          var { allowDeclareFields = false } = opts;
          const classMemberVisitors = { field(path3) {
            const { node } = path3;
            if (!allowDeclareFields && node.declare)
              throw path3.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
            if (node.declare) {
              if (node.value)
                throw path3.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
              node.decorators || path3.remove();
            } else if (node.definite) {
              if (node.value)
                throw path3.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
              allowDeclareFields || node.decorators || t.isClassPrivateProperty(node) || path3.remove();
            } else
              node.abstract ? path3.remove() : allowDeclareFields || node.value || node.decorators || t.isClassPrivateProperty(node) || path3.remove();
            node.accessibility && (node.accessibility = null), node.abstract && (node.abstract = null), node.readonly && (node.readonly = null), node.optional && (node.optional = null), node.typeAnnotation && (node.typeAnnotation = null), node.definite && (node.definite = null), node.declare && (node.declare = null), node.override && (node.override = null);
          }, method({ node }) {
            node.accessibility && (node.accessibility = null), node.abstract && (node.abstract = null), node.optional && (node.optional = null), node.override && (node.override = null);
          }, constructor(path3, classPath) {
            path3.node.accessibility && (path3.node.accessibility = null);
            const assigns = [], { scope } = path3;
            for (const paramPath of path3.get("params")) {
              const param = paramPath.node;
              if ("TSParameterProperty" === param.type) {
                const parameter = param.parameter;
                if (PARSED_PARAMS.has(parameter))
                  continue;
                let id;
                if (PARSED_PARAMS.add(parameter), t.isIdentifier(parameter))
                  id = parameter;
                else {
                  if (!t.isAssignmentPattern(parameter) || !t.isIdentifier(parameter.left))
                    throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                  id = parameter.left;
                }
                assigns.push(template2.statement.ast`
          this.${t.cloneNode(id)} = ${t.cloneNode(id)}`), paramPath.replaceWith(paramPath.get("parameter")), scope.registerBinding("param", paramPath);
              }
            }
            (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path3, assigns);
          } };
          return { name: "transform-typescript", inherits: _pluginSyntaxTypescript.default, visitor: { Pattern: visitPattern, Identifier: visitPattern, RestElement: visitPattern, Program: { enter(path3, state) {
            const { file } = state;
            let fileJsxPragma = null, fileJsxPragmaFrag = null;
            const programScope = path3.scope;
            if (GLOBAL_TYPES.has(programScope) || GLOBAL_TYPES.set(programScope, /* @__PURE__ */ new Set()), file.ast.comments)
              for (const comment of file.ast.comments) {
                const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);
                jsxMatches && (jsxMatches[1] ? fileJsxPragmaFrag = jsxMatches[2] : fileJsxPragma = jsxMatches[2]);
              }
            let pragmaImportName = fileJsxPragma || jsxPragma;
            pragmaImportName && ([pragmaImportName] = pragmaImportName.split("."));
            let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
            pragmaFragImportName && ([pragmaFragImportName] = pragmaFragImportName.split("."));
            for (let stmt of path3.get("body"))
              if (stmt.isImportDeclaration()) {
                if (NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true), "type" === stmt.node.importKind) {
                  for (const specifier of stmt.node.specifiers)
                    registerGlobalType(programScope, specifier.local.name);
                  stmt.remove();
                  continue;
                }
                const importsToRemove = /* @__PURE__ */ new Set(), specifiersLength = stmt.node.specifiers.length, isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;
                for (const specifier of stmt.node.specifiers)
                  if ("ImportSpecifier" === specifier.type && "type" === specifier.importKind) {
                    registerGlobalType(programScope, specifier.local.name);
                    const binding = stmt.scope.getBinding(specifier.local.name);
                    binding && importsToRemove.add(binding.path);
                  }
                if (onlyRemoveTypeImports)
                  NEEDS_EXPLICIT_ESM.set(path3.node, false);
                else {
                  if (0 === stmt.node.specifiers.length) {
                    NEEDS_EXPLICIT_ESM.set(path3.node, false);
                    continue;
                  }
                  for (const specifier of stmt.node.specifiers) {
                    const binding = stmt.scope.getBinding(specifier.local.name);
                    binding && !importsToRemove.has(binding.path) && (isImportTypeOnly({ binding, programPath: path3, pragmaImportName, pragmaFragImportName }) ? importsToRemove.add(binding.path) : NEEDS_EXPLICIT_ESM.set(path3.node, false));
                  }
                }
                if (isAllSpecifiersElided() && !onlyRemoveTypeImports)
                  stmt.remove();
                else
                  for (const importPath of importsToRemove)
                    importPath.remove();
              } else if (stmt.isExportDeclaration() && (stmt = stmt.get("declaration")), stmt.isVariableDeclaration({ declare: true }))
                for (const name of Object.keys(stmt.getBindingIdentifiers()))
                  registerGlobalType(programScope, name);
              else
                (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({ declare: true }) || stmt.isTSEnumDeclaration({ declare: true }) || stmt.isTSModuleDeclaration({ declare: true }) && stmt.get("id").isIdentifier()) && registerGlobalType(programScope, stmt.node.id.name);
          }, exit(path3) {
            "module" === path3.node.sourceType && NEEDS_EXPLICIT_ESM.get(path3.node) && path3.pushContainer("body", t.exportNamedDeclaration());
          } }, ExportNamedDeclaration(path3, state) {
            NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true), "type" !== path3.node.exportKind ? path3.node.source && path3.node.specifiers.length > 0 && path3.node.specifiers.every((specifier) => "ExportSpecifier" === specifier.type && "type" === specifier.exportKind) || !path3.node.source && path3.node.specifiers.length > 0 && path3.node.specifiers.every((specifier) => t.isExportSpecifier(specifier) && isGlobalType(path3, specifier.local.name)) ? path3.remove() : NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false) : path3.remove();
          }, ExportAllDeclaration(path3) {
            "type" === path3.node.exportKind && path3.remove();
          }, ExportSpecifier(path3) {
            (!path3.parent.source && isGlobalType(path3, path3.node.local.name) || "type" === path3.node.exportKind) && path3.remove();
          }, ExportDefaultDeclaration(path3, state) {
            NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true), t.isIdentifier(path3.node.declaration) && isGlobalType(path3, path3.node.declaration.name) ? path3.remove() : NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
          }, TSDeclareFunction(path3) {
            safeRemove(path3);
          }, TSDeclareMethod(path3) {
            safeRemove(path3);
          }, VariableDeclaration(path3) {
            path3.node.declare && safeRemove(path3);
          }, VariableDeclarator({ node }) {
            node.definite && (node.definite = null);
          }, TSIndexSignature(path3) {
            path3.remove();
          }, ClassDeclaration(path3) {
            const { node } = path3;
            node.declare && safeRemove(path3);
          }, Class(path3) {
            const { node } = path3;
            node.typeParameters && (node.typeParameters = null), node.superTypeParameters && (node.superTypeParameters = null), node.implements && (node.implements = null), node.abstract && (node.abstract = null), path3.get("body.body").forEach((child) => {
              child.isClassMethod() || child.isClassPrivateMethod() ? "constructor" === child.node.kind ? classMemberVisitors.constructor(child, path3) : classMemberVisitors.method(child) : (child.isClassProperty() || child.isClassPrivateProperty() || child.isClassAccessorProperty()) && classMemberVisitors.field(child);
            });
          }, Function(path3) {
            const { node } = path3;
            node.typeParameters && (node.typeParameters = null), node.returnType && (node.returnType = null);
            const params = node.params;
            params.length > 0 && t.isIdentifier(params[0], { name: "this" }) && params.shift();
          }, TSModuleDeclaration(path3) {
            (0, _namespace.default)(path3, allowNamespaces);
          }, TSInterfaceDeclaration(path3) {
            path3.remove();
          }, TSTypeAliasDeclaration(path3) {
            path3.remove();
          }, TSEnumDeclaration(path3) {
            optimizeConstEnums && path3.node.const ? (0, _constEnum.default)(path3, t) : (0, _enum.default)(path3, t);
          }, TSImportEqualsDeclaration(path3, pass) {
            const { id, moduleReference } = path3.node;
            let init, varKind;
            t.isTSExternalModuleReference(moduleReference) ? (assertCjsTransformEnabled(path3, pass, `import ${id.name} = require(...);`, `import ${id.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), init = t.callExpression(t.identifier("require"), [moduleReference.expression]), varKind = "const") : (init = entityNameToExpr(moduleReference), varKind = "var"), path3.replaceWith(t.variableDeclaration(varKind, [t.variableDeclarator(id, init)])), path3.scope.registerDeclaration(path3);
          }, TSExportAssignment(path3, pass) {
            assertCjsTransformEnabled(path3, pass, "export = <value>;", "export default <value>;"), path3.replaceWith(template2.statement.ast`module.exports = ${path3.node.expression}`);
          }, TSTypeAssertion(path3) {
            path3.replaceWith(path3.node.expression);
          }, ["TSAsExpression" + (t.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")](path3) {
            let { node } = path3;
            do {
              node = node.expression;
            } while (t.isTSAsExpression(node) || null != t.isTSSatisfiesExpression && t.isTSSatisfiesExpression(node));
            path3.replaceWith(node);
          }, [api.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](path3) {
            path3.replaceWith(path3.node.expression);
          }, CallExpression(path3) {
            path3.node.typeParameters = null;
          }, OptionalCallExpression(path3) {
            path3.node.typeParameters = null;
          }, NewExpression(path3) {
            path3.node.typeParameters = null;
          }, JSXOpeningElement(path3) {
            path3.node.typeParameters = null;
          }, TaggedTemplateExpression(path3) {
            path3.node.typeParameters = null;
          } } };
          function entityNameToExpr(node) {
            return t.isTSQualifiedName(node) ? t.memberExpression(entityNameToExpr(node.left), node.right) : node;
          }
          function visitPattern({ node }) {
            node.typeAnnotation && (node.typeAnnotation = null), t.isIdentifier(node) && node.optional && (node.optional = null);
          }
          function isImportTypeOnly({ binding, programPath, pragmaImportName, pragmaFragImportName }) {
            for (const path3 of binding.referencePaths)
              if (!isInType(path3))
                return false;
            if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName)
              return true;
            let sourceFileHasJsx = false;
            return programPath.traverse({ "JSXElement|JSXFragment"(path3) {
              sourceFileHasJsx = true, path3.stop();
            } }), !sourceFileHasJsx;
          }
        });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/namespace.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(path3, allowNamespaces) {
          if (path3.node.declare || "StringLiteral" === path3.node.id.type)
            return void path3.remove();
          if (!allowNamespaces)
            throw path3.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const name = path3.node.id.name, value2 = handleNested(path3, _core.types.cloneNode(path3.node, true)), bound = path3.scope.hasOwnBinding(name);
          "ExportNamedDeclaration" === path3.parent.type ? bound ? path3.parentPath.replaceWith(value2) : (path3.parentPath.insertAfter(value2), path3.replaceWith(getDeclaration(name)), path3.scope.registerDeclaration(path3.parentPath)) : bound ? path3.replaceWith(value2) : path3.scope.registerDeclaration(path3.replaceWithMultiple([getDeclaration(name), value2])[0]);
        };
        var _core = __webpack_require__2("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js");
        function getDeclaration(name) {
          return _core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.identifier(name))]);
        }
        function getMemberExpression(name, itemName) {
          return _core.types.memberExpression(_core.types.identifier(name), _core.types.identifier(itemName));
        }
        function handleVariableDeclaration(node, name, hub) {
          if ("const" !== node.kind)
            throw hub.file.buildCodeFrameError(node, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const { declarations } = node;
          if (declarations.every((declarator) => _core.types.isIdentifier(declarator.id))) {
            for (const declarator of declarations)
              declarator.init = _core.types.assignmentExpression("=", getMemberExpression(name, declarator.id.name), declarator.init);
            return [node];
          }
          const bindingIdentifiers = _core.types.getBindingIdentifiers(node), assignments = [];
          for (const idName in bindingIdentifiers)
            assignments.push(_core.types.assignmentExpression("=", getMemberExpression(name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));
          return [node, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];
        }
        function buildNestedAmbientModuleError(path3, node) {
          return path3.hub.buildError(node, "Ambient modules cannot be nested in other modules or namespaces.", Error);
        }
        function handleNested(path3, node, parentExport) {
          const names = /* @__PURE__ */ new Set(), realName = node.id;
          _core.types.assertIdentifier(realName);
          const name = path3.scope.generateUid(realName.name), namespaceTopLevel = _core.types.isTSModuleBlock(node.body) ? node.body.body : [_core.types.exportNamedDeclaration(node.body)];
          for (let i = 0; i < namespaceTopLevel.length; i++) {
            const subNode = namespaceTopLevel[i];
            switch (subNode.type) {
              case "TSModuleDeclaration": {
                if (!_core.types.isIdentifier(subNode.id))
                  throw buildNestedAmbientModuleError(path3, subNode);
                const transformed = handleNested(path3, subNode), moduleName = subNode.id.name;
                names.has(moduleName) ? namespaceTopLevel[i] = transformed : (names.add(moduleName), namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed));
                continue;
              }
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration":
                names.add(subNode.id.name);
                continue;
              case "VariableDeclaration":
                for (const name2 in _core.types.getBindingIdentifiers(subNode))
                  names.add(name2);
                continue;
              default:
                continue;
              case "ExportNamedDeclaration":
            }
            if (!("declare" in subNode.declaration) || !subNode.declaration.declare)
              switch (subNode.declaration.type) {
                case "TSEnumDeclaration":
                case "FunctionDeclaration":
                case "ClassDeclaration": {
                  const itemName = subNode.declaration.id.name;
                  names.add(itemName), namespaceTopLevel.splice(i++, 1, subNode.declaration, _core.types.expressionStatement(_core.types.assignmentExpression("=", getMemberExpression(name, itemName), _core.types.identifier(itemName))));
                  break;
                }
                case "VariableDeclaration": {
                  const nodes = handleVariableDeclaration(subNode.declaration, name, path3.hub);
                  namespaceTopLevel.splice(i, nodes.length, ...nodes), i += nodes.length - 1;
                  break;
                }
                case "TSModuleDeclaration": {
                  if (!_core.types.isIdentifier(subNode.declaration.id))
                    throw buildNestedAmbientModuleError(path3, subNode.declaration);
                  const transformed = handleNested(path3, subNode.declaration, _core.types.identifier(name)), moduleName = subNode.declaration.id.name;
                  names.has(moduleName) ? namespaceTopLevel[i] = transformed : (names.add(moduleName), namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed));
                }
              }
          }
          let fallthroughValue = _core.types.objectExpression([]);
          if (parentExport) {
            const memberExpr = _core.types.memberExpression(parentExport, realName);
            fallthroughValue = _core.template.expression.ast`
      ${_core.types.cloneNode(memberExpr)} ||
        (${_core.types.cloneNode(memberExpr)} = ${fallthroughValue})
    `;
          }
          return _core.template.statement.ast`
    (function (${_core.types.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${_core.types.cloneNode(realName)} = ${fallthroughValue}));
  `;
        }
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/preset-typescript/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var helperPluginUtils = __webpack_require__2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js"), transformTypeScript = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/index.js");
        __webpack_require__2("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-jsx/lib/index.js");
        var transformModulesCommonJS = __webpack_require__2("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), helperValidatorOption = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-option@7.22.5/node_modules/@babel/helper-validator-option/lib/index.js");
        function _interopDefaultLegacy(e) {
          return e && "object" == typeof e && "default" in e ? e : { default: e };
        }
        var transformTypeScript__default = _interopDefaultLegacy(transformTypeScript), transformModulesCommonJS__default = _interopDefaultLegacy(transformModulesCommonJS);
        const v = new helperValidatorOption.OptionValidator("@babel/preset-typescript");
        var index2 = helperPluginUtils.declarePreset((api, opts) => {
          api.assertVersion(7);
          const { allExtensions, ignoreExtensions, allowNamespaces, disallowAmbiguousJSXLike, isTSX, jsxPragma, jsxPragmaFrag, onlyRemoveTypeImports, optimizeConstEnums } = function(options = {}) {
            let { allowNamespaces: allowNamespaces2 = true, jsxPragma: jsxPragma2, onlyRemoveTypeImports: onlyRemoveTypeImports2 } = options;
            const TopLevelOptions_ignoreExtensions = "ignoreExtensions", TopLevelOptions_disallowAmbiguousJSXLike = "disallowAmbiguousJSXLike", TopLevelOptions_jsxPragmaFrag = "jsxPragmaFrag", TopLevelOptions_optimizeConstEnums = "optimizeConstEnums", TopLevelOptions_allExtensions = "allExtensions", TopLevelOptions_isTSX = "isTSX", jsxPragmaFrag2 = v.validateStringOption(TopLevelOptions_jsxPragmaFrag, options.jsxPragmaFrag, "React.Fragment");
            var allExtensions2 = v.validateBooleanOption(TopLevelOptions_allExtensions, options.allExtensions, false), isTSX2 = v.validateBooleanOption(TopLevelOptions_isTSX, options.isTSX, false);
            isTSX2 && v.invariant(allExtensions2, "isTSX:true requires allExtensions:true");
            const ignoreExtensions2 = v.validateBooleanOption(TopLevelOptions_ignoreExtensions, options.ignoreExtensions, false), disallowAmbiguousJSXLike2 = v.validateBooleanOption(TopLevelOptions_disallowAmbiguousJSXLike, options.disallowAmbiguousJSXLike, false);
            disallowAmbiguousJSXLike2 && v.invariant(allExtensions2, "disallowAmbiguousJSXLike:true requires allExtensions:true");
            const normalized = { ignoreExtensions: ignoreExtensions2, allowNamespaces: allowNamespaces2, disallowAmbiguousJSXLike: disallowAmbiguousJSXLike2, jsxPragma: jsxPragma2, jsxPragmaFrag: jsxPragmaFrag2, onlyRemoveTypeImports: onlyRemoveTypeImports2, optimizeConstEnums: v.validateBooleanOption(TopLevelOptions_optimizeConstEnums, options.optimizeConstEnums, false) };
            return normalized.allExtensions = allExtensions2, normalized.isTSX = isTSX2, normalized;
          }(opts), pluginOptions = (disallowAmbiguousJSXLike2) => ({ allowDeclareFields: opts.allowDeclareFields, allowNamespaces, disallowAmbiguousJSXLike: disallowAmbiguousJSXLike2, jsxPragma, jsxPragmaFrag, onlyRemoveTypeImports, optimizeConstEnums }), getPlugins = (isTSX2, disallowAmbiguousJSXLike2) => [[transformTypeScript__default.default, Object.assign({ isTSX: isTSX2 }, pluginOptions(disallowAmbiguousJSXLike2))]];
          return { overrides: allExtensions || ignoreExtensions ? [{ plugins: getPlugins(isTSX, disallowAmbiguousJSXLike) }] : [{ test: /\.ts$/, plugins: getPlugins(false, false) }, { test: /\.mts$/, sourceType: "module", plugins: getPlugins(false, true) }, { test: /\.cts$/, sourceType: "unambiguous", plugins: [[transformModulesCommonJS__default.default, { allowTopLevelThis: true }], [transformTypeScript__default.default, pluginOptions(true)]] }, { test: /\.tsx$/, plugins: getPlugins(true, false) }] };
        });
        exports3.default = index2;
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/builder.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function createTemplateBuilder(formatter, defaultOpts) {
          const templateFnCache = /* @__PURE__ */ new WeakMap(), templateAstCache = /* @__PURE__ */ new WeakMap(), cachedOpts = defaultOpts || (0, _options.validate)(null);
          return Object.assign((tpl, ...args) => {
            if ("string" == typeof tpl) {
              if (args.length > 1)
                throw new Error("Unexpected extra params.");
              return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
            }
            if (Array.isArray(tpl)) {
              let builder = templateFnCache.get(tpl);
              return builder || (builder = (0, _literal.default)(formatter, tpl, cachedOpts), templateFnCache.set(tpl, builder)), extendedTrace(builder(args));
            }
            if ("object" == typeof tpl && tpl) {
              if (args.length > 0)
                throw new Error("Unexpected extra params.");
              return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
            }
            throw new Error("Unexpected template param " + typeof tpl);
          }, { ast: (tpl, ...args) => {
            if ("string" == typeof tpl) {
              if (args.length > 1)
                throw new Error("Unexpected extra params.");
              return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
            }
            if (Array.isArray(tpl)) {
              let builder = templateAstCache.get(tpl);
              return builder || (builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER)), templateAstCache.set(tpl, builder)), builder(args)();
            }
            throw new Error("Unexpected template param " + typeof tpl);
          } });
        };
        var _options = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/options.js"), _string = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/string.js"), _literal = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/literal.js");
        const NO_PLACEHOLDER = (0, _options.validate)({ placeholderPattern: false });
        function extendedTrace(fn) {
          let rootStack = "";
          try {
            throw new Error();
          } catch (error) {
            error.stack && (rootStack = error.stack.split("\n").slice(3).join("\n"));
          }
          return (arg) => {
            try {
              return fn(arg);
            } catch (err) {
              throw err.stack += `
    =============
${rootStack}`, err;
            }
          };
        }
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/formatters.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.statements = exports3.statement = exports3.smart = exports3.program = exports3.expression = void 0;
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { assertExpressionStatement } = _t;
        function makeStatementFormatter(fn) {
          return { code: (str) => `/* @babel/template */;
${str}`, validate: () => {
          }, unwrap: (ast) => fn(ast.program.body.slice(1)) };
        }
        const smart = makeStatementFormatter((body) => body.length > 1 ? body : body[0]);
        exports3.smart = smart;
        const statements = makeStatementFormatter((body) => body);
        exports3.statements = statements;
        const statement = makeStatementFormatter((body) => {
          if (0 === body.length)
            throw new Error("Found nothing to return.");
          if (body.length > 1)
            throw new Error("Found multiple statements but wanted one");
          return body[0];
        });
        exports3.statement = statement;
        const expression = { code: (str) => `(
${str}
)`, validate: (ast) => {
          if (ast.program.body.length > 1)
            throw new Error("Found multiple statements but wanted one");
          if (0 === expression.unwrap(ast).start)
            throw new Error("Parse result included parens.");
        }, unwrap: ({ program }) => {
          const [stmt] = program.body;
          return assertExpressionStatement(stmt), stmt.expression;
        } };
        exports3.expression = expression;
        exports3.program = { code: (str) => str, validate: () => {
        }, unwrap: (ast) => ast.program };
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.statements = exports3.statement = exports3.smart = exports3.program = exports3.expression = exports3.default = void 0;
        var formatters = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/formatters.js"), _builder = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/builder.js");
        const smart = (0, _builder.default)(formatters.smart);
        exports3.smart = smart;
        const statement = (0, _builder.default)(formatters.statement);
        exports3.statement = statement;
        const statements = (0, _builder.default)(formatters.statements);
        exports3.statements = statements;
        const expression = (0, _builder.default)(formatters.expression);
        exports3.expression = expression;
        const program = (0, _builder.default)(formatters.program);
        exports3.program = program;
        var _default = Object.assign(smart.bind(void 0), { smart, statement, statements, expression, program, ast: smart.ast });
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/literal.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(formatter, tpl, opts) {
          const { metadata, names } = function(formatter2, tpl2, opts2) {
            let prefix = "BABEL_TPL$";
            const raw = tpl2.join("");
            do {
              prefix = "$$" + prefix;
            } while (raw.includes(prefix));
            const { names: names2, code } = function(tpl3, prefix2) {
              const names3 = [];
              let code2 = tpl3[0];
              for (let i = 1; i < tpl3.length; i++) {
                const value2 = `${prefix2}${i - 1}`;
                names3.push(value2), code2 += value2 + tpl3[i];
              }
              return { names: names3, code: code2 };
            }(tpl2, prefix), metadata2 = (0, _parse.default)(formatter2, formatter2.code(code), { parser: opts2.parser, placeholderWhitelist: new Set(names2.concat(opts2.placeholderWhitelist ? Array.from(opts2.placeholderWhitelist) : [])), placeholderPattern: opts2.placeholderPattern, preserveComments: opts2.preserveComments, syntacticPlaceholders: opts2.syntacticPlaceholders });
            return { metadata: metadata2, names: names2 };
          }(formatter, tpl, opts);
          return (arg) => {
            const defaultReplacements = {};
            return arg.forEach((replacement, i) => {
              defaultReplacements[names[i]] = replacement;
            }), (arg2) => {
              const replacements = (0, _options.normalizeReplacements)(arg2);
              return replacements && Object.keys(replacements).forEach((key) => {
                if (Object.prototype.hasOwnProperty.call(defaultReplacements, key))
                  throw new Error("Unexpected replacement overlap.");
              }), formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
            };
          };
        };
        var _options = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/options.js"), _parse = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/parse.js"), _populate = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/options.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.merge = function(a, b) {
          const { placeholderWhitelist = a.placeholderWhitelist, placeholderPattern = a.placeholderPattern, preserveComments = a.preserveComments, syntacticPlaceholders = a.syntacticPlaceholders } = b;
          return { parser: Object.assign({}, a.parser, b.parser), placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders };
        }, exports3.normalizeReplacements = function(replacements) {
          if (Array.isArray(replacements))
            return replacements.reduce((acc, replacement, i) => (acc["$" + i] = replacement, acc), {});
          if ("object" == typeof replacements || null == replacements)
            return replacements || void 0;
          throw new Error("Template replacements must be an array, object, null, or undefined");
        }, exports3.validate = function(opts) {
          if (null != opts && "object" != typeof opts)
            throw new Error("Unknown template options.");
          const _ref = opts || {}, { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = _ref, parser = function(source, excluded) {
            if (null == source)
              return {};
            var key, i, target = {}, sourceKeys = Object.keys(source);
            for (i = 0; i < sourceKeys.length; i++)
              key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
            return target;
          }(_ref, _excluded);
          if (null != placeholderWhitelist && !(placeholderWhitelist instanceof Set))
            throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
          if (null != placeholderPattern && !(placeholderPattern instanceof RegExp) && false !== placeholderPattern)
            throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
          if (null != preserveComments && "boolean" != typeof preserveComments)
            throw new Error("'.preserveComments' must be a boolean, null, or undefined");
          if (null != syntacticPlaceholders && "boolean" != typeof syntacticPlaceholders)
            throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
          if (true === syntacticPlaceholders && (null != placeholderWhitelist || null != placeholderPattern))
            throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          return { parser, placeholderWhitelist: placeholderWhitelist || void 0, placeholderPattern: null == placeholderPattern ? void 0 : placeholderPattern, preserveComments: null == preserveComments ? void 0 : preserveComments, syntacticPlaceholders: null == syntacticPlaceholders ? void 0 : syntacticPlaceholders };
        };
        const _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/parse.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(formatter, code, opts) {
          const { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = opts, ast = function(code2, parserOpts, syntacticPlaceholders2) {
            const plugins = (parserOpts.plugins || []).slice();
            false !== syntacticPlaceholders2 && plugins.push("placeholders");
            parserOpts = Object.assign({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, sourceType: "module" }, parserOpts, { plugins });
            try {
              return (0, _parser.parse)(code2, parserOpts);
            } catch (err) {
              const loc = err.loc;
              throw loc && (err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code2, { start: loc }), err.code = "BABEL_TEMPLATE_PARSE_ERROR"), err;
            }
          }(code, opts.parser, syntacticPlaceholders);
          removePropertiesDeep(ast, { preserveComments }), formatter.validate(ast);
          const state = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist, placeholderPattern, syntacticPlaceholders };
          return traverse(ast, placeholderVisitorHandler, state), Object.assign({ ast }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _parser = __webpack_require__2("./node_modules/.pnpm/@babel+parser@7.22.6/node_modules/@babel/parser/lib/index.js"), _codeFrame = __webpack_require__2("./stubs/babel-codeframe.js");
        const { isCallExpression, isExpressionStatement, isFunction: isFunction2, isIdentifier, isJSXIdentifier, isNewExpression, isPlaceholder, isStatement, isStringLiteral, removePropertiesDeep, traverse } = _t, PATTERN = /^[_$A-Z0-9]+$/;
        function placeholderVisitorHandler(node, ancestors, state) {
          var _state$placeholderWhi;
          let name, hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
          if (isPlaceholder(node)) {
            if (false === state.syntacticPlaceholders)
              throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            name = node.name.name, hasSyntacticPlaceholders = true;
          } else {
            if (hasSyntacticPlaceholders || state.syntacticPlaceholders)
              return;
            if (isIdentifier(node) || isJSXIdentifier(node))
              name = node.name;
            else {
              if (!isStringLiteral(node))
                return;
              name = node.value;
            }
          }
          if (hasSyntacticPlaceholders && (null != state.placeholderPattern || null != state.placeholderWhitelist))
            throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          if (!(hasSyntacticPlaceholders || false !== state.placeholderPattern && (state.placeholderPattern || PATTERN).test(name) || null != (_state$placeholderWhi = state.placeholderWhitelist) && _state$placeholderWhi.has(name)))
            return;
          ancestors = ancestors.slice();
          const { node: parent, key } = ancestors[ancestors.length - 1];
          let type;
          isStringLiteral(node) || isPlaceholder(node, { expectedNode: "StringLiteral" }) ? type = "string" : isNewExpression(parent) && "arguments" === key || isCallExpression(parent) && "arguments" === key || isFunction2(parent) && "params" === key ? type = "param" : isExpressionStatement(parent) && !isPlaceholder(node) ? (type = "statement", ancestors = ancestors.slice(0, -1)) : type = isStatement(node) && isPlaceholder(node) ? "statement" : "other";
          const { placeholders, placeholderNames } = hasSyntacticPlaceholders ? state.syntactic : state.legacy;
          placeholders.push({ name, type, resolve: (ast) => function(ast2, ancestors2) {
            let parent2 = ast2;
            for (let i = 0; i < ancestors2.length - 1; i++) {
              const { key: key3, index: index3 } = ancestors2[i];
              parent2 = void 0 === index3 ? parent2[key3] : parent2[key3][index3];
            }
            const { key: key2, index: index2 } = ancestors2[ancestors2.length - 1];
            return { parent: parent2, key: key2, index: index2 };
          }(ast, ancestors), isDuplicate: placeholderNames.has(name) }), placeholderNames.add(name);
        }
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/populate.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(metadata, replacements) {
          const ast = cloneNode(metadata.ast);
          replacements && (metadata.placeholders.forEach((placeholder) => {
            if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
              const placeholderName = placeholder.name;
              throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
            }
          }), Object.keys(replacements).forEach((key) => {
            if (!metadata.placeholderNames.has(key))
              throw new Error(`Unknown substitution "${key}" given`);
          }));
          return metadata.placeholders.slice().reverse().forEach((placeholder) => {
            try {
              !function(placeholder2, ast2, replacement) {
                placeholder2.isDuplicate && (Array.isArray(replacement) ? replacement = replacement.map((node) => cloneNode(node)) : "object" == typeof replacement && (replacement = cloneNode(replacement)));
                const { parent, key, index: index2 } = placeholder2.resolve(ast2);
                if ("string" === placeholder2.type) {
                  if ("string" == typeof replacement && (replacement = stringLiteral(replacement)), !replacement || !isStringLiteral(replacement))
                    throw new Error("Expected string substitution");
                } else if ("statement" === placeholder2.type)
                  void 0 === index2 ? replacement ? Array.isArray(replacement) ? replacement = blockStatement(replacement) : "string" == typeof replacement ? replacement = expressionStatement(identifier(replacement)) : isStatement(replacement) || (replacement = expressionStatement(replacement)) : replacement = emptyStatement() : replacement && !Array.isArray(replacement) && ("string" == typeof replacement && (replacement = identifier(replacement)), isStatement(replacement) || (replacement = expressionStatement(replacement)));
                else if ("param" === placeholder2.type) {
                  if ("string" == typeof replacement && (replacement = identifier(replacement)), void 0 === index2)
                    throw new Error("Assertion failure.");
                } else if ("string" == typeof replacement && (replacement = identifier(replacement)), Array.isArray(replacement))
                  throw new Error("Cannot replace single expression with an array.");
                if (void 0 === index2)
                  validate(parent, key, replacement), parent[key] = replacement;
                else {
                  const items = parent[key].slice();
                  "statement" === placeholder2.type || "param" === placeholder2.type ? null == replacement ? items.splice(index2, 1) : Array.isArray(replacement) ? items.splice(index2, 1, ...replacement) : items[index2] = replacement : items[index2] = replacement, validate(parent, key, items), parent[key] = items;
                }
              }(placeholder, ast, replacements && replacements[placeholder.name] || null);
            } catch (e) {
              throw e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`, e;
            }
          }), ast;
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { blockStatement, cloneNode, emptyStatement, expressionStatement, identifier, isStatement, isStringLiteral, stringLiteral, validate } = _t;
      }, "./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/string.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(formatter, code, opts) {
          let metadata;
          return code = formatter.code(code), (arg) => {
            const replacements = (0, _options.normalizeReplacements)(arg);
            return metadata || (metadata = (0, _parse.default)(formatter, code, opts)), formatter.unwrap((0, _populate.default)(metadata, replacements));
          };
        };
        var _options = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/options.js"), _parse = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/parse.js"), _populate = __webpack_require__2("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/cache.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.clear = function() {
          clearPath(), clearScope();
        }, exports3.clearPath = clearPath, exports3.clearScope = clearScope, exports3.scope = exports3.path = void 0;
        let path3 = /* @__PURE__ */ new WeakMap();
        exports3.path = path3;
        let scope = /* @__PURE__ */ new WeakMap();
        function clearPath() {
          exports3.path = path3 = /* @__PURE__ */ new WeakMap();
        }
        function clearScope() {
          exports3.scope = scope = /* @__PURE__ */ new WeakMap();
        }
        exports3.scope = scope;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/context.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _path = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS } = _t;
        exports3.default = class {
          constructor(scope, opts, state, parentPath) {
            this.queue = null, this.priorityQueue = null, this.parentPath = parentPath, this.scope = scope, this.state = state, this.opts = opts;
          }
          shouldVisit(node) {
            const opts = this.opts;
            if (opts.enter || opts.exit)
              return true;
            if (opts[node.type])
              return true;
            const keys2 = VISITOR_KEYS[node.type];
            if (null == keys2 || !keys2.length)
              return false;
            for (const key of keys2)
              if (node[key])
                return true;
            return false;
          }
          create(node, container, key, listKey) {
            return _path.default.get({ parentPath: this.parentPath, parent: node, container, key, listKey });
          }
          maybeQueue(path3, notPriority) {
            this.queue && (notPriority ? this.queue.push(path3) : this.priorityQueue.push(path3));
          }
          visitMultiple(container, parent, listKey) {
            if (0 === container.length)
              return false;
            const queue2 = [];
            for (let key = 0; key < container.length; key++) {
              const node = container[key];
              node && this.shouldVisit(node) && queue2.push(this.create(parent, container, key, listKey));
            }
            return this.visitQueue(queue2);
          }
          visitSingle(node, key) {
            return !!this.shouldVisit(node[key]) && this.visitQueue([this.create(node, node, key)]);
          }
          visitQueue(queue2) {
            this.queue = queue2, this.priorityQueue = [];
            const visited = /* @__PURE__ */ new WeakSet();
            let stop = false;
            for (const path3 of queue2) {
              if (path3.resync(), 0 !== path3.contexts.length && path3.contexts[path3.contexts.length - 1] === this || path3.pushContext(this), null === path3.key)
                continue;
              const { node } = path3;
              if (!visited.has(node)) {
                if (node && visited.add(node), path3.visit()) {
                  stop = true;
                  break;
                }
                if (this.priorityQueue.length && (stop = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = queue2, stop))
                  break;
              }
            }
            for (const path3 of queue2)
              path3.popContext();
            return this.queue = null, stop;
          }
          visit(node, key) {
            const nodes = node[key];
            return !!nodes && (Array.isArray(nodes) ? this.visitMultiple(nodes, node, key) : this.visitSingle(node, key));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/hub.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        exports3.default = class {
          getCode() {
          }
          getScope() {
          }
          addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
          }
          buildError(node, msg, Error2 = TypeError) {
            return new Error2(msg);
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "Hub", { enumerable: true, get: function() {
          return _hub.default;
        } }), Object.defineProperty(exports3, "NodePath", { enumerable: true, get: function() {
          return _path.default;
        } }), Object.defineProperty(exports3, "Scope", { enumerable: true, get: function() {
          return _scope.default;
        } }), exports3.visitors = exports3.default = void 0;
        var visitors = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/visitors.js");
        exports3.visitors = visitors;
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), cache = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/cache.js"), _traverseNode = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/traverse-node.js"), _path = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js"), _scope = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/scope/index.js"), _hub = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/hub.js");
        const { VISITOR_KEYS, removeProperties, traverseFast } = _t;
        function traverse(parent, opts = {}, scope, state, parentPath) {
          if (parent) {
            if (!opts.noScope && !scope && "Program" !== parent.type && "File" !== parent.type)
              throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
            VISITOR_KEYS[parent.type] && (visitors.explode(opts), (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath));
          }
        }
        var _default = traverse;
        function hasDenylistedType(path3, state) {
          path3.node.type === state.type && (state.has = true, path3.stop());
        }
        exports3.default = _default, traverse.visitors = visitors, traverse.verify = visitors.verify, traverse.explode = visitors.explode, traverse.cheap = function(node, enter) {
          traverseFast(node, enter);
        }, traverse.node = function(node, opts, scope, state, path3, skipKeys) {
          (0, _traverseNode.traverseNode)(node, opts, scope, state, path3, skipKeys);
        }, traverse.clearNode = function(node, opts) {
          removeProperties(node, opts), cache.path.delete(node);
        }, traverse.removeProperties = function(tree, opts) {
          return traverseFast(tree, traverse.clearNode, opts), tree;
        }, traverse.hasType = function(tree, type, denylistTypes) {
          if (null != denylistTypes && denylistTypes.includes(tree.type))
            return false;
          if (tree.type === type)
            return true;
          const state = { has: false, type };
          return traverse(tree, { noScope: true, denylist: denylistTypes, enter: hasDenylistedType }, null, state), state.has;
        }, traverse.cache = cache;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/ancestry.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.find = function(callback) {
          let path3 = this;
          do {
            if (callback(path3))
              return path3;
          } while (path3 = path3.parentPath);
          return null;
        }, exports3.findParent = function(callback) {
          let path3 = this;
          for (; path3 = path3.parentPath; )
            if (callback(path3))
              return path3;
          return null;
        }, exports3.getAncestry = function() {
          let path3 = this;
          const paths = [];
          do {
            paths.push(path3);
          } while (path3 = path3.parentPath);
          return paths;
        }, exports3.getDeepestCommonAncestorFrom = function(paths, filter) {
          if (!paths.length)
            return this;
          if (1 === paths.length)
            return paths[0];
          let lastCommonIndex, lastCommon, minDepth = 1 / 0;
          const ancestries = paths.map((path3) => {
            const ancestry = [];
            do {
              ancestry.unshift(path3);
            } while ((path3 = path3.parentPath) && path3 !== this);
            return ancestry.length < minDepth && (minDepth = ancestry.length), ancestry;
          }), first = ancestries[0];
          depthLoop:
            for (let i = 0; i < minDepth; i++) {
              const shouldMatch = first[i];
              for (const ancestry of ancestries)
                if (ancestry[i] !== shouldMatch)
                  break depthLoop;
              lastCommonIndex = i, lastCommon = shouldMatch;
            }
          if (lastCommon)
            return filter ? filter(lastCommon, lastCommonIndex, ancestries) : lastCommon;
          throw new Error("Couldn't find intersection");
        }, exports3.getEarliestCommonAncestorFrom = function(paths) {
          return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
            let earliest;
            const keys2 = VISITOR_KEYS[deepest.type];
            for (const ancestry of ancestries) {
              const path3 = ancestry[i + 1];
              if (!earliest) {
                earliest = path3;
                continue;
              }
              if (path3.listKey && earliest.listKey === path3.listKey && path3.key < earliest.key) {
                earliest = path3;
                continue;
              }
              keys2.indexOf(earliest.parentKey) > keys2.indexOf(path3.parentKey) && (earliest = path3);
            }
            return earliest;
          });
        }, exports3.getFunctionParent = function() {
          return this.findParent((p) => p.isFunction());
        }, exports3.getStatementParent = function() {
          let path3 = this;
          do {
            if (!path3.parentPath || Array.isArray(path3.container) && path3.isStatement())
              break;
            path3 = path3.parentPath;
          } while (path3);
          if (path3 && (path3.isProgram() || path3.isFile()))
            throw new Error("File/Program node, we can't possibly find a statement parent to this");
          return path3;
        }, exports3.inType = function(...candidateTypes) {
          let path3 = this;
          for (; path3; ) {
            for (const type of candidateTypes)
              if (path3.node.type === type)
                return true;
            path3 = path3.parentPath;
          }
          return false;
        }, exports3.isAncestor = function(maybeDescendant) {
          return maybeDescendant.isDescendant(this);
        }, exports3.isDescendant = function(maybeAncestor) {
          return !!this.findParent((parent) => parent === maybeAncestor);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS } = _t;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/comments.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.addComment = function(type, content, line) {
          _addComment(this.node, type, content, line);
        }, exports3.addComments = function(type, comments) {
          _addComments(this.node, type, comments);
        }, exports3.shareCommentsWithSiblings = function() {
          if ("string" == typeof this.key)
            return;
          const node = this.node;
          if (!node)
            return;
          const trailing = node.trailingComments, leading = node.leadingComments;
          if (!trailing && !leading)
            return;
          const prev = this.getSibling(this.key - 1), next = this.getSibling(this.key + 1), hasPrev = Boolean(prev.node), hasNext = Boolean(next.node);
          hasPrev && (leading && prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments)), trailing && !hasNext && prev.addComments("trailing", trailing));
          hasNext && (trailing && next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments)), leading && !hasPrev && next.addComments("leading", leading));
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { addComment: _addComment, addComments: _addComments } = _t;
        function removeIfExisting(list, toRemove) {
          if (!toRemove)
            return list;
          let lastFoundIndex = -1;
          return list.filter((el) => {
            const i = toRemove.indexOf(el, lastFoundIndex);
            if (-1 === i)
              return true;
            lastFoundIndex = i;
          });
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/context.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3._call = function(fns) {
          if (!fns)
            return false;
          for (const fn of fns) {
            if (!fn)
              continue;
            const node = this.node;
            if (!node)
              return true;
            const ret = fn.call(this.state, this, this.state);
            if (ret && "object" == typeof ret && "function" == typeof ret.then)
              throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (ret)
              throw new Error(`Unexpected return value from visitor method ${fn}`);
            if (this.node !== node)
              return true;
            if (this._traverseFlags > 0)
              return true;
          }
          return false;
        }, exports3._getQueueContexts = function() {
          let path3 = this, contexts = this.contexts;
          for (; !contexts.length && (path3 = path3.parentPath, path3); )
            contexts = path3.contexts;
          return contexts;
        }, exports3._resyncKey = function() {
          if (!this.container)
            return;
          if (this.node === this.container[this.key])
            return;
          if (Array.isArray(this.container)) {
            for (let i = 0; i < this.container.length; i++)
              if (this.container[i] === this.node)
                return void this.setKey(i);
          } else
            for (const key of Object.keys(this.container))
              if (this.container[key] === this.node)
                return void this.setKey(key);
          this.key = null;
        }, exports3._resyncList = function() {
          if (!this.parent || !this.inList)
            return;
          const newContainer = this.parent[this.listKey];
          if (this.container === newContainer)
            return;
          this.container = newContainer || null;
        }, exports3._resyncParent = function() {
          this.parentPath && (this.parent = this.parentPath.node);
        }, exports3._resyncRemoved = function() {
          null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved();
        }, exports3.call = function(key) {
          const opts = this.opts;
          if (this.debug(key), this.node && this._call(opts[key]))
            return true;
          var _opts$this$node$type;
          return !!this.node && this._call(null == (_opts$this$node$type = opts[this.node.type]) ? void 0 : _opts$this$node$type[key]);
        }, exports3.isBlacklisted = exports3.isDenylisted = function() {
          var _this$opts$denylist;
          const denylist = null != (_this$opts$denylist = this.opts.denylist) ? _this$opts$denylist : this.opts.blacklist;
          return denylist && denylist.indexOf(this.node.type) > -1;
        }, exports3.popContext = function() {
          this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
        }, exports3.pushContext = function(context) {
          this.contexts.push(context), this.setContext(context);
        }, exports3.requeue = function(pathToQueue = this) {
          if (pathToQueue.removed)
            return;
          const contexts = this.contexts;
          for (const context of contexts)
            context.maybeQueue(pathToQueue);
        }, exports3.resync = function() {
          if (this.removed)
            return;
          this._resyncParent(), this._resyncList(), this._resyncKey();
        }, exports3.setContext = function(context) {
          null != this.skipKeys && (this.skipKeys = {});
          this._traverseFlags = 0, context && (this.context = context, this.state = context.state, this.opts = context.opts);
          return this.setScope(), this;
        }, exports3.setKey = function(key) {
          var _this$node;
          this.key = key, this.node = this.container[this.key], this.type = null == (_this$node = this.node) ? void 0 : _this$node.type;
        }, exports3.setScope = function() {
          var _this$opts2, _this$scope;
          if (null != (_this$opts2 = this.opts) && _this$opts2.noScope)
            return;
          let target, path3 = this.parentPath;
          (("key" === this.key || "decorators" === this.listKey) && path3.isMethod() || "discriminant" === this.key && path3.isSwitchStatement()) && (path3 = path3.parentPath);
          for (; path3 && !target; ) {
            var _path$opts;
            if (null != (_path$opts = path3.opts) && _path$opts.noScope)
              return;
            target = path3.scope, path3 = path3.parentPath;
          }
          this.scope = this.getScope(target), null == (_this$scope = this.scope) || _this$scope.init();
        }, exports3.setup = function(parentPath, container, listKey, key) {
          this.listKey = listKey, this.container = container, this.parentPath = parentPath || this.parentPath, this.setKey(key);
        }, exports3.skip = function() {
          this.shouldSkip = true;
        }, exports3.skipKey = function(key) {
          null == this.skipKeys && (this.skipKeys = {});
          this.skipKeys[key] = true;
        }, exports3.stop = function() {
          this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
        }, exports3.visit = function() {
          var _this$opts$shouldSkip, _this$opts;
          if (!this.node)
            return false;
          if (this.isDenylisted())
            return false;
          if (null != (_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) && _this$opts$shouldSkip.call(_this$opts, this))
            return false;
          const currentContext = this.context;
          if (this.shouldSkip || this.call("enter"))
            return this.debug("Skip..."), this.shouldStop;
          return restoreContext(this, currentContext), this.debug("Recursing into..."), this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), restoreContext(this, currentContext), this.call("exit"), this.shouldStop;
        };
        var _traverseNode = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/traverse-node.js"), _index = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js");
        function restoreContext(path3, context) {
          path3.context !== context && (path3.context = context, path3.state = context.state, path3.opts = context.opts);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/conversion.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.arrowFunctionToExpression = function({ allowInsertArrow = true, allowInsertArrowWithRest = allowInsertArrow, noNewArrows = !(() => {
          var _arguments$;
          return null == (_arguments$ = arguments[0]) ? void 0 : _arguments$.specCompliant;
        })() } = {}) {
          if (!this.isArrowFunctionExpression())
            throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
          const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
          if (fn.ensureBlock(), function(path3, type) {
            path3.node.type = type;
          }(fn, "FunctionExpression"), !noNewArrows) {
            const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
            return checkBinding && fn.parentPath.scope.push({ id: checkBinding, init: objectExpression([]) }), fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), identifier(checkBinding ? checkBinding.name : thisBinding)]))), fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()])), fn.get("callee.object");
          }
          return fn;
        }, exports3.ensureBlock = function() {
          const body = this.get("body"), bodyNode = body.node;
          if (Array.isArray(body))
            throw new Error("Can't convert array path to a block statement");
          if (!bodyNode)
            throw new Error("Can't convert node without a body");
          if (body.isBlockStatement())
            return bodyNode;
          const statements = [];
          let key, listKey, stringPath = "body";
          body.isStatement() ? (listKey = "body", key = 0, statements.push(body.node)) : (stringPath += ".body.0", this.isFunction() ? (key = "argument", statements.push(returnStatement(body.node))) : (key = "expression", statements.push(expressionStatement(body.node))));
          this.node.body = blockStatement(statements);
          const parentPath = this.get(stringPath);
          return body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key), this.node;
        }, exports3.toComputedKey = function() {
          let key;
          if (this.isMemberExpression())
            key = this.node.property;
          else {
            if (!this.isProperty() && !this.isMethod())
              throw new ReferenceError("todo");
            key = this.node.key;
          }
          this.node.computed || isIdentifier(key) && (key = stringLiteral(key.name));
          return key;
        }, exports3.unwrapFunctionEnvironment = function() {
          if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
            throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
          hoistFunctionEnvironment(this);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), _helperFunctionName = __webpack_require__2("./node_modules/.pnpm/@babel+helper-function-name@7.22.5/node_modules/@babel/helper-function-name/lib/index.js"), _visitors = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/visitors.js");
        const { arrowFunctionExpression, assignmentExpression, binaryExpression, blockStatement, callExpression, conditionalExpression, expressionStatement, identifier, isIdentifier, jsxIdentifier, logicalExpression, LOGICAL_OPERATORS, memberExpression, metaProperty, numericLiteral, objectExpression, restElement, returnStatement, sequenceExpression, spreadElement, stringLiteral, super: _super, thisExpression, toExpression, unaryExpression } = _t;
        exports3.arrowFunctionToShadowed = function() {
          this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
        };
        const getSuperCallsVisitor = (0, _visitors.merge)([{ CallExpression(child, { allSuperCalls }) {
          child.get("callee").isSuper() && allSuperCalls.push(child);
        } }, _helperEnvironmentVisitor.default]);
        function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
          let arrowParent, thisEnvFn = fnPath.findParent((p) => p.isArrowFunctionExpression() ? (null != arrowParent || (arrowParent = p), false) : p.isFunction() || p.isProgram() || p.isClassProperty({ static: false }) || p.isClassPrivateProperty({ static: false }));
          const inConstructor = thisEnvFn.isClassMethod({ kind: "constructor" });
          if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty())
            if (arrowParent)
              thisEnvFn = arrowParent;
            else {
              if (!allowInsertArrow)
                throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
              fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), [])), thisEnvFn = fnPath.get("callee"), fnPath = thisEnvFn.get("body");
            }
          const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } = function(fnPath2) {
            const thisPaths2 = [], argumentsPaths2 = [], newTargetPaths2 = [], superProps2 = [], superCalls2 = [];
            return fnPath2.traverse(getScopeInformationVisitor, { thisPaths: thisPaths2, argumentsPaths: argumentsPaths2, newTargetPaths: newTargetPaths2, superProps: superProps2, superCalls: superCalls2 }), { thisPaths: thisPaths2, argumentsPaths: argumentsPaths2, newTargetPaths: newTargetPaths2, superProps: superProps2, superCalls: superCalls2 };
          }(fnPath);
          if (inConstructor && superCalls.length > 0) {
            if (!allowInsertArrow)
              throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            if (!allowInsertArrowWithRest)
              throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            const allSuperCalls = [];
            thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });
            const superBinding = function(thisEnvFn2) {
              return getBinding(thisEnvFn2, "supercall", () => {
                const argsBinding = thisEnvFn2.scope.generateUidIdentifier("args");
                return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
              });
            }(thisEnvFn);
            allSuperCalls.forEach((superCall) => {
              const callee = identifier(superBinding);
              callee.loc = superCall.node.callee.loc, superCall.get("callee").replaceWith(callee);
            });
          }
          if (argumentsPaths.length > 0) {
            const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
              const args = () => identifier("arguments");
              return thisEnvFn.scope.path.isProgram() ? conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args()) : args();
            });
            argumentsPaths.forEach((argumentsChild) => {
              const argsRef = identifier(argumentsBinding);
              argsRef.loc = argumentsChild.node.loc, argumentsChild.replaceWith(argsRef);
            });
          }
          if (newTargetPaths.length > 0) {
            const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
            newTargetPaths.forEach((targetChild) => {
              const targetRef = identifier(newTargetBinding);
              targetRef.loc = targetChild.node.loc, targetChild.replaceWith(targetRef);
            });
          }
          if (superProps.length > 0) {
            if (!allowInsertArrow)
              throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            superProps.reduce((acc, superProp) => acc.concat(function(superProp2) {
              if (superProp2.parentPath.isAssignmentExpression() && "=" !== superProp2.parentPath.node.operator) {
                const assignmentPath = superProp2.parentPath, op = assignmentPath.node.operator.slice(0, -1), value2 = assignmentPath.node.right, isLogicalAssignment = function(op2) {
                  return LOGICAL_OPERATORS.includes(op2);
                }(op);
                if (superProp2.node.computed) {
                  const tmp = superProp2.scope.generateDeclaredUidIdentifier("tmp"), object = superProp2.node.object, property = superProp2.node.property;
                  assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true)), assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value2));
                } else {
                  const object = superProp2.node.object, property = superProp2.node.property;
                  assignmentPath.get("left").replaceWith(memberExpression(object, property)), assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value2));
                }
                return isLogicalAssignment ? assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right)) : assignmentPath.node.operator = "=", [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
              }
              if (superProp2.parentPath.isUpdateExpression()) {
                const updateExpr = superProp2.parentPath, tmp = superProp2.scope.generateDeclaredUidIdentifier("tmp"), computedKey = superProp2.node.computed ? superProp2.scope.generateDeclaredUidIdentifier("prop") : null, parts = [assignmentExpression("=", tmp, memberExpression(superProp2.node.object, computedKey ? assignmentExpression("=", computedKey, superProp2.node.property) : superProp2.node.property, superProp2.node.computed)), assignmentExpression("=", memberExpression(superProp2.node.object, computedKey ? identifier(computedKey.name) : superProp2.node.property, superProp2.node.computed), binaryExpression(superProp2.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
                superProp2.parentPath.node.prefix || parts.push(identifier(tmp.name)), updateExpr.replaceWith(sequenceExpression(parts));
                return [updateExpr.get("expressions.0.right"), updateExpr.get("expressions.1.left")];
              }
              return [superProp2];
              function rightExpression(op, left, right) {
                return "=" === op ? assignmentExpression("=", left, right) : binaryExpression(op, left, right);
              }
            }(superProp)), []).forEach((superProp) => {
              const key = superProp.node.computed ? "" : superProp.get("property").node.name, superParentPath = superProp.parentPath, isAssignment = superParentPath.isAssignmentExpression({ left: superProp.node }), isCall = superParentPath.isCallExpression({ callee: superProp.node }), isTaggedTemplate = superParentPath.isTaggedTemplateExpression({ tag: superProp.node }), superBinding = function(thisEnvFn2, isAssignment2, propName) {
                const op = isAssignment2 ? "set" : "get";
                return getBinding(thisEnvFn2, `superprop_${op}:${propName || ""}`, () => {
                  const argsList = [];
                  let fnBody;
                  if (propName)
                    fnBody = memberExpression(_super(), identifier(propName));
                  else {
                    const method = thisEnvFn2.scope.generateUidIdentifier("prop");
                    argsList.unshift(method), fnBody = memberExpression(_super(), identifier(method.name), true);
                  }
                  if (isAssignment2) {
                    const valueIdent = thisEnvFn2.scope.generateUidIdentifier("value");
                    argsList.push(valueIdent), fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
                  }
                  return arrowFunctionExpression(argsList, fnBody);
                });
              }(thisEnvFn, isAssignment, key), args = [];
              if (superProp.node.computed && args.push(superProp.get("property").node), isAssignment) {
                const value2 = superParentPath.node.right;
                args.push(value2);
              }
              const call = callExpression(identifier(superBinding), args);
              isCall ? (superParentPath.unshiftContainer("arguments", thisExpression()), superProp.replaceWith(memberExpression(call, identifier("call"))), thisPaths.push(superParentPath.get("arguments.0"))) : isAssignment ? superParentPath.replaceWith(call) : isTaggedTemplate ? (superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()])), thisPaths.push(superProp.get("arguments.0"))) : superProp.replaceWith(call);
            });
          }
          let thisBinding;
          return (thisPaths.length > 0 || !noNewArrows) && (thisBinding = function(thisEnvFn2, inConstructor2) {
            return getBinding(thisEnvFn2, "this", (thisBinding2) => {
              if (!inConstructor2 || !hasSuperClass(thisEnvFn2))
                return thisExpression();
              thisEnvFn2.traverse(assignSuperThisVisitor, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: thisBinding2 });
            });
          }(thisEnvFn, inConstructor), (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) && (thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
            thisRef.loc = thisChild.node.loc, thisChild.replaceWith(thisRef);
          }), noNewArrows || (thisBinding = null))), { thisBinding, fnPath };
        }
        function hasSuperClass(thisEnvFn) {
          return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
        }
        const assignSuperThisVisitor = (0, _visitors.merge)([{ CallExpression(child, { supers, thisBinding }) {
          child.get("callee").isSuper() && (supers.has(child.node) || (supers.add(child.node), child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))])));
        } }, _helperEnvironmentVisitor.default]);
        function getBinding(thisEnvFn, key, init) {
          const cacheKey = "binding:" + key;
          let data2 = thisEnvFn.getData(cacheKey);
          if (!data2) {
            const id = thisEnvFn.scope.generateUidIdentifier(key);
            data2 = id.name, thisEnvFn.setData(cacheKey, data2), thisEnvFn.scope.push({ id, init: init(data2) });
          }
          return data2;
        }
        const getScopeInformationVisitor = (0, _visitors.merge)([{ ThisExpression(child, { thisPaths }) {
          thisPaths.push(child);
        }, JSXIdentifier(child, { thisPaths }) {
          "this" === child.node.name && (child.parentPath.isJSXMemberExpression({ object: child.node }) || child.parentPath.isJSXOpeningElement({ name: child.node })) && thisPaths.push(child);
        }, CallExpression(child, { superCalls }) {
          child.get("callee").isSuper() && superCalls.push(child);
        }, MemberExpression(child, { superProps }) {
          child.get("object").isSuper() && superProps.push(child);
        }, Identifier(child, { argumentsPaths }) {
          if (!child.isReferencedIdentifier({ name: "arguments" }))
            return;
          let curr = child.scope;
          do {
            if (curr.hasOwnBinding("arguments"))
              return void curr.rename("arguments");
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression())
              break;
          } while (curr = curr.parent);
          argumentsPaths.push(child);
        }, MetaProperty(child, { newTargetPaths }) {
          child.get("meta").isIdentifier({ name: "new" }) && child.get("property").isIdentifier({ name: "target" }) && newTargetPaths.push(child);
        } }, _helperEnvironmentVisitor.default]);
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/evaluation.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.evaluate = function() {
          const state = { confident: true, deoptPath: null, seen: /* @__PURE__ */ new Map() };
          let value2 = evaluateCached(this, state);
          state.confident || (value2 = void 0);
          return { confident: state.confident, deopt: state.deoptPath, value: value2 };
        }, exports3.evaluateTruthy = function() {
          const res = this.evaluate();
          if (res.confident)
            return !!res.value;
        };
        const VALID_CALLEES = ["String", "Number", "Math"], INVALID_METHODS = ["random"];
        function isValidCallee(val) {
          return VALID_CALLEES.includes(val);
        }
        function deopt(path3, state) {
          state.confident && (state.deoptPath = path3, state.confident = false);
        }
        const Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
        function evaluateCached(path3, state) {
          const { node } = path3, { seen } = state;
          if (seen.has(node)) {
            const existing = seen.get(node);
            return existing.resolved ? existing.value : void deopt(path3, state);
          }
          {
            const item = { resolved: false };
            seen.set(node, item);
            const val = function(path4, state2) {
              if (!state2.confident)
                return;
              if (path4.isSequenceExpression()) {
                const exprs = path4.get("expressions");
                return evaluateCached(exprs[exprs.length - 1], state2);
              }
              if (path4.isStringLiteral() || path4.isNumericLiteral() || path4.isBooleanLiteral())
                return path4.node.value;
              if (path4.isNullLiteral())
                return null;
              if (path4.isTemplateLiteral())
                return evaluateQuasis(path4, path4.node.quasis, state2);
              if (path4.isTaggedTemplateExpression() && path4.get("tag").isMemberExpression()) {
                const object = path4.get("tag.object"), { node: { name } } = object, property = path4.get("tag.property");
                if (object.isIdentifier() && "String" === name && !path4.scope.getBinding(name) && property.isIdentifier() && "raw" === property.node.name)
                  return evaluateQuasis(path4, path4.node.quasi.quasis, state2, true);
              }
              if (path4.isConditionalExpression()) {
                const testResult = evaluateCached(path4.get("test"), state2);
                if (!state2.confident)
                  return;
                return evaluateCached(testResult ? path4.get("consequent") : path4.get("alternate"), state2);
              }
              if (path4.isExpressionWrapper())
                return evaluateCached(path4.get("expression"), state2);
              if (path4.isMemberExpression() && !path4.parentPath.isCallExpression({ callee: path4.node })) {
                const property = path4.get("property"), object = path4.get("object");
                if (object.isLiteral()) {
                  const value2 = object.node.value, type = typeof value2;
                  let key = null;
                  if (path4.node.computed) {
                    if (key = evaluateCached(property, state2), !state2.confident)
                      return;
                  } else
                    property.isIdentifier() && (key = property.node.name);
                  if (!("number" !== type && "string" !== type || null == key || "number" != typeof key && "string" != typeof key))
                    return value2[key];
                }
              }
              if (path4.isReferencedIdentifier()) {
                const binding = path4.scope.getBinding(path4.node.name);
                if (binding) {
                  if (binding.constantViolations.length > 0 || path4.node.start < binding.path.node.end)
                    return void deopt(binding.path, state2);
                  if (binding.hasValue)
                    return binding.value;
                }
                const name = path4.node.name;
                if (Globals.has(name))
                  return binding ? void deopt(binding.path, state2) : Globals.get(name);
                const resolved = path4.resolve();
                return resolved === path4 ? void deopt(path4, state2) : evaluateCached(resolved, state2);
              }
              if (path4.isUnaryExpression({ prefix: true })) {
                if ("void" === path4.node.operator)
                  return;
                const argument = path4.get("argument");
                if ("typeof" === path4.node.operator && (argument.isFunction() || argument.isClass()))
                  return "function";
                const arg = evaluateCached(argument, state2);
                if (!state2.confident)
                  return;
                switch (path4.node.operator) {
                  case "!":
                    return !arg;
                  case "+":
                    return +arg;
                  case "-":
                    return -arg;
                  case "~":
                    return ~arg;
                  case "typeof":
                    return typeof arg;
                }
              }
              if (path4.isArrayExpression()) {
                const arr = [], elems = path4.get("elements");
                for (const elem of elems) {
                  const elemValue = elem.evaluate();
                  if (!elemValue.confident)
                    return void deopt(elemValue.deopt, state2);
                  arr.push(elemValue.value);
                }
                return arr;
              }
              if (path4.isObjectExpression()) {
                const obj = {}, props = path4.get("properties");
                for (const prop of props) {
                  if (prop.isObjectMethod() || prop.isSpreadElement())
                    return void deopt(prop, state2);
                  const keyPath = prop.get("key");
                  let key;
                  if (prop.node.computed) {
                    if (key = keyPath.evaluate(), !key.confident)
                      return void deopt(key.deopt, state2);
                    key = key.value;
                  } else
                    key = keyPath.isIdentifier() ? keyPath.node.name : keyPath.node.value;
                  let value2 = prop.get("value").evaluate();
                  if (!value2.confident)
                    return void deopt(value2.deopt, state2);
                  value2 = value2.value, obj[key] = value2;
                }
                return obj;
              }
              if (path4.isLogicalExpression()) {
                const wasConfident = state2.confident, left = evaluateCached(path4.get("left"), state2), leftConfident = state2.confident;
                state2.confident = wasConfident;
                const right = evaluateCached(path4.get("right"), state2), rightConfident = state2.confident;
                switch (path4.node.operator) {
                  case "||":
                    if (state2.confident = leftConfident && (!!left || rightConfident), !state2.confident)
                      return;
                    return left || right;
                  case "&&":
                    if (state2.confident = leftConfident && (!left || rightConfident), !state2.confident)
                      return;
                    return left && right;
                  case "??":
                    if (state2.confident = leftConfident && (null != left || rightConfident), !state2.confident)
                      return;
                    return null != left ? left : right;
                }
              }
              if (path4.isBinaryExpression()) {
                const left = evaluateCached(path4.get("left"), state2);
                if (!state2.confident)
                  return;
                const right = evaluateCached(path4.get("right"), state2);
                if (!state2.confident)
                  return;
                switch (path4.node.operator) {
                  case "-":
                    return left - right;
                  case "+":
                    return left + right;
                  case "/":
                    return left / right;
                  case "*":
                    return left * right;
                  case "%":
                    return left % right;
                  case "**":
                    return Math.pow(left, right);
                  case "<":
                    return left < right;
                  case ">":
                    return left > right;
                  case "<=":
                    return left <= right;
                  case ">=":
                    return left >= right;
                  case "==":
                    return left == right;
                  case "!=":
                    return left != right;
                  case "===":
                    return left === right;
                  case "!==":
                    return left !== right;
                  case "|":
                    return left | right;
                  case "&":
                    return left & right;
                  case "^":
                    return left ^ right;
                  case "<<":
                    return left << right;
                  case ">>":
                    return left >> right;
                  case ">>>":
                    return left >>> right;
                }
              }
              if (path4.isCallExpression()) {
                const callee = path4.get("callee");
                let context, func;
                if (callee.isIdentifier() && !path4.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name) && (func = global[callee.node.name]), callee.isMemberExpression()) {
                  const object = callee.get("object"), property = callee.get("property");
                  if (object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !function(val2) {
                    return INVALID_METHODS.includes(val2);
                  }(property.node.name) && (context = global[object.node.name], func = context[property.node.name]), object.isLiteral() && property.isIdentifier()) {
                    const type = typeof object.node.value;
                    "string" !== type && "number" !== type || (context = object.node.value, func = context[property.node.name]);
                  }
                }
                if (func) {
                  const args = path4.get("arguments").map((arg) => evaluateCached(arg, state2));
                  if (!state2.confident)
                    return;
                  return func.apply(context, args);
                }
              }
              deopt(path4, state2);
            }(path3, state);
            return state.confident && (item.resolved = true, item.value = val), val;
          }
        }
        function evaluateQuasis(path3, quasis, state, raw = false) {
          let str = "", i = 0;
          const exprs = path3.isTemplateLiteral() ? path3.get("expressions") : path3.get("quasi.expressions");
          for (const elem of quasis) {
            if (!state.confident)
              break;
            str += raw ? elem.value.raw : elem.value.cooked;
            const expr = exprs[i++];
            expr && (str += String(evaluateCached(expr, state)));
          }
          if (state.confident)
            return str;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/family.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3._getKey = function(key, context) {
          const node = this.node, container = node[key];
          return Array.isArray(container) ? container.map((_, i) => _index.default.get({ listKey: key, parentPath: this, parent: node, container, key: i }).setContext(context)) : _index.default.get({ parentPath: this, parent: node, container: node, key }).setContext(context);
        }, exports3._getPattern = function(parts, context) {
          let path3 = this;
          for (const part of parts)
            path3 = "." === part ? path3.parentPath : Array.isArray(path3) ? path3[part] : path3.get(part, context);
          return path3;
        }, exports3.get = function(key, context = true) {
          true === context && (context = this.context);
          const parts = key.split(".");
          return 1 === parts.length ? this._getKey(key, context) : this._getPattern(parts, context);
        }, exports3.getAllNextSiblings = function() {
          let _key = this.key, sibling = this.getSibling(++_key);
          const siblings = [];
          for (; sibling.node; )
            siblings.push(sibling), sibling = this.getSibling(++_key);
          return siblings;
        }, exports3.getAllPrevSiblings = function() {
          let _key = this.key, sibling = this.getSibling(--_key);
          const siblings = [];
          for (; sibling.node; )
            siblings.push(sibling), sibling = this.getSibling(--_key);
          return siblings;
        }, exports3.getBindingIdentifierPaths = function(duplicates = false, outerOnly = false) {
          const search = [this], ids = /* @__PURE__ */ Object.create(null);
          for (; search.length; ) {
            const id = search.shift();
            if (!id)
              continue;
            if (!id.node)
              continue;
            const keys2 = _getBindingIdentifiers.keys[id.node.type];
            if (id.isIdentifier())
              if (duplicates) {
                (ids[id.node.name] = ids[id.node.name] || []).push(id);
              } else
                ids[id.node.name] = id;
            else if (id.isExportDeclaration()) {
              const declaration = id.get("declaration");
              isDeclaration(declaration) && search.push(declaration);
            } else {
              if (outerOnly) {
                if (id.isFunctionDeclaration()) {
                  search.push(id.get("id"));
                  continue;
                }
                if (id.isFunctionExpression())
                  continue;
              }
              if (keys2)
                for (let i = 0; i < keys2.length; i++) {
                  const key = keys2[i], child = id.get(key);
                  Array.isArray(child) ? search.push(...child) : child.node && search.push(child);
                }
            }
          }
          return ids;
        }, exports3.getBindingIdentifiers = function(duplicates) {
          return _getBindingIdentifiers(this.node, duplicates);
        }, exports3.getCompletionRecords = function() {
          return _getCompletionRecords(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false }).map((r2) => r2.path);
        }, exports3.getNextSibling = function() {
          return this.getSibling(this.key + 1);
        }, exports3.getOpposite = function() {
          if ("left" === this.key)
            return this.getSibling("right");
          if ("right" === this.key)
            return this.getSibling("left");
          return null;
        }, exports3.getOuterBindingIdentifierPaths = function(duplicates = false) {
          return this.getBindingIdentifierPaths(duplicates, true);
        }, exports3.getOuterBindingIdentifiers = function(duplicates) {
          return _getOuterBindingIdentifiers(this.node, duplicates);
        }, exports3.getPrevSibling = function() {
          return this.getSibling(this.key - 1);
        }, exports3.getSibling = function(key) {
          return _index.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key }).setContext(this.context);
        };
        var _index = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { getBindingIdentifiers: _getBindingIdentifiers, getOuterBindingIdentifiers: _getOuterBindingIdentifiers, isDeclaration, numericLiteral, unaryExpression } = _t, NORMAL_COMPLETION = 0, BREAK_COMPLETION = 1;
        function addCompletionRecords(path3, records, context) {
          return path3 && records.push(..._getCompletionRecords(path3, context)), records;
        }
        function normalCompletionToBreak(completions) {
          completions.forEach((c) => {
            c.type = BREAK_COMPLETION;
          });
        }
        function replaceBreakStatementInBreakCompletion(completions, reachable) {
          completions.forEach((c) => {
            c.path.isBreakStatement({ label: null }) && (reachable ? c.path.replaceWith(unaryExpression("void", numericLiteral(0))) : c.path.remove());
          });
        }
        function getStatementListCompletion(paths, context) {
          const completions = [];
          if (context.canHaveBreak) {
            let lastNormalCompletions = [];
            for (let i = 0; i < paths.length; i++) {
              const path3 = paths[i], newContext = Object.assign({}, context, { inCaseClause: false });
              path3.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak) ? newContext.shouldPopulateBreak = true : newContext.shouldPopulateBreak = false;
              const statementCompletions = _getCompletionRecords(path3, newContext);
              if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
                lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({ label: null })) ? (normalCompletionToBreak(lastNormalCompletions), completions.push(...lastNormalCompletions), lastNormalCompletions.some((c) => c.path.isDeclaration()) && (completions.push(...statementCompletions), replaceBreakStatementInBreakCompletion(statementCompletions, true)), replaceBreakStatementInBreakCompletion(statementCompletions, false)) : (completions.push(...statementCompletions), context.shouldPopulateBreak || replaceBreakStatementInBreakCompletion(statementCompletions, true));
                break;
              }
              if (i === paths.length - 1)
                completions.push(...statementCompletions);
              else {
                lastNormalCompletions = [];
                for (let i2 = 0; i2 < statementCompletions.length; i2++) {
                  const c = statementCompletions[i2];
                  c.type === BREAK_COMPLETION && completions.push(c), c.type === NORMAL_COMPLETION && lastNormalCompletions.push(c);
                }
              }
            }
          } else if (paths.length)
            for (let i = paths.length - 1; i >= 0; i--) {
              const pathCompletions = _getCompletionRecords(paths[i], context);
              if (pathCompletions.length > 1 || 1 === pathCompletions.length && !pathCompletions[0].path.isVariableDeclaration()) {
                completions.push(...pathCompletions);
                break;
              }
            }
          return completions;
        }
        function _getCompletionRecords(path3, context) {
          let records = [];
          if (path3.isIfStatement())
            records = addCompletionRecords(path3.get("consequent"), records, context), records = addCompletionRecords(path3.get("alternate"), records, context);
          else {
            if (path3.isDoExpression() || path3.isFor() || path3.isWhile() || path3.isLabeledStatement())
              return addCompletionRecords(path3.get("body"), records, context);
            if (path3.isProgram() || path3.isBlockStatement())
              return getStatementListCompletion(path3.get("body"), context);
            if (path3.isFunction())
              return _getCompletionRecords(path3.get("body"), context);
            if (path3.isTryStatement())
              records = addCompletionRecords(path3.get("block"), records, context), records = addCompletionRecords(path3.get("handler"), records, context);
            else {
              if (path3.isCatchClause())
                return addCompletionRecords(path3.get("body"), records, context);
              if (path3.isSwitchStatement())
                return function(cases, records2, context2) {
                  let lastNormalCompletions = [];
                  for (let i = 0; i < cases.length; i++) {
                    const caseCompletions = _getCompletionRecords(cases[i], context2), normalCompletions = [], breakCompletions = [];
                    for (const c of caseCompletions)
                      c.type === NORMAL_COMPLETION && normalCompletions.push(c), c.type === BREAK_COMPLETION && breakCompletions.push(c);
                    normalCompletions.length && (lastNormalCompletions = normalCompletions), records2.push(...breakCompletions);
                  }
                  return records2.push(...lastNormalCompletions), records2;
                }(path3.get("cases"), records, context);
              if (path3.isSwitchCase())
                return getStatementListCompletion(path3.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true });
              path3.isBreakStatement() ? records.push(function(path4) {
                return { type: BREAK_COMPLETION, path: path4 };
              }(path3)) : records.push(function(path4) {
                return { type: NORMAL_COMPLETION, path: path4 };
              }(path3));
            }
          }
          return records;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = exports3.SHOULD_STOP = exports3.SHOULD_SKIP = exports3.REMOVED = void 0;
        var virtualTypes = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), _debug = __webpack_require__2("./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"), _index = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js"), _scope = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/scope/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), t = _t, _cache = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/cache.js"), _generator = __webpack_require__2("./node_modules/.pnpm/@babel+generator@7.22.5/node_modules/@babel/generator/lib/index.js"), NodePath_ancestry = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/ancestry.js"), NodePath_inference = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/index.js"), NodePath_replacement = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/replacement.js"), NodePath_evaluation = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/evaluation.js"), NodePath_conversion = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/conversion.js"), NodePath_introspection = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/introspection.js"), NodePath_context = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/context.js"), NodePath_removal = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/removal.js"), NodePath_modification = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/modification.js"), NodePath_family = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/family.js"), NodePath_comments = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/comments.js"), NodePath_virtual_types_validator = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js");
        const { validate } = _t, debug = _debug("babel");
        exports3.REMOVED = 1;
        exports3.SHOULD_STOP = 2;
        exports3.SHOULD_SKIP = 4;
        class NodePath {
          constructor(hub, parent) {
            this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = parent, this.hub = hub, this.data = null, this.context = null, this.scope = null;
          }
          static get({ hub, parentPath, parent, container, listKey, key }) {
            if (!hub && parentPath && (hub = parentPath.hub), !parent)
              throw new Error("To get a node path the parent needs to exist");
            const targetNode = container[key];
            let paths = _cache.path.get(parent);
            paths || (paths = /* @__PURE__ */ new Map(), _cache.path.set(parent, paths));
            let path3 = paths.get(targetNode);
            return path3 || (path3 = new NodePath(hub, parent), targetNode && paths.set(targetNode, path3)), path3.setup(parentPath, container, listKey, key), path3;
          }
          getScope(scope) {
            return this.isScope() ? new _scope.default(this) : scope;
          }
          setData(key, val) {
            return null == this.data && (this.data = /* @__PURE__ */ Object.create(null)), this.data[key] = val;
          }
          getData(key, def) {
            null == this.data && (this.data = /* @__PURE__ */ Object.create(null));
            let val = this.data[key];
            return void 0 === val && void 0 !== def && (val = this.data[key] = def), val;
          }
          hasNode() {
            return null != this.node;
          }
          buildCodeFrameError(msg, Error2 = SyntaxError) {
            return this.hub.buildError(this.node, msg, Error2);
          }
          traverse(visitor, state) {
            (0, _index.default)(this.node, visitor, this.scope, state, this);
          }
          set(key, node) {
            validate(this.node, key, node), this.node[key] = node;
          }
          getPathLocation() {
            const parts = [];
            let path3 = this;
            do {
              let key = path3.key;
              path3.inList && (key = `${path3.listKey}[${key}]`), parts.unshift(key);
            } while (path3 = path3.parentPath);
            return parts.join(".");
          }
          debug(message) {
            debug.enabled && debug(`${this.getPathLocation()} ${this.type}: ${message}`);
          }
          toString() {
            return (0, _generator.default)(this.node).code;
          }
          get inList() {
            return !!this.listKey;
          }
          set inList(inList) {
            inList || (this.listKey = null);
          }
          get parentKey() {
            return this.listKey || this.key;
          }
          get shouldSkip() {
            return !!(4 & this._traverseFlags);
          }
          set shouldSkip(v) {
            v ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
          }
          get shouldStop() {
            return !!(2 & this._traverseFlags);
          }
          set shouldStop(v) {
            v ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
          }
          get removed() {
            return !!(1 & this._traverseFlags);
          }
          set removed(v) {
            v ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
          }
        }
        Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments), NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
        for (const type of t.TYPES) {
          const typeKey = `is${type}`, fn = t[typeKey];
          NodePath.prototype[typeKey] = function(opts) {
            return fn(this.node, opts);
          }, NodePath.prototype[`assert${type}`] = function(opts) {
            if (!fn(this.node, opts))
              throw new TypeError(`Expected node path of type ${type}`);
          };
        }
        Object.assign(NodePath.prototype, NodePath_virtual_types_validator);
        for (const type of Object.keys(virtualTypes))
          "_" !== type[0] && (t.TYPES.includes(type) || t.TYPES.push(type));
        var _default = NodePath;
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3._getTypeAnnotation = function() {
          const node = this.node;
          if (!node) {
            if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
              const declar = this.parentPath.parentPath, declarParent = declar.parentPath;
              return "left" === declar.key && declarParent.isForInStatement() ? stringTypeAnnotation() : "left" === declar.key && declarParent.isForOfStatement() ? anyTypeAnnotation() : voidTypeAnnotation();
            }
            return;
          }
          if (node.typeAnnotation)
            return node.typeAnnotation;
          if (typeAnnotationInferringNodes.has(node))
            return;
          typeAnnotationInferringNodes.add(node);
          try {
            var _inferer;
            let inferer = inferers[node.type];
            if (inferer)
              return inferer.call(this, node);
            if (inferer = inferers[this.parentPath.type], null != (_inferer = inferer) && _inferer.validParent)
              return this.parentPath.getTypeAnnotation();
          } finally {
            typeAnnotationInferringNodes.delete(node);
          }
        }, exports3.baseTypeStrictlyMatches = function(rightArg) {
          const left = this.getTypeAnnotation(), right = rightArg.getTypeAnnotation();
          if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left))
            return right.type === left.type;
          return false;
        }, exports3.couldBeBaseType = function(name) {
          const type = this.getTypeAnnotation();
          if (isAnyTypeAnnotation(type))
            return true;
          if (isUnionTypeAnnotation(type)) {
            for (const type2 of type.types)
              if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true))
                return true;
            return false;
          }
          return _isBaseType(name, type, true);
        }, exports3.getTypeAnnotation = function() {
          let type = this.getData("typeAnnotation");
          if (null != type)
            return type;
          type = this._getTypeAnnotation() || anyTypeAnnotation(), (isTypeAnnotation(type) || isTSTypeAnnotation(type)) && (type = type.typeAnnotation);
          return this.setData("typeAnnotation", type), type;
        }, exports3.isBaseType = function(baseName, soft) {
          return _isBaseType(baseName, this.getTypeAnnotation(), soft);
        }, exports3.isGenericType = function(genericName) {
          const type = this.getTypeAnnotation();
          if ("Array" === genericName && (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)))
            return true;
          return isGenericTypeAnnotation(type) && isIdentifier(type.id, { name: genericName }) || isTSTypeReference(type) && isIdentifier(type.typeName, { name: genericName });
        };
        var inferers = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/inferers.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { anyTypeAnnotation, isAnyTypeAnnotation, isArrayTypeAnnotation, isBooleanTypeAnnotation, isEmptyTypeAnnotation, isFlowBaseAnnotation, isGenericTypeAnnotation, isIdentifier, isMixedTypeAnnotation, isNumberTypeAnnotation, isStringTypeAnnotation, isTSArrayType, isTSTypeAnnotation, isTSTypeReference, isTupleTypeAnnotation, isTypeAnnotation, isUnionTypeAnnotation, isVoidTypeAnnotation, stringTypeAnnotation, voidTypeAnnotation } = _t;
        const typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
        function _isBaseType(baseName, type, soft) {
          if ("string" === baseName)
            return isStringTypeAnnotation(type);
          if ("number" === baseName)
            return isNumberTypeAnnotation(type);
          if ("boolean" === baseName)
            return isBooleanTypeAnnotation(type);
          if ("any" === baseName)
            return isAnyTypeAnnotation(type);
          if ("mixed" === baseName)
            return isMixedTypeAnnotation(type);
          if ("empty" === baseName)
            return isEmptyTypeAnnotation(type);
          if ("void" === baseName)
            return isVoidTypeAnnotation(type);
          if (soft)
            return false;
          throw new Error(`Unknown base type ${baseName}`);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          if (!this.isReferenced())
            return;
          const binding = this.scope.getBinding(node.name);
          if (binding)
            return binding.identifier.typeAnnotation ? binding.identifier.typeAnnotation : function(binding2, path3, name) {
              const types2 = [], functionConstantViolations = [];
              let constantViolations = getConstantViolationsBefore(binding2, path3, functionConstantViolations);
              const testType = getConditionalAnnotation(binding2, path3, name);
              if (testType) {
                const testConstantViolations = getConstantViolationsBefore(binding2, testType.ifStatement);
                constantViolations = constantViolations.filter((path4) => testConstantViolations.indexOf(path4) < 0), types2.push(testType.typeAnnotation);
              }
              if (constantViolations.length) {
                constantViolations.push(...functionConstantViolations);
                for (const violation of constantViolations)
                  types2.push(violation.getTypeAnnotation());
              }
              if (!types2.length)
                return;
              return (0, _util.createUnionType)(types2);
            }(binding, this, node.name);
          if ("undefined" === node.name)
            return voidTypeAnnotation();
          if ("NaN" === node.name || "Infinity" === node.name)
            return numberTypeAnnotation();
          node.name;
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _util = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_NUMBER_BINARY_OPERATORS, createTypeAnnotationBasedOnTypeof, numberTypeAnnotation, voidTypeAnnotation } = _t;
        function getConstantViolationsBefore(binding, path3, functions) {
          const violations = binding.constantViolations.slice();
          return violations.unshift(binding.path), violations.filter((violation) => {
            const status = (violation = violation.resolve())._guessExecutionStatusRelativeTo(path3);
            return functions && "unknown" === status && functions.push(violation), "before" === status;
          });
        }
        function inferAnnotationFromBinaryExpression(name, path3) {
          const operator = path3.node.operator, right = path3.get("right").resolve(), left = path3.get("left").resolve();
          let target, typeofPath, typePath;
          if (left.isIdentifier({ name }) ? target = right : right.isIdentifier({ name }) && (target = left), target)
            return "===" === operator ? target.getTypeAnnotation() : BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0 ? numberTypeAnnotation() : void 0;
          if ("===" !== operator && "==" !== operator)
            return;
          if (left.isUnaryExpression({ operator: "typeof" }) ? (typeofPath = left, typePath = right) : right.isUnaryExpression({ operator: "typeof" }) && (typeofPath = right, typePath = left), !typeofPath)
            return;
          if (!typeofPath.get("argument").isIdentifier({ name }))
            return;
          if (typePath = typePath.resolve(), !typePath.isLiteral())
            return;
          const typeValue = typePath.node.value;
          return "string" == typeof typeValue ? createTypeAnnotationBasedOnTypeof(typeValue) : void 0;
        }
        function getConditionalAnnotation(binding, path3, name) {
          const ifStatement = function(binding2, path4, name2) {
            let parentPath;
            for (; parentPath = path4.parentPath; ) {
              if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
                if ("test" === path4.key)
                  return;
                return parentPath;
              }
              if (parentPath.isFunction() && parentPath.parentPath.scope.getBinding(name2) !== binding2)
                return;
              path4 = parentPath;
            }
          }(binding, path3, name);
          if (!ifStatement)
            return;
          const paths = [ifStatement.get("test")], types2 = [];
          for (let i = 0; i < paths.length; i++) {
            const path4 = paths[i];
            if (path4.isLogicalExpression())
              "&&" === path4.node.operator && (paths.push(path4.get("left")), paths.push(path4.get("right")));
            else if (path4.isBinaryExpression()) {
              const type = inferAnnotationFromBinaryExpression(name, path4);
              type && types2.push(type);
            }
          }
          return types2.length ? { typeAnnotation: (0, _util.createUnionType)(types2), ifStatement } : getConditionalAnnotation(binding, ifStatement, name);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/inferers.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.ArrayExpression = ArrayExpression, exports3.AssignmentExpression = function() {
          return this.get("right").getTypeAnnotation();
        }, exports3.BinaryExpression = function(node) {
          const operator = node.operator;
          if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0)
            return numberTypeAnnotation();
          if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0)
            return booleanTypeAnnotation();
          if ("+" === operator) {
            const right = this.get("right"), left = this.get("left");
            return left.isBaseType("number") && right.isBaseType("number") ? numberTypeAnnotation() : left.isBaseType("string") || right.isBaseType("string") ? stringTypeAnnotation() : unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
          }
        }, exports3.BooleanLiteral = function() {
          return booleanTypeAnnotation();
        }, exports3.CallExpression = function() {
          const { callee } = this.node;
          if (isObjectKeys(callee))
            return arrayTypeAnnotation(stringTypeAnnotation());
          if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, { name: "Array" }))
            return arrayTypeAnnotation(anyTypeAnnotation());
          if (isObjectEntries(callee))
            return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
          return resolveCall(this.get("callee"));
        }, exports3.ConditionalExpression = function() {
          const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
          return (0, _util.createUnionType)(argumentTypes);
        }, exports3.ClassDeclaration = exports3.ClassExpression = exports3.FunctionDeclaration = exports3.ArrowFunctionExpression = exports3.FunctionExpression = function() {
          return genericTypeAnnotation(identifier("Function"));
        }, Object.defineProperty(exports3, "Identifier", { enumerable: true, get: function() {
          return _infererReference.default;
        } }), exports3.LogicalExpression = function() {
          const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
          return (0, _util.createUnionType)(argumentTypes);
        }, exports3.NewExpression = function(node) {
          if ("Identifier" === node.callee.type)
            return genericTypeAnnotation(node.callee);
        }, exports3.NullLiteral = function() {
          return nullLiteralTypeAnnotation();
        }, exports3.NumericLiteral = function() {
          return numberTypeAnnotation();
        }, exports3.ObjectExpression = function() {
          return genericTypeAnnotation(identifier("Object"));
        }, exports3.ParenthesizedExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, exports3.RegExpLiteral = function() {
          return genericTypeAnnotation(identifier("RegExp"));
        }, exports3.RestElement = RestElement, exports3.SequenceExpression = function() {
          return this.get("expressions").pop().getTypeAnnotation();
        }, exports3.StringLiteral = function() {
          return stringTypeAnnotation();
        }, exports3.TSAsExpression = TSAsExpression, exports3.TSNonNullExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, exports3.TaggedTemplateExpression = function() {
          return resolveCall(this.get("tag"));
        }, exports3.TemplateLiteral = function() {
          return stringTypeAnnotation();
        }, exports3.TypeCastExpression = TypeCastExpression, exports3.UnaryExpression = function(node) {
          const operator = node.operator;
          if ("void" === operator)
            return voidTypeAnnotation();
          if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0)
            return numberTypeAnnotation();
          if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0)
            return stringTypeAnnotation();
          if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0)
            return booleanTypeAnnotation();
        }, exports3.UpdateExpression = function(node) {
          const operator = node.operator;
          if ("++" === operator || "--" === operator)
            return numberTypeAnnotation();
        }, exports3.VariableDeclarator = function() {
          if (!this.get("id").isIdentifier())
            return;
          return this.get("init").getTypeAnnotation();
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _infererReference = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"), _util = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_BINARY_OPERATORS, BOOLEAN_UNARY_OPERATORS, NUMBER_BINARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS, anyTypeAnnotation, arrayTypeAnnotation, booleanTypeAnnotation, buildMatchMemberExpression, genericTypeAnnotation, identifier, nullLiteralTypeAnnotation, numberTypeAnnotation, stringTypeAnnotation, tupleTypeAnnotation, unionTypeAnnotation, voidTypeAnnotation, isIdentifier } = _t;
        function TypeCastExpression(node) {
          return node.typeAnnotation;
        }
        function TSAsExpression(node) {
          return node.typeAnnotation;
        }
        function ArrayExpression() {
          return genericTypeAnnotation(identifier("Array"));
        }
        function RestElement() {
          return ArrayExpression();
        }
        TypeCastExpression.validParent = true, TSAsExpression.validParent = true, RestElement.validParent = true;
        const isArrayFrom = buildMatchMemberExpression("Array.from"), isObjectKeys = buildMatchMemberExpression("Object.keys"), isObjectValues = buildMatchMemberExpression("Object.values"), isObjectEntries = buildMatchMemberExpression("Object.entries");
        function resolveCall(callee) {
          if ((callee = callee.resolve()).isFunction()) {
            const { node } = callee;
            if (node.async)
              return node.generator ? genericTypeAnnotation(identifier("AsyncIterator")) : genericTypeAnnotation(identifier("Promise"));
            if (node.generator)
              return genericTypeAnnotation(identifier("Iterator"));
            if (callee.node.returnType)
              return callee.node.returnType;
          }
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/inference/util.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.createUnionType = function(types2) {
          if (isFlowType(types2[0]))
            return createFlowUnionType ? createFlowUnionType(types2) : createUnionTypeAnnotation(types2);
          if (createTSUnionType)
            return createTSUnionType(types2);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { createFlowUnionType, createTSUnionType, createUnionTypeAnnotation, isFlowType, isTSType } = _t;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/introspection.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3._guessExecutionStatusRelativeTo = function(target) {
          return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
        }, exports3._resolve = function(dangerous, resolved) {
          if (resolved && resolved.indexOf(this) >= 0)
            return;
          if ((resolved = resolved || []).push(this), this.isVariableDeclarator()) {
            if (this.get("id").isIdentifier())
              return this.get("init").resolve(dangerous, resolved);
          } else if (this.isReferencedIdentifier()) {
            const binding = this.scope.getBinding(this.node.name);
            if (!binding)
              return;
            if (!binding.constant)
              return;
            if ("module" === binding.kind)
              return;
            if (binding.path !== this) {
              const ret = binding.path.resolve(dangerous, resolved);
              if (this.find((parent) => parent.node === ret.node))
                return;
              return ret;
            }
          } else {
            if (this.isTypeCastExpression())
              return this.get("expression").resolve(dangerous, resolved);
            if (dangerous && this.isMemberExpression()) {
              const targetKey = this.toComputedKey();
              if (!isLiteral(targetKey))
                return;
              const targetName = targetKey.value, target = this.get("object").resolve(dangerous, resolved);
              if (target.isObjectExpression()) {
                const props = target.get("properties");
                for (const prop of props) {
                  if (!prop.isProperty())
                    continue;
                  const key = prop.get("key");
                  let match = prop.isnt("computed") && key.isIdentifier({ name: targetName });
                  if (match = match || key.isLiteral({ value: targetName }), match)
                    return prop.get("value").resolve(dangerous, resolved);
                }
              } else if (target.isArrayExpression() && !isNaN(+targetName)) {
                const elem = target.get("elements")[targetName];
                if (elem)
                  return elem.resolve(dangerous, resolved);
              }
            }
          }
        }, exports3.canHaveVariableDeclarationOrExpression = function() {
          return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
        }, exports3.canSwapBetweenExpressionAndStatement = function(replacement) {
          if ("body" !== this.key || !this.parentPath.isArrowFunctionExpression())
            return false;
          if (this.isExpression())
            return isBlockStatement(replacement);
          if (this.isBlockStatement())
            return isExpression(replacement);
          return false;
        }, exports3.equals = function(key, value2) {
          return this.node[key] === value2;
        }, exports3.getSource = function() {
          const node = this.node;
          if (node.end) {
            const code = this.hub.getCode();
            if (code)
              return code.slice(node.start, node.end);
          }
          return "";
        }, exports3.has = has, exports3.is = void 0, exports3.isCompletionRecord = function(allowInsideFunction) {
          let path3 = this, first = true;
          do {
            const { type, container } = path3;
            if (!first && (path3.isFunction() || "StaticBlock" === type))
              return !!allowInsideFunction;
            if (first = false, Array.isArray(container) && path3.key !== container.length - 1)
              return false;
          } while ((path3 = path3.parentPath) && !path3.isProgram() && !path3.isDoExpression());
          return true;
        }, exports3.isConstantExpression = function() {
          if (this.isIdentifier()) {
            const binding = this.scope.getBinding(this.node.name);
            return !!binding && binding.constant;
          }
          if (this.isLiteral())
            return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((expression) => expression.isConstantExpression()));
          if (this.isUnaryExpression())
            return "void" === this.node.operator && this.get("argument").isConstantExpression();
          if (this.isBinaryExpression()) {
            const { operator } = this.node;
            return "in" !== operator && "instanceof" !== operator && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
          }
          return false;
        }, exports3.isInStrictMode = function() {
          const start = this.isProgram() ? this : this.parentPath;
          return !!start.find((path3) => {
            if (path3.isProgram({ sourceType: "module" }))
              return true;
            if (path3.isClass())
              return true;
            if (path3.isArrowFunctionExpression() && !path3.get("body").isBlockStatement())
              return false;
            let body;
            if (path3.isFunction())
              body = path3.node.body;
            else {
              if (!path3.isProgram())
                return false;
              body = path3.node;
            }
            for (const directive of body.directives)
              if ("use strict" === directive.value.value)
                return true;
          });
        }, exports3.isNodeType = function(type) {
          return isType(this.type, type);
        }, exports3.isStatementOrBlock = function() {
          return !this.parentPath.isLabeledStatement() && !isBlockStatement(this.container) && STATEMENT_OR_BLOCK_KEYS.includes(this.key);
        }, exports3.isStatic = function() {
          return this.scope.isStatic(this.node);
        }, exports3.isnt = function(key) {
          return !this.has(key);
        }, exports3.matchesPattern = function(pattern, allowPartial) {
          return _matchesPattern(this.node, pattern, allowPartial);
        }, exports3.referencesImport = function(moduleSource, importName2) {
          if (!this.isReferencedIdentifier()) {
            if (this.isJSXMemberExpression() && this.node.property.name === importName2 || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, { value: importName2 }) : this.node.property.name === importName2)) {
              const object = this.get("object");
              return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
            }
            return false;
          }
          const binding = this.scope.getBinding(this.node.name);
          if (!binding || "module" !== binding.kind)
            return false;
          const path3 = binding.path, parent = path3.parentPath;
          if (!parent.isImportDeclaration())
            return false;
          if (parent.node.source.value !== moduleSource)
            return false;
          if (!importName2)
            return true;
          if (path3.isImportDefaultSpecifier() && "default" === importName2)
            return true;
          if (path3.isImportNamespaceSpecifier() && "*" === importName2)
            return true;
          if (path3.isImportSpecifier() && isIdentifier(path3.node.imported, { name: importName2 }))
            return true;
          return false;
        }, exports3.resolve = function(dangerous, resolved) {
          return this._resolve(dangerous, resolved) || this;
        }, exports3.willIMaybeExecuteBefore = function(target) {
          return "after" !== this._guessExecutionStatusRelativeTo(target);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { STATEMENT_OR_BLOCK_KEYS, VISITOR_KEYS, isBlockStatement, isExpression, isIdentifier, isLiteral, isStringLiteral, isType, matchesPattern: _matchesPattern } = _t;
        function has(key) {
          const val = this.node && this.node[key];
          return val && Array.isArray(val) ? !!val.length : !!val;
        }
        const is = has;
        function getOuterFunction(path3) {
          return path3.isProgram() ? path3 : (path3.parentPath.scope.getFunctionParent() || path3.parentPath.scope.getProgramParent()).path;
        }
        function isExecutionUncertain(type, key) {
          switch (type) {
            case "LogicalExpression":
            case "AssignmentPattern":
              return "right" === key;
            case "ConditionalExpression":
            case "IfStatement":
              return "consequent" === key || "alternate" === key;
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
              return "body" === key;
            case "ForStatement":
              return "body" === key || "update" === key;
            case "SwitchStatement":
              return "cases" === key;
            case "TryStatement":
              return "handler" === key;
            case "OptionalMemberExpression":
              return "property" === key;
            case "OptionalCallExpression":
              return "arguments" === key;
            default:
              return false;
          }
        }
        function isExecutionUncertainInList(paths, maxIndex) {
          for (let i = 0; i < maxIndex; i++) {
            const path3 = paths[i];
            if (isExecutionUncertain(path3.parent.type, path3.parentKey))
              return true;
          }
          return false;
        }
        exports3.is = is;
        const SYMBOL_CHECKING = Symbol();
        function _guessExecutionStatusRelativeToCached(base, target, cache) {
          const funcParent = { this: getOuterFunction(base), target: getOuterFunction(target) };
          if (funcParent.target.node !== funcParent.this.node)
            return function(base2, target2, cache2) {
              let cached, nodeMap = cache2.get(base2.node);
              if (nodeMap) {
                if (cached = nodeMap.get(target2.node))
                  return cached === SYMBOL_CHECKING ? "unknown" : cached;
              } else
                cache2.set(base2.node, nodeMap = /* @__PURE__ */ new Map());
              nodeMap.set(target2.node, SYMBOL_CHECKING);
              const result = function(base3, target3, cache3) {
                if (!target3.isFunctionDeclaration())
                  return "before" === _guessExecutionStatusRelativeToCached(base3, target3, cache3) ? "before" : "unknown";
                if (target3.parentPath.isExportDeclaration())
                  return "unknown";
                const binding = target3.scope.getBinding(target3.node.id.name);
                if (!binding.references)
                  return "before";
                const referencePaths = binding.referencePaths;
                let allStatus;
                for (const path3 of referencePaths) {
                  if (!!path3.find((path4) => path4.node === target3.node))
                    continue;
                  if ("callee" !== path3.key || !path3.parentPath.isCallExpression())
                    return "unknown";
                  const status = _guessExecutionStatusRelativeToCached(base3, path3, cache3);
                  if (allStatus && allStatus !== status)
                    return "unknown";
                  allStatus = status;
                }
                return allStatus;
              }(base2, target2, cache2);
              return nodeMap.set(target2.node, result), result;
            }(base, funcParent.target, cache);
          const paths = { target: target.getAncestry(), this: base.getAncestry() };
          if (paths.target.indexOf(base) >= 0)
            return "after";
          if (paths.this.indexOf(target) >= 0)
            return "before";
          let commonPath;
          const commonIndex = { target: 0, this: 0 };
          for (; !commonPath && commonIndex.this < paths.this.length; ) {
            const path3 = paths.this[commonIndex.this];
            commonIndex.target = paths.target.indexOf(path3), commonIndex.target >= 0 ? commonPath = path3 : commonIndex.this++;
          }
          if (!commonPath)
            throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
          if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1))
            return "unknown";
          const divergence = { this: paths.this[commonIndex.this - 1], target: paths.target[commonIndex.target - 1] };
          if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container)
            return divergence.target.key > divergence.this.key ? "before" : "after";
          const keys2 = VISITOR_KEYS[commonPath.type], keyPosition_this = keys2.indexOf(divergence.this.parentKey);
          return keys2.indexOf(divergence.target.parentKey) > keyPosition_this ? "before" : "after";
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/hoister.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _t2 = _t;
        const { react } = _t, { cloneNode, jsxExpressionContainer, variableDeclaration, variableDeclarator } = _t2, referenceVisitor = { ReferencedIdentifier(path3, state) {
          if (path3.isJSXIdentifier() && react.isCompatTag(path3.node.name) && !path3.parentPath.isJSXMemberExpression())
            return;
          if ("this" === path3.node.name) {
            let scope = path3.scope;
            do {
              if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression())
                break;
            } while (scope = scope.parent);
            scope && state.breakOnScopePaths.push(scope.path);
          }
          const binding = path3.scope.getBinding(path3.node.name);
          if (binding) {
            for (const violation of binding.constantViolations)
              if (violation.scope !== binding.path.scope)
                return state.mutableBinding = true, void path3.stop();
            binding === state.scope.getBinding(path3.node.name) && (state.bindings[path3.node.name] = binding);
          }
        } };
        exports3.default = class {
          constructor(path3, scope) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = scope, this.path = path3, this.attachAfter = false;
          }
          isCompatibleScope(scope) {
            for (const key of Object.keys(this.bindings)) {
              const binding = this.bindings[key];
              if (!scope.bindingIdentifierEquals(key, binding.identifier))
                return false;
            }
            return true;
          }
          getCompatibleScopes() {
            let scope = this.path.scope;
            do {
              if (!this.isCompatibleScope(scope))
                break;
              if (this.scopes.push(scope), this.breakOnScopePaths.indexOf(scope.path) >= 0)
                break;
            } while (scope = scope.parent);
          }
          getAttachmentPath() {
            let path3 = this._getAttachmentPath();
            if (!path3)
              return;
            let targetScope = path3.scope;
            if (targetScope.path === path3 && (targetScope = path3.scope.parent), targetScope.path.isProgram() || targetScope.path.isFunction())
              for (const name of Object.keys(this.bindings)) {
                if (!targetScope.hasOwnBinding(name))
                  continue;
                const binding = this.bindings[name];
                if ("param" === binding.kind || "params" === binding.path.parentKey)
                  continue;
                if (this.getAttachmentParentForPath(binding.path).key >= path3.key) {
                  this.attachAfter = true, path3 = binding.path;
                  for (const violationPath of binding.constantViolations)
                    this.getAttachmentParentForPath(violationPath).key > path3.key && (path3 = violationPath);
                }
              }
            return path3;
          }
          _getAttachmentPath() {
            const scope = this.scopes.pop();
            if (scope) {
              if (scope.path.isFunction()) {
                if (!this.hasOwnParamBindings(scope))
                  return this.getNextScopeAttachmentParent();
                {
                  if (this.scope === scope)
                    return;
                  const bodies = scope.path.get("body").get("body");
                  for (let i = 0; i < bodies.length; i++)
                    if (!bodies[i].node._blockHoist)
                      return bodies[i];
                }
              } else if (scope.path.isProgram())
                return this.getNextScopeAttachmentParent();
            }
          }
          getNextScopeAttachmentParent() {
            const scope = this.scopes.pop();
            if (scope)
              return this.getAttachmentParentForPath(scope.path);
          }
          getAttachmentParentForPath(path3) {
            do {
              if (!path3.parentPath || Array.isArray(path3.container) && path3.isStatement())
                return path3;
            } while (path3 = path3.parentPath);
          }
          hasOwnParamBindings(scope) {
            for (const name of Object.keys(this.bindings)) {
              if (!scope.hasOwnBinding(name))
                continue;
              const binding = this.bindings[name];
              if ("param" === binding.kind && binding.constant)
                return true;
            }
            return false;
          }
          run() {
            if (this.path.traverse(referenceVisitor, this), this.mutableBinding)
              return;
            this.getCompatibleScopes();
            const attachTo = this.getAttachmentPath();
            if (!attachTo)
              return;
            if (attachTo.getFunctionParent() === this.path.getFunctionParent())
              return;
            let uid = attachTo.scope.generateUidIdentifier("ref");
            const declarator = variableDeclarator(uid, this.path.node), insertFn = this.attachAfter ? "insertAfter" : "insertBefore", [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]), parent = this.path.parentPath;
            return parent.isJSXElement() && this.path.container === parent.node.children && (uid = jsxExpressionContainer(uid)), this.path.replaceWith(cloneNode(uid)), attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.hooks = void 0;
        exports3.hooks = [function(self2, parent) {
          if ("test" === self2.key && (parent.isWhile() || parent.isSwitchCase()) || "declaration" === self2.key && parent.isExportDeclaration() || "body" === self2.key && parent.isLabeledStatement() || "declarations" === self2.listKey && parent.isVariableDeclaration() && 1 === parent.node.declarations.length || "expression" === self2.key && parent.isExpressionStatement())
            return parent.remove(), true;
        }, function(self2, parent) {
          if (parent.isSequenceExpression() && 1 === parent.node.expressions.length)
            return parent.replaceWith(parent.node.expressions[0]), true;
        }, function(self2, parent) {
          if (parent.isBinary())
            return "left" === self2.key ? parent.replaceWith(parent.node.right) : parent.replaceWith(parent.node.left), true;
        }, function(self2, parent) {
          if (parent.isIfStatement() && "consequent" === self2.key || "body" === self2.key && (parent.isLoop() || parent.isArrowFunctionExpression()))
            return self2.replaceWith({ type: "BlockStatement", body: [] }), true;
        }];
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.isBindingIdentifier = function() {
          const { node, parent } = this, grandparent = this.parentPath.parent;
          return isIdentifier(node) && isBinding(node, parent, grandparent);
        }, exports3.isBlockScoped = function() {
          return nodeIsBlockScoped(this.node);
        }, exports3.isExistentialTypeParam = function() {
          throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
        }, exports3.isExpression = function() {
          return this.isIdentifier() ? this.isReferencedIdentifier() : nodeIsExpression(this.node);
        }, exports3.isFlow = function() {
          const { node } = this;
          return !!nodeIsFlow(node) || (isImportDeclaration(node) ? "type" === node.importKind || "typeof" === node.importKind : isExportDeclaration(node) ? "type" === node.exportKind : !!isImportSpecifier(node) && ("type" === node.importKind || "typeof" === node.importKind));
        }, exports3.isForAwaitStatement = function() {
          return isForOfStatement(this.node, { await: true });
        }, exports3.isGenerated = function() {
          return !this.isUser();
        }, exports3.isNumericLiteralTypeAnnotation = function() {
          throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
        }, exports3.isPure = function(constantsOnly) {
          return this.scope.isPure(this.node, constantsOnly);
        }, exports3.isReferenced = function() {
          return nodeIsReferenced(this.node, this.parent);
        }, exports3.isReferencedIdentifier = function(opts) {
          const { node, parent } = this;
          if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
            if (!isJSXIdentifier(node, opts))
              return false;
            if (isCompatTag(node.name))
              return false;
          }
          return nodeIsReferenced(node, parent, this.parentPath.parent);
        }, exports3.isReferencedMemberExpression = function() {
          const { node, parent } = this;
          return isMemberExpression(node) && nodeIsReferenced(node, parent);
        }, exports3.isRestProperty = function() {
          return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
        }, exports3.isScope = function() {
          return nodeIsScope(this.node, this.parent);
        }, exports3.isSpreadProperty = function() {
          return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
        }, exports3.isStatement = function() {
          const { node, parent } = this;
          if (nodeIsStatement(node)) {
            if (isVariableDeclaration(node)) {
              if (isForXStatement(parent, { left: node }))
                return false;
              if (isForStatement(parent, { init: node }))
                return false;
            }
            return true;
          }
          return false;
        }, exports3.isUser = function() {
          return this.node && !!this.node.loc;
        }, exports3.isVar = function() {
          return nodeIsVar(this.node);
        };
        var _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { isBinding, isBlockScoped: nodeIsBlockScoped, isExportDeclaration, isExpression: nodeIsExpression, isFlow: nodeIsFlow, isForStatement, isForXStatement, isIdentifier, isImportDeclaration, isImportSpecifier, isJSXIdentifier, isJSXMemberExpression, isMemberExpression, isRestElement: nodeIsRestElement, isReferenced: nodeIsReferenced, isScope: nodeIsScope, isStatement: nodeIsStatement, isVar: nodeIsVar, isVariableDeclaration, react, isForOfStatement } = _t, { isCompatTag } = react;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/virtual-types.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.Var = exports3.User = exports3.Statement = exports3.SpreadProperty = exports3.Scope = exports3.RestProperty = exports3.ReferencedMemberExpression = exports3.ReferencedIdentifier = exports3.Referenced = exports3.Pure = exports3.NumericLiteralTypeAnnotation = exports3.Generated = exports3.ForAwaitStatement = exports3.Flow = exports3.Expression = exports3.ExistentialTypeParam = exports3.BlockScoped = exports3.BindingIdentifier = void 0;
        exports3.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
        exports3.ReferencedMemberExpression = ["MemberExpression"];
        exports3.BindingIdentifier = ["Identifier"];
        exports3.Statement = ["Statement"];
        exports3.Expression = ["Expression"];
        exports3.Scope = ["Scopable", "Pattern"];
        exports3.Referenced = null;
        exports3.BlockScoped = null;
        exports3.Var = ["VariableDeclaration"];
        exports3.User = null;
        exports3.Generated = null;
        exports3.Pure = null;
        exports3.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
        exports3.RestProperty = ["RestElement"];
        exports3.SpreadProperty = ["RestElement"];
        exports3.ExistentialTypeParam = ["ExistsTypeAnnotation"];
        exports3.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
        exports3.ForAwaitStatement = ["ForOfStatement"];
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/modification.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3._containerInsert = function(from, nodes) {
          this.updateSiblingKeys(from, nodes.length);
          const paths = [];
          this.container.splice(from, 0, ...nodes);
          for (let i = 0; i < nodes.length; i++) {
            const to = from + i, path3 = this.getSibling(to);
            paths.push(path3), this.context && this.context.queue && path3.pushContext(this.context);
          }
          const contexts = this._getQueueContexts();
          for (const path3 of paths) {
            path3.setScope(), path3.debug("Inserted.");
            for (const context of contexts)
              context.maybeQueue(path3, true);
          }
          return paths;
        }, exports3._containerInsertAfter = function(nodes) {
          return this._containerInsert(this.key + 1, nodes);
        }, exports3._containerInsertBefore = function(nodes) {
          return this._containerInsert(this.key, nodes);
        }, exports3._verifyNodeList = function(nodes) {
          if (!nodes)
            return [];
          Array.isArray(nodes) || (nodes = [nodes]);
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            let msg;
            if (node ? "object" != typeof node ? msg = "contains a non-object node" : node.type ? node instanceof _index.default && (msg = "has a NodePath when it expected a raw object") : msg = "without a type" : msg = "has falsy node", msg) {
              const type = Array.isArray(node) ? "array" : typeof node;
              throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
            }
          }
          return nodes;
        }, exports3.hoist = function(scope = this.scope) {
          return new _hoister.default(this, scope).run();
        }, exports3.insertAfter = function(nodes_) {
          if (this._assertUnremoved(), this.isSequenceExpression())
            return last(this.get("expressions")).insertAfter(nodes_);
          const nodes = this._verifyNodeList(nodes_), { parentPath, parent } = this;
          if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration())
            return parentPath.insertAfter(nodes.map((node) => isExpression(node) ? expressionStatement(node) : node));
          if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && "init" === this.key) {
            if (this.node) {
              const node = this.node;
              let { scope } = this;
              if (scope.path.isPattern())
                return assertExpression(node), this.replaceWith(callExpression(arrowFunctionExpression([], node), [])), this.get("callee.body").insertAfter(nodes), [this];
              if (isHiddenInSequenceExpression(this))
                nodes.unshift(node);
              else if (isCallExpression(node) && isSuper(node.callee))
                nodes.unshift(node), nodes.push(thisExpression());
              else if (function(node2, scope2) {
                if (!isAssignmentExpression(node2) || !isIdentifier(node2.left))
                  return false;
                const blockScope = scope2.getBlockParent();
                return blockScope.hasOwnBinding(node2.left.name) && blockScope.getOwnBinding(node2.left.name).constantViolations.length <= 1;
              }(node, scope))
                nodes.unshift(node), nodes.push(cloneNode(node.left));
              else if (scope.isPure(node, true))
                nodes.push(node);
              else {
                parentPath.isMethod({ computed: true, key: node }) && (scope = scope.parent);
                const temp = scope.generateDeclaredUidIdentifier();
                nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node))), nodes.push(expressionStatement(cloneNode(temp)));
              }
            }
            return this.replaceExpressionWithStatements(nodes);
          }
          if (Array.isArray(this.container))
            return this._containerInsertAfter(nodes);
          if (this.isStatementOrBlock()) {
            const node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || null != node.expression);
            return this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : [])), this.pushContainer("body", nodes);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, exports3.insertBefore = function(nodes_) {
          this._assertUnremoved();
          const nodes = this._verifyNodeList(nodes_), { parentPath, parent } = this;
          if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration())
            return parentPath.insertBefore(nodes);
          if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && "init" === this.key)
            return this.node && nodes.push(this.node), this.replaceExpressionWithStatements(nodes);
          if (Array.isArray(this.container))
            return this._containerInsertBefore(nodes);
          if (this.isStatementOrBlock()) {
            const node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || null != node.expression);
            return this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : [])), this.unshiftContainer("body", nodes);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, exports3.pushContainer = function(listKey, nodes) {
          this._assertUnremoved();
          const verifiedNodes = this._verifyNodeList(nodes), container = this.node[listKey];
          return _index.default.get({ parentPath: this, parent: this.node, container, listKey, key: container.length }).setContext(this.context).replaceWithMultiple(verifiedNodes);
        }, exports3.unshiftContainer = function(listKey, nodes) {
          this._assertUnremoved(), nodes = this._verifyNodeList(nodes);
          return _index.default.get({ parentPath: this, parent: this.node, container: this.node[listKey], listKey, key: 0 }).setContext(this.context)._containerInsertBefore(nodes);
        }, exports3.updateSiblingKeys = function(fromIndex, incrementBy) {
          if (!this.parent)
            return;
          const paths = _cache.path.get(this.parent);
          for (const [, path3] of paths)
            "number" == typeof path3.key && path3.key >= fromIndex && (path3.key += incrementBy);
        };
        var _cache = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/cache.js"), _hoister = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/hoister.js"), _index = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { arrowFunctionExpression, assertExpression, assignmentExpression, blockStatement, callExpression, cloneNode, expressionStatement, isAssignmentExpression, isCallExpression, isExportNamedDeclaration, isExpression, isIdentifier, isSequenceExpression, isSuper, thisExpression } = _t;
        const last = (arr) => arr[arr.length - 1];
        function isHiddenInSequenceExpression(path3) {
          return isSequenceExpression(path3.parent) && (last(path3.parent.expressions) !== path3.node || isHiddenInSequenceExpression(path3.parentPath));
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/removal.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3._assertUnremoved = function() {
          if (this.removed)
            throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }, exports3._callRemovalHooks = function() {
          for (const fn of _removalHooks.hooks)
            if (fn(this, this.parentPath))
              return true;
        }, exports3._markRemoved = function() {
          this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED, this.parent && _cache.path.get(this.parent).delete(this.node);
          this.node = null;
        }, exports3._remove = function() {
          Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
        }, exports3._removeFromScope = function() {
          const bindings = this.getBindingIdentifiers();
          Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
        }, exports3.remove = function() {
          var _this$opts;
          this._assertUnremoved(), this.resync(), null != (_this$opts = this.opts) && _this$opts.noScope || this._removeFromScope();
          if (this._callRemovalHooks())
            return void this._markRemoved();
          this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
        };
        var _removalHooks = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"), _cache = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/cache.js"), _index = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js");
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/replacement.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3._replaceWith = function(node) {
          var _pathCache$get2;
          if (!this.container)
            throw new ReferenceError("Container is falsy");
          this.inList ? validate(this.parent, this.key, [node]) : validate(this.parent, this.key, node);
          this.debug(`Replace with ${null == node ? void 0 : node.type}`), null == (_pathCache$get2 = _cache.path.get(this.parent)) || _pathCache$get2.set(node, this).delete(this.node), this.node = this.container[this.key] = node;
        }, exports3.replaceExpressionWithStatements = function(nodes) {
          this.resync();
          const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);
          if (nodesAsSequenceExpression)
            return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
          const functionParent = this.getFunctionParent(), isParentAsync = null == functionParent ? void 0 : functionParent.is("async"), isParentGenerator = null == functionParent ? void 0 : functionParent.is("generator"), container = arrowFunctionExpression([], blockStatement(nodes));
          this.replaceWith(callExpression(container, []));
          const callee = this.get("callee");
          (0, _helperHoistVariables.default)(callee.get("body"), (id) => {
            this.scope.push({ id });
          }, "var");
          const completionRecords = this.get("callee").getCompletionRecords();
          for (const path3 of completionRecords) {
            if (!path3.isExpressionStatement())
              continue;
            const loop = path3.findParent((path4) => path4.isLoop());
            if (loop) {
              let uid = loop.getData("expressionReplacementReturnUid");
              uid ? uid = identifier(uid.name) : (uid = callee.scope.generateDeclaredUidIdentifier("ret"), callee.get("body").pushContainer("body", returnStatement(cloneNode(uid))), loop.setData("expressionReplacementReturnUid", uid)), path3.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path3.node.expression));
            } else
              path3.replaceWith(returnStatement(path3.node.expression));
          }
          callee.arrowFunctionToExpression();
          const newCallee = callee, needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES), needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
          needToAwaitFunction && (newCallee.set("async", true), needToYieldFunction || this.replaceWith(awaitExpression(this.node)));
          needToYieldFunction && (newCallee.set("generator", true), this.replaceWith(yieldExpression(this.node, true)));
          return newCallee.get("body.body");
        }, exports3.replaceInline = function(nodes) {
          if (this.resync(), Array.isArray(nodes)) {
            if (Array.isArray(this.container)) {
              nodes = this._verifyNodeList(nodes);
              const paths = this._containerInsertAfter(nodes);
              return this.remove(), paths;
            }
            return this.replaceWithMultiple(nodes);
          }
          return this.replaceWith(nodes);
        }, exports3.replaceWith = function(replacementPath) {
          if (this.resync(), this.removed)
            throw new Error("You can't replace this node, we've already removed it");
          let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
          if (!replacement)
            throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
          if (this.node === replacement)
            return [this];
          if (this.isProgram() && !isProgram(replacement))
            throw new Error("You can only replace a Program root node with another Program node");
          if (Array.isArray(replacement))
            throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
          if ("string" == typeof replacement)
            throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
          let nodePath2 = "";
          this.isNodeType("Statement") && isExpression(replacement) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(replacement) || this.parentPath.isExportDefaultDeclaration() || (replacement = expressionStatement(replacement), nodePath2 = "expression"));
          if (this.isNodeType("Expression") && isStatement(replacement) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement))
            return this.replaceExpressionWithStatements([replacement]);
          const oldNode = this.node;
          oldNode && (inheritsComments(replacement, oldNode), removeComments(oldNode));
          return this._replaceWith(replacement), this.type = replacement.type, this.setScope(), this.requeue(), [nodePath2 ? this.get(nodePath2) : this];
        }, exports3.replaceWithMultiple = function(nodes) {
          var _pathCache$get;
          this.resync(), nodes = this._verifyNodeList(nodes), inheritLeadingComments(nodes[0], this.node), inheritTrailingComments(nodes[nodes.length - 1], this.node), null == (_pathCache$get = _cache.path.get(this.parent)) || _pathCache$get.delete(this.node), this.node = this.container[this.key] = null;
          const paths = this.insertAfter(nodes);
          this.node ? this.requeue() : this.remove();
          return paths;
        }, exports3.replaceWithSourceString = function(replacement) {
          let ast;
          this.resync();
          try {
            replacement = `(${replacement})`, ast = (0, _parser.parse)(replacement);
          } catch (err) {
            const loc = err.loc;
            throw loc && (err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, { start: { line: loc.line, column: loc.column + 1 } }), err.code = "BABEL_REPLACE_SOURCE_ERROR"), err;
          }
          const expressionAST = ast.program.body[0].expression;
          return _index.default.removeProperties(expressionAST), this.replaceWith(expressionAST);
        };
        var _codeFrame = __webpack_require__2("./stubs/babel-codeframe.js"), _index = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js"), _index2 = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/index.js"), _cache = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/cache.js"), _parser = __webpack_require__2("./node_modules/.pnpm/@babel+parser@7.22.6/node_modules/@babel/parser/lib/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _helperHoistVariables = __webpack_require__2("./node_modules/.pnpm/@babel+helper-hoist-variables@7.22.5/node_modules/@babel/helper-hoist-variables/lib/index.js");
        const { FUNCTION_TYPES, arrowFunctionExpression, assignmentExpression, awaitExpression, blockStatement, callExpression, cloneNode, expressionStatement, identifier, inheritLeadingComments, inheritTrailingComments, inheritsComments, isExpression, isProgram, isStatement, removeComments, returnStatement, toSequenceExpression, validate, yieldExpression } = _t;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/scope/binding.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        exports3.default = class {
          constructor({ identifier, scope, path: path3, kind }) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = identifier, this.scope = scope, this.path = path3, this.kind = kind, "var" !== kind && "hoisted" !== kind || !function(path4) {
              for (let { parentPath, key } = path4; parentPath; { parentPath, key } = parentPath) {
                if (parentPath.isFunctionParent())
                  return false;
                if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && "body" === key)
                  return true;
              }
              return false;
            }(path3 || (() => {
              throw new Error("Internal Babel error: unreachable ");
            })()) || this.reassign(path3), this.clearValue();
          }
          deoptValue() {
            this.clearValue(), this.hasDeoptedValue = true;
          }
          setValue(value2) {
            this.hasDeoptedValue || (this.hasValue = true, this.value = value2);
          }
          clearValue() {
            this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
          }
          reassign(path3) {
            this.constant = false, -1 === this.constantViolations.indexOf(path3) && this.constantViolations.push(path3);
          }
          reference(path3) {
            -1 === this.referencePaths.indexOf(path3) && (this.referenced = true, this.references++, this.referencePaths.push(path3));
          }
          dereference() {
            this.references--, this.referenced = !!this.references;
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/scope/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _renamer = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/scope/lib/renamer.js"), _index = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/index.js"), _binding = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/scope/binding.js"), _globals = __webpack_require__2("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), t = _t, _cache = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/cache.js"), _visitors = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/visitors.js");
        const { NOT_LOCAL_BINDING, callExpression, cloneNode, getBindingIdentifiers, identifier, isArrayExpression, isBinary, isClass, isClassBody, isClassDeclaration, isExportAllDeclaration, isExportDefaultDeclaration, isExportNamedDeclaration, isFunctionDeclaration, isIdentifier, isImportDeclaration, isLiteral, isMethod, isModuleSpecifier, isNullLiteral, isObjectExpression, isProperty, isPureish, isRegExpLiteral, isSuper, isTaggedTemplateExpression, isTemplateLiteral, isThisExpression, isUnaryExpression, isVariableDeclaration, matchesPattern, memberExpression, numericLiteral, toIdentifier, unaryExpression, variableDeclaration, variableDeclarator, isRecordExpression, isTupleExpression, isObjectProperty, isTopicReference, isMetaProperty, isPrivateName, isExportDeclaration } = _t;
        function gatherNodeParts(node, parts) {
          switch (null == node ? void 0 : node.type) {
            default:
              if (isImportDeclaration(node) || isExportDeclaration(node))
                if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source)
                  gatherNodeParts(node.source, parts);
                else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length)
                  for (const e of node.specifiers)
                    gatherNodeParts(e, parts);
                else
                  (isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration && gatherNodeParts(node.declaration, parts);
              else
                isModuleSpecifier(node) ? gatherNodeParts(node.local, parts) : !isLiteral(node) || isNullLiteral(node) || isRegExpLiteral(node) || isTemplateLiteral(node) || parts.push(node.value);
              break;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "JSXMemberExpression":
              gatherNodeParts(node.object, parts), gatherNodeParts(node.property, parts);
              break;
            case "Identifier":
            case "JSXIdentifier":
              parts.push(node.name);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              gatherNodeParts(node.callee, parts);
              break;
            case "ObjectExpression":
            case "ObjectPattern":
              for (const e of node.properties)
                gatherNodeParts(e, parts);
              break;
            case "SpreadElement":
            case "RestElement":
            case "UnaryExpression":
            case "UpdateExpression":
              gatherNodeParts(node.argument, parts);
              break;
            case "ObjectProperty":
            case "ObjectMethod":
            case "ClassProperty":
            case "ClassMethod":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
              gatherNodeParts(node.key, parts);
              break;
            case "ThisExpression":
              parts.push("this");
              break;
            case "Super":
              parts.push("super");
              break;
            case "Import":
              parts.push("import");
              break;
            case "DoExpression":
              parts.push("do");
              break;
            case "YieldExpression":
              parts.push("yield"), gatherNodeParts(node.argument, parts);
              break;
            case "AwaitExpression":
              parts.push("await"), gatherNodeParts(node.argument, parts);
              break;
            case "AssignmentExpression":
              gatherNodeParts(node.left, parts);
              break;
            case "VariableDeclarator":
            case "FunctionExpression":
            case "FunctionDeclaration":
            case "ClassExpression":
            case "ClassDeclaration":
            case "PrivateName":
              gatherNodeParts(node.id, parts);
              break;
            case "ParenthesizedExpression":
              gatherNodeParts(node.expression, parts);
              break;
            case "MetaProperty":
              gatherNodeParts(node.meta, parts), gatherNodeParts(node.property, parts);
              break;
            case "JSXElement":
              gatherNodeParts(node.openingElement, parts);
              break;
            case "JSXOpeningElement":
              gatherNodeParts(node.name, parts);
              break;
            case "JSXFragment":
              gatherNodeParts(node.openingFragment, parts);
              break;
            case "JSXOpeningFragment":
              parts.push("Fragment");
              break;
            case "JSXNamespacedName":
              gatherNodeParts(node.namespace, parts), gatherNodeParts(node.name, parts);
          }
        }
        const collectorVisitor = { ForStatement(path3) {
          const declar = path3.get("init");
          if (declar.isVar()) {
            const { scope } = path3;
            (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", declar);
          }
        }, Declaration(path3) {
          if (path3.isBlockScoped())
            return;
          if (path3.isImportDeclaration())
            return;
          if (path3.isExportDeclaration())
            return;
          (path3.scope.getFunctionParent() || path3.scope.getProgramParent()).registerDeclaration(path3);
        }, ImportDeclaration(path3) {
          path3.scope.getBlockParent().registerDeclaration(path3);
        }, ReferencedIdentifier(path3, state) {
          state.references.push(path3);
        }, ForXStatement(path3, state) {
          const left = path3.get("left");
          if (left.isPattern() || left.isIdentifier())
            state.constantViolations.push(path3);
          else if (left.isVar()) {
            const { scope } = path3;
            (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", left);
          }
        }, ExportDeclaration: { exit(path3) {
          const { node, scope } = path3;
          if (isExportAllDeclaration(node))
            return;
          const declar = node.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id)
              return;
            const binding = scope.getBinding(id.name);
            null == binding || binding.reference(path3);
          } else if (isVariableDeclaration(declar))
            for (const decl of declar.declarations)
              for (const name of Object.keys(getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name);
                null == binding || binding.reference(path3);
              }
        } }, LabeledStatement(path3) {
          path3.scope.getBlockParent().registerDeclaration(path3);
        }, AssignmentExpression(path3, state) {
          state.assignments.push(path3);
        }, UpdateExpression(path3, state) {
          state.constantViolations.push(path3);
        }, UnaryExpression(path3, state) {
          "delete" === path3.node.operator && state.constantViolations.push(path3);
        }, BlockScoped(path3) {
          let scope = path3.scope;
          scope.path === path3 && (scope = scope.parent);
          if (scope.getBlockParent().registerDeclaration(path3), path3.isClassDeclaration() && path3.node.id) {
            const name = path3.node.id.name;
            path3.scope.bindings[name] = path3.scope.parent.getBinding(name);
          }
        }, CatchClause(path3) {
          path3.scope.registerBinding("let", path3);
        }, Function(path3) {
          const params = path3.get("params");
          for (const param of params)
            path3.scope.registerBinding("param", param);
          path3.isFunctionExpression() && path3.has("id") && !path3.get("id").node[NOT_LOCAL_BINDING] && path3.scope.registerBinding("local", path3.get("id"), path3);
        }, ClassExpression(path3) {
          path3.has("id") && !path3.get("id").node[NOT_LOCAL_BINDING] && path3.scope.registerBinding("local", path3);
        } };
        let uid = 0;
        class Scope3 {
          constructor(path3) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
            const { node } = path3, cached = _cache.scope.get(node);
            if ((null == cached ? void 0 : cached.path) === path3)
              return cached;
            _cache.scope.set(node, this), this.uid = uid++, this.block = node, this.path = path3, this.labels = /* @__PURE__ */ new Map(), this.inited = false;
          }
          get parent() {
            var _parent;
            let parent, path3 = this.path;
            do {
              const shouldSkip = "key" === path3.key || "decorators" === path3.listKey;
              path3 = path3.parentPath, shouldSkip && path3.isMethod() && (path3 = path3.parentPath), path3 && path3.isScope() && (parent = path3);
            } while (path3 && !parent);
            return null == (_parent = parent) ? void 0 : _parent.scope;
          }
          get parentBlock() {
            return this.path.parent;
          }
          get hub() {
            return this.path.hub;
          }
          traverse(node, opts, state) {
            (0, _index.default)(node, opts, this, state, this.path);
          }
          generateDeclaredUidIdentifier(name) {
            const id = this.generateUidIdentifier(name);
            return this.push({ id }), cloneNode(id);
          }
          generateUidIdentifier(name) {
            return identifier(this.generateUid(name));
          }
          generateUid(name = "temp") {
            let uid2;
            name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
            let i = 1;
            do {
              uid2 = this._generateUid(name, i), i++;
            } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
            const program = this.getProgramParent();
            return program.references[uid2] = true, program.uids[uid2] = true, uid2;
          }
          _generateUid(name, i) {
            let id = name;
            return i > 1 && (id += i), `_${id}`;
          }
          generateUidBasedOnNode(node, defaultName) {
            const parts = [];
            gatherNodeParts(node, parts);
            let id = parts.join("$");
            return id = id.replace(/^_/, "") || defaultName || "ref", this.generateUid(id.slice(0, 20));
          }
          generateUidIdentifierBasedOnNode(node, defaultName) {
            return identifier(this.generateUidBasedOnNode(node, defaultName));
          }
          isStatic(node) {
            if (isThisExpression(node) || isSuper(node) || isTopicReference(node))
              return true;
            if (isIdentifier(node)) {
              const binding = this.getBinding(node.name);
              return binding ? binding.constant : this.hasBinding(node.name);
            }
            return false;
          }
          maybeGenerateMemoised(node, dontPush) {
            if (this.isStatic(node))
              return null;
            {
              const id = this.generateUidIdentifierBasedOnNode(node);
              return dontPush ? id : (this.push({ id }), cloneNode(id));
            }
          }
          checkBlockScopedCollisions(local, kind, name, id) {
            if ("param" === kind)
              return;
            if ("local" === local.kind)
              return;
            if ("let" === kind || "let" === local.kind || "const" === local.kind || "module" === local.kind || "param" === local.kind && "const" === kind)
              throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
          }
          rename(oldName, newName) {
            const binding = this.getBinding(oldName);
            if (binding) {
              newName || (newName = this.generateUidIdentifier(oldName).name);
              new _renamer.default(binding, oldName, newName).rename(arguments[2]);
            }
          }
          _renameFromMap(map, oldName, newName, value2) {
            map[oldName] && (map[newName] = value2, map[oldName] = null);
          }
          dump() {
            const sep = "-".repeat(60);
            console.log(sep);
            let scope = this;
            do {
              console.log("#", scope.block.type);
              for (const name of Object.keys(scope.bindings)) {
                const binding = scope.bindings[name];
                console.log(" -", name, { constant: binding.constant, references: binding.references, violations: binding.constantViolations.length, kind: binding.kind });
              }
            } while (scope = scope.parent);
            console.log(sep);
          }
          toArray(node, i, arrayLikeIsIterable) {
            if (isIdentifier(node)) {
              const binding = this.getBinding(node.name);
              if (null != binding && binding.constant && binding.path.isGenericType("Array"))
                return node;
            }
            if (isArrayExpression(node))
              return node;
            if (isIdentifier(node, { name: "arguments" }))
              return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
            let helperName;
            const args = [node];
            return true === i ? helperName = "toConsumableArray" : "number" == typeof i ? (args.push(numericLiteral(i)), helperName = "slicedToArray") : helperName = "toArray", arrayLikeIsIterable && (args.unshift(this.hub.addHelper(helperName)), helperName = "maybeArrayLike"), callExpression(this.hub.addHelper(helperName), args);
          }
          hasLabel(name) {
            return !!this.getLabel(name);
          }
          getLabel(name) {
            return this.labels.get(name);
          }
          registerLabel(path3) {
            this.labels.set(path3.node.label.name, path3);
          }
          registerDeclaration(path3) {
            if (path3.isLabeledStatement())
              this.registerLabel(path3);
            else if (path3.isFunctionDeclaration())
              this.registerBinding("hoisted", path3.get("id"), path3);
            else if (path3.isVariableDeclaration()) {
              const declarations = path3.get("declarations"), { kind } = path3.node;
              for (const declar of declarations)
                this.registerBinding("using" === kind || "await using" === kind ? "const" : kind, declar);
            } else if (path3.isClassDeclaration()) {
              if (path3.node.declare)
                return;
              this.registerBinding("let", path3);
            } else if (path3.isImportDeclaration()) {
              const isTypeDeclaration = "type" === path3.node.importKind || "typeof" === path3.node.importKind, specifiers = path3.get("specifiers");
              for (const specifier of specifiers) {
                const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && ("type" === specifier.node.importKind || "typeof" === specifier.node.importKind);
                this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
              }
            } else if (path3.isExportDeclaration()) {
              const declar = path3.get("declaration");
              (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) && this.registerDeclaration(declar);
            } else
              this.registerBinding("unknown", path3);
          }
          buildUndefinedNode() {
            return unaryExpression("void", numericLiteral(0), true);
          }
          registerConstantViolation(path3) {
            const ids = path3.getBindingIdentifiers();
            for (const name of Object.keys(ids)) {
              var _this$getBinding;
              null == (_this$getBinding = this.getBinding(name)) || _this$getBinding.reassign(path3);
            }
          }
          registerBinding(kind, path3, bindingPath = path3) {
            if (!kind)
              throw new ReferenceError("no `kind`");
            if (path3.isVariableDeclaration()) {
              const declarators = path3.get("declarations");
              for (const declar of declarators)
                this.registerBinding(kind, declar);
              return;
            }
            const parent = this.getProgramParent(), ids = path3.getOuterBindingIdentifiers(true);
            for (const name of Object.keys(ids)) {
              parent.references[name] = true;
              for (const id of ids[name]) {
                const local = this.getOwnBinding(name);
                if (local) {
                  if (local.identifier === id)
                    continue;
                  this.checkBlockScopedCollisions(local, kind, name, id);
                }
                local ? this.registerConstantViolation(bindingPath) : this.bindings[name] = new _binding.default({ identifier: id, scope: this, path: bindingPath, kind });
              }
            }
          }
          addGlobal(node) {
            this.globals[node.name] = node;
          }
          hasUid(name) {
            let scope = this;
            do {
              if (scope.uids[name])
                return true;
            } while (scope = scope.parent);
            return false;
          }
          hasGlobal(name) {
            let scope = this;
            do {
              if (scope.globals[name])
                return true;
            } while (scope = scope.parent);
            return false;
          }
          hasReference(name) {
            return !!this.getProgramParent().references[name];
          }
          isPure(node, constantsOnly) {
            if (isIdentifier(node)) {
              const binding = this.getBinding(node.name);
              return !!binding && (!constantsOnly || binding.constant);
            }
            if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node))
              return true;
            var _node$decorators, _node$decorators2, _node$decorators3;
            if (isClass(node))
              return !(node.superClass && !this.isPure(node.superClass, constantsOnly)) && (!((null == (_node$decorators = node.decorators) ? void 0 : _node$decorators.length) > 0) && this.isPure(node.body, constantsOnly));
            if (isClassBody(node)) {
              for (const method of node.body)
                if (!this.isPure(method, constantsOnly))
                  return false;
              return true;
            }
            if (isBinary(node))
              return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
            if (isArrayExpression(node) || isTupleExpression(node)) {
              for (const elem of node.elements)
                if (null !== elem && !this.isPure(elem, constantsOnly))
                  return false;
              return true;
            }
            if (isObjectExpression(node) || isRecordExpression(node)) {
              for (const prop of node.properties)
                if (!this.isPure(prop, constantsOnly))
                  return false;
              return true;
            }
            if (isMethod(node))
              return !(node.computed && !this.isPure(node.key, constantsOnly)) && !((null == (_node$decorators2 = node.decorators) ? void 0 : _node$decorators2.length) > 0);
            if (isProperty(node))
              return !(node.computed && !this.isPure(node.key, constantsOnly)) && (!((null == (_node$decorators3 = node.decorators) ? void 0 : _node$decorators3.length) > 0) && !((isObjectProperty(node) || node.static) && null !== node.value && !this.isPure(node.value, constantsOnly)));
            if (isUnaryExpression(node))
              return this.isPure(node.argument, constantsOnly);
            if (isTaggedTemplateExpression(node))
              return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
            if (isTemplateLiteral(node)) {
              for (const expression of node.expressions)
                if (!this.isPure(expression, constantsOnly))
                  return false;
              return true;
            }
            return isPureish(node);
          }
          setData(key, val) {
            return this.data[key] = val;
          }
          getData(key) {
            let scope = this;
            do {
              const data2 = scope.data[key];
              if (null != data2)
                return data2;
            } while (scope = scope.parent);
          }
          removeData(key) {
            let scope = this;
            do {
              null != scope.data[key] && (scope.data[key] = null);
            } while (scope = scope.parent);
          }
          init() {
            this.inited || (this.inited = true, this.crawl());
          }
          crawl() {
            const path3 = this.path;
            this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
            const programParent = this.getProgramParent();
            if (programParent.crawling)
              return;
            const state = { references: [], constantViolations: [], assignments: [] };
            if (this.crawling = true, "Program" !== path3.type && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
              for (const visit of collectorVisitor.enter)
                visit.call(state, path3, state);
              const typeVisitors = collectorVisitor[path3.type];
              if (typeVisitors)
                for (const visit of typeVisitors.enter)
                  visit.call(state, path3, state);
            }
            path3.traverse(collectorVisitor, state), this.crawling = false;
            for (const path4 of state.assignments) {
              const ids = path4.getBindingIdentifiers();
              for (const name of Object.keys(ids))
                path4.scope.getBinding(name) || programParent.addGlobal(ids[name]);
              path4.scope.registerConstantViolation(path4);
            }
            for (const ref2 of state.references) {
              const binding = ref2.scope.getBinding(ref2.node.name);
              binding ? binding.reference(ref2) : programParent.addGlobal(ref2.node);
            }
            for (const path4 of state.constantViolations)
              path4.scope.registerConstantViolation(path4);
          }
          push(opts) {
            let path3 = this.path;
            path3.isPattern() ? path3 = this.getPatternParent().path : path3.isBlockStatement() || path3.isProgram() || (path3 = this.getBlockParent().path), path3.isSwitchStatement() && (path3 = (this.getFunctionParent() || this.getProgramParent()).path);
            const { init, unique: unique2, kind = "var", id } = opts;
            if (!init && !unique2 && ("var" === kind || "let" === kind) && path3.isFunction() && !path3.node.name && t.isCallExpression(path3.parent, { callee: path3.node }) && path3.parent.arguments.length <= path3.node.params.length && t.isIdentifier(id))
              return path3.pushContainer("params", id), void path3.scope.registerBinding("param", path3.get("params")[path3.node.params.length - 1]);
            (path3.isLoop() || path3.isCatchClause() || path3.isFunction()) && (path3.ensureBlock(), path3 = path3.get("body"));
            const blockHoist = null == opts._blockHoist ? 2 : opts._blockHoist, dataKey = `declaration:${kind}:${blockHoist}`;
            let declarPath = !unique2 && path3.getData(dataKey);
            if (!declarPath) {
              const declar = variableDeclaration(kind, []);
              declar._blockHoist = blockHoist, [declarPath] = path3.unshiftContainer("body", [declar]), unique2 || path3.setData(dataKey, declarPath);
            }
            const declarator = variableDeclarator(id, init), len = declarPath.node.declarations.push(declarator);
            path3.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
          }
          getProgramParent() {
            let scope = this;
            do {
              if (scope.path.isProgram())
                return scope;
            } while (scope = scope.parent);
            throw new Error("Couldn't find a Program");
          }
          getFunctionParent() {
            let scope = this;
            do {
              if (scope.path.isFunctionParent())
                return scope;
            } while (scope = scope.parent);
            return null;
          }
          getBlockParent() {
            let scope = this;
            do {
              if (scope.path.isBlockParent())
                return scope;
            } while (scope = scope.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getPatternParent() {
            let scope = this;
            do {
              if (!scope.path.isPattern())
                return scope.getBlockParent();
            } while (scope = scope.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getAllBindings() {
            const ids = /* @__PURE__ */ Object.create(null);
            let scope = this;
            do {
              for (const key of Object.keys(scope.bindings))
                key in ids == false && (ids[key] = scope.bindings[key]);
              scope = scope.parent;
            } while (scope);
            return ids;
          }
          getAllBindingsOfKind(...kinds) {
            const ids = /* @__PURE__ */ Object.create(null);
            for (const kind of kinds) {
              let scope = this;
              do {
                for (const name of Object.keys(scope.bindings)) {
                  const binding = scope.bindings[name];
                  binding.kind === kind && (ids[name] = binding);
                }
                scope = scope.parent;
              } while (scope);
            }
            return ids;
          }
          bindingIdentifierEquals(name, node) {
            return this.getBindingIdentifier(name) === node;
          }
          getBinding(name) {
            let previousPath, scope = this;
            do {
              const binding = scope.getOwnBinding(name);
              var _previousPath;
              if (binding) {
                if (null == (_previousPath = previousPath) || !_previousPath.isPattern() || "param" === binding.kind || "local" === binding.kind)
                  return binding;
              } else if (!binding && "arguments" === name && scope.path.isFunction() && !scope.path.isArrowFunctionExpression())
                break;
              previousPath = scope.path;
            } while (scope = scope.parent);
          }
          getOwnBinding(name) {
            return this.bindings[name];
          }
          getBindingIdentifier(name) {
            var _this$getBinding2;
            return null == (_this$getBinding2 = this.getBinding(name)) ? void 0 : _this$getBinding2.identifier;
          }
          getOwnBindingIdentifier(name) {
            const binding = this.bindings[name];
            return null == binding ? void 0 : binding.identifier;
          }
          hasOwnBinding(name) {
            return !!this.getOwnBinding(name);
          }
          hasBinding(name, opts) {
            var _opts, _opts2, _opts3;
            return !!name && (!!this.hasOwnBinding(name) || ("boolean" == typeof opts && (opts = { noGlobals: opts }), !!this.parentHasBinding(name, opts) || (!(null != (_opts = opts) && _opts.noUids || !this.hasUid(name)) || (!(null != (_opts2 = opts) && _opts2.noGlobals || !Scope3.globals.includes(name)) || !(null != (_opts3 = opts) && _opts3.noGlobals || !Scope3.contextVariables.includes(name))))));
          }
          parentHasBinding(name, opts) {
            var _this$parent;
            return null == (_this$parent = this.parent) ? void 0 : _this$parent.hasBinding(name, opts);
          }
          moveBindingTo(name, scope) {
            const info = this.getBinding(name);
            info && (info.scope.removeOwnBinding(name), info.scope = scope, scope.bindings[name] = info);
          }
          removeOwnBinding(name) {
            delete this.bindings[name];
          }
          removeBinding(name) {
            var _this$getBinding3;
            null == (_this$getBinding3 = this.getBinding(name)) || _this$getBinding3.scope.removeOwnBinding(name);
            let scope = this;
            do {
              scope.uids[name] && (scope.uids[name] = false);
            } while (scope = scope.parent);
          }
        }
        exports3.default = Scope3, Scope3.globals = Object.keys(_globals.builtin), Scope3.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/scope/lib/renamer.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _helperSplitExportDeclaration = __webpack_require__2("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.22.6/node_modules/@babel/helper-split-export-declaration/lib/index.js"), t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/.pnpm/@babel+helper-environment-visitor@7.22.5/node_modules/@babel/helper-environment-visitor/lib/index.js"), _traverseNode = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/traverse-node.js"), _visitors = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/visitors.js");
        const renameVisitor = { ReferencedIdentifier({ node }, state) {
          node.name === state.oldName && (node.name = state.newName);
        }, Scope(path3, state) {
          path3.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier) || (path3.skip(), path3.isMethod() && (0, _helperEnvironmentVisitor.requeueComputedKeyAndDecorators)(path3));
        }, ObjectProperty({ node, scope }, state) {
          const { name } = node.key;
          var _node$extra;
          !node.shorthand || name !== state.oldName && name !== state.newName || scope.getBindingIdentifier(name) !== state.binding.identifier || (node.shorthand = false, null != (_node$extra = node.extra) && _node$extra.shorthand && (node.extra.shorthand = false));
        }, "AssignmentExpression|Declaration|VariableDeclarator"(path3, state) {
          if (path3.isVariableDeclaration())
            return;
          const ids = path3.getOuterBindingIdentifiers();
          for (const name in ids)
            name === state.oldName && (ids[name].name = state.newName);
        } };
        exports3.default = class {
          constructor(binding, oldName, newName) {
            this.newName = newName, this.oldName = oldName, this.binding = binding;
          }
          maybeConvertFromExportDeclaration(parentDeclar) {
            const maybeExportDeclar = parentDeclar.parentPath;
            if (maybeExportDeclar.isExportDeclaration()) {
              if (maybeExportDeclar.isExportDefaultDeclaration()) {
                const { declaration } = maybeExportDeclar.node;
                if (t.isDeclaration(declaration) && !declaration.id)
                  return;
              }
              maybeExportDeclar.isExportAllDeclaration() || (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
            }
          }
          maybeConvertFromClassFunctionDeclaration(path3) {
            return path3;
          }
          maybeConvertFromClassFunctionExpression(path3) {
            return path3;
          }
          rename() {
            const { binding, oldName, newName } = this, { scope, path: path3 } = binding, parentDeclar = path3.find((path4) => path4.isDeclaration() || path4.isFunctionExpression() || path4.isClassExpression());
            if (parentDeclar) {
              parentDeclar.getOuterBindingIdentifiers()[oldName] === binding.identifier && this.maybeConvertFromExportDeclaration(parentDeclar);
            }
            const blockToTraverse = arguments[0] || scope.block;
            (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, { discriminant: true }), arguments[0] || (scope.removeOwnBinding(oldName), scope.bindings[newName] = binding, this.binding.identifier.name = newName), parentDeclar && (this.maybeConvertFromClassFunctionDeclaration(path3), this.maybeConvertFromClassFunctionExpression(path3));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/traverse-node.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.traverseNode = function(node, opts, scope, state, path3, skipKeys) {
          const keys2 = VISITOR_KEYS[node.type];
          if (!keys2)
            return false;
          const context = new _context.default(scope, opts, state, path3);
          for (const key of keys2)
            if ((!skipKeys || !skipKeys[key]) && context.visit(node, key))
              return true;
          return false;
        };
        var _context = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/context.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS } = _t;
      }, "./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/visitors.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.explode = explode, exports3.isExplodedVisitor = isExplodedVisitor, exports3.merge = function(visitors, states = [], wrapper) {
          const rootVisitor = {};
          for (let i = 0; i < visitors.length; i++) {
            const visitor = visitors[i], state = states[i];
            explode(visitor);
            for (const type of Object.keys(visitor)) {
              let visitorType = visitor[type];
              (state || wrapper) && (visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper));
              mergePair(rootVisitor[type] || (rootVisitor[type] = {}), visitorType);
            }
          }
          return rootVisitor;
        }, exports3.verify = verify;
        var virtualTypes = __webpack_require__2("./node_modules/.pnpm/@babel+traverse@7.22.6/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), _t = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
        const { DEPRECATED_KEYS, DEPRECATED_ALIASES, FLIPPED_ALIAS_KEYS, TYPES, __internal__deprecationWarning: deprecationWarning } = _t;
        function isExplodedVisitor(visitor) {
          return null == visitor ? void 0 : visitor._exploded;
        }
        function explode(visitor) {
          if (isExplodedVisitor(visitor))
            return visitor;
          visitor._exploded = true;
          for (const nodeType of Object.keys(visitor)) {
            if (shouldIgnoreKey(nodeType))
              continue;
            const parts = nodeType.split("|");
            if (1 === parts.length)
              continue;
            const fns = visitor[nodeType];
            delete visitor[nodeType];
            for (const part of parts)
              visitor[part] = fns;
          }
          verify(visitor), delete visitor.__esModule, function(obj) {
            for (const key of Object.keys(obj)) {
              if (shouldIgnoreKey(key))
                continue;
              const fns = obj[key];
              "function" == typeof fns && (obj[key] = { enter: fns });
            }
          }(visitor), ensureCallbackArrays(visitor);
          for (const nodeType of Object.keys(visitor)) {
            if (shouldIgnoreKey(nodeType))
              continue;
            if (!(nodeType in virtualTypes))
              continue;
            const fns = visitor[nodeType];
            for (const type of Object.keys(fns))
              fns[type] = wrapCheck(nodeType, fns[type]);
            delete visitor[nodeType];
            const types2 = virtualTypes[nodeType];
            if (null !== types2)
              for (const type of types2)
                visitor[type] ? mergePair(visitor[type], fns) : visitor[type] = fns;
            else
              mergePair(visitor, fns);
          }
          for (const nodeType of Object.keys(visitor)) {
            if (shouldIgnoreKey(nodeType))
              continue;
            let aliases = FLIPPED_ALIAS_KEYS[nodeType];
            if (nodeType in DEPRECATED_KEYS) {
              const deprecatedKey = DEPRECATED_KEYS[nodeType];
              deprecationWarning(nodeType, deprecatedKey, "Visitor "), aliases = [deprecatedKey];
            } else if (nodeType in DEPRECATED_ALIASES) {
              const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
              deprecationWarning(nodeType, deprecatedAlias, "Visitor "), aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
            }
            if (!aliases)
              continue;
            const fns = visitor[nodeType];
            delete visitor[nodeType];
            for (const alias of aliases) {
              const existing = visitor[alias];
              existing ? mergePair(existing, fns) : visitor[alias] = Object.assign({}, fns);
            }
          }
          for (const nodeType of Object.keys(visitor))
            shouldIgnoreKey(nodeType) || ensureCallbackArrays(visitor[nodeType]);
          return visitor;
        }
        function verify(visitor) {
          if (!visitor._verified) {
            if ("function" == typeof visitor)
              throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (const nodeType of Object.keys(visitor)) {
              if ("enter" !== nodeType && "exit" !== nodeType || validateVisitorMethods(nodeType, visitor[nodeType]), shouldIgnoreKey(nodeType))
                continue;
              if (TYPES.indexOf(nodeType) < 0)
                throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
              const visitors = visitor[nodeType];
              if ("object" == typeof visitors)
                for (const visitorKey of Object.keys(visitors)) {
                  if ("enter" !== visitorKey && "exit" !== visitorKey)
                    throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
                  validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
                }
            }
            visitor._verified = true;
          }
        }
        function validateVisitorMethods(path3, val) {
          const fns = [].concat(val);
          for (const fn of fns)
            if ("function" != typeof fn)
              throw new TypeError(`Non-function found defined in ${path3} with type ${typeof fn}`);
        }
        function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
          const newVisitor = {};
          for (const key of Object.keys(oldVisitor)) {
            let fns = oldVisitor[key];
            Array.isArray(fns) && (fns = fns.map(function(fn) {
              let newFn = fn;
              return state && (newFn = function(path3) {
                fn.call(state, path3, state);
              }), wrapper && (newFn = wrapper(state.key, key, newFn)), newFn !== fn && (newFn.toString = () => fn.toString()), newFn;
            }), newVisitor[key] = fns);
          }
          return newVisitor;
        }
        function ensureCallbackArrays(obj) {
          obj.enter && !Array.isArray(obj.enter) && (obj.enter = [obj.enter]), obj.exit && !Array.isArray(obj.exit) && (obj.exit = [obj.exit]);
        }
        function wrapCheck(nodeType, fn) {
          const newFn = function(path3) {
            if (path3[`is${nodeType}`]())
              return fn.apply(this, arguments);
          };
          return newFn.toString = () => fn.toString(), newFn;
        }
        function shouldIgnoreKey(key) {
          return "_" === key[0] || ("enter" === key || "exit" === key || "shouldSkip" === key || ("denylist" === key || "noScope" === key || "skipKeys" === key || "blacklist" === key));
        }
        function mergePair(dest, src) {
          for (const key of Object.keys(src))
            dest[key] = [].concat(dest[key] || [], src[key]);
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/asserts/assertNode.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          if (!(0, _isNode.default)(node)) {
            var _node$type;
            const type = null != (_node$type = null == node ? void 0 : node.type) ? _node$type : JSON.stringify(node);
            throw new TypeError(`Not a valid node of type "${type}"`);
          }
        };
        var _isNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/asserts/generated/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.assertAccessor = function(node, opts) {
          assert2("Accessor", node, opts);
        }, exports3.assertAnyTypeAnnotation = function(node, opts) {
          assert2("AnyTypeAnnotation", node, opts);
        }, exports3.assertArgumentPlaceholder = function(node, opts) {
          assert2("ArgumentPlaceholder", node, opts);
        }, exports3.assertArrayExpression = function(node, opts) {
          assert2("ArrayExpression", node, opts);
        }, exports3.assertArrayPattern = function(node, opts) {
          assert2("ArrayPattern", node, opts);
        }, exports3.assertArrayTypeAnnotation = function(node, opts) {
          assert2("ArrayTypeAnnotation", node, opts);
        }, exports3.assertArrowFunctionExpression = function(node, opts) {
          assert2("ArrowFunctionExpression", node, opts);
        }, exports3.assertAssignmentExpression = function(node, opts) {
          assert2("AssignmentExpression", node, opts);
        }, exports3.assertAssignmentPattern = function(node, opts) {
          assert2("AssignmentPattern", node, opts);
        }, exports3.assertAwaitExpression = function(node, opts) {
          assert2("AwaitExpression", node, opts);
        }, exports3.assertBigIntLiteral = function(node, opts) {
          assert2("BigIntLiteral", node, opts);
        }, exports3.assertBinary = function(node, opts) {
          assert2("Binary", node, opts);
        }, exports3.assertBinaryExpression = function(node, opts) {
          assert2("BinaryExpression", node, opts);
        }, exports3.assertBindExpression = function(node, opts) {
          assert2("BindExpression", node, opts);
        }, exports3.assertBlock = function(node, opts) {
          assert2("Block", node, opts);
        }, exports3.assertBlockParent = function(node, opts) {
          assert2("BlockParent", node, opts);
        }, exports3.assertBlockStatement = function(node, opts) {
          assert2("BlockStatement", node, opts);
        }, exports3.assertBooleanLiteral = function(node, opts) {
          assert2("BooleanLiteral", node, opts);
        }, exports3.assertBooleanLiteralTypeAnnotation = function(node, opts) {
          assert2("BooleanLiteralTypeAnnotation", node, opts);
        }, exports3.assertBooleanTypeAnnotation = function(node, opts) {
          assert2("BooleanTypeAnnotation", node, opts);
        }, exports3.assertBreakStatement = function(node, opts) {
          assert2("BreakStatement", node, opts);
        }, exports3.assertCallExpression = function(node, opts) {
          assert2("CallExpression", node, opts);
        }, exports3.assertCatchClause = function(node, opts) {
          assert2("CatchClause", node, opts);
        }, exports3.assertClass = function(node, opts) {
          assert2("Class", node, opts);
        }, exports3.assertClassAccessorProperty = function(node, opts) {
          assert2("ClassAccessorProperty", node, opts);
        }, exports3.assertClassBody = function(node, opts) {
          assert2("ClassBody", node, opts);
        }, exports3.assertClassDeclaration = function(node, opts) {
          assert2("ClassDeclaration", node, opts);
        }, exports3.assertClassExpression = function(node, opts) {
          assert2("ClassExpression", node, opts);
        }, exports3.assertClassImplements = function(node, opts) {
          assert2("ClassImplements", node, opts);
        }, exports3.assertClassMethod = function(node, opts) {
          assert2("ClassMethod", node, opts);
        }, exports3.assertClassPrivateMethod = function(node, opts) {
          assert2("ClassPrivateMethod", node, opts);
        }, exports3.assertClassPrivateProperty = function(node, opts) {
          assert2("ClassPrivateProperty", node, opts);
        }, exports3.assertClassProperty = function(node, opts) {
          assert2("ClassProperty", node, opts);
        }, exports3.assertCompletionStatement = function(node, opts) {
          assert2("CompletionStatement", node, opts);
        }, exports3.assertConditional = function(node, opts) {
          assert2("Conditional", node, opts);
        }, exports3.assertConditionalExpression = function(node, opts) {
          assert2("ConditionalExpression", node, opts);
        }, exports3.assertContinueStatement = function(node, opts) {
          assert2("ContinueStatement", node, opts);
        }, exports3.assertDebuggerStatement = function(node, opts) {
          assert2("DebuggerStatement", node, opts);
        }, exports3.assertDecimalLiteral = function(node, opts) {
          assert2("DecimalLiteral", node, opts);
        }, exports3.assertDeclaration = function(node, opts) {
          assert2("Declaration", node, opts);
        }, exports3.assertDeclareClass = function(node, opts) {
          assert2("DeclareClass", node, opts);
        }, exports3.assertDeclareExportAllDeclaration = function(node, opts) {
          assert2("DeclareExportAllDeclaration", node, opts);
        }, exports3.assertDeclareExportDeclaration = function(node, opts) {
          assert2("DeclareExportDeclaration", node, opts);
        }, exports3.assertDeclareFunction = function(node, opts) {
          assert2("DeclareFunction", node, opts);
        }, exports3.assertDeclareInterface = function(node, opts) {
          assert2("DeclareInterface", node, opts);
        }, exports3.assertDeclareModule = function(node, opts) {
          assert2("DeclareModule", node, opts);
        }, exports3.assertDeclareModuleExports = function(node, opts) {
          assert2("DeclareModuleExports", node, opts);
        }, exports3.assertDeclareOpaqueType = function(node, opts) {
          assert2("DeclareOpaqueType", node, opts);
        }, exports3.assertDeclareTypeAlias = function(node, opts) {
          assert2("DeclareTypeAlias", node, opts);
        }, exports3.assertDeclareVariable = function(node, opts) {
          assert2("DeclareVariable", node, opts);
        }, exports3.assertDeclaredPredicate = function(node, opts) {
          assert2("DeclaredPredicate", node, opts);
        }, exports3.assertDecorator = function(node, opts) {
          assert2("Decorator", node, opts);
        }, exports3.assertDirective = function(node, opts) {
          assert2("Directive", node, opts);
        }, exports3.assertDirectiveLiteral = function(node, opts) {
          assert2("DirectiveLiteral", node, opts);
        }, exports3.assertDoExpression = function(node, opts) {
          assert2("DoExpression", node, opts);
        }, exports3.assertDoWhileStatement = function(node, opts) {
          assert2("DoWhileStatement", node, opts);
        }, exports3.assertEmptyStatement = function(node, opts) {
          assert2("EmptyStatement", node, opts);
        }, exports3.assertEmptyTypeAnnotation = function(node, opts) {
          assert2("EmptyTypeAnnotation", node, opts);
        }, exports3.assertEnumBody = function(node, opts) {
          assert2("EnumBody", node, opts);
        }, exports3.assertEnumBooleanBody = function(node, opts) {
          assert2("EnumBooleanBody", node, opts);
        }, exports3.assertEnumBooleanMember = function(node, opts) {
          assert2("EnumBooleanMember", node, opts);
        }, exports3.assertEnumDeclaration = function(node, opts) {
          assert2("EnumDeclaration", node, opts);
        }, exports3.assertEnumDefaultedMember = function(node, opts) {
          assert2("EnumDefaultedMember", node, opts);
        }, exports3.assertEnumMember = function(node, opts) {
          assert2("EnumMember", node, opts);
        }, exports3.assertEnumNumberBody = function(node, opts) {
          assert2("EnumNumberBody", node, opts);
        }, exports3.assertEnumNumberMember = function(node, opts) {
          assert2("EnumNumberMember", node, opts);
        }, exports3.assertEnumStringBody = function(node, opts) {
          assert2("EnumStringBody", node, opts);
        }, exports3.assertEnumStringMember = function(node, opts) {
          assert2("EnumStringMember", node, opts);
        }, exports3.assertEnumSymbolBody = function(node, opts) {
          assert2("EnumSymbolBody", node, opts);
        }, exports3.assertExistsTypeAnnotation = function(node, opts) {
          assert2("ExistsTypeAnnotation", node, opts);
        }, exports3.assertExportAllDeclaration = function(node, opts) {
          assert2("ExportAllDeclaration", node, opts);
        }, exports3.assertExportDeclaration = function(node, opts) {
          assert2("ExportDeclaration", node, opts);
        }, exports3.assertExportDefaultDeclaration = function(node, opts) {
          assert2("ExportDefaultDeclaration", node, opts);
        }, exports3.assertExportDefaultSpecifier = function(node, opts) {
          assert2("ExportDefaultSpecifier", node, opts);
        }, exports3.assertExportNamedDeclaration = function(node, opts) {
          assert2("ExportNamedDeclaration", node, opts);
        }, exports3.assertExportNamespaceSpecifier = function(node, opts) {
          assert2("ExportNamespaceSpecifier", node, opts);
        }, exports3.assertExportSpecifier = function(node, opts) {
          assert2("ExportSpecifier", node, opts);
        }, exports3.assertExpression = function(node, opts) {
          assert2("Expression", node, opts);
        }, exports3.assertExpressionStatement = function(node, opts) {
          assert2("ExpressionStatement", node, opts);
        }, exports3.assertExpressionWrapper = function(node, opts) {
          assert2("ExpressionWrapper", node, opts);
        }, exports3.assertFile = function(node, opts) {
          assert2("File", node, opts);
        }, exports3.assertFlow = function(node, opts) {
          assert2("Flow", node, opts);
        }, exports3.assertFlowBaseAnnotation = function(node, opts) {
          assert2("FlowBaseAnnotation", node, opts);
        }, exports3.assertFlowDeclaration = function(node, opts) {
          assert2("FlowDeclaration", node, opts);
        }, exports3.assertFlowPredicate = function(node, opts) {
          assert2("FlowPredicate", node, opts);
        }, exports3.assertFlowType = function(node, opts) {
          assert2("FlowType", node, opts);
        }, exports3.assertFor = function(node, opts) {
          assert2("For", node, opts);
        }, exports3.assertForInStatement = function(node, opts) {
          assert2("ForInStatement", node, opts);
        }, exports3.assertForOfStatement = function(node, opts) {
          assert2("ForOfStatement", node, opts);
        }, exports3.assertForStatement = function(node, opts) {
          assert2("ForStatement", node, opts);
        }, exports3.assertForXStatement = function(node, opts) {
          assert2("ForXStatement", node, opts);
        }, exports3.assertFunction = function(node, opts) {
          assert2("Function", node, opts);
        }, exports3.assertFunctionDeclaration = function(node, opts) {
          assert2("FunctionDeclaration", node, opts);
        }, exports3.assertFunctionExpression = function(node, opts) {
          assert2("FunctionExpression", node, opts);
        }, exports3.assertFunctionParent = function(node, opts) {
          assert2("FunctionParent", node, opts);
        }, exports3.assertFunctionTypeAnnotation = function(node, opts) {
          assert2("FunctionTypeAnnotation", node, opts);
        }, exports3.assertFunctionTypeParam = function(node, opts) {
          assert2("FunctionTypeParam", node, opts);
        }, exports3.assertGenericTypeAnnotation = function(node, opts) {
          assert2("GenericTypeAnnotation", node, opts);
        }, exports3.assertIdentifier = function(node, opts) {
          assert2("Identifier", node, opts);
        }, exports3.assertIfStatement = function(node, opts) {
          assert2("IfStatement", node, opts);
        }, exports3.assertImmutable = function(node, opts) {
          assert2("Immutable", node, opts);
        }, exports3.assertImport = function(node, opts) {
          assert2("Import", node, opts);
        }, exports3.assertImportAttribute = function(node, opts) {
          assert2("ImportAttribute", node, opts);
        }, exports3.assertImportDeclaration = function(node, opts) {
          assert2("ImportDeclaration", node, opts);
        }, exports3.assertImportDefaultSpecifier = function(node, opts) {
          assert2("ImportDefaultSpecifier", node, opts);
        }, exports3.assertImportNamespaceSpecifier = function(node, opts) {
          assert2("ImportNamespaceSpecifier", node, opts);
        }, exports3.assertImportOrExportDeclaration = function(node, opts) {
          assert2("ImportOrExportDeclaration", node, opts);
        }, exports3.assertImportSpecifier = function(node, opts) {
          assert2("ImportSpecifier", node, opts);
        }, exports3.assertIndexedAccessType = function(node, opts) {
          assert2("IndexedAccessType", node, opts);
        }, exports3.assertInferredPredicate = function(node, opts) {
          assert2("InferredPredicate", node, opts);
        }, exports3.assertInterfaceDeclaration = function(node, opts) {
          assert2("InterfaceDeclaration", node, opts);
        }, exports3.assertInterfaceExtends = function(node, opts) {
          assert2("InterfaceExtends", node, opts);
        }, exports3.assertInterfaceTypeAnnotation = function(node, opts) {
          assert2("InterfaceTypeAnnotation", node, opts);
        }, exports3.assertInterpreterDirective = function(node, opts) {
          assert2("InterpreterDirective", node, opts);
        }, exports3.assertIntersectionTypeAnnotation = function(node, opts) {
          assert2("IntersectionTypeAnnotation", node, opts);
        }, exports3.assertJSX = function(node, opts) {
          assert2("JSX", node, opts);
        }, exports3.assertJSXAttribute = function(node, opts) {
          assert2("JSXAttribute", node, opts);
        }, exports3.assertJSXClosingElement = function(node, opts) {
          assert2("JSXClosingElement", node, opts);
        }, exports3.assertJSXClosingFragment = function(node, opts) {
          assert2("JSXClosingFragment", node, opts);
        }, exports3.assertJSXElement = function(node, opts) {
          assert2("JSXElement", node, opts);
        }, exports3.assertJSXEmptyExpression = function(node, opts) {
          assert2("JSXEmptyExpression", node, opts);
        }, exports3.assertJSXExpressionContainer = function(node, opts) {
          assert2("JSXExpressionContainer", node, opts);
        }, exports3.assertJSXFragment = function(node, opts) {
          assert2("JSXFragment", node, opts);
        }, exports3.assertJSXIdentifier = function(node, opts) {
          assert2("JSXIdentifier", node, opts);
        }, exports3.assertJSXMemberExpression = function(node, opts) {
          assert2("JSXMemberExpression", node, opts);
        }, exports3.assertJSXNamespacedName = function(node, opts) {
          assert2("JSXNamespacedName", node, opts);
        }, exports3.assertJSXOpeningElement = function(node, opts) {
          assert2("JSXOpeningElement", node, opts);
        }, exports3.assertJSXOpeningFragment = function(node, opts) {
          assert2("JSXOpeningFragment", node, opts);
        }, exports3.assertJSXSpreadAttribute = function(node, opts) {
          assert2("JSXSpreadAttribute", node, opts);
        }, exports3.assertJSXSpreadChild = function(node, opts) {
          assert2("JSXSpreadChild", node, opts);
        }, exports3.assertJSXText = function(node, opts) {
          assert2("JSXText", node, opts);
        }, exports3.assertLVal = function(node, opts) {
          assert2("LVal", node, opts);
        }, exports3.assertLabeledStatement = function(node, opts) {
          assert2("LabeledStatement", node, opts);
        }, exports3.assertLiteral = function(node, opts) {
          assert2("Literal", node, opts);
        }, exports3.assertLogicalExpression = function(node, opts) {
          assert2("LogicalExpression", node, opts);
        }, exports3.assertLoop = function(node, opts) {
          assert2("Loop", node, opts);
        }, exports3.assertMemberExpression = function(node, opts) {
          assert2("MemberExpression", node, opts);
        }, exports3.assertMetaProperty = function(node, opts) {
          assert2("MetaProperty", node, opts);
        }, exports3.assertMethod = function(node, opts) {
          assert2("Method", node, opts);
        }, exports3.assertMiscellaneous = function(node, opts) {
          assert2("Miscellaneous", node, opts);
        }, exports3.assertMixedTypeAnnotation = function(node, opts) {
          assert2("MixedTypeAnnotation", node, opts);
        }, exports3.assertModuleDeclaration = function(node, opts) {
          (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), assert2("ModuleDeclaration", node, opts);
        }, exports3.assertModuleExpression = function(node, opts) {
          assert2("ModuleExpression", node, opts);
        }, exports3.assertModuleSpecifier = function(node, opts) {
          assert2("ModuleSpecifier", node, opts);
        }, exports3.assertNewExpression = function(node, opts) {
          assert2("NewExpression", node, opts);
        }, exports3.assertNoop = function(node, opts) {
          assert2("Noop", node, opts);
        }, exports3.assertNullLiteral = function(node, opts) {
          assert2("NullLiteral", node, opts);
        }, exports3.assertNullLiteralTypeAnnotation = function(node, opts) {
          assert2("NullLiteralTypeAnnotation", node, opts);
        }, exports3.assertNullableTypeAnnotation = function(node, opts) {
          assert2("NullableTypeAnnotation", node, opts);
        }, exports3.assertNumberLiteral = function(node, opts) {
          (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral"), assert2("NumberLiteral", node, opts);
        }, exports3.assertNumberLiteralTypeAnnotation = function(node, opts) {
          assert2("NumberLiteralTypeAnnotation", node, opts);
        }, exports3.assertNumberTypeAnnotation = function(node, opts) {
          assert2("NumberTypeAnnotation", node, opts);
        }, exports3.assertNumericLiteral = function(node, opts) {
          assert2("NumericLiteral", node, opts);
        }, exports3.assertObjectExpression = function(node, opts) {
          assert2("ObjectExpression", node, opts);
        }, exports3.assertObjectMember = function(node, opts) {
          assert2("ObjectMember", node, opts);
        }, exports3.assertObjectMethod = function(node, opts) {
          assert2("ObjectMethod", node, opts);
        }, exports3.assertObjectPattern = function(node, opts) {
          assert2("ObjectPattern", node, opts);
        }, exports3.assertObjectProperty = function(node, opts) {
          assert2("ObjectProperty", node, opts);
        }, exports3.assertObjectTypeAnnotation = function(node, opts) {
          assert2("ObjectTypeAnnotation", node, opts);
        }, exports3.assertObjectTypeCallProperty = function(node, opts) {
          assert2("ObjectTypeCallProperty", node, opts);
        }, exports3.assertObjectTypeIndexer = function(node, opts) {
          assert2("ObjectTypeIndexer", node, opts);
        }, exports3.assertObjectTypeInternalSlot = function(node, opts) {
          assert2("ObjectTypeInternalSlot", node, opts);
        }, exports3.assertObjectTypeProperty = function(node, opts) {
          assert2("ObjectTypeProperty", node, opts);
        }, exports3.assertObjectTypeSpreadProperty = function(node, opts) {
          assert2("ObjectTypeSpreadProperty", node, opts);
        }, exports3.assertOpaqueType = function(node, opts) {
          assert2("OpaqueType", node, opts);
        }, exports3.assertOptionalCallExpression = function(node, opts) {
          assert2("OptionalCallExpression", node, opts);
        }, exports3.assertOptionalIndexedAccessType = function(node, opts) {
          assert2("OptionalIndexedAccessType", node, opts);
        }, exports3.assertOptionalMemberExpression = function(node, opts) {
          assert2("OptionalMemberExpression", node, opts);
        }, exports3.assertParenthesizedExpression = function(node, opts) {
          assert2("ParenthesizedExpression", node, opts);
        }, exports3.assertPattern = function(node, opts) {
          assert2("Pattern", node, opts);
        }, exports3.assertPatternLike = function(node, opts) {
          assert2("PatternLike", node, opts);
        }, exports3.assertPipelineBareFunction = function(node, opts) {
          assert2("PipelineBareFunction", node, opts);
        }, exports3.assertPipelinePrimaryTopicReference = function(node, opts) {
          assert2("PipelinePrimaryTopicReference", node, opts);
        }, exports3.assertPipelineTopicExpression = function(node, opts) {
          assert2("PipelineTopicExpression", node, opts);
        }, exports3.assertPlaceholder = function(node, opts) {
          assert2("Placeholder", node, opts);
        }, exports3.assertPrivate = function(node, opts) {
          assert2("Private", node, opts);
        }, exports3.assertPrivateName = function(node, opts) {
          assert2("PrivateName", node, opts);
        }, exports3.assertProgram = function(node, opts) {
          assert2("Program", node, opts);
        }, exports3.assertProperty = function(node, opts) {
          assert2("Property", node, opts);
        }, exports3.assertPureish = function(node, opts) {
          assert2("Pureish", node, opts);
        }, exports3.assertQualifiedTypeIdentifier = function(node, opts) {
          assert2("QualifiedTypeIdentifier", node, opts);
        }, exports3.assertRecordExpression = function(node, opts) {
          assert2("RecordExpression", node, opts);
        }, exports3.assertRegExpLiteral = function(node, opts) {
          assert2("RegExpLiteral", node, opts);
        }, exports3.assertRegexLiteral = function(node, opts) {
          (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral"), assert2("RegexLiteral", node, opts);
        }, exports3.assertRestElement = function(node, opts) {
          assert2("RestElement", node, opts);
        }, exports3.assertRestProperty = function(node, opts) {
          (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement"), assert2("RestProperty", node, opts);
        }, exports3.assertReturnStatement = function(node, opts) {
          assert2("ReturnStatement", node, opts);
        }, exports3.assertScopable = function(node, opts) {
          assert2("Scopable", node, opts);
        }, exports3.assertSequenceExpression = function(node, opts) {
          assert2("SequenceExpression", node, opts);
        }, exports3.assertSpreadElement = function(node, opts) {
          assert2("SpreadElement", node, opts);
        }, exports3.assertSpreadProperty = function(node, opts) {
          (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement"), assert2("SpreadProperty", node, opts);
        }, exports3.assertStandardized = function(node, opts) {
          assert2("Standardized", node, opts);
        }, exports3.assertStatement = function(node, opts) {
          assert2("Statement", node, opts);
        }, exports3.assertStaticBlock = function(node, opts) {
          assert2("StaticBlock", node, opts);
        }, exports3.assertStringLiteral = function(node, opts) {
          assert2("StringLiteral", node, opts);
        }, exports3.assertStringLiteralTypeAnnotation = function(node, opts) {
          assert2("StringLiteralTypeAnnotation", node, opts);
        }, exports3.assertStringTypeAnnotation = function(node, opts) {
          assert2("StringTypeAnnotation", node, opts);
        }, exports3.assertSuper = function(node, opts) {
          assert2("Super", node, opts);
        }, exports3.assertSwitchCase = function(node, opts) {
          assert2("SwitchCase", node, opts);
        }, exports3.assertSwitchStatement = function(node, opts) {
          assert2("SwitchStatement", node, opts);
        }, exports3.assertSymbolTypeAnnotation = function(node, opts) {
          assert2("SymbolTypeAnnotation", node, opts);
        }, exports3.assertTSAnyKeyword = function(node, opts) {
          assert2("TSAnyKeyword", node, opts);
        }, exports3.assertTSArrayType = function(node, opts) {
          assert2("TSArrayType", node, opts);
        }, exports3.assertTSAsExpression = function(node, opts) {
          assert2("TSAsExpression", node, opts);
        }, exports3.assertTSBaseType = function(node, opts) {
          assert2("TSBaseType", node, opts);
        }, exports3.assertTSBigIntKeyword = function(node, opts) {
          assert2("TSBigIntKeyword", node, opts);
        }, exports3.assertTSBooleanKeyword = function(node, opts) {
          assert2("TSBooleanKeyword", node, opts);
        }, exports3.assertTSCallSignatureDeclaration = function(node, opts) {
          assert2("TSCallSignatureDeclaration", node, opts);
        }, exports3.assertTSConditionalType = function(node, opts) {
          assert2("TSConditionalType", node, opts);
        }, exports3.assertTSConstructSignatureDeclaration = function(node, opts) {
          assert2("TSConstructSignatureDeclaration", node, opts);
        }, exports3.assertTSConstructorType = function(node, opts) {
          assert2("TSConstructorType", node, opts);
        }, exports3.assertTSDeclareFunction = function(node, opts) {
          assert2("TSDeclareFunction", node, opts);
        }, exports3.assertTSDeclareMethod = function(node, opts) {
          assert2("TSDeclareMethod", node, opts);
        }, exports3.assertTSEntityName = function(node, opts) {
          assert2("TSEntityName", node, opts);
        }, exports3.assertTSEnumDeclaration = function(node, opts) {
          assert2("TSEnumDeclaration", node, opts);
        }, exports3.assertTSEnumMember = function(node, opts) {
          assert2("TSEnumMember", node, opts);
        }, exports3.assertTSExportAssignment = function(node, opts) {
          assert2("TSExportAssignment", node, opts);
        }, exports3.assertTSExpressionWithTypeArguments = function(node, opts) {
          assert2("TSExpressionWithTypeArguments", node, opts);
        }, exports3.assertTSExternalModuleReference = function(node, opts) {
          assert2("TSExternalModuleReference", node, opts);
        }, exports3.assertTSFunctionType = function(node, opts) {
          assert2("TSFunctionType", node, opts);
        }, exports3.assertTSImportEqualsDeclaration = function(node, opts) {
          assert2("TSImportEqualsDeclaration", node, opts);
        }, exports3.assertTSImportType = function(node, opts) {
          assert2("TSImportType", node, opts);
        }, exports3.assertTSIndexSignature = function(node, opts) {
          assert2("TSIndexSignature", node, opts);
        }, exports3.assertTSIndexedAccessType = function(node, opts) {
          assert2("TSIndexedAccessType", node, opts);
        }, exports3.assertTSInferType = function(node, opts) {
          assert2("TSInferType", node, opts);
        }, exports3.assertTSInstantiationExpression = function(node, opts) {
          assert2("TSInstantiationExpression", node, opts);
        }, exports3.assertTSInterfaceBody = function(node, opts) {
          assert2("TSInterfaceBody", node, opts);
        }, exports3.assertTSInterfaceDeclaration = function(node, opts) {
          assert2("TSInterfaceDeclaration", node, opts);
        }, exports3.assertTSIntersectionType = function(node, opts) {
          assert2("TSIntersectionType", node, opts);
        }, exports3.assertTSIntrinsicKeyword = function(node, opts) {
          assert2("TSIntrinsicKeyword", node, opts);
        }, exports3.assertTSLiteralType = function(node, opts) {
          assert2("TSLiteralType", node, opts);
        }, exports3.assertTSMappedType = function(node, opts) {
          assert2("TSMappedType", node, opts);
        }, exports3.assertTSMethodSignature = function(node, opts) {
          assert2("TSMethodSignature", node, opts);
        }, exports3.assertTSModuleBlock = function(node, opts) {
          assert2("TSModuleBlock", node, opts);
        }, exports3.assertTSModuleDeclaration = function(node, opts) {
          assert2("TSModuleDeclaration", node, opts);
        }, exports3.assertTSNamedTupleMember = function(node, opts) {
          assert2("TSNamedTupleMember", node, opts);
        }, exports3.assertTSNamespaceExportDeclaration = function(node, opts) {
          assert2("TSNamespaceExportDeclaration", node, opts);
        }, exports3.assertTSNeverKeyword = function(node, opts) {
          assert2("TSNeverKeyword", node, opts);
        }, exports3.assertTSNonNullExpression = function(node, opts) {
          assert2("TSNonNullExpression", node, opts);
        }, exports3.assertTSNullKeyword = function(node, opts) {
          assert2("TSNullKeyword", node, opts);
        }, exports3.assertTSNumberKeyword = function(node, opts) {
          assert2("TSNumberKeyword", node, opts);
        }, exports3.assertTSObjectKeyword = function(node, opts) {
          assert2("TSObjectKeyword", node, opts);
        }, exports3.assertTSOptionalType = function(node, opts) {
          assert2("TSOptionalType", node, opts);
        }, exports3.assertTSParameterProperty = function(node, opts) {
          assert2("TSParameterProperty", node, opts);
        }, exports3.assertTSParenthesizedType = function(node, opts) {
          assert2("TSParenthesizedType", node, opts);
        }, exports3.assertTSPropertySignature = function(node, opts) {
          assert2("TSPropertySignature", node, opts);
        }, exports3.assertTSQualifiedName = function(node, opts) {
          assert2("TSQualifiedName", node, opts);
        }, exports3.assertTSRestType = function(node, opts) {
          assert2("TSRestType", node, opts);
        }, exports3.assertTSSatisfiesExpression = function(node, opts) {
          assert2("TSSatisfiesExpression", node, opts);
        }, exports3.assertTSStringKeyword = function(node, opts) {
          assert2("TSStringKeyword", node, opts);
        }, exports3.assertTSSymbolKeyword = function(node, opts) {
          assert2("TSSymbolKeyword", node, opts);
        }, exports3.assertTSThisType = function(node, opts) {
          assert2("TSThisType", node, opts);
        }, exports3.assertTSTupleType = function(node, opts) {
          assert2("TSTupleType", node, opts);
        }, exports3.assertTSType = function(node, opts) {
          assert2("TSType", node, opts);
        }, exports3.assertTSTypeAliasDeclaration = function(node, opts) {
          assert2("TSTypeAliasDeclaration", node, opts);
        }, exports3.assertTSTypeAnnotation = function(node, opts) {
          assert2("TSTypeAnnotation", node, opts);
        }, exports3.assertTSTypeAssertion = function(node, opts) {
          assert2("TSTypeAssertion", node, opts);
        }, exports3.assertTSTypeElement = function(node, opts) {
          assert2("TSTypeElement", node, opts);
        }, exports3.assertTSTypeLiteral = function(node, opts) {
          assert2("TSTypeLiteral", node, opts);
        }, exports3.assertTSTypeOperator = function(node, opts) {
          assert2("TSTypeOperator", node, opts);
        }, exports3.assertTSTypeParameter = function(node, opts) {
          assert2("TSTypeParameter", node, opts);
        }, exports3.assertTSTypeParameterDeclaration = function(node, opts) {
          assert2("TSTypeParameterDeclaration", node, opts);
        }, exports3.assertTSTypeParameterInstantiation = function(node, opts) {
          assert2("TSTypeParameterInstantiation", node, opts);
        }, exports3.assertTSTypePredicate = function(node, opts) {
          assert2("TSTypePredicate", node, opts);
        }, exports3.assertTSTypeQuery = function(node, opts) {
          assert2("TSTypeQuery", node, opts);
        }, exports3.assertTSTypeReference = function(node, opts) {
          assert2("TSTypeReference", node, opts);
        }, exports3.assertTSUndefinedKeyword = function(node, opts) {
          assert2("TSUndefinedKeyword", node, opts);
        }, exports3.assertTSUnionType = function(node, opts) {
          assert2("TSUnionType", node, opts);
        }, exports3.assertTSUnknownKeyword = function(node, opts) {
          assert2("TSUnknownKeyword", node, opts);
        }, exports3.assertTSVoidKeyword = function(node, opts) {
          assert2("TSVoidKeyword", node, opts);
        }, exports3.assertTaggedTemplateExpression = function(node, opts) {
          assert2("TaggedTemplateExpression", node, opts);
        }, exports3.assertTemplateElement = function(node, opts) {
          assert2("TemplateElement", node, opts);
        }, exports3.assertTemplateLiteral = function(node, opts) {
          assert2("TemplateLiteral", node, opts);
        }, exports3.assertTerminatorless = function(node, opts) {
          assert2("Terminatorless", node, opts);
        }, exports3.assertThisExpression = function(node, opts) {
          assert2("ThisExpression", node, opts);
        }, exports3.assertThisTypeAnnotation = function(node, opts) {
          assert2("ThisTypeAnnotation", node, opts);
        }, exports3.assertThrowStatement = function(node, opts) {
          assert2("ThrowStatement", node, opts);
        }, exports3.assertTopicReference = function(node, opts) {
          assert2("TopicReference", node, opts);
        }, exports3.assertTryStatement = function(node, opts) {
          assert2("TryStatement", node, opts);
        }, exports3.assertTupleExpression = function(node, opts) {
          assert2("TupleExpression", node, opts);
        }, exports3.assertTupleTypeAnnotation = function(node, opts) {
          assert2("TupleTypeAnnotation", node, opts);
        }, exports3.assertTypeAlias = function(node, opts) {
          assert2("TypeAlias", node, opts);
        }, exports3.assertTypeAnnotation = function(node, opts) {
          assert2("TypeAnnotation", node, opts);
        }, exports3.assertTypeCastExpression = function(node, opts) {
          assert2("TypeCastExpression", node, opts);
        }, exports3.assertTypeParameter = function(node, opts) {
          assert2("TypeParameter", node, opts);
        }, exports3.assertTypeParameterDeclaration = function(node, opts) {
          assert2("TypeParameterDeclaration", node, opts);
        }, exports3.assertTypeParameterInstantiation = function(node, opts) {
          assert2("TypeParameterInstantiation", node, opts);
        }, exports3.assertTypeScript = function(node, opts) {
          assert2("TypeScript", node, opts);
        }, exports3.assertTypeofTypeAnnotation = function(node, opts) {
          assert2("TypeofTypeAnnotation", node, opts);
        }, exports3.assertUnaryExpression = function(node, opts) {
          assert2("UnaryExpression", node, opts);
        }, exports3.assertUnaryLike = function(node, opts) {
          assert2("UnaryLike", node, opts);
        }, exports3.assertUnionTypeAnnotation = function(node, opts) {
          assert2("UnionTypeAnnotation", node, opts);
        }, exports3.assertUpdateExpression = function(node, opts) {
          assert2("UpdateExpression", node, opts);
        }, exports3.assertUserWhitespacable = function(node, opts) {
          assert2("UserWhitespacable", node, opts);
        }, exports3.assertV8IntrinsicIdentifier = function(node, opts) {
          assert2("V8IntrinsicIdentifier", node, opts);
        }, exports3.assertVariableDeclaration = function(node, opts) {
          assert2("VariableDeclaration", node, opts);
        }, exports3.assertVariableDeclarator = function(node, opts) {
          assert2("VariableDeclarator", node, opts);
        }, exports3.assertVariance = function(node, opts) {
          assert2("Variance", node, opts);
        }, exports3.assertVoidTypeAnnotation = function(node, opts) {
          assert2("VoidTypeAnnotation", node, opts);
        }, exports3.assertWhile = function(node, opts) {
          assert2("While", node, opts);
        }, exports3.assertWhileStatement = function(node, opts) {
          assert2("WhileStatement", node, opts);
        }, exports3.assertWithStatement = function(node, opts) {
          assert2("WithStatement", node, opts);
        }, exports3.assertYieldExpression = function(node, opts) {
          assert2("YieldExpression", node, opts);
        };
        var _is = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/is.js"), _deprecationWarning = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function assert2(type, node, opts) {
          if (!(0, _is.default)(type, node, opts))
            throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(types2) {
          const flattened = (0, _removeTypeDuplicates.default)(types2);
          return 1 === flattened.length ? flattened[0] : (0, _generated.unionTypeAnnotation)(flattened);
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _removeTypeDuplicates = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _default = function(type) {
          switch (type) {
            case "string":
              return (0, _generated.stringTypeAnnotation)();
            case "number":
              return (0, _generated.numberTypeAnnotation)();
            case "undefined":
              return (0, _generated.voidTypeAnnotation)();
            case "boolean":
              return (0, _generated.booleanTypeAnnotation)();
            case "function":
              return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
            case "object":
              return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
            case "symbol":
              return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
            case "bigint":
              return (0, _generated.anyTypeAnnotation)();
          }
          throw new Error("Invalid typeof value: " + type);
        };
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.anyTypeAnnotation = function() {
          return { type: "AnyTypeAnnotation" };
        }, exports3.argumentPlaceholder = function() {
          return { type: "ArgumentPlaceholder" };
        }, exports3.arrayExpression = function(elements = []) {
          return (0, _validateNode.default)({ type: "ArrayExpression", elements });
        }, exports3.arrayPattern = function(elements) {
          return (0, _validateNode.default)({ type: "ArrayPattern", elements });
        }, exports3.arrayTypeAnnotation = function(elementType) {
          return (0, _validateNode.default)({ type: "ArrayTypeAnnotation", elementType });
        }, exports3.arrowFunctionExpression = function(params, body, async = false) {
          return (0, _validateNode.default)({ type: "ArrowFunctionExpression", params, body, async, expression: null });
        }, exports3.assignmentExpression = function(operator, left, right) {
          return (0, _validateNode.default)({ type: "AssignmentExpression", operator, left, right });
        }, exports3.assignmentPattern = function(left, right) {
          return (0, _validateNode.default)({ type: "AssignmentPattern", left, right });
        }, exports3.awaitExpression = function(argument) {
          return (0, _validateNode.default)({ type: "AwaitExpression", argument });
        }, exports3.bigIntLiteral = function(value2) {
          return (0, _validateNode.default)({ type: "BigIntLiteral", value: value2 });
        }, exports3.binaryExpression = function(operator, left, right) {
          return (0, _validateNode.default)({ type: "BinaryExpression", operator, left, right });
        }, exports3.bindExpression = function(object, callee) {
          return (0, _validateNode.default)({ type: "BindExpression", object, callee });
        }, exports3.blockStatement = function(body, directives = []) {
          return (0, _validateNode.default)({ type: "BlockStatement", body, directives });
        }, exports3.booleanLiteral = function(value2) {
          return (0, _validateNode.default)({ type: "BooleanLiteral", value: value2 });
        }, exports3.booleanLiteralTypeAnnotation = function(value2) {
          return (0, _validateNode.default)({ type: "BooleanLiteralTypeAnnotation", value: value2 });
        }, exports3.booleanTypeAnnotation = function() {
          return { type: "BooleanTypeAnnotation" };
        }, exports3.breakStatement = function(label = null) {
          return (0, _validateNode.default)({ type: "BreakStatement", label });
        }, exports3.callExpression = function(callee, _arguments) {
          return (0, _validateNode.default)({ type: "CallExpression", callee, arguments: _arguments });
        }, exports3.catchClause = function(param = null, body) {
          return (0, _validateNode.default)({ type: "CatchClause", param, body });
        }, exports3.classAccessorProperty = function(key, value2 = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
          return (0, _validateNode.default)({ type: "ClassAccessorProperty", key, value: value2, typeAnnotation, decorators, computed, static: _static });
        }, exports3.classBody = function(body) {
          return (0, _validateNode.default)({ type: "ClassBody", body });
        }, exports3.classDeclaration = function(id, superClass = null, body, decorators = null) {
          return (0, _validateNode.default)({ type: "ClassDeclaration", id, superClass, body, decorators });
        }, exports3.classExpression = function(id = null, superClass = null, body, decorators = null) {
          return (0, _validateNode.default)({ type: "ClassExpression", id, superClass, body, decorators });
        }, exports3.classImplements = function(id, typeParameters = null) {
          return (0, _validateNode.default)({ type: "ClassImplements", id, typeParameters });
        }, exports3.classMethod = function(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
          return (0, _validateNode.default)({ type: "ClassMethod", kind, key, params, body, computed, static: _static, generator, async });
        }, exports3.classPrivateMethod = function(kind = "method", key, params, body, _static = false) {
          return (0, _validateNode.default)({ type: "ClassPrivateMethod", kind, key, params, body, static: _static });
        }, exports3.classPrivateProperty = function(key, value2 = null, decorators = null, _static = false) {
          return (0, _validateNode.default)({ type: "ClassPrivateProperty", key, value: value2, decorators, static: _static });
        }, exports3.classProperty = function(key, value2 = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
          return (0, _validateNode.default)({ type: "ClassProperty", key, value: value2, typeAnnotation, decorators, computed, static: _static });
        }, exports3.conditionalExpression = function(test, consequent, alternate) {
          return (0, _validateNode.default)({ type: "ConditionalExpression", test, consequent, alternate });
        }, exports3.continueStatement = function(label = null) {
          return (0, _validateNode.default)({ type: "ContinueStatement", label });
        }, exports3.debuggerStatement = function() {
          return { type: "DebuggerStatement" };
        }, exports3.decimalLiteral = function(value2) {
          return (0, _validateNode.default)({ type: "DecimalLiteral", value: value2 });
        }, exports3.declareClass = function(id, typeParameters = null, _extends = null, body) {
          return (0, _validateNode.default)({ type: "DeclareClass", id, typeParameters, extends: _extends, body });
        }, exports3.declareExportAllDeclaration = function(source) {
          return (0, _validateNode.default)({ type: "DeclareExportAllDeclaration", source });
        }, exports3.declareExportDeclaration = function(declaration = null, specifiers = null, source = null) {
          return (0, _validateNode.default)({ type: "DeclareExportDeclaration", declaration, specifiers, source });
        }, exports3.declareFunction = function(id) {
          return (0, _validateNode.default)({ type: "DeclareFunction", id });
        }, exports3.declareInterface = function(id, typeParameters = null, _extends = null, body) {
          return (0, _validateNode.default)({ type: "DeclareInterface", id, typeParameters, extends: _extends, body });
        }, exports3.declareModule = function(id, body, kind = null) {
          return (0, _validateNode.default)({ type: "DeclareModule", id, body, kind });
        }, exports3.declareModuleExports = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "DeclareModuleExports", typeAnnotation });
        }, exports3.declareOpaqueType = function(id, typeParameters = null, supertype = null) {
          return (0, _validateNode.default)({ type: "DeclareOpaqueType", id, typeParameters, supertype });
        }, exports3.declareTypeAlias = function(id, typeParameters = null, right) {
          return (0, _validateNode.default)({ type: "DeclareTypeAlias", id, typeParameters, right });
        }, exports3.declareVariable = function(id) {
          return (0, _validateNode.default)({ type: "DeclareVariable", id });
        }, exports3.declaredPredicate = function(value2) {
          return (0, _validateNode.default)({ type: "DeclaredPredicate", value: value2 });
        }, exports3.decorator = function(expression) {
          return (0, _validateNode.default)({ type: "Decorator", expression });
        }, exports3.directive = function(value2) {
          return (0, _validateNode.default)({ type: "Directive", value: value2 });
        }, exports3.directiveLiteral = function(value2) {
          return (0, _validateNode.default)({ type: "DirectiveLiteral", value: value2 });
        }, exports3.doExpression = function(body, async = false) {
          return (0, _validateNode.default)({ type: "DoExpression", body, async });
        }, exports3.doWhileStatement = function(test, body) {
          return (0, _validateNode.default)({ type: "DoWhileStatement", test, body });
        }, exports3.emptyStatement = function() {
          return { type: "EmptyStatement" };
        }, exports3.emptyTypeAnnotation = function() {
          return { type: "EmptyTypeAnnotation" };
        }, exports3.enumBooleanBody = function(members) {
          return (0, _validateNode.default)({ type: "EnumBooleanBody", members, explicitType: null, hasUnknownMembers: null });
        }, exports3.enumBooleanMember = function(id) {
          return (0, _validateNode.default)({ type: "EnumBooleanMember", id, init: null });
        }, exports3.enumDeclaration = function(id, body) {
          return (0, _validateNode.default)({ type: "EnumDeclaration", id, body });
        }, exports3.enumDefaultedMember = function(id) {
          return (0, _validateNode.default)({ type: "EnumDefaultedMember", id });
        }, exports3.enumNumberBody = function(members) {
          return (0, _validateNode.default)({ type: "EnumNumberBody", members, explicitType: null, hasUnknownMembers: null });
        }, exports3.enumNumberMember = function(id, init) {
          return (0, _validateNode.default)({ type: "EnumNumberMember", id, init });
        }, exports3.enumStringBody = function(members) {
          return (0, _validateNode.default)({ type: "EnumStringBody", members, explicitType: null, hasUnknownMembers: null });
        }, exports3.enumStringMember = function(id, init) {
          return (0, _validateNode.default)({ type: "EnumStringMember", id, init });
        }, exports3.enumSymbolBody = function(members) {
          return (0, _validateNode.default)({ type: "EnumSymbolBody", members, hasUnknownMembers: null });
        }, exports3.existsTypeAnnotation = function() {
          return { type: "ExistsTypeAnnotation" };
        }, exports3.exportAllDeclaration = function(source) {
          return (0, _validateNode.default)({ type: "ExportAllDeclaration", source });
        }, exports3.exportDefaultDeclaration = function(declaration) {
          return (0, _validateNode.default)({ type: "ExportDefaultDeclaration", declaration });
        }, exports3.exportDefaultSpecifier = function(exported) {
          return (0, _validateNode.default)({ type: "ExportDefaultSpecifier", exported });
        }, exports3.exportNamedDeclaration = function(declaration = null, specifiers = [], source = null) {
          return (0, _validateNode.default)({ type: "ExportNamedDeclaration", declaration, specifiers, source });
        }, exports3.exportNamespaceSpecifier = function(exported) {
          return (0, _validateNode.default)({ type: "ExportNamespaceSpecifier", exported });
        }, exports3.exportSpecifier = function(local, exported) {
          return (0, _validateNode.default)({ type: "ExportSpecifier", local, exported });
        }, exports3.expressionStatement = function(expression) {
          return (0, _validateNode.default)({ type: "ExpressionStatement", expression });
        }, exports3.file = function(program, comments = null, tokens = null) {
          return (0, _validateNode.default)({ type: "File", program, comments, tokens });
        }, exports3.forInStatement = function(left, right, body) {
          return (0, _validateNode.default)({ type: "ForInStatement", left, right, body });
        }, exports3.forOfStatement = function(left, right, body, _await = false) {
          return (0, _validateNode.default)({ type: "ForOfStatement", left, right, body, await: _await });
        }, exports3.forStatement = function(init = null, test = null, update = null, body) {
          return (0, _validateNode.default)({ type: "ForStatement", init, test, update, body });
        }, exports3.functionDeclaration = function(id = null, params, body, generator = false, async = false) {
          return (0, _validateNode.default)({ type: "FunctionDeclaration", id, params, body, generator, async });
        }, exports3.functionExpression = function(id = null, params, body, generator = false, async = false) {
          return (0, _validateNode.default)({ type: "FunctionExpression", id, params, body, generator, async });
        }, exports3.functionTypeAnnotation = function(typeParameters = null, params, rest = null, returnType) {
          return (0, _validateNode.default)({ type: "FunctionTypeAnnotation", typeParameters, params, rest, returnType });
        }, exports3.functionTypeParam = function(name = null, typeAnnotation) {
          return (0, _validateNode.default)({ type: "FunctionTypeParam", name, typeAnnotation });
        }, exports3.genericTypeAnnotation = function(id, typeParameters = null) {
          return (0, _validateNode.default)({ type: "GenericTypeAnnotation", id, typeParameters });
        }, exports3.identifier = function(name) {
          return (0, _validateNode.default)({ type: "Identifier", name });
        }, exports3.ifStatement = function(test, consequent, alternate = null) {
          return (0, _validateNode.default)({ type: "IfStatement", test, consequent, alternate });
        }, exports3.import = function() {
          return { type: "Import" };
        }, exports3.importAttribute = function(key, value2) {
          return (0, _validateNode.default)({ type: "ImportAttribute", key, value: value2 });
        }, exports3.importDeclaration = function(specifiers, source) {
          return (0, _validateNode.default)({ type: "ImportDeclaration", specifiers, source });
        }, exports3.importDefaultSpecifier = function(local) {
          return (0, _validateNode.default)({ type: "ImportDefaultSpecifier", local });
        }, exports3.importNamespaceSpecifier = function(local) {
          return (0, _validateNode.default)({ type: "ImportNamespaceSpecifier", local });
        }, exports3.importSpecifier = function(local, imported) {
          return (0, _validateNode.default)({ type: "ImportSpecifier", local, imported });
        }, exports3.indexedAccessType = function(objectType, indexType) {
          return (0, _validateNode.default)({ type: "IndexedAccessType", objectType, indexType });
        }, exports3.inferredPredicate = function() {
          return { type: "InferredPredicate" };
        }, exports3.interfaceDeclaration = function(id, typeParameters = null, _extends = null, body) {
          return (0, _validateNode.default)({ type: "InterfaceDeclaration", id, typeParameters, extends: _extends, body });
        }, exports3.interfaceExtends = function(id, typeParameters = null) {
          return (0, _validateNode.default)({ type: "InterfaceExtends", id, typeParameters });
        }, exports3.interfaceTypeAnnotation = function(_extends = null, body) {
          return (0, _validateNode.default)({ type: "InterfaceTypeAnnotation", extends: _extends, body });
        }, exports3.interpreterDirective = function(value2) {
          return (0, _validateNode.default)({ type: "InterpreterDirective", value: value2 });
        }, exports3.intersectionTypeAnnotation = function(types2) {
          return (0, _validateNode.default)({ type: "IntersectionTypeAnnotation", types: types2 });
        }, exports3.jSXAttribute = exports3.jsxAttribute = function(name, value2 = null) {
          return (0, _validateNode.default)({ type: "JSXAttribute", name, value: value2 });
        }, exports3.jSXClosingElement = exports3.jsxClosingElement = function(name) {
          return (0, _validateNode.default)({ type: "JSXClosingElement", name });
        }, exports3.jSXClosingFragment = exports3.jsxClosingFragment = function() {
          return { type: "JSXClosingFragment" };
        }, exports3.jSXElement = exports3.jsxElement = function(openingElement, closingElement = null, children, selfClosing = null) {
          return (0, _validateNode.default)({ type: "JSXElement", openingElement, closingElement, children, selfClosing });
        }, exports3.jSXEmptyExpression = exports3.jsxEmptyExpression = function() {
          return { type: "JSXEmptyExpression" };
        }, exports3.jSXExpressionContainer = exports3.jsxExpressionContainer = function(expression) {
          return (0, _validateNode.default)({ type: "JSXExpressionContainer", expression });
        }, exports3.jSXFragment = exports3.jsxFragment = function(openingFragment, closingFragment, children) {
          return (0, _validateNode.default)({ type: "JSXFragment", openingFragment, closingFragment, children });
        }, exports3.jSXIdentifier = exports3.jsxIdentifier = function(name) {
          return (0, _validateNode.default)({ type: "JSXIdentifier", name });
        }, exports3.jSXMemberExpression = exports3.jsxMemberExpression = function(object, property) {
          return (0, _validateNode.default)({ type: "JSXMemberExpression", object, property });
        }, exports3.jSXNamespacedName = exports3.jsxNamespacedName = function(namespace, name) {
          return (0, _validateNode.default)({ type: "JSXNamespacedName", namespace, name });
        }, exports3.jSXOpeningElement = exports3.jsxOpeningElement = function(name, attributes, selfClosing = false) {
          return (0, _validateNode.default)({ type: "JSXOpeningElement", name, attributes, selfClosing });
        }, exports3.jSXOpeningFragment = exports3.jsxOpeningFragment = function() {
          return { type: "JSXOpeningFragment" };
        }, exports3.jSXSpreadAttribute = exports3.jsxSpreadAttribute = function(argument) {
          return (0, _validateNode.default)({ type: "JSXSpreadAttribute", argument });
        }, exports3.jSXSpreadChild = exports3.jsxSpreadChild = function(expression) {
          return (0, _validateNode.default)({ type: "JSXSpreadChild", expression });
        }, exports3.jSXText = exports3.jsxText = function(value2) {
          return (0, _validateNode.default)({ type: "JSXText", value: value2 });
        }, exports3.labeledStatement = function(label, body) {
          return (0, _validateNode.default)({ type: "LabeledStatement", label, body });
        }, exports3.logicalExpression = function(operator, left, right) {
          return (0, _validateNode.default)({ type: "LogicalExpression", operator, left, right });
        }, exports3.memberExpression = function(object, property, computed = false, optional = null) {
          return (0, _validateNode.default)({ type: "MemberExpression", object, property, computed, optional });
        }, exports3.metaProperty = function(meta, property) {
          return (0, _validateNode.default)({ type: "MetaProperty", meta, property });
        }, exports3.mixedTypeAnnotation = function() {
          return { type: "MixedTypeAnnotation" };
        }, exports3.moduleExpression = function(body) {
          return (0, _validateNode.default)({ type: "ModuleExpression", body });
        }, exports3.newExpression = function(callee, _arguments) {
          return (0, _validateNode.default)({ type: "NewExpression", callee, arguments: _arguments });
        }, exports3.noop = function() {
          return { type: "Noop" };
        }, exports3.nullLiteral = function() {
          return { type: "NullLiteral" };
        }, exports3.nullLiteralTypeAnnotation = function() {
          return { type: "NullLiteralTypeAnnotation" };
        }, exports3.nullableTypeAnnotation = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "NullableTypeAnnotation", typeAnnotation });
        }, exports3.numberLiteral = function(value2) {
          return (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type "), numericLiteral(value2);
        }, exports3.numberLiteralTypeAnnotation = function(value2) {
          return (0, _validateNode.default)({ type: "NumberLiteralTypeAnnotation", value: value2 });
        }, exports3.numberTypeAnnotation = function() {
          return { type: "NumberTypeAnnotation" };
        }, exports3.numericLiteral = numericLiteral, exports3.objectExpression = function(properties) {
          return (0, _validateNode.default)({ type: "ObjectExpression", properties });
        }, exports3.objectMethod = function(kind = "method", key, params, body, computed = false, generator = false, async = false) {
          return (0, _validateNode.default)({ type: "ObjectMethod", kind, key, params, body, computed, generator, async });
        }, exports3.objectPattern = function(properties) {
          return (0, _validateNode.default)({ type: "ObjectPattern", properties });
        }, exports3.objectProperty = function(key, value2, computed = false, shorthand = false, decorators = null) {
          return (0, _validateNode.default)({ type: "ObjectProperty", key, value: value2, computed, shorthand, decorators });
        }, exports3.objectTypeAnnotation = function(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
          return (0, _validateNode.default)({ type: "ObjectTypeAnnotation", properties, indexers, callProperties, internalSlots, exact });
        }, exports3.objectTypeCallProperty = function(value2) {
          return (0, _validateNode.default)({ type: "ObjectTypeCallProperty", value: value2, static: null });
        }, exports3.objectTypeIndexer = function(id = null, key, value2, variance = null) {
          return (0, _validateNode.default)({ type: "ObjectTypeIndexer", id, key, value: value2, variance, static: null });
        }, exports3.objectTypeInternalSlot = function(id, value2, optional, _static, method) {
          return (0, _validateNode.default)({ type: "ObjectTypeInternalSlot", id, value: value2, optional, static: _static, method });
        }, exports3.objectTypeProperty = function(key, value2, variance = null) {
          return (0, _validateNode.default)({ type: "ObjectTypeProperty", key, value: value2, variance, kind: null, method: null, optional: null, proto: null, static: null });
        }, exports3.objectTypeSpreadProperty = function(argument) {
          return (0, _validateNode.default)({ type: "ObjectTypeSpreadProperty", argument });
        }, exports3.opaqueType = function(id, typeParameters = null, supertype = null, impltype) {
          return (0, _validateNode.default)({ type: "OpaqueType", id, typeParameters, supertype, impltype });
        }, exports3.optionalCallExpression = function(callee, _arguments, optional) {
          return (0, _validateNode.default)({ type: "OptionalCallExpression", callee, arguments: _arguments, optional });
        }, exports3.optionalIndexedAccessType = function(objectType, indexType) {
          return (0, _validateNode.default)({ type: "OptionalIndexedAccessType", objectType, indexType, optional: null });
        }, exports3.optionalMemberExpression = function(object, property, computed = false, optional) {
          return (0, _validateNode.default)({ type: "OptionalMemberExpression", object, property, computed, optional });
        }, exports3.parenthesizedExpression = function(expression) {
          return (0, _validateNode.default)({ type: "ParenthesizedExpression", expression });
        }, exports3.pipelineBareFunction = function(callee) {
          return (0, _validateNode.default)({ type: "PipelineBareFunction", callee });
        }, exports3.pipelinePrimaryTopicReference = function() {
          return { type: "PipelinePrimaryTopicReference" };
        }, exports3.pipelineTopicExpression = function(expression) {
          return (0, _validateNode.default)({ type: "PipelineTopicExpression", expression });
        }, exports3.placeholder = function(expectedNode, name) {
          return (0, _validateNode.default)({ type: "Placeholder", expectedNode, name });
        }, exports3.privateName = function(id) {
          return (0, _validateNode.default)({ type: "PrivateName", id });
        }, exports3.program = function(body, directives = [], sourceType = "script", interpreter = null) {
          return (0, _validateNode.default)({ type: "Program", body, directives, sourceType, interpreter, sourceFile: null });
        }, exports3.qualifiedTypeIdentifier = function(id, qualification) {
          return (0, _validateNode.default)({ type: "QualifiedTypeIdentifier", id, qualification });
        }, exports3.recordExpression = function(properties) {
          return (0, _validateNode.default)({ type: "RecordExpression", properties });
        }, exports3.regExpLiteral = regExpLiteral, exports3.regexLiteral = function(pattern, flags = "") {
          return (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type "), regExpLiteral(pattern, flags);
        }, exports3.restElement = restElement, exports3.restProperty = function(argument) {
          return (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type "), restElement(argument);
        }, exports3.returnStatement = function(argument = null) {
          return (0, _validateNode.default)({ type: "ReturnStatement", argument });
        }, exports3.sequenceExpression = function(expressions) {
          return (0, _validateNode.default)({ type: "SequenceExpression", expressions });
        }, exports3.spreadElement = spreadElement, exports3.spreadProperty = function(argument) {
          return (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type "), spreadElement(argument);
        }, exports3.staticBlock = function(body) {
          return (0, _validateNode.default)({ type: "StaticBlock", body });
        }, exports3.stringLiteral = function(value2) {
          return (0, _validateNode.default)({ type: "StringLiteral", value: value2 });
        }, exports3.stringLiteralTypeAnnotation = function(value2) {
          return (0, _validateNode.default)({ type: "StringLiteralTypeAnnotation", value: value2 });
        }, exports3.stringTypeAnnotation = function() {
          return { type: "StringTypeAnnotation" };
        }, exports3.super = function() {
          return { type: "Super" };
        }, exports3.switchCase = function(test = null, consequent) {
          return (0, _validateNode.default)({ type: "SwitchCase", test, consequent });
        }, exports3.switchStatement = function(discriminant, cases) {
          return (0, _validateNode.default)({ type: "SwitchStatement", discriminant, cases });
        }, exports3.symbolTypeAnnotation = function() {
          return { type: "SymbolTypeAnnotation" };
        }, exports3.taggedTemplateExpression = function(tag, quasi) {
          return (0, _validateNode.default)({ type: "TaggedTemplateExpression", tag, quasi });
        }, exports3.templateElement = function(value2, tail = false) {
          return (0, _validateNode.default)({ type: "TemplateElement", value: value2, tail });
        }, exports3.templateLiteral = function(quasis, expressions) {
          return (0, _validateNode.default)({ type: "TemplateLiteral", quasis, expressions });
        }, exports3.thisExpression = function() {
          return { type: "ThisExpression" };
        }, exports3.thisTypeAnnotation = function() {
          return { type: "ThisTypeAnnotation" };
        }, exports3.throwStatement = function(argument) {
          return (0, _validateNode.default)({ type: "ThrowStatement", argument });
        }, exports3.topicReference = function() {
          return { type: "TopicReference" };
        }, exports3.tryStatement = function(block, handler = null, finalizer = null) {
          return (0, _validateNode.default)({ type: "TryStatement", block, handler, finalizer });
        }, exports3.tSAnyKeyword = exports3.tsAnyKeyword = function() {
          return { type: "TSAnyKeyword" };
        }, exports3.tSArrayType = exports3.tsArrayType = function(elementType) {
          return (0, _validateNode.default)({ type: "TSArrayType", elementType });
        }, exports3.tSAsExpression = exports3.tsAsExpression = function(expression, typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSAsExpression", expression, typeAnnotation });
        }, exports3.tSBigIntKeyword = exports3.tsBigIntKeyword = function() {
          return { type: "TSBigIntKeyword" };
        }, exports3.tSBooleanKeyword = exports3.tsBooleanKeyword = function() {
          return { type: "TSBooleanKeyword" };
        }, exports3.tSCallSignatureDeclaration = exports3.tsCallSignatureDeclaration = function(typeParameters = null, parameters, typeAnnotation = null) {
          return (0, _validateNode.default)({ type: "TSCallSignatureDeclaration", typeParameters, parameters, typeAnnotation });
        }, exports3.tSConditionalType = exports3.tsConditionalType = function(checkType, extendsType, trueType, falseType) {
          return (0, _validateNode.default)({ type: "TSConditionalType", checkType, extendsType, trueType, falseType });
        }, exports3.tSConstructSignatureDeclaration = exports3.tsConstructSignatureDeclaration = function(typeParameters = null, parameters, typeAnnotation = null) {
          return (0, _validateNode.default)({ type: "TSConstructSignatureDeclaration", typeParameters, parameters, typeAnnotation });
        }, exports3.tSConstructorType = exports3.tsConstructorType = function(typeParameters = null, parameters, typeAnnotation = null) {
          return (0, _validateNode.default)({ type: "TSConstructorType", typeParameters, parameters, typeAnnotation });
        }, exports3.tSDeclareFunction = exports3.tsDeclareFunction = function(id = null, typeParameters = null, params, returnType = null) {
          return (0, _validateNode.default)({ type: "TSDeclareFunction", id, typeParameters, params, returnType });
        }, exports3.tSDeclareMethod = exports3.tsDeclareMethod = function(decorators = null, key, typeParameters = null, params, returnType = null) {
          return (0, _validateNode.default)({ type: "TSDeclareMethod", decorators, key, typeParameters, params, returnType });
        }, exports3.tSEnumDeclaration = exports3.tsEnumDeclaration = function(id, members) {
          return (0, _validateNode.default)({ type: "TSEnumDeclaration", id, members });
        }, exports3.tSEnumMember = exports3.tsEnumMember = function(id, initializer = null) {
          return (0, _validateNode.default)({ type: "TSEnumMember", id, initializer });
        }, exports3.tSExportAssignment = exports3.tsExportAssignment = function(expression) {
          return (0, _validateNode.default)({ type: "TSExportAssignment", expression });
        }, exports3.tSExpressionWithTypeArguments = exports3.tsExpressionWithTypeArguments = function(expression, typeParameters = null) {
          return (0, _validateNode.default)({ type: "TSExpressionWithTypeArguments", expression, typeParameters });
        }, exports3.tSExternalModuleReference = exports3.tsExternalModuleReference = function(expression) {
          return (0, _validateNode.default)({ type: "TSExternalModuleReference", expression });
        }, exports3.tSFunctionType = exports3.tsFunctionType = function(typeParameters = null, parameters, typeAnnotation = null) {
          return (0, _validateNode.default)({ type: "TSFunctionType", typeParameters, parameters, typeAnnotation });
        }, exports3.tSImportEqualsDeclaration = exports3.tsImportEqualsDeclaration = function(id, moduleReference) {
          return (0, _validateNode.default)({ type: "TSImportEqualsDeclaration", id, moduleReference, isExport: null });
        }, exports3.tSImportType = exports3.tsImportType = function(argument, qualifier = null, typeParameters = null) {
          return (0, _validateNode.default)({ type: "TSImportType", argument, qualifier, typeParameters });
        }, exports3.tSIndexSignature = exports3.tsIndexSignature = function(parameters, typeAnnotation = null) {
          return (0, _validateNode.default)({ type: "TSIndexSignature", parameters, typeAnnotation });
        }, exports3.tSIndexedAccessType = exports3.tsIndexedAccessType = function(objectType, indexType) {
          return (0, _validateNode.default)({ type: "TSIndexedAccessType", objectType, indexType });
        }, exports3.tSInferType = exports3.tsInferType = function(typeParameter) {
          return (0, _validateNode.default)({ type: "TSInferType", typeParameter });
        }, exports3.tSInstantiationExpression = exports3.tsInstantiationExpression = function(expression, typeParameters = null) {
          return (0, _validateNode.default)({ type: "TSInstantiationExpression", expression, typeParameters });
        }, exports3.tSInterfaceBody = exports3.tsInterfaceBody = function(body) {
          return (0, _validateNode.default)({ type: "TSInterfaceBody", body });
        }, exports3.tSInterfaceDeclaration = exports3.tsInterfaceDeclaration = function(id, typeParameters = null, _extends = null, body) {
          return (0, _validateNode.default)({ type: "TSInterfaceDeclaration", id, typeParameters, extends: _extends, body });
        }, exports3.tSIntersectionType = exports3.tsIntersectionType = function(types2) {
          return (0, _validateNode.default)({ type: "TSIntersectionType", types: types2 });
        }, exports3.tSIntrinsicKeyword = exports3.tsIntrinsicKeyword = function() {
          return { type: "TSIntrinsicKeyword" };
        }, exports3.tSLiteralType = exports3.tsLiteralType = function(literal2) {
          return (0, _validateNode.default)({ type: "TSLiteralType", literal: literal2 });
        }, exports3.tSMappedType = exports3.tsMappedType = function(typeParameter, typeAnnotation = null, nameType = null) {
          return (0, _validateNode.default)({ type: "TSMappedType", typeParameter, typeAnnotation, nameType });
        }, exports3.tSMethodSignature = exports3.tsMethodSignature = function(key, typeParameters = null, parameters, typeAnnotation = null) {
          return (0, _validateNode.default)({ type: "TSMethodSignature", key, typeParameters, parameters, typeAnnotation, kind: null });
        }, exports3.tSModuleBlock = exports3.tsModuleBlock = function(body) {
          return (0, _validateNode.default)({ type: "TSModuleBlock", body });
        }, exports3.tSModuleDeclaration = exports3.tsModuleDeclaration = function(id, body) {
          return (0, _validateNode.default)({ type: "TSModuleDeclaration", id, body });
        }, exports3.tSNamedTupleMember = exports3.tsNamedTupleMember = function(label, elementType, optional = false) {
          return (0, _validateNode.default)({ type: "TSNamedTupleMember", label, elementType, optional });
        }, exports3.tSNamespaceExportDeclaration = exports3.tsNamespaceExportDeclaration = function(id) {
          return (0, _validateNode.default)({ type: "TSNamespaceExportDeclaration", id });
        }, exports3.tSNeverKeyword = exports3.tsNeverKeyword = function() {
          return { type: "TSNeverKeyword" };
        }, exports3.tSNonNullExpression = exports3.tsNonNullExpression = function(expression) {
          return (0, _validateNode.default)({ type: "TSNonNullExpression", expression });
        }, exports3.tSNullKeyword = exports3.tsNullKeyword = function() {
          return { type: "TSNullKeyword" };
        }, exports3.tSNumberKeyword = exports3.tsNumberKeyword = function() {
          return { type: "TSNumberKeyword" };
        }, exports3.tSObjectKeyword = exports3.tsObjectKeyword = function() {
          return { type: "TSObjectKeyword" };
        }, exports3.tSOptionalType = exports3.tsOptionalType = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSOptionalType", typeAnnotation });
        }, exports3.tSParameterProperty = exports3.tsParameterProperty = function(parameter) {
          return (0, _validateNode.default)({ type: "TSParameterProperty", parameter });
        }, exports3.tSParenthesizedType = exports3.tsParenthesizedType = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSParenthesizedType", typeAnnotation });
        }, exports3.tSPropertySignature = exports3.tsPropertySignature = function(key, typeAnnotation = null, initializer = null) {
          return (0, _validateNode.default)({ type: "TSPropertySignature", key, typeAnnotation, initializer, kind: null });
        }, exports3.tSQualifiedName = exports3.tsQualifiedName = function(left, right) {
          return (0, _validateNode.default)({ type: "TSQualifiedName", left, right });
        }, exports3.tSRestType = exports3.tsRestType = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSRestType", typeAnnotation });
        }, exports3.tSSatisfiesExpression = exports3.tsSatisfiesExpression = function(expression, typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSSatisfiesExpression", expression, typeAnnotation });
        }, exports3.tSStringKeyword = exports3.tsStringKeyword = function() {
          return { type: "TSStringKeyword" };
        }, exports3.tSSymbolKeyword = exports3.tsSymbolKeyword = function() {
          return { type: "TSSymbolKeyword" };
        }, exports3.tSThisType = exports3.tsThisType = function() {
          return { type: "TSThisType" };
        }, exports3.tSTupleType = exports3.tsTupleType = function(elementTypes) {
          return (0, _validateNode.default)({ type: "TSTupleType", elementTypes });
        }, exports3.tSTypeAliasDeclaration = exports3.tsTypeAliasDeclaration = function(id, typeParameters = null, typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSTypeAliasDeclaration", id, typeParameters, typeAnnotation });
        }, exports3.tSTypeAnnotation = exports3.tsTypeAnnotation = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSTypeAnnotation", typeAnnotation });
        }, exports3.tSTypeAssertion = exports3.tsTypeAssertion = function(typeAnnotation, expression) {
          return (0, _validateNode.default)({ type: "TSTypeAssertion", typeAnnotation, expression });
        }, exports3.tSTypeLiteral = exports3.tsTypeLiteral = function(members) {
          return (0, _validateNode.default)({ type: "TSTypeLiteral", members });
        }, exports3.tSTypeOperator = exports3.tsTypeOperator = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "TSTypeOperator", typeAnnotation, operator: null });
        }, exports3.tSTypeParameter = exports3.tsTypeParameter = function(constraint = null, _default = null, name) {
          return (0, _validateNode.default)({ type: "TSTypeParameter", constraint, default: _default, name });
        }, exports3.tSTypeParameterDeclaration = exports3.tsTypeParameterDeclaration = function(params) {
          return (0, _validateNode.default)({ type: "TSTypeParameterDeclaration", params });
        }, exports3.tSTypeParameterInstantiation = exports3.tsTypeParameterInstantiation = function(params) {
          return (0, _validateNode.default)({ type: "TSTypeParameterInstantiation", params });
        }, exports3.tSTypePredicate = exports3.tsTypePredicate = function(parameterName, typeAnnotation = null, asserts = null) {
          return (0, _validateNode.default)({ type: "TSTypePredicate", parameterName, typeAnnotation, asserts });
        }, exports3.tSTypeQuery = exports3.tsTypeQuery = function(exprName, typeParameters = null) {
          return (0, _validateNode.default)({ type: "TSTypeQuery", exprName, typeParameters });
        }, exports3.tSTypeReference = exports3.tsTypeReference = function(typeName, typeParameters = null) {
          return (0, _validateNode.default)({ type: "TSTypeReference", typeName, typeParameters });
        }, exports3.tSUndefinedKeyword = exports3.tsUndefinedKeyword = function() {
          return { type: "TSUndefinedKeyword" };
        }, exports3.tSUnionType = exports3.tsUnionType = function(types2) {
          return (0, _validateNode.default)({ type: "TSUnionType", types: types2 });
        }, exports3.tSUnknownKeyword = exports3.tsUnknownKeyword = function() {
          return { type: "TSUnknownKeyword" };
        }, exports3.tSVoidKeyword = exports3.tsVoidKeyword = function() {
          return { type: "TSVoidKeyword" };
        }, exports3.tupleExpression = function(elements = []) {
          return (0, _validateNode.default)({ type: "TupleExpression", elements });
        }, exports3.tupleTypeAnnotation = function(types2) {
          return (0, _validateNode.default)({ type: "TupleTypeAnnotation", types: types2 });
        }, exports3.typeAlias = function(id, typeParameters = null, right) {
          return (0, _validateNode.default)({ type: "TypeAlias", id, typeParameters, right });
        }, exports3.typeAnnotation = function(typeAnnotation) {
          return (0, _validateNode.default)({ type: "TypeAnnotation", typeAnnotation });
        }, exports3.typeCastExpression = function(expression, typeAnnotation) {
          return (0, _validateNode.default)({ type: "TypeCastExpression", expression, typeAnnotation });
        }, exports3.typeParameter = function(bound = null, _default = null, variance = null) {
          return (0, _validateNode.default)({ type: "TypeParameter", bound, default: _default, variance, name: null });
        }, exports3.typeParameterDeclaration = function(params) {
          return (0, _validateNode.default)({ type: "TypeParameterDeclaration", params });
        }, exports3.typeParameterInstantiation = function(params) {
          return (0, _validateNode.default)({ type: "TypeParameterInstantiation", params });
        }, exports3.typeofTypeAnnotation = function(argument) {
          return (0, _validateNode.default)({ type: "TypeofTypeAnnotation", argument });
        }, exports3.unaryExpression = function(operator, argument, prefix = true) {
          return (0, _validateNode.default)({ type: "UnaryExpression", operator, argument, prefix });
        }, exports3.unionTypeAnnotation = function(types2) {
          return (0, _validateNode.default)({ type: "UnionTypeAnnotation", types: types2 });
        }, exports3.updateExpression = function(operator, argument, prefix = false) {
          return (0, _validateNode.default)({ type: "UpdateExpression", operator, argument, prefix });
        }, exports3.v8IntrinsicIdentifier = function(name) {
          return (0, _validateNode.default)({ type: "V8IntrinsicIdentifier", name });
        }, exports3.variableDeclaration = function(kind, declarations) {
          return (0, _validateNode.default)({ type: "VariableDeclaration", kind, declarations });
        }, exports3.variableDeclarator = function(id, init = null) {
          return (0, _validateNode.default)({ type: "VariableDeclarator", id, init });
        }, exports3.variance = function(kind) {
          return (0, _validateNode.default)({ type: "Variance", kind });
        }, exports3.voidTypeAnnotation = function() {
          return { type: "VoidTypeAnnotation" };
        }, exports3.whileStatement = function(test, body) {
          return (0, _validateNode.default)({ type: "WhileStatement", test, body });
        }, exports3.withStatement = function(object, body) {
          return (0, _validateNode.default)({ type: "WithStatement", object, body });
        }, exports3.yieldExpression = function(argument = null, delegate = false) {
          return (0, _validateNode.default)({ type: "YieldExpression", argument, delegate });
        };
        var _validateNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/validateNode.js"), _deprecationWarning = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function numericLiteral(value2) {
          return (0, _validateNode.default)({ type: "NumericLiteral", value: value2 });
        }
        function regExpLiteral(pattern, flags = "") {
          return (0, _validateNode.default)({ type: "RegExpLiteral", pattern, flags });
        }
        function restElement(argument) {
          return (0, _validateNode.default)({ type: "RestElement", argument });
        }
        function spreadElement(argument) {
          return (0, _validateNode.default)({ type: "SpreadElement", argument });
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/uppercase.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "AnyTypeAnnotation", { enumerable: true, get: function() {
          return _index.anyTypeAnnotation;
        } }), Object.defineProperty(exports3, "ArgumentPlaceholder", { enumerable: true, get: function() {
          return _index.argumentPlaceholder;
        } }), Object.defineProperty(exports3, "ArrayExpression", { enumerable: true, get: function() {
          return _index.arrayExpression;
        } }), Object.defineProperty(exports3, "ArrayPattern", { enumerable: true, get: function() {
          return _index.arrayPattern;
        } }), Object.defineProperty(exports3, "ArrayTypeAnnotation", { enumerable: true, get: function() {
          return _index.arrayTypeAnnotation;
        } }), Object.defineProperty(exports3, "ArrowFunctionExpression", { enumerable: true, get: function() {
          return _index.arrowFunctionExpression;
        } }), Object.defineProperty(exports3, "AssignmentExpression", { enumerable: true, get: function() {
          return _index.assignmentExpression;
        } }), Object.defineProperty(exports3, "AssignmentPattern", { enumerable: true, get: function() {
          return _index.assignmentPattern;
        } }), Object.defineProperty(exports3, "AwaitExpression", { enumerable: true, get: function() {
          return _index.awaitExpression;
        } }), Object.defineProperty(exports3, "BigIntLiteral", { enumerable: true, get: function() {
          return _index.bigIntLiteral;
        } }), Object.defineProperty(exports3, "BinaryExpression", { enumerable: true, get: function() {
          return _index.binaryExpression;
        } }), Object.defineProperty(exports3, "BindExpression", { enumerable: true, get: function() {
          return _index.bindExpression;
        } }), Object.defineProperty(exports3, "BlockStatement", { enumerable: true, get: function() {
          return _index.blockStatement;
        } }), Object.defineProperty(exports3, "BooleanLiteral", { enumerable: true, get: function() {
          return _index.booleanLiteral;
        } }), Object.defineProperty(exports3, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.booleanLiteralTypeAnnotation;
        } }), Object.defineProperty(exports3, "BooleanTypeAnnotation", { enumerable: true, get: function() {
          return _index.booleanTypeAnnotation;
        } }), Object.defineProperty(exports3, "BreakStatement", { enumerable: true, get: function() {
          return _index.breakStatement;
        } }), Object.defineProperty(exports3, "CallExpression", { enumerable: true, get: function() {
          return _index.callExpression;
        } }), Object.defineProperty(exports3, "CatchClause", { enumerable: true, get: function() {
          return _index.catchClause;
        } }), Object.defineProperty(exports3, "ClassAccessorProperty", { enumerable: true, get: function() {
          return _index.classAccessorProperty;
        } }), Object.defineProperty(exports3, "ClassBody", { enumerable: true, get: function() {
          return _index.classBody;
        } }), Object.defineProperty(exports3, "ClassDeclaration", { enumerable: true, get: function() {
          return _index.classDeclaration;
        } }), Object.defineProperty(exports3, "ClassExpression", { enumerable: true, get: function() {
          return _index.classExpression;
        } }), Object.defineProperty(exports3, "ClassImplements", { enumerable: true, get: function() {
          return _index.classImplements;
        } }), Object.defineProperty(exports3, "ClassMethod", { enumerable: true, get: function() {
          return _index.classMethod;
        } }), Object.defineProperty(exports3, "ClassPrivateMethod", { enumerable: true, get: function() {
          return _index.classPrivateMethod;
        } }), Object.defineProperty(exports3, "ClassPrivateProperty", { enumerable: true, get: function() {
          return _index.classPrivateProperty;
        } }), Object.defineProperty(exports3, "ClassProperty", { enumerable: true, get: function() {
          return _index.classProperty;
        } }), Object.defineProperty(exports3, "ConditionalExpression", { enumerable: true, get: function() {
          return _index.conditionalExpression;
        } }), Object.defineProperty(exports3, "ContinueStatement", { enumerable: true, get: function() {
          return _index.continueStatement;
        } }), Object.defineProperty(exports3, "DebuggerStatement", { enumerable: true, get: function() {
          return _index.debuggerStatement;
        } }), Object.defineProperty(exports3, "DecimalLiteral", { enumerable: true, get: function() {
          return _index.decimalLiteral;
        } }), Object.defineProperty(exports3, "DeclareClass", { enumerable: true, get: function() {
          return _index.declareClass;
        } }), Object.defineProperty(exports3, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
          return _index.declareExportAllDeclaration;
        } }), Object.defineProperty(exports3, "DeclareExportDeclaration", { enumerable: true, get: function() {
          return _index.declareExportDeclaration;
        } }), Object.defineProperty(exports3, "DeclareFunction", { enumerable: true, get: function() {
          return _index.declareFunction;
        } }), Object.defineProperty(exports3, "DeclareInterface", { enumerable: true, get: function() {
          return _index.declareInterface;
        } }), Object.defineProperty(exports3, "DeclareModule", { enumerable: true, get: function() {
          return _index.declareModule;
        } }), Object.defineProperty(exports3, "DeclareModuleExports", { enumerable: true, get: function() {
          return _index.declareModuleExports;
        } }), Object.defineProperty(exports3, "DeclareOpaqueType", { enumerable: true, get: function() {
          return _index.declareOpaqueType;
        } }), Object.defineProperty(exports3, "DeclareTypeAlias", { enumerable: true, get: function() {
          return _index.declareTypeAlias;
        } }), Object.defineProperty(exports3, "DeclareVariable", { enumerable: true, get: function() {
          return _index.declareVariable;
        } }), Object.defineProperty(exports3, "DeclaredPredicate", { enumerable: true, get: function() {
          return _index.declaredPredicate;
        } }), Object.defineProperty(exports3, "Decorator", { enumerable: true, get: function() {
          return _index.decorator;
        } }), Object.defineProperty(exports3, "Directive", { enumerable: true, get: function() {
          return _index.directive;
        } }), Object.defineProperty(exports3, "DirectiveLiteral", { enumerable: true, get: function() {
          return _index.directiveLiteral;
        } }), Object.defineProperty(exports3, "DoExpression", { enumerable: true, get: function() {
          return _index.doExpression;
        } }), Object.defineProperty(exports3, "DoWhileStatement", { enumerable: true, get: function() {
          return _index.doWhileStatement;
        } }), Object.defineProperty(exports3, "EmptyStatement", { enumerable: true, get: function() {
          return _index.emptyStatement;
        } }), Object.defineProperty(exports3, "EmptyTypeAnnotation", { enumerable: true, get: function() {
          return _index.emptyTypeAnnotation;
        } }), Object.defineProperty(exports3, "EnumBooleanBody", { enumerable: true, get: function() {
          return _index.enumBooleanBody;
        } }), Object.defineProperty(exports3, "EnumBooleanMember", { enumerable: true, get: function() {
          return _index.enumBooleanMember;
        } }), Object.defineProperty(exports3, "EnumDeclaration", { enumerable: true, get: function() {
          return _index.enumDeclaration;
        } }), Object.defineProperty(exports3, "EnumDefaultedMember", { enumerable: true, get: function() {
          return _index.enumDefaultedMember;
        } }), Object.defineProperty(exports3, "EnumNumberBody", { enumerable: true, get: function() {
          return _index.enumNumberBody;
        } }), Object.defineProperty(exports3, "EnumNumberMember", { enumerable: true, get: function() {
          return _index.enumNumberMember;
        } }), Object.defineProperty(exports3, "EnumStringBody", { enumerable: true, get: function() {
          return _index.enumStringBody;
        } }), Object.defineProperty(exports3, "EnumStringMember", { enumerable: true, get: function() {
          return _index.enumStringMember;
        } }), Object.defineProperty(exports3, "EnumSymbolBody", { enumerable: true, get: function() {
          return _index.enumSymbolBody;
        } }), Object.defineProperty(exports3, "ExistsTypeAnnotation", { enumerable: true, get: function() {
          return _index.existsTypeAnnotation;
        } }), Object.defineProperty(exports3, "ExportAllDeclaration", { enumerable: true, get: function() {
          return _index.exportAllDeclaration;
        } }), Object.defineProperty(exports3, "ExportDefaultDeclaration", { enumerable: true, get: function() {
          return _index.exportDefaultDeclaration;
        } }), Object.defineProperty(exports3, "ExportDefaultSpecifier", { enumerable: true, get: function() {
          return _index.exportDefaultSpecifier;
        } }), Object.defineProperty(exports3, "ExportNamedDeclaration", { enumerable: true, get: function() {
          return _index.exportNamedDeclaration;
        } }), Object.defineProperty(exports3, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
          return _index.exportNamespaceSpecifier;
        } }), Object.defineProperty(exports3, "ExportSpecifier", { enumerable: true, get: function() {
          return _index.exportSpecifier;
        } }), Object.defineProperty(exports3, "ExpressionStatement", { enumerable: true, get: function() {
          return _index.expressionStatement;
        } }), Object.defineProperty(exports3, "File", { enumerable: true, get: function() {
          return _index.file;
        } }), Object.defineProperty(exports3, "ForInStatement", { enumerable: true, get: function() {
          return _index.forInStatement;
        } }), Object.defineProperty(exports3, "ForOfStatement", { enumerable: true, get: function() {
          return _index.forOfStatement;
        } }), Object.defineProperty(exports3, "ForStatement", { enumerable: true, get: function() {
          return _index.forStatement;
        } }), Object.defineProperty(exports3, "FunctionDeclaration", { enumerable: true, get: function() {
          return _index.functionDeclaration;
        } }), Object.defineProperty(exports3, "FunctionExpression", { enumerable: true, get: function() {
          return _index.functionExpression;
        } }), Object.defineProperty(exports3, "FunctionTypeAnnotation", { enumerable: true, get: function() {
          return _index.functionTypeAnnotation;
        } }), Object.defineProperty(exports3, "FunctionTypeParam", { enumerable: true, get: function() {
          return _index.functionTypeParam;
        } }), Object.defineProperty(exports3, "GenericTypeAnnotation", { enumerable: true, get: function() {
          return _index.genericTypeAnnotation;
        } }), Object.defineProperty(exports3, "Identifier", { enumerable: true, get: function() {
          return _index.identifier;
        } }), Object.defineProperty(exports3, "IfStatement", { enumerable: true, get: function() {
          return _index.ifStatement;
        } }), Object.defineProperty(exports3, "Import", { enumerable: true, get: function() {
          return _index.import;
        } }), Object.defineProperty(exports3, "ImportAttribute", { enumerable: true, get: function() {
          return _index.importAttribute;
        } }), Object.defineProperty(exports3, "ImportDeclaration", { enumerable: true, get: function() {
          return _index.importDeclaration;
        } }), Object.defineProperty(exports3, "ImportDefaultSpecifier", { enumerable: true, get: function() {
          return _index.importDefaultSpecifier;
        } }), Object.defineProperty(exports3, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
          return _index.importNamespaceSpecifier;
        } }), Object.defineProperty(exports3, "ImportSpecifier", { enumerable: true, get: function() {
          return _index.importSpecifier;
        } }), Object.defineProperty(exports3, "IndexedAccessType", { enumerable: true, get: function() {
          return _index.indexedAccessType;
        } }), Object.defineProperty(exports3, "InferredPredicate", { enumerable: true, get: function() {
          return _index.inferredPredicate;
        } }), Object.defineProperty(exports3, "InterfaceDeclaration", { enumerable: true, get: function() {
          return _index.interfaceDeclaration;
        } }), Object.defineProperty(exports3, "InterfaceExtends", { enumerable: true, get: function() {
          return _index.interfaceExtends;
        } }), Object.defineProperty(exports3, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
          return _index.interfaceTypeAnnotation;
        } }), Object.defineProperty(exports3, "InterpreterDirective", { enumerable: true, get: function() {
          return _index.interpreterDirective;
        } }), Object.defineProperty(exports3, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
          return _index.intersectionTypeAnnotation;
        } }), Object.defineProperty(exports3, "JSXAttribute", { enumerable: true, get: function() {
          return _index.jsxAttribute;
        } }), Object.defineProperty(exports3, "JSXClosingElement", { enumerable: true, get: function() {
          return _index.jsxClosingElement;
        } }), Object.defineProperty(exports3, "JSXClosingFragment", { enumerable: true, get: function() {
          return _index.jsxClosingFragment;
        } }), Object.defineProperty(exports3, "JSXElement", { enumerable: true, get: function() {
          return _index.jsxElement;
        } }), Object.defineProperty(exports3, "JSXEmptyExpression", { enumerable: true, get: function() {
          return _index.jsxEmptyExpression;
        } }), Object.defineProperty(exports3, "JSXExpressionContainer", { enumerable: true, get: function() {
          return _index.jsxExpressionContainer;
        } }), Object.defineProperty(exports3, "JSXFragment", { enumerable: true, get: function() {
          return _index.jsxFragment;
        } }), Object.defineProperty(exports3, "JSXIdentifier", { enumerable: true, get: function() {
          return _index.jsxIdentifier;
        } }), Object.defineProperty(exports3, "JSXMemberExpression", { enumerable: true, get: function() {
          return _index.jsxMemberExpression;
        } }), Object.defineProperty(exports3, "JSXNamespacedName", { enumerable: true, get: function() {
          return _index.jsxNamespacedName;
        } }), Object.defineProperty(exports3, "JSXOpeningElement", { enumerable: true, get: function() {
          return _index.jsxOpeningElement;
        } }), Object.defineProperty(exports3, "JSXOpeningFragment", { enumerable: true, get: function() {
          return _index.jsxOpeningFragment;
        } }), Object.defineProperty(exports3, "JSXSpreadAttribute", { enumerable: true, get: function() {
          return _index.jsxSpreadAttribute;
        } }), Object.defineProperty(exports3, "JSXSpreadChild", { enumerable: true, get: function() {
          return _index.jsxSpreadChild;
        } }), Object.defineProperty(exports3, "JSXText", { enumerable: true, get: function() {
          return _index.jsxText;
        } }), Object.defineProperty(exports3, "LabeledStatement", { enumerable: true, get: function() {
          return _index.labeledStatement;
        } }), Object.defineProperty(exports3, "LogicalExpression", { enumerable: true, get: function() {
          return _index.logicalExpression;
        } }), Object.defineProperty(exports3, "MemberExpression", { enumerable: true, get: function() {
          return _index.memberExpression;
        } }), Object.defineProperty(exports3, "MetaProperty", { enumerable: true, get: function() {
          return _index.metaProperty;
        } }), Object.defineProperty(exports3, "MixedTypeAnnotation", { enumerable: true, get: function() {
          return _index.mixedTypeAnnotation;
        } }), Object.defineProperty(exports3, "ModuleExpression", { enumerable: true, get: function() {
          return _index.moduleExpression;
        } }), Object.defineProperty(exports3, "NewExpression", { enumerable: true, get: function() {
          return _index.newExpression;
        } }), Object.defineProperty(exports3, "Noop", { enumerable: true, get: function() {
          return _index.noop;
        } }), Object.defineProperty(exports3, "NullLiteral", { enumerable: true, get: function() {
          return _index.nullLiteral;
        } }), Object.defineProperty(exports3, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.nullLiteralTypeAnnotation;
        } }), Object.defineProperty(exports3, "NullableTypeAnnotation", { enumerable: true, get: function() {
          return _index.nullableTypeAnnotation;
        } }), Object.defineProperty(exports3, "NumberLiteral", { enumerable: true, get: function() {
          return _index.numberLiteral;
        } }), Object.defineProperty(exports3, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.numberLiteralTypeAnnotation;
        } }), Object.defineProperty(exports3, "NumberTypeAnnotation", { enumerable: true, get: function() {
          return _index.numberTypeAnnotation;
        } }), Object.defineProperty(exports3, "NumericLiteral", { enumerable: true, get: function() {
          return _index.numericLiteral;
        } }), Object.defineProperty(exports3, "ObjectExpression", { enumerable: true, get: function() {
          return _index.objectExpression;
        } }), Object.defineProperty(exports3, "ObjectMethod", { enumerable: true, get: function() {
          return _index.objectMethod;
        } }), Object.defineProperty(exports3, "ObjectPattern", { enumerable: true, get: function() {
          return _index.objectPattern;
        } }), Object.defineProperty(exports3, "ObjectProperty", { enumerable: true, get: function() {
          return _index.objectProperty;
        } }), Object.defineProperty(exports3, "ObjectTypeAnnotation", { enumerable: true, get: function() {
          return _index.objectTypeAnnotation;
        } }), Object.defineProperty(exports3, "ObjectTypeCallProperty", { enumerable: true, get: function() {
          return _index.objectTypeCallProperty;
        } }), Object.defineProperty(exports3, "ObjectTypeIndexer", { enumerable: true, get: function() {
          return _index.objectTypeIndexer;
        } }), Object.defineProperty(exports3, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
          return _index.objectTypeInternalSlot;
        } }), Object.defineProperty(exports3, "ObjectTypeProperty", { enumerable: true, get: function() {
          return _index.objectTypeProperty;
        } }), Object.defineProperty(exports3, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
          return _index.objectTypeSpreadProperty;
        } }), Object.defineProperty(exports3, "OpaqueType", { enumerable: true, get: function() {
          return _index.opaqueType;
        } }), Object.defineProperty(exports3, "OptionalCallExpression", { enumerable: true, get: function() {
          return _index.optionalCallExpression;
        } }), Object.defineProperty(exports3, "OptionalIndexedAccessType", { enumerable: true, get: function() {
          return _index.optionalIndexedAccessType;
        } }), Object.defineProperty(exports3, "OptionalMemberExpression", { enumerable: true, get: function() {
          return _index.optionalMemberExpression;
        } }), Object.defineProperty(exports3, "ParenthesizedExpression", { enumerable: true, get: function() {
          return _index.parenthesizedExpression;
        } }), Object.defineProperty(exports3, "PipelineBareFunction", { enumerable: true, get: function() {
          return _index.pipelineBareFunction;
        } }), Object.defineProperty(exports3, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
          return _index.pipelinePrimaryTopicReference;
        } }), Object.defineProperty(exports3, "PipelineTopicExpression", { enumerable: true, get: function() {
          return _index.pipelineTopicExpression;
        } }), Object.defineProperty(exports3, "Placeholder", { enumerable: true, get: function() {
          return _index.placeholder;
        } }), Object.defineProperty(exports3, "PrivateName", { enumerable: true, get: function() {
          return _index.privateName;
        } }), Object.defineProperty(exports3, "Program", { enumerable: true, get: function() {
          return _index.program;
        } }), Object.defineProperty(exports3, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
          return _index.qualifiedTypeIdentifier;
        } }), Object.defineProperty(exports3, "RecordExpression", { enumerable: true, get: function() {
          return _index.recordExpression;
        } }), Object.defineProperty(exports3, "RegExpLiteral", { enumerable: true, get: function() {
          return _index.regExpLiteral;
        } }), Object.defineProperty(exports3, "RegexLiteral", { enumerable: true, get: function() {
          return _index.regexLiteral;
        } }), Object.defineProperty(exports3, "RestElement", { enumerable: true, get: function() {
          return _index.restElement;
        } }), Object.defineProperty(exports3, "RestProperty", { enumerable: true, get: function() {
          return _index.restProperty;
        } }), Object.defineProperty(exports3, "ReturnStatement", { enumerable: true, get: function() {
          return _index.returnStatement;
        } }), Object.defineProperty(exports3, "SequenceExpression", { enumerable: true, get: function() {
          return _index.sequenceExpression;
        } }), Object.defineProperty(exports3, "SpreadElement", { enumerable: true, get: function() {
          return _index.spreadElement;
        } }), Object.defineProperty(exports3, "SpreadProperty", { enumerable: true, get: function() {
          return _index.spreadProperty;
        } }), Object.defineProperty(exports3, "StaticBlock", { enumerable: true, get: function() {
          return _index.staticBlock;
        } }), Object.defineProperty(exports3, "StringLiteral", { enumerable: true, get: function() {
          return _index.stringLiteral;
        } }), Object.defineProperty(exports3, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.stringLiteralTypeAnnotation;
        } }), Object.defineProperty(exports3, "StringTypeAnnotation", { enumerable: true, get: function() {
          return _index.stringTypeAnnotation;
        } }), Object.defineProperty(exports3, "Super", { enumerable: true, get: function() {
          return _index.super;
        } }), Object.defineProperty(exports3, "SwitchCase", { enumerable: true, get: function() {
          return _index.switchCase;
        } }), Object.defineProperty(exports3, "SwitchStatement", { enumerable: true, get: function() {
          return _index.switchStatement;
        } }), Object.defineProperty(exports3, "SymbolTypeAnnotation", { enumerable: true, get: function() {
          return _index.symbolTypeAnnotation;
        } }), Object.defineProperty(exports3, "TSAnyKeyword", { enumerable: true, get: function() {
          return _index.tsAnyKeyword;
        } }), Object.defineProperty(exports3, "TSArrayType", { enumerable: true, get: function() {
          return _index.tsArrayType;
        } }), Object.defineProperty(exports3, "TSAsExpression", { enumerable: true, get: function() {
          return _index.tsAsExpression;
        } }), Object.defineProperty(exports3, "TSBigIntKeyword", { enumerable: true, get: function() {
          return _index.tsBigIntKeyword;
        } }), Object.defineProperty(exports3, "TSBooleanKeyword", { enumerable: true, get: function() {
          return _index.tsBooleanKeyword;
        } }), Object.defineProperty(exports3, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
          return _index.tsCallSignatureDeclaration;
        } }), Object.defineProperty(exports3, "TSConditionalType", { enumerable: true, get: function() {
          return _index.tsConditionalType;
        } }), Object.defineProperty(exports3, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
          return _index.tsConstructSignatureDeclaration;
        } }), Object.defineProperty(exports3, "TSConstructorType", { enumerable: true, get: function() {
          return _index.tsConstructorType;
        } }), Object.defineProperty(exports3, "TSDeclareFunction", { enumerable: true, get: function() {
          return _index.tsDeclareFunction;
        } }), Object.defineProperty(exports3, "TSDeclareMethod", { enumerable: true, get: function() {
          return _index.tsDeclareMethod;
        } }), Object.defineProperty(exports3, "TSEnumDeclaration", { enumerable: true, get: function() {
          return _index.tsEnumDeclaration;
        } }), Object.defineProperty(exports3, "TSEnumMember", { enumerable: true, get: function() {
          return _index.tsEnumMember;
        } }), Object.defineProperty(exports3, "TSExportAssignment", { enumerable: true, get: function() {
          return _index.tsExportAssignment;
        } }), Object.defineProperty(exports3, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
          return _index.tsExpressionWithTypeArguments;
        } }), Object.defineProperty(exports3, "TSExternalModuleReference", { enumerable: true, get: function() {
          return _index.tsExternalModuleReference;
        } }), Object.defineProperty(exports3, "TSFunctionType", { enumerable: true, get: function() {
          return _index.tsFunctionType;
        } }), Object.defineProperty(exports3, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
          return _index.tsImportEqualsDeclaration;
        } }), Object.defineProperty(exports3, "TSImportType", { enumerable: true, get: function() {
          return _index.tsImportType;
        } }), Object.defineProperty(exports3, "TSIndexSignature", { enumerable: true, get: function() {
          return _index.tsIndexSignature;
        } }), Object.defineProperty(exports3, "TSIndexedAccessType", { enumerable: true, get: function() {
          return _index.tsIndexedAccessType;
        } }), Object.defineProperty(exports3, "TSInferType", { enumerable: true, get: function() {
          return _index.tsInferType;
        } }), Object.defineProperty(exports3, "TSInstantiationExpression", { enumerable: true, get: function() {
          return _index.tsInstantiationExpression;
        } }), Object.defineProperty(exports3, "TSInterfaceBody", { enumerable: true, get: function() {
          return _index.tsInterfaceBody;
        } }), Object.defineProperty(exports3, "TSInterfaceDeclaration", { enumerable: true, get: function() {
          return _index.tsInterfaceDeclaration;
        } }), Object.defineProperty(exports3, "TSIntersectionType", { enumerable: true, get: function() {
          return _index.tsIntersectionType;
        } }), Object.defineProperty(exports3, "TSIntrinsicKeyword", { enumerable: true, get: function() {
          return _index.tsIntrinsicKeyword;
        } }), Object.defineProperty(exports3, "TSLiteralType", { enumerable: true, get: function() {
          return _index.tsLiteralType;
        } }), Object.defineProperty(exports3, "TSMappedType", { enumerable: true, get: function() {
          return _index.tsMappedType;
        } }), Object.defineProperty(exports3, "TSMethodSignature", { enumerable: true, get: function() {
          return _index.tsMethodSignature;
        } }), Object.defineProperty(exports3, "TSModuleBlock", { enumerable: true, get: function() {
          return _index.tsModuleBlock;
        } }), Object.defineProperty(exports3, "TSModuleDeclaration", { enumerable: true, get: function() {
          return _index.tsModuleDeclaration;
        } }), Object.defineProperty(exports3, "TSNamedTupleMember", { enumerable: true, get: function() {
          return _index.tsNamedTupleMember;
        } }), Object.defineProperty(exports3, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
          return _index.tsNamespaceExportDeclaration;
        } }), Object.defineProperty(exports3, "TSNeverKeyword", { enumerable: true, get: function() {
          return _index.tsNeverKeyword;
        } }), Object.defineProperty(exports3, "TSNonNullExpression", { enumerable: true, get: function() {
          return _index.tsNonNullExpression;
        } }), Object.defineProperty(exports3, "TSNullKeyword", { enumerable: true, get: function() {
          return _index.tsNullKeyword;
        } }), Object.defineProperty(exports3, "TSNumberKeyword", { enumerable: true, get: function() {
          return _index.tsNumberKeyword;
        } }), Object.defineProperty(exports3, "TSObjectKeyword", { enumerable: true, get: function() {
          return _index.tsObjectKeyword;
        } }), Object.defineProperty(exports3, "TSOptionalType", { enumerable: true, get: function() {
          return _index.tsOptionalType;
        } }), Object.defineProperty(exports3, "TSParameterProperty", { enumerable: true, get: function() {
          return _index.tsParameterProperty;
        } }), Object.defineProperty(exports3, "TSParenthesizedType", { enumerable: true, get: function() {
          return _index.tsParenthesizedType;
        } }), Object.defineProperty(exports3, "TSPropertySignature", { enumerable: true, get: function() {
          return _index.tsPropertySignature;
        } }), Object.defineProperty(exports3, "TSQualifiedName", { enumerable: true, get: function() {
          return _index.tsQualifiedName;
        } }), Object.defineProperty(exports3, "TSRestType", { enumerable: true, get: function() {
          return _index.tsRestType;
        } }), Object.defineProperty(exports3, "TSSatisfiesExpression", { enumerable: true, get: function() {
          return _index.tsSatisfiesExpression;
        } }), Object.defineProperty(exports3, "TSStringKeyword", { enumerable: true, get: function() {
          return _index.tsStringKeyword;
        } }), Object.defineProperty(exports3, "TSSymbolKeyword", { enumerable: true, get: function() {
          return _index.tsSymbolKeyword;
        } }), Object.defineProperty(exports3, "TSThisType", { enumerable: true, get: function() {
          return _index.tsThisType;
        } }), Object.defineProperty(exports3, "TSTupleType", { enumerable: true, get: function() {
          return _index.tsTupleType;
        } }), Object.defineProperty(exports3, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
          return _index.tsTypeAliasDeclaration;
        } }), Object.defineProperty(exports3, "TSTypeAnnotation", { enumerable: true, get: function() {
          return _index.tsTypeAnnotation;
        } }), Object.defineProperty(exports3, "TSTypeAssertion", { enumerable: true, get: function() {
          return _index.tsTypeAssertion;
        } }), Object.defineProperty(exports3, "TSTypeLiteral", { enumerable: true, get: function() {
          return _index.tsTypeLiteral;
        } }), Object.defineProperty(exports3, "TSTypeOperator", { enumerable: true, get: function() {
          return _index.tsTypeOperator;
        } }), Object.defineProperty(exports3, "TSTypeParameter", { enumerable: true, get: function() {
          return _index.tsTypeParameter;
        } }), Object.defineProperty(exports3, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
          return _index.tsTypeParameterDeclaration;
        } }), Object.defineProperty(exports3, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
          return _index.tsTypeParameterInstantiation;
        } }), Object.defineProperty(exports3, "TSTypePredicate", { enumerable: true, get: function() {
          return _index.tsTypePredicate;
        } }), Object.defineProperty(exports3, "TSTypeQuery", { enumerable: true, get: function() {
          return _index.tsTypeQuery;
        } }), Object.defineProperty(exports3, "TSTypeReference", { enumerable: true, get: function() {
          return _index.tsTypeReference;
        } }), Object.defineProperty(exports3, "TSUndefinedKeyword", { enumerable: true, get: function() {
          return _index.tsUndefinedKeyword;
        } }), Object.defineProperty(exports3, "TSUnionType", { enumerable: true, get: function() {
          return _index.tsUnionType;
        } }), Object.defineProperty(exports3, "TSUnknownKeyword", { enumerable: true, get: function() {
          return _index.tsUnknownKeyword;
        } }), Object.defineProperty(exports3, "TSVoidKeyword", { enumerable: true, get: function() {
          return _index.tsVoidKeyword;
        } }), Object.defineProperty(exports3, "TaggedTemplateExpression", { enumerable: true, get: function() {
          return _index.taggedTemplateExpression;
        } }), Object.defineProperty(exports3, "TemplateElement", { enumerable: true, get: function() {
          return _index.templateElement;
        } }), Object.defineProperty(exports3, "TemplateLiteral", { enumerable: true, get: function() {
          return _index.templateLiteral;
        } }), Object.defineProperty(exports3, "ThisExpression", { enumerable: true, get: function() {
          return _index.thisExpression;
        } }), Object.defineProperty(exports3, "ThisTypeAnnotation", { enumerable: true, get: function() {
          return _index.thisTypeAnnotation;
        } }), Object.defineProperty(exports3, "ThrowStatement", { enumerable: true, get: function() {
          return _index.throwStatement;
        } }), Object.defineProperty(exports3, "TopicReference", { enumerable: true, get: function() {
          return _index.topicReference;
        } }), Object.defineProperty(exports3, "TryStatement", { enumerable: true, get: function() {
          return _index.tryStatement;
        } }), Object.defineProperty(exports3, "TupleExpression", { enumerable: true, get: function() {
          return _index.tupleExpression;
        } }), Object.defineProperty(exports3, "TupleTypeAnnotation", { enumerable: true, get: function() {
          return _index.tupleTypeAnnotation;
        } }), Object.defineProperty(exports3, "TypeAlias", { enumerable: true, get: function() {
          return _index.typeAlias;
        } }), Object.defineProperty(exports3, "TypeAnnotation", { enumerable: true, get: function() {
          return _index.typeAnnotation;
        } }), Object.defineProperty(exports3, "TypeCastExpression", { enumerable: true, get: function() {
          return _index.typeCastExpression;
        } }), Object.defineProperty(exports3, "TypeParameter", { enumerable: true, get: function() {
          return _index.typeParameter;
        } }), Object.defineProperty(exports3, "TypeParameterDeclaration", { enumerable: true, get: function() {
          return _index.typeParameterDeclaration;
        } }), Object.defineProperty(exports3, "TypeParameterInstantiation", { enumerable: true, get: function() {
          return _index.typeParameterInstantiation;
        } }), Object.defineProperty(exports3, "TypeofTypeAnnotation", { enumerable: true, get: function() {
          return _index.typeofTypeAnnotation;
        } }), Object.defineProperty(exports3, "UnaryExpression", { enumerable: true, get: function() {
          return _index.unaryExpression;
        } }), Object.defineProperty(exports3, "UnionTypeAnnotation", { enumerable: true, get: function() {
          return _index.unionTypeAnnotation;
        } }), Object.defineProperty(exports3, "UpdateExpression", { enumerable: true, get: function() {
          return _index.updateExpression;
        } }), Object.defineProperty(exports3, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
          return _index.v8IntrinsicIdentifier;
        } }), Object.defineProperty(exports3, "VariableDeclaration", { enumerable: true, get: function() {
          return _index.variableDeclaration;
        } }), Object.defineProperty(exports3, "VariableDeclarator", { enumerable: true, get: function() {
          return _index.variableDeclarator;
        } }), Object.defineProperty(exports3, "Variance", { enumerable: true, get: function() {
          return _index.variance;
        } }), Object.defineProperty(exports3, "VoidTypeAnnotation", { enumerable: true, get: function() {
          return _index.voidTypeAnnotation;
        } }), Object.defineProperty(exports3, "WhileStatement", { enumerable: true, get: function() {
          return _index.whileStatement;
        } }), Object.defineProperty(exports3, "WithStatement", { enumerable: true, get: function() {
          return _index.withStatement;
        } }), Object.defineProperty(exports3, "YieldExpression", { enumerable: true, get: function() {
          return _index.yieldExpression;
        } });
        var _index = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/react/buildChildren.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          const elements = [];
          for (let i = 0; i < node.children.length; i++) {
            let child = node.children[i];
            (0, _generated.isJSXText)(child) ? (0, _cleanJSXElementLiteralChild.default)(child, elements) : ((0, _generated.isJSXExpressionContainer)(child) && (child = child.expression), (0, _generated.isJSXEmptyExpression)(child) || elements.push(child));
          }
          return elements;
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _cleanJSXElementLiteralChild = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(typeAnnotations) {
          const types2 = typeAnnotations.map((type) => (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type), flattened = (0, _removeTypeDuplicates.default)(types2);
          return 1 === flattened.length ? flattened[0] : (0, _generated.tsUnionType)(flattened);
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _removeTypeDuplicates = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"), _index = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/validateNode.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          const keys2 = _.BUILDER_KEYS[node.type];
          for (const key of keys2)
            (0, _validate.default)(node, key, node[key]);
          return node;
        };
        var _validate = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/validate.js"), _ = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/clone.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return (0, _cloneNode.default)(node, false);
        };
        var _cloneNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneDeep.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return (0, _cloneNode.default)(node);
        };
        var _cloneNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return (0, _cloneNode.default)(node, true, true);
        };
        var _cloneNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, deep = true, withoutLoc = false) {
          return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
        };
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js"), _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
        const has = Function.call.bind(Object.prototype.hasOwnProperty);
        function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
          return obj && "string" == typeof obj.type ? cloneNodeInternal(obj, deep, withoutLoc, commentsCache) : obj;
        }
        function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
          return Array.isArray(obj) ? obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache)) : cloneIfNode(obj, deep, withoutLoc, commentsCache);
        }
        function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
          if (!node)
            return node;
          const { type } = node, newNode = { type: node.type };
          if ((0, _generated.isIdentifier)(node))
            newNode.name = node.name, has(node, "optional") && "boolean" == typeof node.optional && (newNode.optional = node.optional), has(node, "typeAnnotation") && (newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation);
          else {
            if (!has(_definitions.NODE_FIELDS, type))
              throw new Error(`Unknown node type: "${type}"`);
            for (const field of Object.keys(_definitions.NODE_FIELDS[type]))
              has(node, field) && (newNode[field] = deep ? (0, _generated.isFile)(node) && "comments" === field ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache) : node[field]);
          }
          return has(node, "loc") && (newNode.loc = withoutLoc ? null : node.loc), has(node, "leadingComments") && (newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache)), has(node, "innerComments") && (newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache)), has(node, "trailingComments") && (newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache)), has(node, "extra") && (newNode.extra = Object.assign({}, node.extra)), newNode;
        }
        function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
          return comments && deep ? comments.map((comment) => {
            const cache = commentsCache.get(comment);
            if (cache)
              return cache;
            const { type, value: value2, loc } = comment, ret = { type, value: value2, loc };
            return withoutLoc && (ret.loc = null), commentsCache.set(comment, ret), ret;
          }) : comments;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return (0, _cloneNode.default)(node, false, true);
        };
        var _cloneNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/addComment.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, type, content, line) {
          return (0, _addComments.default)(node, type, [{ type: line ? "CommentLine" : "CommentBlock", value: content }]);
        };
        var _addComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/addComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/addComments.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, type, comments) {
          if (!comments || !node)
            return node;
          const key = `${type}Comments`;
          node[key] ? "leading" === type ? node[key] = comments.concat(node[key]) : node[key].push(...comments) : node[key] = comments;
          return node;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritInnerComments.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(child, parent) {
          (0, _inherit.default)("innerComments", child, parent);
        };
        var _inherit = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritLeadingComments.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(child, parent) {
          (0, _inherit.default)("leadingComments", child, parent);
        };
        var _inherit = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritTrailingComments.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(child, parent) {
          (0, _inherit.default)("trailingComments", child, parent);
        };
        var _inherit = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritsComments.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(child, parent) {
          return (0, _inheritTrailingComments.default)(child, parent), (0, _inheritLeadingComments.default)(child, parent), (0, _inheritInnerComments.default)(child, parent), child;
        };
        var _inheritTrailingComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), _inheritLeadingComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), _inheritInnerComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritInnerComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/removeComments.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return _constants.COMMENT_KEYS.forEach((key) => {
            node[key] = null;
          }), node;
        };
        var _constants = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/generated/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.WHILE_TYPES = exports3.USERWHITESPACABLE_TYPES = exports3.UNARYLIKE_TYPES = exports3.TYPESCRIPT_TYPES = exports3.TSTYPE_TYPES = exports3.TSTYPEELEMENT_TYPES = exports3.TSENTITYNAME_TYPES = exports3.TSBASETYPE_TYPES = exports3.TERMINATORLESS_TYPES = exports3.STATEMENT_TYPES = exports3.STANDARDIZED_TYPES = exports3.SCOPABLE_TYPES = exports3.PUREISH_TYPES = exports3.PROPERTY_TYPES = exports3.PRIVATE_TYPES = exports3.PATTERN_TYPES = exports3.PATTERNLIKE_TYPES = exports3.OBJECTMEMBER_TYPES = exports3.MODULESPECIFIER_TYPES = exports3.MODULEDECLARATION_TYPES = exports3.MISCELLANEOUS_TYPES = exports3.METHOD_TYPES = exports3.LVAL_TYPES = exports3.LOOP_TYPES = exports3.LITERAL_TYPES = exports3.JSX_TYPES = exports3.IMPORTOREXPORTDECLARATION_TYPES = exports3.IMMUTABLE_TYPES = exports3.FUNCTION_TYPES = exports3.FUNCTIONPARENT_TYPES = exports3.FOR_TYPES = exports3.FORXSTATEMENT_TYPES = exports3.FLOW_TYPES = exports3.FLOWTYPE_TYPES = exports3.FLOWPREDICATE_TYPES = exports3.FLOWDECLARATION_TYPES = exports3.FLOWBASEANNOTATION_TYPES = exports3.EXPRESSION_TYPES = exports3.EXPRESSIONWRAPPER_TYPES = exports3.EXPORTDECLARATION_TYPES = exports3.ENUMMEMBER_TYPES = exports3.ENUMBODY_TYPES = exports3.DECLARATION_TYPES = exports3.CONDITIONAL_TYPES = exports3.COMPLETIONSTATEMENT_TYPES = exports3.CLASS_TYPES = exports3.BLOCK_TYPES = exports3.BLOCKPARENT_TYPES = exports3.BINARY_TYPES = exports3.ACCESSOR_TYPES = void 0;
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
        const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Standardized;
        exports3.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
        const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Expression;
        exports3.EXPRESSION_TYPES = EXPRESSION_TYPES;
        const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Binary;
        exports3.BINARY_TYPES = BINARY_TYPES;
        const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Scopable;
        exports3.SCOPABLE_TYPES = SCOPABLE_TYPES;
        const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.BlockParent;
        exports3.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
        const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Block;
        exports3.BLOCK_TYPES = BLOCK_TYPES;
        const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Statement;
        exports3.STATEMENT_TYPES = STATEMENT_TYPES;
        const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Terminatorless;
        exports3.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
        const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.CompletionStatement;
        exports3.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
        const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Conditional;
        exports3.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
        const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Loop;
        exports3.LOOP_TYPES = LOOP_TYPES;
        const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.While;
        exports3.WHILE_TYPES = WHILE_TYPES;
        const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
        exports3.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
        const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS.For;
        exports3.FOR_TYPES = FOR_TYPES;
        const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ForXStatement;
        exports3.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
        const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Function;
        exports3.FUNCTION_TYPES = FUNCTION_TYPES;
        const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FunctionParent;
        exports3.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
        const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pureish;
        exports3.PUREISH_TYPES = PUREISH_TYPES;
        const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Declaration;
        exports3.DECLARATION_TYPES = DECLARATION_TYPES;
        const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.PatternLike;
        exports3.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
        const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.LVal;
        exports3.LVAL_TYPES = LVAL_TYPES;
        const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSEntityName;
        exports3.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
        const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Literal;
        exports3.LITERAL_TYPES = LITERAL_TYPES;
        const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Immutable;
        exports3.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
        const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UserWhitespacable;
        exports3.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
        const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Method;
        exports3.METHOD_TYPES = METHOD_TYPES;
        const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ObjectMember;
        exports3.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
        const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Property;
        exports3.PROPERTY_TYPES = PROPERTY_TYPES;
        const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UnaryLike;
        exports3.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
        const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pattern;
        exports3.PATTERN_TYPES = PATTERN_TYPES;
        const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Class;
        exports3.CLASS_TYPES = CLASS_TYPES;
        const IMPORTOREXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
        exports3.IMPORTOREXPORTDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
        const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExportDeclaration;
        exports3.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
        const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
        exports3.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
        const ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Accessor;
        exports3.ACCESSOR_TYPES = ACCESSOR_TYPES;
        const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Private;
        exports3.PRIVATE_TYPES = PRIVATE_TYPES;
        const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Flow;
        exports3.FLOW_TYPES = FLOW_TYPES;
        const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowType;
        exports3.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
        const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
        exports3.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
        const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowDeclaration;
        exports3.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
        const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowPredicate;
        exports3.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
        const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumBody;
        exports3.ENUMBODY_TYPES = ENUMBODY_TYPES;
        const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumMember;
        exports3.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
        const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS.JSX;
        exports3.JSX_TYPES = JSX_TYPES;
        const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Miscellaneous;
        exports3.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
        const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TypeScript;
        exports3.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
        const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSTypeElement;
        exports3.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
        const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSType;
        exports3.TSTYPE_TYPES = TSTYPE_TYPES;
        const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSBaseType;
        exports3.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
        const MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
        exports3.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.UPDATE_OPERATORS = exports3.UNARY_OPERATORS = exports3.STRING_UNARY_OPERATORS = exports3.STATEMENT_OR_BLOCK_KEYS = exports3.NUMBER_UNARY_OPERATORS = exports3.NUMBER_BINARY_OPERATORS = exports3.NOT_LOCAL_BINDING = exports3.LOGICAL_OPERATORS = exports3.INHERIT_KEYS = exports3.FOR_INIT_KEYS = exports3.FLATTENABLE_KEYS = exports3.EQUALITY_BINARY_OPERATORS = exports3.COMPARISON_BINARY_OPERATORS = exports3.COMMENT_KEYS = exports3.BOOLEAN_UNARY_OPERATORS = exports3.BOOLEAN_NUMBER_BINARY_OPERATORS = exports3.BOOLEAN_BINARY_OPERATORS = exports3.BLOCK_SCOPED_SYMBOL = exports3.BINARY_OPERATORS = exports3.ASSIGNMENT_OPERATORS = void 0;
        exports3.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
        exports3.FLATTENABLE_KEYS = ["body", "expressions"];
        exports3.FOR_INIT_KEYS = ["left", "init"];
        exports3.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const LOGICAL_OPERATORS = ["||", "&&", "??"];
        exports3.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
        exports3.UPDATE_OPERATORS = ["++", "--"];
        const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
        exports3.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
        const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
        exports3.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
        const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
        exports3.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
        const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
        exports3.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
        const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
        exports3.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
        const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
        exports3.BINARY_OPERATORS = BINARY_OPERATORS;
        const ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
        exports3.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
        const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
        exports3.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
        const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
        exports3.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
        const STRING_UNARY_OPERATORS = ["typeof"];
        exports3.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
        const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
        exports3.UNARY_OPERATORS = UNARY_OPERATORS;
        exports3.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] };
        const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
        exports3.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
        const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
        exports3.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/ensureBlock.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, key = "body") {
          const result = (0, _toBlock.default)(node[key], node);
          return node[key] = result, result;
        };
        var _toBlock = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toBlock.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function gatherSequenceExpressions(nodes, scope, declars) {
          const exprs = [];
          let ensureLastUndefined = true;
          for (const node of nodes)
            if ((0, _generated.isEmptyStatement)(node) || (ensureLastUndefined = false), (0, _generated.isExpression)(node))
              exprs.push(node);
            else if ((0, _generated.isExpressionStatement)(node))
              exprs.push(node.expression);
            else if ((0, _generated.isVariableDeclaration)(node)) {
              if ("var" !== node.kind)
                return;
              for (const declar of node.declarations) {
                const bindings = (0, _getBindingIdentifiers.default)(declar);
                for (const key of Object.keys(bindings))
                  declars.push({ kind: node.kind, id: (0, _cloneNode.default)(bindings[key]) });
                declar.init && exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
              }
              ensureLastUndefined = true;
            } else if ((0, _generated.isIfStatement)(node)) {
              const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode(), alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
              if (!consequent || !alternate)
                return;
              exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
            } else if ((0, _generated.isBlockStatement)(node)) {
              const body = gatherSequenceExpressions(node.body, scope, declars);
              if (!body)
                return;
              exprs.push(body);
            } else {
              if (!(0, _generated.isEmptyStatement)(node))
                return;
              0 === nodes.indexOf(node) && (ensureLastUndefined = true);
            }
          ensureLastUndefined && exprs.push(scope.buildUndefinedNode());
          return 1 === exprs.length ? exprs[0] : (0, _generated2.sequenceExpression)(exprs);
        };
        var _getBindingIdentifiers = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _cloneNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(name) {
          "eval" !== (name = (0, _toIdentifier.default)(name)) && "arguments" !== name || (name = "_" + name);
          return name;
        };
        var _toIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toIdentifier.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toBlock.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, parent) {
          if ((0, _generated.isBlockStatement)(node))
            return node;
          let blockNodes = [];
          (0, _generated.isEmptyStatement)(node) ? blockNodes = [] : ((0, _generated.isStatement)(node) || (node = (0, _generated.isFunction)(parent) ? (0, _generated2.returnStatement)(node) : (0, _generated2.expressionStatement)(node)), blockNodes = [node]);
          return (0, _generated2.blockStatement)(blockNodes);
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toComputedKey.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, key = node.key || node.property) {
          !node.computed && (0, _generated.isIdentifier)(key) && (key = (0, _generated2.stringLiteral)(key.name));
          return key;
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toExpression.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _default = function(node) {
          (0, _generated.isExpressionStatement)(node) && (node = node.expression);
          if ((0, _generated.isExpression)(node))
            return node;
          (0, _generated.isClass)(node) ? node.type = "ClassExpression" : (0, _generated.isFunction)(node) && (node.type = "FunctionExpression");
          if (!(0, _generated.isExpression)(node))
            throw new Error(`cannot turn ${node.type} to an expression`);
          return node;
        };
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toIdentifier.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(input) {
          input += "";
          let name = "";
          for (const c of input)
            name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
          name = name.replace(/^[-0-9]+/, ""), name = name.replace(/[-\s]+(.)?/g, function(match, c) {
            return c ? c.toUpperCase() : "";
          }), (0, _isValidIdentifier.default)(name) || (name = `_${name}`);
          return name || "_";
        };
        var _isValidIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _helperValidatorIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toKeyAlias.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = toKeyAlias;
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _cloneNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js"), _removePropertiesDeep = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");
        function toKeyAlias(node, key = node.key) {
          let alias;
          return "method" === node.kind ? toKeyAlias.increment() + "" : (alias = (0, _generated.isIdentifier)(key) ? key.name : (0, _generated.isStringLiteral)(key) ? JSON.stringify(key.value) : JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))), node.computed && (alias = `[${alias}]`), node.static && (alias = `static:${alias}`), alias);
        }
        toKeyAlias.uid = 0, toKeyAlias.increment = function() {
          return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toSequenceExpression.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(nodes, scope) {
          if (null == nodes || !nodes.length)
            return;
          const declars = [], result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
          if (!result)
            return;
          for (const declar of declars)
            scope.push(declar);
          return result;
        };
        var _gatherSequenceExpressions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toStatement.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _default = function(node, ignore2) {
          if ((0, _generated.isStatement)(node))
            return node;
          let newType, mustHaveId = false;
          if ((0, _generated.isClass)(node))
            mustHaveId = true, newType = "ClassDeclaration";
          else if ((0, _generated.isFunction)(node))
            mustHaveId = true, newType = "FunctionDeclaration";
          else if ((0, _generated.isAssignmentExpression)(node))
            return (0, _generated2.expressionStatement)(node);
          mustHaveId && !node.id && (newType = false);
          if (!newType) {
            if (ignore2)
              return false;
            throw new Error(`cannot turn ${node.type} to a statement`);
          }
          return node.type = newType, node;
        };
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/valueToNode.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _isValidIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _default = function valueToNode(value2) {
          if (void 0 === value2)
            return (0, _generated.identifier)("undefined");
          if (true === value2 || false === value2)
            return (0, _generated.booleanLiteral)(value2);
          if (null === value2)
            return (0, _generated.nullLiteral)();
          if ("string" == typeof value2)
            return (0, _generated.stringLiteral)(value2);
          if ("number" == typeof value2) {
            let result;
            if (Number.isFinite(value2))
              result = (0, _generated.numericLiteral)(Math.abs(value2));
            else {
              let numerator;
              numerator = Number.isNaN(value2) ? (0, _generated.numericLiteral)(0) : (0, _generated.numericLiteral)(1), result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
            }
            return (value2 < 0 || Object.is(value2, -0)) && (result = (0, _generated.unaryExpression)("-", result)), result;
          }
          if (function(value3) {
            return "[object RegExp]" === objectToString2(value3);
          }(value2)) {
            const pattern = value2.source, flags = value2.toString().match(/\/([a-z]+|)$/)[1];
            return (0, _generated.regExpLiteral)(pattern, flags);
          }
          if (Array.isArray(value2))
            return (0, _generated.arrayExpression)(value2.map(valueToNode));
          if (function(value3) {
            if ("object" != typeof value3 || null === value3 || "[object Object]" !== Object.prototype.toString.call(value3))
              return false;
            const proto = Object.getPrototypeOf(value3);
            return null === proto || null === Object.getPrototypeOf(proto);
          }(value2)) {
            const props = [];
            for (const key of Object.keys(value2)) {
              let nodeKey;
              nodeKey = (0, _isValidIdentifier.default)(key) ? (0, _generated.identifier)(key) : (0, _generated.stringLiteral)(key), props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value2[key])));
            }
            return (0, _generated.objectExpression)(props);
          }
          throw new Error("don't know how to turn this value into a node");
        };
        exports3.default = _default;
        const objectToString2 = Function.call.bind(Object.prototype.toString);
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/core.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.patternLikeCommon = exports3.functionTypeAnnotationCommon = exports3.functionDeclarationCommon = exports3.functionCommon = exports3.classMethodOrPropertyCommon = exports3.classMethodOrDeclareMethodCommon = void 0;
        var _is = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/is.js"), _isValidIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _helperValidatorIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/index.js"), _helperStringParser = __webpack_require__2("./node_modules/.pnpm/@babel+helper-string-parser@7.22.5/node_modules/@babel/helper-string-parser/lib/index.js"), _constants = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js"), _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js");
        const defineType = (0, _utils.defineAliasedType)("Standardized");
        defineType("ArrayExpression", { fields: { elements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] }), defineType("AssignmentExpression", { fields: { operator: { validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, _utils.assertValueType)("string");
          const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS), pattern = (0, _utils.assertOneOf)("=");
          return function(node, key, val) {
            ((0, _is.default)("Pattern", node.left) ? pattern : identifier)(node, key, val);
          };
        }() }, left: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, _utils.assertNodeType)("LVal") }, right: { validate: (0, _utils.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), defineType("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS) }, left: { validate: function() {
          const expression = (0, _utils.assertNodeType)("Expression"), inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(node, key, val) {
            ("in" === node.operator ? inOp : expression)(node, key, val);
          }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
        }() }, right: { validate: (0, _utils.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), defineType("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } } }), defineType("Directive", { visitor: ["value"], fields: { value: { validate: (0, _utils.assertNodeType)("DirectiveLiteral") } } }), defineType("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } } }), defineType("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), defineType("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), defineType("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, _utils.assertOneOf)(true, false), optional: true } }, { typeArguments: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), defineType("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), defineType("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, consequent: { validate: (0, _utils.assertNodeType)("Expression") }, alternate: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), defineType("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), defineType("DebuggerStatement", { aliases: ["Statement"] }), defineType("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), defineType("EmptyStatement", { aliases: ["Statement"] }), defineType("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), defineType("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, _utils.assertNodeType)("Program") }, comments: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, _utils.assertEach)(Object.assign(() => {
        }, { type: "any" })), optional: true } } }), defineType("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, _utils.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, update: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, body: { validate: (0, _utils.assertNodeType)("Statement") } } });
        const functionCommon = () => ({ params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: false }, async: { default: false } });
        exports3.functionCommon = functionCommon;
        const functionTypeAnnotationCommon = () => ({ returnType: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } });
        exports3.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
        const functionDeclarationCommon = () => Object.assign({}, functionCommon(), { declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, id: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true } });
        exports3.functionDeclarationCommon = functionDeclarationCommon, defineType("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), { body: { validate: (0, _utils.assertNodeType)("BlockStatement") }, predicate: { validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return () => {
            };
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            (0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id);
          };
        }() }), defineType("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), { id: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") }, predicate: { validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
        const patternLikeCommon = () => ({ typeAnnotation: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, optional: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } });
        exports3.patternLikeCommon = patternLikeCommon, defineType("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, patternLikeCommon(), { name: { validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, _isValidIdentifier.default)(val, false))
            throw new TypeError(`"${val}" is not a valid identifier name`);
        }, { type: "string" })) } }), validate(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const match = /\.(\w+)$/.exec(key);
          if (!match)
            return;
          const [, parentKey] = match, nonComp = { computed: false };
          if ("property" === parentKey) {
            if ((0, _is.default)("MemberExpression", parent, nonComp))
              return;
            if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
              return;
          } else if ("key" === parentKey) {
            if ((0, _is.default)("Property", parent, nonComp))
              return;
            if ((0, _is.default)("Method", parent, nonComp))
              return;
          } else if ("exported" === parentKey) {
            if ((0, _is.default)("ExportSpecifier", parent))
              return;
          } else if ("imported" === parentKey) {
            if ((0, _is.default)("ImportSpecifier", parent, { imported: node }))
              return;
          } else if ("meta" === parentKey && (0, _is.default)("MetaProperty", parent, { meta: node }))
            return;
          if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && "this" !== node.name)
            throw new TypeError(`"${node.name}" is not a valid identifier`);
        } }), defineType("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, consequent: { validate: (0, _utils.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, _utils.assertNodeType)("Identifier") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, _utils.assertValueType)("number") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, _utils.assertValueType)("string") }, flags: { validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const invalid = /[^gimsuy]/.exec(val);
          if (invalid)
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
        }, { type: "string" })), default: "" } } }), defineType("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS) }, left: { validate: (0, _utils.assertNodeType)("Expression") }, right: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("MemberExpression", { builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, _utils.assertNodeType)("Expression", "Super") }, property: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], validator;
        }() }, computed: { default: false } }, process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, _utils.assertOneOf)(true, false), optional: true } }) }), defineType("NewExpression", { inherits: "CallExpression" }), defineType("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, _utils.assertValueType)("string") }, sourceType: { validate: (0, _utils.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, _utils.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), defineType("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), defineType("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), { kind: Object.assign({ validate: (0, _utils.assertOneOf)("method", "get", "set") }, process.env.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: false }, key: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], validator;
        }() }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), defineType("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: false }, key: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), computed = (0, _utils.assertNodeType)("Expression");
          return Object.assign(function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
        }() }, value: { validate: (0, _utils.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, { type: "boolean" }), function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && !(0, _is.default)("Identifier", node.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }), default: false }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: function() {
          const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), expression = (0, _utils.assertNodeType)("Expression");
          return function(parent, key, node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            ((0, _is.default)("ObjectPattern", parent) ? pattern : expression)(node, "value", node.value);
          };
        }() }), defineType("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, patternLikeCommon(), { argument: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, _utils.assertNodeType)("LVal") } }), validate(parent, key) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const match = /(\w+)\[(\d+)\]/.exec(key);
          if (!match)
            throw new Error("Internal Babel error: malformed key.");
          const [, listKey, index2] = match;
          if (parent[listKey].length > +index2 + 1)
            throw new TypeError(`RestElement must be last element of ${listKey}`);
        } }), defineType("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression"), optional: true } } }), defineType("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), defineType("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, consequent: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } } }), defineType("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, _utils.assertNodeType)("Expression") }, cases: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase"))) } } }), defineType("ThisExpression", { aliases: ["Expression"] }), defineType("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
          if (process.env.BABEL_TYPES_8_BREAKING && !node.handler && !node.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: true, validate: (0, _utils.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, _utils.assertNodeType)("BlockStatement") } } }), defineType("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, _utils.assertNodeType)("Expression") }, operator: { validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), defineType("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression") : (0, _utils.assertNodeType)("Expression") }, operator: { validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), defineType("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, kind: { validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator"))) } }, validate(parent, key, node) {
          if (process.env.BABEL_TYPES_8_BREAKING && (0, _is.default)("ForXStatement", parent, { left: node }) && 1 !== node.declarations.length)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        } }), defineType("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, _utils.assertNodeType)("LVal");
          const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), without = (0, _utils.assertNodeType)("Identifier");
          return function(node, key, val) {
            (node.init ? normal : without)(node, key, val);
          };
        }() }, definite: { optional: true, validate: (0, _utils.assertValueType)("boolean") }, init: { optional: true, validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon(), { left: { validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, _utils.assertNodeType)("Expression") }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } }) }), defineType("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon(), { elements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) }), defineType("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), { expression: { validate: (0, _utils.assertValueType)("boolean") }, body: { validate: (0, _utils.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) }), defineType("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock"))) } } }), defineType("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, _utils.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, _utils.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, _utils.assertNodeType)("InterfaceExtends"), optional: true } } }), defineType("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, _utils.assertNodeType)("Identifier") }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, _utils.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, _utils.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, _utils.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, _utils.assertValueType)("boolean"), optional: true } }, validate: function() {
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            process.env.BABEL_TYPES_8_BREAKING && ((0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id));
          };
        }() }), defineType("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, _utils.assertNodeType)("StringLiteral") }, exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")), attributes: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) } } }), defineType("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression") }, exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value")) } }), defineType("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { optional: true, validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, { oneOfNodeTypes: ["Declaration"] }), function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.source)
            throw new TypeError("Cannot export a declaration from a source");
        }) }, attributes: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(node, key, val) {
            (node.source ? sourced : sourceless)(node, key, val);
          } : sourced;
        }())) }, source: { validate: (0, _utils.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")) } }), defineType("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") }, exported: { validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, _utils.assertOneOf)("type", "value"), optional: true } } }), defineType("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration"), lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(node, key, val) {
            (0, _is.default)("VariableDeclaration", val) ? declaration(node, key, val) : lval(node, key, val);
          };
        }() }, right: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") }, await: { default: false } } }), defineType("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: { attributes: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) }, module: { optional: true, validate: (0, _utils.assertValueType)("boolean") }, specifiers: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, _utils.assertNodeType)("StringLiteral") }, importKind: { validate: (0, _utils.assertOneOf)("type", "typeof", "value"), optional: true } } }), defineType("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") }, imported: { validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, _utils.assertOneOf)("type", "typeof", "value"), optional: true } } }), defineType("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          let property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
          }
          if (!(0, _is.default)("Identifier", node.property, { name: property }))
            throw new TypeError("Unrecognised MetaProperty");
        }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, _utils.assertNodeType)("Identifier") } } });
        const classMethodOrPropertyCommon = () => ({ abstract: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, _utils.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, key: { validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
        exports3.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
        const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), { params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } });
        exports3.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon, defineType("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), { body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }) }), defineType("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon(), { properties: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), defineType("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("Super", { aliases: ["Expression"] }), defineType("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, _utils.assertNodeType)("Expression") }, quasi: { validate: (0, _utils.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), defineType("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, _utils.chain)((0, _utils.assertShape)({ raw: { validate: (0, _utils.assertValueType)("string") }, cooked: { validate: (0, _utils.assertValueType)("string"), optional: true } }), function(node) {
          const raw = node.value.raw;
          let unterminatedCalled = false;
          const error = () => {
            throw new Error("Internal @babel/types error.");
          }, { str, firstInvalidLoc } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, { unterminated() {
            unterminatedCalled = true;
          }, strictNumericEscape: error, invalidEscapeSequence: error, numericSeparatorInEscapeSequence: error, unexpectedNumericSeparator: error, invalidDigit: error, invalidCodePoint: error });
          if (!unterminatedCalled)
            throw new Error("Invalid raw");
          node.value.cooked = firstInvalidLoc ? null : str;
        }) }, tail: { default: false } } }), defineType("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
          if (node.quasis.length !== val.length + 1)
            throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }) } } }), defineType("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && !node.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, { type: "boolean" })), default: false }, argument: { optional: true, validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("Import", { aliases: ["Expression"] }), defineType("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, _utils.assertNodeType)("Expression") }, property: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier"), computed = (0, _utils.assertNodeType)("Expression");
          return Object.assign(function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          }, { oneOfNodeTypes: ["Expression", "Identifier"] });
        }() }, computed: { default: false }, optional: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean") } } }), defineType("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, _utils.assertNodeType)("Expression") }, arguments: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean") }, typeArguments: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } }), defineType("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, classMethodOrPropertyCommon(), { value: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, variance: { validate: (0, _utils.assertNodeType)("Variance"), optional: true } }) }), defineType("ClassAccessorProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, classMethodOrPropertyCommon(), { key: { validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, variance: { validate: (0, _utils.assertNodeType)("Variance"), optional: true } }) }), defineType("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, _utils.assertNodeType)("PrivateName") }, value: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, static: { validate: (0, _utils.assertValueType)("boolean"), default: false }, readonly: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, definite: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, variance: { validate: (0, _utils.assertNodeType)("Variance"), optional: true } } }), defineType("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), { kind: { validate: (0, _utils.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, _utils.assertNodeType)("PrivateName") }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }) }), defineType("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/deprecated-aliases.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.DEPRECATED_ALIASES = void 0;
        exports3.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/experimental.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js");
        (0, _utils.default)("ArgumentPlaceholder", {}), (0, _utils.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: process.env.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, _utils.assertNodeType)("Expression") }, callee: { validate: (0, _utils.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, _utils.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, _utils.assertNodeType)("StringLiteral") } } }), (0, _utils.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } } }), (0, _utils.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, _utils.assertNodeType)("BlockStatement") }, async: { validate: (0, _utils.assertValueType)("boolean"), default: false } } }), (0, _utils.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, _utils.assertNodeType)("Identifier") } } }), (0, _utils.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, _utils.default)("TupleExpression", { fields: { elements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, _utils.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, _utils.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, _utils.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, _utils.default)("TopicReference", { aliases: ["Expression"] }), (0, _utils.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, _utils.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, _utils.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/flow.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js");
        const defineType = (0, _utils.defineAliasedType)("Flow"), defineInterfaceishType = (name) => {
          const isDeclareClass = "DeclareClass" === name;
          defineType(name, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")) }, isDeclareClass ? { mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")), implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")) } : {}, { body: (0, _utils.validateType)("ObjectTypeAnnotation") }) });
        };
        defineType("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, _utils.validateType)("FlowType") } }), defineType("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation") } }), defineInterfaceishType("DeclareClass"), defineType("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), predicate: (0, _utils.validateOptionalType)("DeclaredPredicate") } }), defineInterfaceishType("DeclareInterface"), defineType("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)(["Identifier", "StringLiteral"]), body: (0, _utils.validateType)("BlockStatement"), kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES")) } }), defineType("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, _utils.validateType)("TypeAnnotation") } }), defineType("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), right: (0, _utils.validateType)("FlowType") } }), defineType("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, _utils.validateOptionalType)("FlowType"), impltype: (0, _utils.validateOptionalType)("FlowType") } }), defineType("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier") } }), defineType("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, _utils.validateOptionalType)("Flow"), specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, _utils.validateOptionalType)("StringLiteral"), default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean")) } }), defineType("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, _utils.validateType)("StringLiteral"), exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")) } }), defineType("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, _utils.validateType)("Flow") } }), defineType("ExistsTypeAnnotation", { aliases: ["FlowType"] }), defineType("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")), rest: (0, _utils.validateOptionalType)("FunctionTypeParam"), this: (0, _utils.validateOptionalType)("FunctionTypeParam"), returnType: (0, _utils.validateType)("FlowType") } }), defineType("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, _utils.validateOptionalType)("Identifier"), typeAnnotation: (0, _utils.validateType)("FlowType"), optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean")) } }), defineType("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation") } }), defineType("InferredPredicate", { aliases: ["FlowPredicate"] }), defineType("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation") } }), defineInterfaceishType("InterfaceDeclaration"), defineType("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")), body: (0, _utils.validateType)("ObjectTypeAnnotation") } }), defineType("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, _utils.validateType)("FlowType") } }), defineType("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, _utils.validate)((0, _utils.assertValueType)("number")) } }), defineType("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: { validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"), optional: true, default: [] }, callProperties: { validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"), optional: true, default: [] }, internalSlots: { validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"), optional: true, default: [] }, exact: { validate: (0, _utils.assertValueType)("boolean"), default: false }, inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, _utils.validateType)("Identifier"), value: (0, _utils.validateType)("FlowType"), optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, _utils.validateType)("FlowType"), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, _utils.validateOptionalType)("Identifier"), key: (0, _utils.validateType)("FlowType"), value: (0, _utils.validateType)("FlowType"), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), variance: (0, _utils.validateOptionalType)("Variance") } }), defineType("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, _utils.validateType)(["Identifier", "StringLiteral"]), value: (0, _utils.validateType)("FlowType"), kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), variance: (0, _utils.validateOptionalType)("Variance"), method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, _utils.validateType)("FlowType") } }), defineType("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, _utils.validateOptionalType)("FlowType"), impltype: (0, _utils.validateType)("FlowType") } }), defineType("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, _utils.validateType)("Identifier"), qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), defineType("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, _utils.validate)((0, _utils.assertValueType)("string")) } }), defineType("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, _utils.validateType)("FlowType") } }), defineType("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), right: (0, _utils.validateType)("FlowType") } }), defineType("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("FlowType") } }), defineType("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, _utils.validateType)("Expression"), typeAnnotation: (0, _utils.validateType)("TypeAnnotation") } }), defineType("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, _utils.validate)((0, _utils.assertValueType)("string")), bound: (0, _utils.validateOptionalType)("TypeAnnotation"), default: (0, _utils.validateOptionalType)("FlowType"), variance: (0, _utils.validateOptionalType)("Variance") } }), defineType("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter")) } }), defineType("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("Variance", { builder: ["kind"], fields: { kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus")) } }), defineType("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, _utils.validateType)("Identifier"), body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), defineType("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), members: (0, _utils.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), members: (0, _utils.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, _utils.validateType)("Identifier"), init: (0, _utils.validateType)("BooleanLiteral") } }), defineType("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, _utils.validateType)("Identifier"), init: (0, _utils.validateType)("NumericLiteral") } }), defineType("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, _utils.validateType)("Identifier"), init: (0, _utils.validateType)("StringLiteral") } }), defineType("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, _utils.validateType)("Identifier") } }), defineType("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, _utils.validateType)("FlowType"), indexType: (0, _utils.validateType)("FlowType") } }), defineType("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, _utils.validateType)("FlowType"), indexType: (0, _utils.validateType)("FlowType"), optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } });
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), Object.defineProperty(exports3, "ALIAS_KEYS", { enumerable: true, get: function() {
          return _utils.ALIAS_KEYS;
        } }), Object.defineProperty(exports3, "BUILDER_KEYS", { enumerable: true, get: function() {
          return _utils.BUILDER_KEYS;
        } }), Object.defineProperty(exports3, "DEPRECATED_ALIASES", { enumerable: true, get: function() {
          return _deprecatedAliases.DEPRECATED_ALIASES;
        } }), Object.defineProperty(exports3, "DEPRECATED_KEYS", { enumerable: true, get: function() {
          return _utils.DEPRECATED_KEYS;
        } }), Object.defineProperty(exports3, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
          return _utils.FLIPPED_ALIAS_KEYS;
        } }), Object.defineProperty(exports3, "NODE_FIELDS", { enumerable: true, get: function() {
          return _utils.NODE_FIELDS;
        } }), Object.defineProperty(exports3, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
          return _utils.NODE_PARENT_VALIDATIONS;
        } }), Object.defineProperty(exports3, "PLACEHOLDERS", { enumerable: true, get: function() {
          return _placeholders.PLACEHOLDERS;
        } }), Object.defineProperty(exports3, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
          return _placeholders.PLACEHOLDERS_ALIAS;
        } }), Object.defineProperty(exports3, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
          return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
        } }), exports3.TYPES = void 0, Object.defineProperty(exports3, "VISITOR_KEYS", { enumerable: true, get: function() {
          return _utils.VISITOR_KEYS;
        } });
        var _toFastProperties = __webpack_require__2("./node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js");
        __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/core.js"), __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/flow.js"), __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/jsx.js"), __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/misc.js"), __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/experimental.js"), __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/typescript.js");
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js"), _placeholders = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/placeholders.js"), _deprecatedAliases = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/deprecated-aliases.js");
        Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
          _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
        }), _toFastProperties(_utils.VISITOR_KEYS), _toFastProperties(_utils.ALIAS_KEYS), _toFastProperties(_utils.FLIPPED_ALIAS_KEYS), _toFastProperties(_utils.NODE_FIELDS), _toFastProperties(_utils.BUILDER_KEYS), _toFastProperties(_utils.DEPRECATED_KEYS), _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS), _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
        const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
        exports3.TYPES = TYPES;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/jsx.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js");
        const defineType = (0, _utils.defineAliasedType)("JSX");
        defineType("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), defineType("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), defineType("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, _utils.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, _utils.assertNodeType)("JSXClosingElement") }, children: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } }, { selfClosing: { validate: (0, _utils.assertValueType)("boolean"), optional: true } }) }), defineType("JSXEmptyExpression", {}), defineType("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression") } } }), defineType("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, _utils.assertValueType)("string") } } }), defineType("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, _utils.assertNodeType)("JSXIdentifier") } } }), defineType("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, _utils.assertNodeType)("JSXIdentifier") }, name: { validate: (0, _utils.assertNodeType)("JSXIdentifier") } } }), defineType("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), defineType("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } } }), defineType("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, _utils.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, _utils.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), defineType("JSXOpeningFragment", { aliases: ["Immutable"] }), defineType("JSXClosingFragment", { aliases: ["Immutable"] });
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/misc.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js"), _placeholders = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/placeholders.js");
        const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
        defineType("Noop", { visitor: [] }), defineType("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, _utils.assertNodeType)("Identifier") }, expectedNode: { validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS) } } }), defineType("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, _utils.assertValueType)("string") } } });
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/placeholders.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.PLACEHOLDERS_FLIPPED_ALIAS = exports3.PLACEHOLDERS_ALIAS = exports3.PLACEHOLDERS = void 0;
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js");
        const PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
        exports3.PLACEHOLDERS = PLACEHOLDERS;
        const PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
        exports3.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
        for (const type of PLACEHOLDERS) {
          const alias = _utils.ALIAS_KEYS[type];
          null != alias && alias.length && (PLACEHOLDERS_ALIAS[type] = alias);
        }
        const PLACEHOLDERS_FLIPPED_ALIAS = {};
        exports3.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS, Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
          PLACEHOLDERS_ALIAS[type].forEach((alias) => {
            Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias) || (PLACEHOLDERS_FLIPPED_ALIAS[alias] = []), PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
          });
        });
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/typescript.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js"), _core = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/core.js"), _is = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/is.js");
        const defineType = (0, _utils.defineAliasedType)("TypeScript"), bool = (0, _utils.assertValueType)("boolean"), tSFunctionTypeAnnotationCommon = () => ({ returnType: { validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } });
        defineType("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, _utils.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } } }), defineType("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon()) }), defineType("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon()) }), defineType("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, _utils.validateType)("TSEntityName"), right: (0, _utils.validateType)("Identifier") } });
        const signatureDeclarationCommon = () => ({ typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation") }), callConstructSignatureDeclaration = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: signatureDeclarationCommon() };
        defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration), defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
        const namedTypeElementCommon = () => ({ key: (0, _utils.validateType)("Expression"), computed: { default: false }, optional: (0, _utils.validateOptional)(bool) });
        defineType("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation", "initializer"], fields: Object.assign({}, namedTypeElementCommon(), { readonly: (0, _utils.validateOptional)(bool), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"), initializer: (0, _utils.validateOptionalType)("Expression"), kind: { validate: (0, _utils.assertOneOf)("get", "set") } }) }), defineType("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), { kind: { validate: (0, _utils.assertOneOf)("method", "get", "set") } }) }), defineType("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, _utils.validateOptional)(bool), static: (0, _utils.validateOptional)(bool), parameters: (0, _utils.validateArrayOfType)("Identifier"), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation") } });
        const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const type of tsKeywordTypes)
          defineType(type, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        defineType("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        const fnOrCtrBase = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
        defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, { fields: signatureDeclarationCommon() })), defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, { fields: Object.assign({}, signatureDeclarationCommon(), { abstract: (0, _utils.validateOptional)(bool) }) })), defineType("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, _utils.validateType)("TSEntityName"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } }), defineType("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"), asserts: (0, _utils.validateOptional)(bool) } }), defineType("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } }), defineType("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, _utils.validateArrayOfType)("TSTypeElement") } }), defineType("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, _utils.validateType)("TSType") } }), defineType("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), defineType("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, _utils.validateType)("Identifier"), optional: { validate: bool, default: false }, elementType: (0, _utils.validateType)("TSType") } });
        const unionOrIntersection = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, _utils.validateArrayOfType)("TSType") } };
        defineType("TSUnionType", unionOrIntersection), defineType("TSIntersectionType", unionOrIntersection), defineType("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, _utils.validateType)("TSType"), extendsType: (0, _utils.validateType)("TSType"), trueType: (0, _utils.validateType)("TSType"), falseType: (0, _utils.validateType)("TSType") } }), defineType("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, _utils.validateType)("TSTypeParameter") } }), defineType("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, _utils.validate)((0, _utils.assertValueType)("string")), typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, _utils.validateType)("TSType"), indexType: (0, _utils.validateType)("TSType") } }), defineType("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")), typeParameter: (0, _utils.validateType)("TSTypeParameter"), optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")), typeAnnotation: (0, _utils.validateOptionalType)("TSType"), nameType: (0, _utils.validateOptionalType)("TSType") } }), defineType("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
          const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral"), unaryOperator = (0, _utils.assertOneOf)("-"), literal2 = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function validator(parent, key, node) {
            (0, _is.default)("UnaryExpression", node) ? (unaryOperator(node, "operator", node.operator), unaryExpression(node, "argument", node.argument)) : literal2(parent, key, node);
          }
          return validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], validator;
        }() } } }), defineType("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, _utils.validateType)("TSEntityName"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } }), defineType("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, _utils.validateType)("TSInterfaceBody") } }), defineType("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, _utils.validateArrayOfType)("TSTypeElement") } }), defineType("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, _utils.validateType)("Expression"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } });
        const TSTypeExpression = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, _utils.validateType)("Expression"), typeAnnotation: (0, _utils.validateType)("TSType") } };
        defineType("TSAsExpression", TSTypeExpression), defineType("TSSatisfiesExpression", TSTypeExpression), defineType("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, _utils.validateType)("TSType"), expression: (0, _utils.validateType)("Expression") } }), defineType("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, _utils.validateOptional)(bool), const: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)("Identifier"), members: (0, _utils.validateArrayOfType)("TSEnumMember"), initializer: (0, _utils.validateOptionalType)("Expression") } }), defineType("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, _utils.validateType)(["Identifier", "StringLiteral"]), initializer: (0, _utils.validateOptionalType)("Expression") } }), defineType("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, _utils.validateOptional)(bool), global: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)(["Identifier", "StringLiteral"]), body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), defineType("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, _utils.validateArrayOfType)("Statement") } }), defineType("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, _utils.validateType)("StringLiteral"), qualifier: (0, _utils.validateOptionalType)("TSEntityName"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } }), defineType("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, _utils.validate)(bool), id: (0, _utils.validateType)("Identifier"), moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, _utils.assertOneOf)("type", "value"), optional: true } } }), defineType("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, _utils.validateType)("StringLiteral") } }), defineType("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, _utils.validateType)("Expression") } }), defineType("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, _utils.validateType)("Expression") } }), defineType("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, _utils.validateType)("Identifier") } }), defineType("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, _utils.assertNodeType)("TSType") } } }), defineType("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType"))) } } }), defineType("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter"))) } } }), defineType("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, _utils.assertValueType)("string") }, in: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, out: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, const: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, constraint: { validate: (0, _utils.assertNodeType)("TSType"), optional: true }, default: { validate: (0, _utils.assertNodeType)("TSType"), optional: true } } });
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/utils.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.VISITOR_KEYS = exports3.NODE_PARENT_VALIDATIONS = exports3.NODE_FIELDS = exports3.FLIPPED_ALIAS_KEYS = exports3.DEPRECATED_KEYS = exports3.BUILDER_KEYS = exports3.ALIAS_KEYS = void 0, exports3.arrayOf = arrayOf, exports3.arrayOfType = arrayOfType, exports3.assertEach = assertEach, exports3.assertNodeOrValueType = function(...types2) {
          function validate2(node, key, val) {
            for (const type of types2)
              if (getType2(val) === type || (0, _is.default)(type, val))
                return void (0, _validate.validateChild)(node, key, val);
            throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(null == val ? void 0 : val.type)}`);
          }
          return validate2.oneOfNodeOrValueTypes = types2, validate2;
        }, exports3.assertNodeType = assertNodeType, exports3.assertOneOf = function(...values) {
          function validate2(node, key, val) {
            if (values.indexOf(val) < 0)
              throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
          }
          return validate2.oneOf = values, validate2;
        }, exports3.assertOptionalChainStart = function() {
          return function(node) {
            var _current;
            let current2 = node;
            for (; node; ) {
              const { type } = current2;
              if ("OptionalCallExpression" !== type) {
                if ("OptionalMemberExpression" !== type)
                  break;
                if (current2.optional)
                  return;
                current2 = current2.object;
              } else {
                if (current2.optional)
                  return;
                current2 = current2.callee;
              }
            }
            throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (_current = current2) ? void 0 : _current.type}`);
          };
        }, exports3.assertShape = function(shape) {
          function validate2(node, key, val) {
            const errors = [];
            for (const property of Object.keys(shape))
              try {
                (0, _validate.validateField)(node, property, val[property], shape[property]);
              } catch (error) {
                if (error instanceof TypeError) {
                  errors.push(error.message);
                  continue;
                }
                throw error;
              }
            if (errors.length)
              throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
          }
          return validate2.shapeOf = shape, validate2;
        }, exports3.assertValueType = assertValueType, exports3.chain = chain, exports3.default = defineType, exports3.defineAliasedType = function(...aliases) {
          return (type, opts = {}) => {
            let defined = opts.aliases;
            var _store$opts$inherits$;
            defined || (opts.inherits && (defined = null == (_store$opts$inherits$ = store[opts.inherits].aliases) ? void 0 : _store$opts$inherits$.slice()), null != defined || (defined = []), opts.aliases = defined);
            const additional = aliases.filter((a) => !defined.includes(a));
            defined.unshift(...additional), defineType(type, opts);
          };
        }, exports3.typeIs = typeIs, exports3.validate = validate, exports3.validateArrayOfType = function(typeName) {
          return validate(arrayOfType(typeName));
        }, exports3.validateOptional = function(validate2) {
          return { validate: validate2, optional: true };
        }, exports3.validateOptionalType = function(typeName) {
          return { validate: typeIs(typeName), optional: true };
        }, exports3.validateType = function(typeName) {
          return validate(typeIs(typeName));
        };
        var _is = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/is.js"), _validate = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/validate.js");
        const VISITOR_KEYS = {};
        exports3.VISITOR_KEYS = VISITOR_KEYS;
        const ALIAS_KEYS = {};
        exports3.ALIAS_KEYS = ALIAS_KEYS;
        const FLIPPED_ALIAS_KEYS = {};
        exports3.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
        const NODE_FIELDS = {};
        exports3.NODE_FIELDS = NODE_FIELDS;
        const BUILDER_KEYS = {};
        exports3.BUILDER_KEYS = BUILDER_KEYS;
        const DEPRECATED_KEYS = {};
        exports3.DEPRECATED_KEYS = DEPRECATED_KEYS;
        const NODE_PARENT_VALIDATIONS = {};
        function getType2(val) {
          return Array.isArray(val) ? "array" : null === val ? "null" : typeof val;
        }
        function validate(validate2) {
          return { validate: validate2 };
        }
        function typeIs(typeName) {
          return "string" == typeof typeName ? assertNodeType(typeName) : assertNodeType(...typeName);
        }
        function arrayOf(elementType) {
          return chain(assertValueType("array"), assertEach(elementType));
        }
        function arrayOfType(typeName) {
          return arrayOf(typeIs(typeName));
        }
        function assertEach(callback) {
          function validator(node, key, val) {
            if (Array.isArray(val))
              for (let i = 0; i < val.length; i++) {
                const subkey = `${key}[${i}]`, v = val[i];
                callback(node, subkey, v), process.env.BABEL_TYPES_8_BREAKING && (0, _validate.validateChild)(node, subkey, v);
              }
          }
          return validator.each = callback, validator;
        }
        function assertNodeType(...types2) {
          function validate2(node, key, val) {
            for (const type of types2)
              if ((0, _is.default)(type, val))
                return void (0, _validate.validateChild)(node, key, val);
            throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(null == val ? void 0 : val.type)}`);
          }
          return validate2.oneOfNodeTypes = types2, validate2;
        }
        function assertValueType(type) {
          function validate2(node, key, val) {
            if (!(getType2(val) === type))
              throw new TypeError(`Property ${key} expected type of ${type} but got ${getType2(val)}`);
          }
          return validate2.type = type, validate2;
        }
        function chain(...fns) {
          function validate2(...args) {
            for (const fn of fns)
              fn(...args);
          }
          if (validate2.chainOf = fns, fns.length >= 2 && "type" in fns[0] && "array" === fns[0].type && !("each" in fns[1]))
            throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
          return validate2;
        }
        exports3.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
        const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], validFieldKeys = ["default", "optional", "deprecated", "validate"], store = {};
        function defineType(type, opts = {}) {
          const inherits = opts.inherits && store[opts.inherits] || {};
          let fields = opts.fields;
          if (!fields && (fields = {}, inherits.fields)) {
            const keys2 = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys2) {
              const field = inherits.fields[key], def = field.default;
              if (Array.isArray(def) ? def.length > 0 : def && "object" == typeof def)
                throw new Error("field defaults can only be primitives or empty arrays currently");
              fields[key] = { default: Array.isArray(def) ? [] : def, optional: field.optional, deprecated: field.deprecated, validate: field.validate };
            }
          }
          const visitor = opts.visitor || inherits.visitor || [], aliases = opts.aliases || inherits.aliases || [], builder = opts.builder || inherits.builder || opts.visitor || [];
          for (const k of Object.keys(opts))
            if (-1 === validTypeOpts.indexOf(k))
              throw new Error(`Unknown type option "${k}" on ${type}`);
          opts.deprecatedAlias && (DEPRECATED_KEYS[opts.deprecatedAlias] = type);
          for (const key of visitor.concat(builder))
            fields[key] = fields[key] || {};
          for (const key of Object.keys(fields)) {
            const field = fields[key];
            void 0 !== field.default && -1 === builder.indexOf(key) && (field.optional = true), void 0 === field.default ? field.default = null : field.validate || null == field.default || (field.validate = assertValueType(getType2(field.default)));
            for (const k of Object.keys(field))
              if (-1 === validFieldKeys.indexOf(k))
                throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
          VISITOR_KEYS[type] = opts.visitor = visitor, BUILDER_KEYS[type] = opts.builder = builder, NODE_FIELDS[type] = opts.fields = fields, ALIAS_KEYS[type] = opts.aliases = aliases, aliases.forEach((alias) => {
            FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [], FLIPPED_ALIAS_KEYS[alias].push(type);
          }), opts.validate && (NODE_PARENT_VALIDATIONS[type] = opts.validate), store[type] = opts;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var _exportNames = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toSequenceExpression: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true, __internal__deprecationWarning: true };
        Object.defineProperty(exports3, "__internal__deprecationWarning", { enumerable: true, get: function() {
          return _deprecationWarning.default;
        } }), Object.defineProperty(exports3, "addComment", { enumerable: true, get: function() {
          return _addComment.default;
        } }), Object.defineProperty(exports3, "addComments", { enumerable: true, get: function() {
          return _addComments.default;
        } }), Object.defineProperty(exports3, "appendToMemberExpression", { enumerable: true, get: function() {
          return _appendToMemberExpression.default;
        } }), Object.defineProperty(exports3, "assertNode", { enumerable: true, get: function() {
          return _assertNode.default;
        } }), Object.defineProperty(exports3, "buildMatchMemberExpression", { enumerable: true, get: function() {
          return _buildMatchMemberExpression.default;
        } }), Object.defineProperty(exports3, "clone", { enumerable: true, get: function() {
          return _clone.default;
        } }), Object.defineProperty(exports3, "cloneDeep", { enumerable: true, get: function() {
          return _cloneDeep.default;
        } }), Object.defineProperty(exports3, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
          return _cloneDeepWithoutLoc.default;
        } }), Object.defineProperty(exports3, "cloneNode", { enumerable: true, get: function() {
          return _cloneNode.default;
        } }), Object.defineProperty(exports3, "cloneWithoutLoc", { enumerable: true, get: function() {
          return _cloneWithoutLoc.default;
        } }), Object.defineProperty(exports3, "createFlowUnionType", { enumerable: true, get: function() {
          return _createFlowUnionType.default;
        } }), Object.defineProperty(exports3, "createTSUnionType", { enumerable: true, get: function() {
          return _createTSUnionType.default;
        } }), Object.defineProperty(exports3, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
          return _createTypeAnnotationBasedOnTypeof.default;
        } }), Object.defineProperty(exports3, "createUnionTypeAnnotation", { enumerable: true, get: function() {
          return _createFlowUnionType.default;
        } }), Object.defineProperty(exports3, "ensureBlock", { enumerable: true, get: function() {
          return _ensureBlock.default;
        } }), Object.defineProperty(exports3, "getBindingIdentifiers", { enumerable: true, get: function() {
          return _getBindingIdentifiers.default;
        } }), Object.defineProperty(exports3, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
          return _getOuterBindingIdentifiers.default;
        } }), Object.defineProperty(exports3, "inheritInnerComments", { enumerable: true, get: function() {
          return _inheritInnerComments.default;
        } }), Object.defineProperty(exports3, "inheritLeadingComments", { enumerable: true, get: function() {
          return _inheritLeadingComments.default;
        } }), Object.defineProperty(exports3, "inheritTrailingComments", { enumerable: true, get: function() {
          return _inheritTrailingComments.default;
        } }), Object.defineProperty(exports3, "inherits", { enumerable: true, get: function() {
          return _inherits.default;
        } }), Object.defineProperty(exports3, "inheritsComments", { enumerable: true, get: function() {
          return _inheritsComments.default;
        } }), Object.defineProperty(exports3, "is", { enumerable: true, get: function() {
          return _is.default;
        } }), Object.defineProperty(exports3, "isBinding", { enumerable: true, get: function() {
          return _isBinding.default;
        } }), Object.defineProperty(exports3, "isBlockScoped", { enumerable: true, get: function() {
          return _isBlockScoped.default;
        } }), Object.defineProperty(exports3, "isImmutable", { enumerable: true, get: function() {
          return _isImmutable.default;
        } }), Object.defineProperty(exports3, "isLet", { enumerable: true, get: function() {
          return _isLet.default;
        } }), Object.defineProperty(exports3, "isNode", { enumerable: true, get: function() {
          return _isNode.default;
        } }), Object.defineProperty(exports3, "isNodesEquivalent", { enumerable: true, get: function() {
          return _isNodesEquivalent.default;
        } }), Object.defineProperty(exports3, "isPlaceholderType", { enumerable: true, get: function() {
          return _isPlaceholderType.default;
        } }), Object.defineProperty(exports3, "isReferenced", { enumerable: true, get: function() {
          return _isReferenced.default;
        } }), Object.defineProperty(exports3, "isScope", { enumerable: true, get: function() {
          return _isScope.default;
        } }), Object.defineProperty(exports3, "isSpecifierDefault", { enumerable: true, get: function() {
          return _isSpecifierDefault.default;
        } }), Object.defineProperty(exports3, "isType", { enumerable: true, get: function() {
          return _isType.default;
        } }), Object.defineProperty(exports3, "isValidES3Identifier", { enumerable: true, get: function() {
          return _isValidES3Identifier.default;
        } }), Object.defineProperty(exports3, "isValidIdentifier", { enumerable: true, get: function() {
          return _isValidIdentifier.default;
        } }), Object.defineProperty(exports3, "isVar", { enumerable: true, get: function() {
          return _isVar.default;
        } }), Object.defineProperty(exports3, "matchesPattern", { enumerable: true, get: function() {
          return _matchesPattern.default;
        } }), Object.defineProperty(exports3, "prependToMemberExpression", { enumerable: true, get: function() {
          return _prependToMemberExpression.default;
        } }), exports3.react = void 0, Object.defineProperty(exports3, "removeComments", { enumerable: true, get: function() {
          return _removeComments.default;
        } }), Object.defineProperty(exports3, "removeProperties", { enumerable: true, get: function() {
          return _removeProperties.default;
        } }), Object.defineProperty(exports3, "removePropertiesDeep", { enumerable: true, get: function() {
          return _removePropertiesDeep.default;
        } }), Object.defineProperty(exports3, "removeTypeDuplicates", { enumerable: true, get: function() {
          return _removeTypeDuplicates.default;
        } }), Object.defineProperty(exports3, "shallowEqual", { enumerable: true, get: function() {
          return _shallowEqual.default;
        } }), Object.defineProperty(exports3, "toBindingIdentifierName", { enumerable: true, get: function() {
          return _toBindingIdentifierName.default;
        } }), Object.defineProperty(exports3, "toBlock", { enumerable: true, get: function() {
          return _toBlock.default;
        } }), Object.defineProperty(exports3, "toComputedKey", { enumerable: true, get: function() {
          return _toComputedKey.default;
        } }), Object.defineProperty(exports3, "toExpression", { enumerable: true, get: function() {
          return _toExpression.default;
        } }), Object.defineProperty(exports3, "toIdentifier", { enumerable: true, get: function() {
          return _toIdentifier.default;
        } }), Object.defineProperty(exports3, "toKeyAlias", { enumerable: true, get: function() {
          return _toKeyAlias.default;
        } }), Object.defineProperty(exports3, "toSequenceExpression", { enumerable: true, get: function() {
          return _toSequenceExpression.default;
        } }), Object.defineProperty(exports3, "toStatement", { enumerable: true, get: function() {
          return _toStatement.default;
        } }), Object.defineProperty(exports3, "traverse", { enumerable: true, get: function() {
          return _traverse.default;
        } }), Object.defineProperty(exports3, "traverseFast", { enumerable: true, get: function() {
          return _traverseFast.default;
        } }), Object.defineProperty(exports3, "validate", { enumerable: true, get: function() {
          return _validate.default;
        } }), Object.defineProperty(exports3, "valueToNode", { enumerable: true, get: function() {
          return _valueToNode.default;
        } });
        var _isReactComponent = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/react/isReactComponent.js"), _isCompatTag = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/react/isCompatTag.js"), _buildChildren = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/react/buildChildren.js"), _assertNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/asserts/assertNode.js"), _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/asserts/generated/index.js");
        Object.keys(_generated).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _generated[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _generated[key];
          } }));
        });
        var _createTypeAnnotationBasedOnTypeof = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"), _createFlowUnionType = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"), _createTSUnionType = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"), _generated2 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js");
        Object.keys(_generated2).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _generated2[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _generated2[key];
          } }));
        });
        var _uppercase = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/uppercase.js");
        Object.keys(_uppercase).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _uppercase[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _uppercase[key];
          } }));
        });
        var _cloneNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneNode.js"), _clone = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/clone.js"), _cloneDeep = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneDeep.js"), _cloneDeepWithoutLoc = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"), _cloneWithoutLoc = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"), _addComment = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/addComment.js"), _addComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/addComments.js"), _inheritInnerComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritInnerComments.js"), _inheritLeadingComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), _inheritsComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritsComments.js"), _inheritTrailingComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), _removeComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/removeComments.js"), _generated3 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/generated/index.js");
        Object.keys(_generated3).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _generated3[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _generated3[key];
          } }));
        });
        var _constants = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js");
        Object.keys(_constants).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _constants[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _constants[key];
          } }));
        });
        var _ensureBlock = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/ensureBlock.js"), _toBindingIdentifierName = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"), _toBlock = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toBlock.js"), _toComputedKey = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toComputedKey.js"), _toExpression = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toExpression.js"), _toIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toIdentifier.js"), _toKeyAlias = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toKeyAlias.js"), _toSequenceExpression = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toSequenceExpression.js"), _toStatement = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/toStatement.js"), _valueToNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/converters/valueToNode.js"), _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
        Object.keys(_definitions).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _definitions[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _definitions[key];
          } }));
        });
        var _appendToMemberExpression = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"), _inherits = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/inherits.js"), _prependToMemberExpression = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"), _removeProperties = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/removeProperties.js"), _removePropertiesDeep = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"), _removeTypeDuplicates = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"), _getBindingIdentifiers = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), _getOuterBindingIdentifiers = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"), _traverse = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/traverse/traverse.js");
        Object.keys(_traverse).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _traverse[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _traverse[key];
          } }));
        });
        var _traverseFast = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/traverse/traverseFast.js"), _shallowEqual = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/shallowEqual.js"), _is = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/is.js"), _isBinding = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isBinding.js"), _isBlockScoped = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isBlockScoped.js"), _isImmutable = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isImmutable.js"), _isLet = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isLet.js"), _isNode = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isNode.js"), _isNodesEquivalent = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"), _isPlaceholderType = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), _isReferenced = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isReferenced.js"), _isScope = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isScope.js"), _isSpecifierDefault = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"), _isType = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isType.js"), _isValidES3Identifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"), _isValidIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _isVar = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isVar.js"), _matchesPattern = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/matchesPattern.js"), _validate = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/validate.js"), _buildMatchMemberExpression = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"), _generated4 = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
        Object.keys(_generated4).forEach(function(key) {
          "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports3 && exports3[key] === _generated4[key] || Object.defineProperty(exports3, key, { enumerable: true, get: function() {
            return _generated4[key];
          } }));
        });
        var _deprecationWarning = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        const react = { isReactComponent: _isReactComponent.default, isCompatTag: _isCompatTag.default, buildChildren: _buildChildren.default };
        exports3.react = react;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(member, append, computed = false) {
          return member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed), member.property = append, member.computed = !!computed, member;
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function removeTypeDuplicates(nodesIn) {
          const nodes = Array.from(nodesIn), generics = /* @__PURE__ */ new Map(), bases = /* @__PURE__ */ new Map(), typeGroups = /* @__PURE__ */ new Set(), types2 = [];
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node && !(types2.indexOf(node) >= 0)) {
              if ((0, _generated.isAnyTypeAnnotation)(node))
                return [node];
              if ((0, _generated.isFlowBaseAnnotation)(node))
                bases.set(node.type, node);
              else if ((0, _generated.isUnionTypeAnnotation)(node))
                typeGroups.has(node.types) || (nodes.push(...node.types), typeGroups.add(node.types));
              else if ((0, _generated.isGenericTypeAnnotation)(node)) {
                const name = getQualifiedName(node.id);
                if (generics.has(name)) {
                  let existing = generics.get(name);
                  existing.typeParameters ? node.typeParameters && (existing.typeParameters.params.push(...node.typeParameters.params), existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params)) : existing = node.typeParameters;
                } else
                  generics.set(name, node);
              } else
                types2.push(node);
            }
          }
          for (const [, baseType] of bases)
            types2.push(baseType);
          for (const [, genericName] of generics)
            types2.push(genericName);
          return types2;
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
        function getQualifiedName(node) {
          return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/inherits.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(child, parent) {
          if (!child || !parent)
            return child;
          for (const key of _constants.INHERIT_KEYS.optional)
            null == child[key] && (child[key] = parent[key]);
          for (const key of Object.keys(parent))
            "_" === key[0] && "__clone" !== key && (child[key] = parent[key]);
          for (const key of _constants.INHERIT_KEYS.force)
            child[key] = parent[key];
          return (0, _inheritsComments.default)(child, parent), child;
        };
        var _constants = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js"), _inheritsComments = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/comments/inheritsComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(member, prepend) {
          if ((0, _.isSuper)(member.object))
            throw new Error("Cannot prepend node to super property access (`super.foo`).");
          return member.object = (0, _generated.memberExpression)(prepend, member.object), member;
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _ = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/removeProperties.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, opts = {}) {
          const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
          for (const key of map)
            null != node[key] && (node[key] = void 0);
          for (const key of Object.keys(node))
            "_" === key[0] && null != node[key] && (node[key] = void 0);
          const symbols = Object.getOwnPropertySymbols(node);
          for (const sym of symbols)
            node[sym] = null;
        };
        var _constants = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js");
        const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"], CLEAR_KEYS_PLUS_COMMENTS = [..._constants.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(tree, opts) {
          return (0, _traverseFast.default)(tree, _removeProperties.default, opts), tree;
        };
        var _traverseFast = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/traverse/traverseFast.js"), _removeProperties = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/removeProperties.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function removeTypeDuplicates(nodesIn) {
          const nodes = Array.from(nodesIn), generics = /* @__PURE__ */ new Map(), bases = /* @__PURE__ */ new Map(), typeGroups = /* @__PURE__ */ new Set(), types2 = [];
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node && !(types2.indexOf(node) >= 0)) {
              if ((0, _generated.isTSAnyKeyword)(node))
                return [node];
              if ((0, _generated.isTSBaseType)(node))
                bases.set(node.type, node);
              else if ((0, _generated.isTSUnionType)(node))
                typeGroups.has(node.types) || (nodes.push(...node.types), typeGroups.add(node.types));
              else if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {
                const name = getQualifiedName(node.typeName);
                if (generics.has(name)) {
                  let existing = generics.get(name);
                  existing.typeParameters ? node.typeParameters && (existing.typeParameters.params.push(...node.typeParameters.params), existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params)) : existing = node.typeParameters;
                } else
                  generics.set(name, node);
              } else
                types2.push(node);
            }
          }
          for (const [, baseType] of bases)
            types2.push(baseType);
          for (const [, genericName] of generics)
            types2.push(genericName);
          return types2;
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
        function getQualifiedName(node) {
          return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = getBindingIdentifiers;
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
        function getBindingIdentifiers(node, duplicates, outerOnly) {
          const search = [].concat(node), ids = /* @__PURE__ */ Object.create(null);
          for (; search.length; ) {
            const id = search.shift();
            if (!id)
              continue;
            const keys2 = getBindingIdentifiers.keys[id.type];
            if ((0, _generated.isIdentifier)(id))
              if (duplicates) {
                (ids[id.name] = ids[id.name] || []).push(id);
              } else
                ids[id.name] = id;
            else if (!(0, _generated.isExportDeclaration)(id) || (0, _generated.isExportAllDeclaration)(id)) {
              if (outerOnly) {
                if ((0, _generated.isFunctionDeclaration)(id)) {
                  search.push(id.id);
                  continue;
                }
                if ((0, _generated.isFunctionExpression)(id))
                  continue;
              }
              if (keys2)
                for (let i = 0; i < keys2.length; i++) {
                  const nodes = id[keys2[i]];
                  nodes && (Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes));
                }
            } else
              (0, _generated.isDeclaration)(id.declaration) && search.push(id.declaration);
          }
          return ids;
        }
        getBindingIdentifiers.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _getBindingIdentifiers = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), _default = function(node, duplicates) {
          return (0, _getBindingIdentifiers.default)(node, duplicates, true);
        };
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/traverse/traverse.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, handlers, state) {
          "function" == typeof handlers && (handlers = { enter: handlers });
          const { enter, exit } = handlers;
          traverseSimpleImpl(node, enter, exit, state, []);
        };
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
        function traverseSimpleImpl(node, enter, exit, state, ancestors) {
          const keys2 = _definitions.VISITOR_KEYS[node.type];
          if (keys2) {
            enter && enter(node, ancestors, state);
            for (const key of keys2) {
              const subNode = node[key];
              if (Array.isArray(subNode))
                for (let i = 0; i < subNode.length; i++) {
                  const child = subNode[i];
                  child && (ancestors.push({ node, key, index: i }), traverseSimpleImpl(child, enter, exit, state, ancestors), ancestors.pop());
                }
              else
                subNode && (ancestors.push({ node, key }), traverseSimpleImpl(subNode, enter, exit, state, ancestors), ancestors.pop());
            }
            exit && exit(node, ancestors, state);
          }
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/traverse/traverseFast.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function traverseFast(node, enter, opts) {
          if (!node)
            return;
          const keys2 = _definitions.VISITOR_KEYS[node.type];
          if (!keys2)
            return;
          enter(node, opts = opts || {});
          for (const key of keys2) {
            const subNode = node[key];
            if (Array.isArray(subNode))
              for (const node2 of subNode)
                traverseFast(node2, enter, opts);
            else
              traverseFast(subNode, enter, opts);
          }
        };
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/deprecationWarning.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(oldName, newName, prefix = "") {
          if (warnings.has(oldName))
            return;
          warnings.add(oldName);
          const { internal: internal2, trace } = function(skip, length) {
            const { stackTraceLimit, prepareStackTrace } = Error;
            let stackTrace;
            if (Error.stackTraceLimit = 1 + skip + length, Error.prepareStackTrace = function(err, stack) {
              stackTrace = stack;
            }, new Error().stack, Error.stackTraceLimit = stackTraceLimit, Error.prepareStackTrace = prepareStackTrace, !stackTrace)
              return { internal: false, trace: "" };
            const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
            return { internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()), trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n") };
          }(1, 2);
          if (internal2)
            return;
          console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
        };
        const warnings = /* @__PURE__ */ new Set();
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/inherit.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(key, child, parent) {
          child && parent && (child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean))));
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(child, args) {
          const lines = child.value.split(/\r\n|\n|\r/);
          let lastNonEmptyLine = 0;
          for (let i = 0; i < lines.length; i++)
            lines[i].match(/[^ \t]/) && (lastNonEmptyLine = i);
          let str = "";
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i], isFirstLine = 0 === i, isLastLine = i === lines.length - 1, isLastNonEmptyLine = i === lastNonEmptyLine;
            let trimmedLine = line.replace(/\t/g, " ");
            isFirstLine || (trimmedLine = trimmedLine.replace(/^[ ]+/, "")), isLastLine || (trimmedLine = trimmedLine.replace(/[ ]+$/, "")), trimmedLine && (isLastNonEmptyLine || (trimmedLine += " "), str += trimmedLine);
          }
          str && args.push((0, _.inherits)((0, _generated.stringLiteral)(str), child));
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/builders/generated/index.js"), _ = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/shallowEqual.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(actual, expected) {
          const keys2 = Object.keys(expected);
          for (const key of keys2)
            if (actual[key] !== expected[key])
              return false;
          return true;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(match, allowPartial) {
          const parts = match.split(".");
          return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
        };
        var _matchesPattern = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/matchesPattern.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.isAccessor = function(node, opts) {
          if (!node)
            return false;
          if ("ClassAccessorProperty" !== node.type)
            return false;
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isAnyTypeAnnotation = function(node, opts) {
          return !!node && ("AnyTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isArgumentPlaceholder = function(node, opts) {
          return !!node && ("ArgumentPlaceholder" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isArrayExpression = function(node, opts) {
          return !!node && ("ArrayExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isArrayPattern = function(node, opts) {
          return !!node && ("ArrayPattern" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isArrayTypeAnnotation = function(node, opts) {
          return !!node && ("ArrayTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isArrowFunctionExpression = function(node, opts) {
          return !!node && ("ArrowFunctionExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isAssignmentExpression = function(node, opts) {
          return !!node && ("AssignmentExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isAssignmentPattern = function(node, opts) {
          return !!node && ("AssignmentPattern" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isAwaitExpression = function(node, opts) {
          return !!node && ("AwaitExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBigIntLiteral = function(node, opts) {
          return !!node && ("BigIntLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBinary = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "BinaryExpression":
            case "LogicalExpression":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isBinaryExpression = function(node, opts) {
          return !!node && ("BinaryExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBindExpression = function(node, opts) {
          return !!node && ("BindExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBlock = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "BlockStatement":
            case "Program":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isBlockParent = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isBlockStatement = function(node, opts) {
          return !!node && ("BlockStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBooleanLiteral = function(node, opts) {
          return !!node && ("BooleanLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBooleanLiteralTypeAnnotation = function(node, opts) {
          return !!node && ("BooleanLiteralTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBooleanTypeAnnotation = function(node, opts) {
          return !!node && ("BooleanTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isBreakStatement = function(node, opts) {
          return !!node && ("BreakStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isCallExpression = function(node, opts) {
          return !!node && ("CallExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isCatchClause = function(node, opts) {
          return !!node && ("CatchClause" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClass = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ClassExpression":
            case "ClassDeclaration":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isClassAccessorProperty = function(node, opts) {
          return !!node && ("ClassAccessorProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassBody = function(node, opts) {
          return !!node && ("ClassBody" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassDeclaration = function(node, opts) {
          return !!node && ("ClassDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassExpression = function(node, opts) {
          return !!node && ("ClassExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassImplements = function(node, opts) {
          return !!node && ("ClassImplements" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassMethod = function(node, opts) {
          return !!node && ("ClassMethod" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassPrivateMethod = function(node, opts) {
          return !!node && ("ClassPrivateMethod" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassPrivateProperty = function(node, opts) {
          return !!node && ("ClassPrivateProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isClassProperty = function(node, opts) {
          return !!node && ("ClassProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isCompletionStatement = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isConditional = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ConditionalExpression":
            case "IfStatement":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isConditionalExpression = function(node, opts) {
          return !!node && ("ConditionalExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isContinueStatement = function(node, opts) {
          return !!node && ("ContinueStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDebuggerStatement = function(node, opts) {
          return !!node && ("DebuggerStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDecimalLiteral = function(node, opts) {
          return !!node && ("DecimalLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclaration = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "FunctionDeclaration":
            case "VariableDeclaration":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
              break;
            case "Placeholder":
              if ("Declaration" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isDeclareClass = function(node, opts) {
          return !!node && ("DeclareClass" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareExportAllDeclaration = function(node, opts) {
          return !!node && ("DeclareExportAllDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareExportDeclaration = function(node, opts) {
          return !!node && ("DeclareExportDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareFunction = function(node, opts) {
          return !!node && ("DeclareFunction" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareInterface = function(node, opts) {
          return !!node && ("DeclareInterface" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareModule = function(node, opts) {
          return !!node && ("DeclareModule" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareModuleExports = function(node, opts) {
          return !!node && ("DeclareModuleExports" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareOpaqueType = function(node, opts) {
          return !!node && ("DeclareOpaqueType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareTypeAlias = function(node, opts) {
          return !!node && ("DeclareTypeAlias" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclareVariable = function(node, opts) {
          return !!node && ("DeclareVariable" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDeclaredPredicate = function(node, opts) {
          return !!node && ("DeclaredPredicate" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDecorator = function(node, opts) {
          return !!node && ("Decorator" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDirective = function(node, opts) {
          return !!node && ("Directive" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDirectiveLiteral = function(node, opts) {
          return !!node && ("DirectiveLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDoExpression = function(node, opts) {
          return !!node && ("DoExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isDoWhileStatement = function(node, opts) {
          return !!node && ("DoWhileStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEmptyStatement = function(node, opts) {
          return !!node && ("EmptyStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEmptyTypeAnnotation = function(node, opts) {
          return !!node && ("EmptyTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumBody = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isEnumBooleanBody = function(node, opts) {
          return !!node && ("EnumBooleanBody" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumBooleanMember = function(node, opts) {
          return !!node && ("EnumBooleanMember" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumDeclaration = function(node, opts) {
          return !!node && ("EnumDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumDefaultedMember = function(node, opts) {
          return !!node && ("EnumDefaultedMember" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumMember = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isEnumNumberBody = function(node, opts) {
          return !!node && ("EnumNumberBody" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumNumberMember = function(node, opts) {
          return !!node && ("EnumNumberMember" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumStringBody = function(node, opts) {
          return !!node && ("EnumStringBody" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumStringMember = function(node, opts) {
          return !!node && ("EnumStringMember" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isEnumSymbolBody = function(node, opts) {
          return !!node && ("EnumSymbolBody" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExistsTypeAnnotation = function(node, opts) {
          return !!node && ("ExistsTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExportAllDeclaration = function(node, opts) {
          return !!node && ("ExportAllDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExportDeclaration = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isExportDefaultDeclaration = function(node, opts) {
          return !!node && ("ExportDefaultDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExportDefaultSpecifier = function(node, opts) {
          return !!node && ("ExportDefaultSpecifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExportNamedDeclaration = function(node, opts) {
          return !!node && ("ExportNamedDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExportNamespaceSpecifier = function(node, opts) {
          return !!node && ("ExportNamespaceSpecifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExportSpecifier = function(node, opts) {
          return !!node && ("ExportSpecifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExpression = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "CallExpression":
            case "ConditionalExpression":
            case "FunctionExpression":
            case "Identifier":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "ObjectExpression":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "ThisExpression":
            case "UnaryExpression":
            case "UpdateExpression":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "MetaProperty":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "TypeCastExpression":
            case "JSXElement":
            case "JSXFragment":
            case "BindExpression":
            case "DoExpression":
            case "RecordExpression":
            case "TupleExpression":
            case "DecimalLiteral":
            case "ModuleExpression":
            case "TopicReference":
            case "PipelineTopicExpression":
            case "PipelineBareFunction":
            case "PipelinePrimaryTopicReference":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (node.expectedNode) {
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isExpressionStatement = function(node, opts) {
          return !!node && ("ExpressionStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isExpressionWrapper = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ExpressionStatement":
            case "ParenthesizedExpression":
            case "TypeCastExpression":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFile = function(node, opts) {
          return !!node && ("File" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isFlow = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ClassImplements":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "DeclaredPredicate":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "FunctionTypeParam":
            case "GenericTypeAnnotation":
            case "InferredPredicate":
            case "InterfaceExtends":
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
            case "OpaqueType":
            case "QualifiedTypeIdentifier":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "TypeAlias":
            case "TypeAnnotation":
            case "TypeCastExpression":
            case "TypeParameter":
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation":
            case "UnionTypeAnnotation":
            case "Variance":
            case "VoidTypeAnnotation":
            case "EnumDeclaration":
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFlowBaseAnnotation = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "AnyTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NumberTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "VoidTypeAnnotation":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFlowDeclaration = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFlowPredicate = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "DeclaredPredicate":
            case "InferredPredicate":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFlowType = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "UnionTypeAnnotation":
            case "VoidTypeAnnotation":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFor = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ForInStatement":
            case "ForStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isForInStatement = function(node, opts) {
          return !!node && ("ForInStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isForOfStatement = function(node, opts) {
          return !!node && ("ForOfStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isForStatement = function(node, opts) {
          return !!node && ("ForStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isForXStatement = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ForInStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFunction = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFunctionDeclaration = function(node, opts) {
          return !!node && ("FunctionDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isFunctionExpression = function(node, opts) {
          return !!node && ("FunctionExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isFunctionParent = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isFunctionTypeAnnotation = function(node, opts) {
          return !!node && ("FunctionTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isFunctionTypeParam = function(node, opts) {
          return !!node && ("FunctionTypeParam" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isGenericTypeAnnotation = function(node, opts) {
          return !!node && ("GenericTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isIdentifier = function(node, opts) {
          return !!node && ("Identifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isIfStatement = function(node, opts) {
          return !!node && ("IfStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isImmutable = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "BigIntLiteral":
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXOpeningElement":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isImport = function(node, opts) {
          return !!node && ("Import" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isImportAttribute = function(node, opts) {
          return !!node && ("ImportAttribute" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isImportDeclaration = function(node, opts) {
          return !!node && ("ImportDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isImportDefaultSpecifier = function(node, opts) {
          return !!node && ("ImportDefaultSpecifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isImportNamespaceSpecifier = function(node, opts) {
          return !!node && ("ImportNamespaceSpecifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isImportOrExportDeclaration = isImportOrExportDeclaration, exports3.isImportSpecifier = function(node, opts) {
          return !!node && ("ImportSpecifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isIndexedAccessType = function(node, opts) {
          return !!node && ("IndexedAccessType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isInferredPredicate = function(node, opts) {
          return !!node && ("InferredPredicate" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isInterfaceDeclaration = function(node, opts) {
          return !!node && ("InterfaceDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isInterfaceExtends = function(node, opts) {
          return !!node && ("InterfaceExtends" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isInterfaceTypeAnnotation = function(node, opts) {
          return !!node && ("InterfaceTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isInterpreterDirective = function(node, opts) {
          return !!node && ("InterpreterDirective" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isIntersectionTypeAnnotation = function(node, opts) {
          return !!node && ("IntersectionTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSX = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXEmptyExpression":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXIdentifier":
            case "JSXMemberExpression":
            case "JSXNamespacedName":
            case "JSXOpeningElement":
            case "JSXSpreadAttribute":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isJSXAttribute = function(node, opts) {
          return !!node && ("JSXAttribute" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXClosingElement = function(node, opts) {
          return !!node && ("JSXClosingElement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXClosingFragment = function(node, opts) {
          return !!node && ("JSXClosingFragment" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXElement = function(node, opts) {
          return !!node && ("JSXElement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXEmptyExpression = function(node, opts) {
          return !!node && ("JSXEmptyExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXExpressionContainer = function(node, opts) {
          return !!node && ("JSXExpressionContainer" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXFragment = function(node, opts) {
          return !!node && ("JSXFragment" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXIdentifier = function(node, opts) {
          return !!node && ("JSXIdentifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXMemberExpression = function(node, opts) {
          return !!node && ("JSXMemberExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXNamespacedName = function(node, opts) {
          return !!node && ("JSXNamespacedName" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXOpeningElement = function(node, opts) {
          return !!node && ("JSXOpeningElement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXOpeningFragment = function(node, opts) {
          return !!node && ("JSXOpeningFragment" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXSpreadAttribute = function(node, opts) {
          return !!node && ("JSXSpreadAttribute" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXSpreadChild = function(node, opts) {
          return !!node && ("JSXSpreadChild" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isJSXText = function(node, opts) {
          return !!node && ("JSXText" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isLVal = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "Identifier":
            case "MemberExpression":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSParameterProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (node.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isLabeledStatement = function(node, opts) {
          return !!node && ("LabeledStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isLiteral = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "TemplateLiteral":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isLogicalExpression = function(node, opts) {
          return !!node && ("LogicalExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isLoop = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "WhileStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isMemberExpression = function(node, opts) {
          return !!node && ("MemberExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isMetaProperty = function(node, opts) {
          return !!node && ("MetaProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isMethod = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isMiscellaneous = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "Noop":
            case "Placeholder":
            case "V8IntrinsicIdentifier":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isMixedTypeAnnotation = function(node, opts) {
          return !!node && ("MixedTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isModuleDeclaration = function(node, opts) {
          return (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration"), isImportOrExportDeclaration(node, opts);
        }, exports3.isModuleExpression = function(node, opts) {
          return !!node && ("ModuleExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isModuleSpecifier = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ExportSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isNewExpression = function(node, opts) {
          return !!node && ("NewExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNoop = function(node, opts) {
          return !!node && ("Noop" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNullLiteral = function(node, opts) {
          return !!node && ("NullLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNullLiteralTypeAnnotation = function(node, opts) {
          return !!node && ("NullLiteralTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNullableTypeAnnotation = function(node, opts) {
          return !!node && ("NullableTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNumberLiteral = function(node, opts) {
          return (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral"), !!node && ("NumberLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNumberLiteralTypeAnnotation = function(node, opts) {
          return !!node && ("NumberLiteralTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNumberTypeAnnotation = function(node, opts) {
          return !!node && ("NumberTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isNumericLiteral = function(node, opts) {
          return !!node && ("NumericLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectExpression = function(node, opts) {
          return !!node && ("ObjectExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectMember = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ObjectMethod":
            case "ObjectProperty":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isObjectMethod = function(node, opts) {
          return !!node && ("ObjectMethod" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectPattern = function(node, opts) {
          return !!node && ("ObjectPattern" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectProperty = function(node, opts) {
          return !!node && ("ObjectProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectTypeAnnotation = function(node, opts) {
          return !!node && ("ObjectTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectTypeCallProperty = function(node, opts) {
          return !!node && ("ObjectTypeCallProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectTypeIndexer = function(node, opts) {
          return !!node && ("ObjectTypeIndexer" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectTypeInternalSlot = function(node, opts) {
          return !!node && ("ObjectTypeInternalSlot" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectTypeProperty = function(node, opts) {
          return !!node && ("ObjectTypeProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isObjectTypeSpreadProperty = function(node, opts) {
          return !!node && ("ObjectTypeSpreadProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isOpaqueType = function(node, opts) {
          return !!node && ("OpaqueType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isOptionalCallExpression = function(node, opts) {
          return !!node && ("OptionalCallExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isOptionalIndexedAccessType = function(node, opts) {
          return !!node && ("OptionalIndexedAccessType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isOptionalMemberExpression = function(node, opts) {
          return !!node && ("OptionalMemberExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isParenthesizedExpression = function(node, opts) {
          return !!node && ("ParenthesizedExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isPattern = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
              break;
            case "Placeholder":
              if ("Pattern" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isPatternLike = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "Identifier":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (node.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isPipelineBareFunction = function(node, opts) {
          return !!node && ("PipelineBareFunction" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isPipelinePrimaryTopicReference = function(node, opts) {
          return !!node && ("PipelinePrimaryTopicReference" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isPipelineTopicExpression = function(node, opts) {
          return !!node && ("PipelineTopicExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isPlaceholder = function(node, opts) {
          return !!node && ("Placeholder" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isPrivate = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isPrivateName = function(node, opts) {
          return !!node && ("PrivateName" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isProgram = function(node, opts) {
          return !!node && ("Program" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isProperty = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ObjectProperty":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isPureish = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "ArrowFunctionExpression":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isQualifiedTypeIdentifier = function(node, opts) {
          return !!node && ("QualifiedTypeIdentifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isRecordExpression = function(node, opts) {
          return !!node && ("RecordExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isRegExpLiteral = function(node, opts) {
          return !!node && ("RegExpLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isRegexLiteral = function(node, opts) {
          return (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral"), !!node && ("RegexLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isRestElement = function(node, opts) {
          return !!node && ("RestElement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isRestProperty = function(node, opts) {
          return (0, _deprecationWarning.default)("isRestProperty", "isRestElement"), !!node && ("RestProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isReturnStatement = function(node, opts) {
          return !!node && ("ReturnStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isScopable = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isSequenceExpression = function(node, opts) {
          return !!node && ("SequenceExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isSpreadElement = function(node, opts) {
          return !!node && ("SpreadElement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isSpreadProperty = function(node, opts) {
          return (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement"), !!node && ("SpreadProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isStandardized = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "InterpreterDirective":
            case "Directive":
            case "DirectiveLiteral":
            case "BlockStatement":
            case "BreakStatement":
            case "CallExpression":
            case "CatchClause":
            case "ConditionalExpression":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "File":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Identifier":
            case "IfStatement":
            case "LabeledStatement":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "Program":
            case "ObjectExpression":
            case "ObjectMethod":
            case "ObjectProperty":
            case "RestElement":
            case "ReturnStatement":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "SwitchCase":
            case "SwitchStatement":
            case "ThisExpression":
            case "ThrowStatement":
            case "TryStatement":
            case "UnaryExpression":
            case "UpdateExpression":
            case "VariableDeclaration":
            case "VariableDeclarator":
            case "WhileStatement":
            case "WithStatement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ArrowFunctionExpression":
            case "ClassBody":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ExportSpecifier":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "MetaProperty":
            case "ClassMethod":
            case "ObjectPattern":
            case "SpreadElement":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateElement":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "ExportNamespaceSpecifier":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
            case "StaticBlock":
              break;
            case "Placeholder":
              switch (node.expectedNode) {
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isStatement = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "BlockStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "IfStatement":
            case "LabeledStatement":
            case "ReturnStatement":
            case "SwitchStatement":
            case "ThrowStatement":
            case "TryStatement":
            case "VariableDeclaration":
            case "WhileStatement":
            case "WithStatement":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
            case "TSImportEqualsDeclaration":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
              break;
            case "Placeholder":
              switch (node.expectedNode) {
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isStaticBlock = function(node, opts) {
          return !!node && ("StaticBlock" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isStringLiteral = function(node, opts) {
          return !!node && ("StringLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isStringLiteralTypeAnnotation = function(node, opts) {
          return !!node && ("StringLiteralTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isStringTypeAnnotation = function(node, opts) {
          return !!node && ("StringTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isSuper = function(node, opts) {
          return !!node && ("Super" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isSwitchCase = function(node, opts) {
          return !!node && ("SwitchCase" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isSwitchStatement = function(node, opts) {
          return !!node && ("SwitchStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isSymbolTypeAnnotation = function(node, opts) {
          return !!node && ("SymbolTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSAnyKeyword = function(node, opts) {
          return !!node && ("TSAnyKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSArrayType = function(node, opts) {
          return !!node && ("TSArrayType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSAsExpression = function(node, opts) {
          return !!node && ("TSAsExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSBaseType = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSLiteralType":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isTSBigIntKeyword = function(node, opts) {
          return !!node && ("TSBigIntKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSBooleanKeyword = function(node, opts) {
          return !!node && ("TSBooleanKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSCallSignatureDeclaration = function(node, opts) {
          return !!node && ("TSCallSignatureDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSConditionalType = function(node, opts) {
          return !!node && ("TSConditionalType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSConstructSignatureDeclaration = function(node, opts) {
          return !!node && ("TSConstructSignatureDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSConstructorType = function(node, opts) {
          return !!node && ("TSConstructorType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSDeclareFunction = function(node, opts) {
          return !!node && ("TSDeclareFunction" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSDeclareMethod = function(node, opts) {
          return !!node && ("TSDeclareMethod" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSEntityName = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "Identifier":
            case "TSQualifiedName":
              break;
            case "Placeholder":
              if ("Identifier" === node.expectedNode)
                break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isTSEnumDeclaration = function(node, opts) {
          return !!node && ("TSEnumDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSEnumMember = function(node, opts) {
          return !!node && ("TSEnumMember" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSExportAssignment = function(node, opts) {
          return !!node && ("TSExportAssignment" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSExpressionWithTypeArguments = function(node, opts) {
          return !!node && ("TSExpressionWithTypeArguments" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSExternalModuleReference = function(node, opts) {
          return !!node && ("TSExternalModuleReference" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSFunctionType = function(node, opts) {
          return !!node && ("TSFunctionType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSImportEqualsDeclaration = function(node, opts) {
          return !!node && ("TSImportEqualsDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSImportType = function(node, opts) {
          return !!node && ("TSImportType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSIndexSignature = function(node, opts) {
          return !!node && ("TSIndexSignature" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSIndexedAccessType = function(node, opts) {
          return !!node && ("TSIndexedAccessType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSInferType = function(node, opts) {
          return !!node && ("TSInferType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSInstantiationExpression = function(node, opts) {
          return !!node && ("TSInstantiationExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSInterfaceBody = function(node, opts) {
          return !!node && ("TSInterfaceBody" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSInterfaceDeclaration = function(node, opts) {
          return !!node && ("TSInterfaceDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSIntersectionType = function(node, opts) {
          return !!node && ("TSIntersectionType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSIntrinsicKeyword = function(node, opts) {
          return !!node && ("TSIntrinsicKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSLiteralType = function(node, opts) {
          return !!node && ("TSLiteralType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSMappedType = function(node, opts) {
          return !!node && ("TSMappedType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSMethodSignature = function(node, opts) {
          return !!node && ("TSMethodSignature" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSModuleBlock = function(node, opts) {
          return !!node && ("TSModuleBlock" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSModuleDeclaration = function(node, opts) {
          return !!node && ("TSModuleDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSNamedTupleMember = function(node, opts) {
          return !!node && ("TSNamedTupleMember" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSNamespaceExportDeclaration = function(node, opts) {
          return !!node && ("TSNamespaceExportDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSNeverKeyword = function(node, opts) {
          return !!node && ("TSNeverKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSNonNullExpression = function(node, opts) {
          return !!node && ("TSNonNullExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSNullKeyword = function(node, opts) {
          return !!node && ("TSNullKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSNumberKeyword = function(node, opts) {
          return !!node && ("TSNumberKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSObjectKeyword = function(node, opts) {
          return !!node && ("TSObjectKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSOptionalType = function(node, opts) {
          return !!node && ("TSOptionalType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSParameterProperty = function(node, opts) {
          return !!node && ("TSParameterProperty" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSParenthesizedType = function(node, opts) {
          return !!node && ("TSParenthesizedType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSPropertySignature = function(node, opts) {
          return !!node && ("TSPropertySignature" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSQualifiedName = function(node, opts) {
          return !!node && ("TSQualifiedName" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSRestType = function(node, opts) {
          return !!node && ("TSRestType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSSatisfiesExpression = function(node, opts) {
          return !!node && ("TSSatisfiesExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSStringKeyword = function(node, opts) {
          return !!node && ("TSStringKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSSymbolKeyword = function(node, opts) {
          return !!node && ("TSSymbolKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSThisType = function(node, opts) {
          return !!node && ("TSThisType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTupleType = function(node, opts) {
          return !!node && ("TSTupleType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSType = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSImportType":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isTSTypeAliasDeclaration = function(node, opts) {
          return !!node && ("TSTypeAliasDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeAnnotation = function(node, opts) {
          return !!node && ("TSTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeAssertion = function(node, opts) {
          return !!node && ("TSTypeAssertion" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeElement = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isTSTypeLiteral = function(node, opts) {
          return !!node && ("TSTypeLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeOperator = function(node, opts) {
          return !!node && ("TSTypeOperator" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeParameter = function(node, opts) {
          return !!node && ("TSTypeParameter" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeParameterDeclaration = function(node, opts) {
          return !!node && ("TSTypeParameterDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeParameterInstantiation = function(node, opts) {
          return !!node && ("TSTypeParameterInstantiation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypePredicate = function(node, opts) {
          return !!node && ("TSTypePredicate" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeQuery = function(node, opts) {
          return !!node && ("TSTypeQuery" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSTypeReference = function(node, opts) {
          return !!node && ("TSTypeReference" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSUndefinedKeyword = function(node, opts) {
          return !!node && ("TSUndefinedKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSUnionType = function(node, opts) {
          return !!node && ("TSUnionType" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSUnknownKeyword = function(node, opts) {
          return !!node && ("TSUnknownKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTSVoidKeyword = function(node, opts) {
          return !!node && ("TSVoidKeyword" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTaggedTemplateExpression = function(node, opts) {
          return !!node && ("TaggedTemplateExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTemplateElement = function(node, opts) {
          return !!node && ("TemplateElement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTemplateLiteral = function(node, opts) {
          return !!node && ("TemplateLiteral" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTerminatorless = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "YieldExpression":
            case "AwaitExpression":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isThisExpression = function(node, opts) {
          return !!node && ("ThisExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isThisTypeAnnotation = function(node, opts) {
          return !!node && ("ThisTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isThrowStatement = function(node, opts) {
          return !!node && ("ThrowStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTopicReference = function(node, opts) {
          return !!node && ("TopicReference" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTryStatement = function(node, opts) {
          return !!node && ("TryStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTupleExpression = function(node, opts) {
          return !!node && ("TupleExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTupleTypeAnnotation = function(node, opts) {
          return !!node && ("TupleTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTypeAlias = function(node, opts) {
          return !!node && ("TypeAlias" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTypeAnnotation = function(node, opts) {
          return !!node && ("TypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTypeCastExpression = function(node, opts) {
          return !!node && ("TypeCastExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTypeParameter = function(node, opts) {
          return !!node && ("TypeParameter" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTypeParameterDeclaration = function(node, opts) {
          return !!node && ("TypeParameterDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTypeParameterInstantiation = function(node, opts) {
          return !!node && ("TypeParameterInstantiation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isTypeScript = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "TSParameterProperty":
            case "TSDeclareFunction":
            case "TSDeclareMethod":
            case "TSQualifiedName":
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSNamedTupleMember":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSInterfaceDeclaration":
            case "TSInterfaceBody":
            case "TSTypeAliasDeclaration":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSEnumDeclaration":
            case "TSEnumMember":
            case "TSModuleDeclaration":
            case "TSModuleBlock":
            case "TSImportType":
            case "TSImportEqualsDeclaration":
            case "TSExternalModuleReference":
            case "TSNonNullExpression":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
            case "TSTypeAnnotation":
            case "TSTypeParameterInstantiation":
            case "TSTypeParameterDeclaration":
            case "TSTypeParameter":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isTypeofTypeAnnotation = function(node, opts) {
          return !!node && ("TypeofTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isUnaryExpression = function(node, opts) {
          return !!node && ("UnaryExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isUnaryLike = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "UnaryExpression":
            case "SpreadElement":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isUnionTypeAnnotation = function(node, opts) {
          return !!node && ("UnionTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isUpdateExpression = function(node, opts) {
          return !!node && ("UpdateExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isUserWhitespacable = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ObjectMethod":
            case "ObjectProperty":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isV8IntrinsicIdentifier = function(node, opts) {
          return !!node && ("V8IntrinsicIdentifier" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isVariableDeclaration = function(node, opts) {
          return !!node && ("VariableDeclaration" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isVariableDeclarator = function(node, opts) {
          return !!node && ("VariableDeclarator" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isVariance = function(node, opts) {
          return !!node && ("Variance" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isVoidTypeAnnotation = function(node, opts) {
          return !!node && ("VoidTypeAnnotation" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isWhile = function(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "DoWhileStatement":
            case "WhileStatement":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }, exports3.isWhileStatement = function(node, opts) {
          return !!node && ("WhileStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isWithStatement = function(node, opts) {
          return !!node && ("WithStatement" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        }, exports3.isYieldExpression = function(node, opts) {
          return !!node && ("YieldExpression" === node.type && (null == opts || (0, _shallowEqual.default)(node, opts)));
        };
        var _shallowEqual = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/shallowEqual.js"), _deprecationWarning = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function isImportOrExportDeclaration(node, opts) {
          if (!node)
            return false;
          switch (node.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              break;
            default:
              return false;
          }
          return null == opts || (0, _shallowEqual.default)(node, opts);
        }
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/is.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(type, node, opts) {
          if (!node)
            return false;
          if (!(0, _isType.default)(node.type, type))
            return !opts && "Placeholder" === node.type && type in _definitions.FLIPPED_ALIAS_KEYS && (0, _isPlaceholderType.default)(node.expectedNode, type);
          return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        };
        var _shallowEqual = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/utils/shallowEqual.js"), _isType = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isType.js"), _isPlaceholderType = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isBinding.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, parent, grandparent) {
          if (grandparent && "Identifier" === node.type && "ObjectProperty" === parent.type && "ObjectExpression" === grandparent.type)
            return false;
          const keys2 = _getBindingIdentifiers.default.keys[parent.type];
          if (keys2)
            for (let i = 0; i < keys2.length; i++) {
              const val = parent[keys2[i]];
              if (Array.isArray(val)) {
                if (val.indexOf(node) >= 0)
                  return true;
              } else if (val === node)
                return true;
            }
          return false;
        };
        var _getBindingIdentifiers = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isBlockScoped.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _isLet = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isLet.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isImmutable.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          if ((0, _isType.default)(node.type, "Immutable"))
            return true;
          if ((0, _generated.isIdentifier)(node))
            return "undefined" === node.name;
          return false;
        };
        var _isType = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isType.js"), _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isLet.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return (0, _generated.isVariableDeclaration)(node) && ("var" !== node.kind || node[_constants.BLOCK_SCOPED_SYMBOL]);
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _constants = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isNode.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return !(!node || !_definitions.VISITOR_KEYS[node.type]);
        };
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isNodesEquivalent.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function isNodesEquivalent(a, b) {
          if ("object" != typeof a || "object" != typeof b || null == a || null == b)
            return a === b;
          if (a.type !== b.type)
            return false;
          const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type), visitorKeys = _definitions.VISITOR_KEYS[a.type];
          for (const field of fields) {
            const val_a = a[field], val_b = b[field];
            if (typeof val_a != typeof val_b)
              return false;
            if (null != val_a || null != val_b) {
              if (null == val_a || null == val_b)
                return false;
              if (Array.isArray(val_a)) {
                if (!Array.isArray(val_b))
                  return false;
                if (val_a.length !== val_b.length)
                  return false;
                for (let i = 0; i < val_a.length; i++)
                  if (!isNodesEquivalent(val_a[i], val_b[i]))
                    return false;
              } else if ("object" != typeof val_a || null != visitorKeys && visitorKeys.includes(field)) {
                if (!isNodesEquivalent(val_a, val_b))
                  return false;
              } else
                for (const key of Object.keys(val_a))
                  if (val_a[key] !== val_b[key])
                    return false;
            }
          }
          return true;
        };
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isPlaceholderType.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(placeholderType, targetType) {
          if (placeholderType === targetType)
            return true;
          const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
          if (aliases) {
            for (const alias of aliases)
              if (targetType === alias)
                return true;
          }
          return false;
        };
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isReferenced.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, parent, grandparent) {
          switch (parent.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
              return parent.property === node ? !!parent.computed : parent.object === node;
            case "JSXMemberExpression":
              return parent.object === node;
            case "VariableDeclarator":
              return parent.init === node;
            case "ArrowFunctionExpression":
              return parent.body === node;
            case "PrivateName":
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
            case "BreakStatement":
            case "ContinueStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
              return false;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
              return parent.key === node && !!parent.computed;
            case "ObjectProperty":
              return parent.key === node ? !!parent.computed : !grandparent || "ObjectPattern" !== grandparent.type;
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "TSPropertySignature":
              return parent.key !== node || !!parent.computed;
            case "ClassPrivateProperty":
            case "ObjectTypeProperty":
              return parent.key !== node;
            case "ClassDeclaration":
            case "ClassExpression":
              return parent.superClass === node;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return parent.right === node;
            case "ExportSpecifier":
              return (null == grandparent || !grandparent.source) && parent.local === node;
            case "TSEnumMember":
              return parent.id !== node;
          }
          return true;
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isScope.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, parent) {
          if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent)))
            return false;
          if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent)))
            return true;
          return (0, _generated.isScopable)(node);
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isSpecifierDefault.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(specifier) {
          return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, { name: "default" });
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isType.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(nodeType, targetType) {
          if (nodeType === targetType)
            return true;
          if (_definitions.ALIAS_KEYS[targetType])
            return false;
          const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
          if (aliases) {
            if (aliases[0] === nodeType)
              return true;
            for (const alias of aliases)
              if (nodeType === alias)
                return true;
          }
          return false;
        };
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidES3Identifier.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(name) {
          return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
        };
        var _isValidIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js");
        const RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(name, reserved = true) {
          if ("string" != typeof name)
            return false;
          if (reserved && ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)))
            return false;
          return (0, _helperValidatorIdentifier.isIdentifierName)(name);
        };
        var _helperValidatorIdentifier = __webpack_require__2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.22.5/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/isVar.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node) {
          return (0, _generated.isVariableDeclaration)(node, { kind: "var" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js"), _constants = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/matchesPattern.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(member, match, allowPartial) {
          if (!(0, _generated.isMemberExpression)(member))
            return false;
          const parts = Array.isArray(match) ? match : match.split("."), nodes = [];
          let node;
          for (node = member; (0, _generated.isMemberExpression)(node); node = node.object)
            nodes.push(node.property);
          if (nodes.push(node), nodes.length < parts.length)
            return false;
          if (!allowPartial && nodes.length > parts.length)
            return false;
          for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
            const node2 = nodes[j];
            let value2;
            if ((0, _generated.isIdentifier)(node2))
              value2 = node2.name;
            else if ((0, _generated.isStringLiteral)(node2))
              value2 = node2.value;
            else {
              if (!(0, _generated.isThisExpression)(node2))
                return false;
              value2 = "this";
            }
            if (parts[i] !== value2)
              return false;
          }
          return true;
        };
        var _generated = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/react/isCompatTag.js": (__unused_webpack_module, exports3) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(tagName) {
          return !!tagName && /^[a-z]/.test(tagName);
        };
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/react/isReactComponent.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");
        exports3.default = _default;
      }, "./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/validators/validate.js": (__unused_webpack_module, exports3, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true }), exports3.default = function(node, key, val) {
          if (!node)
            return;
          const fields = _definitions.NODE_FIELDS[node.type];
          if (!fields)
            return;
          const field = fields[key];
          validateField(node, key, val, field), validateChild(node, key, val);
        }, exports3.validateChild = validateChild, exports3.validateField = validateField;
        var _definitions = __webpack_require__2("./node_modules/.pnpm/@babel+types@7.22.5/node_modules/@babel/types/lib/definitions/index.js");
        function validateField(node, key, val, field) {
          null != field && field.validate && (field.optional && null == val || field.validate(node, key, val));
        }
        function validateChild(node, key, val) {
          if (null == val)
            return;
          const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
          validate && validate(node, key, val);
        }
      }, "./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
        "use strict";
        __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, { default: () => __WEBPACK_DEFAULT_EXPORT__ });
        var unicode = { Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, util = { isSpaceSeparator: (c2) => "string" == typeof c2 && unicode.Space_Separator.test(c2), isIdStartChar: (c2) => "string" == typeof c2 && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || "$" === c2 || "_" === c2 || unicode.ID_Start.test(c2)), isIdContinueChar: (c2) => "string" == typeof c2 && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || "$" === c2 || "_" === c2 || "" === c2 || "" === c2 || unicode.ID_Continue.test(c2)), isDigit: (c2) => "string" == typeof c2 && /[0-9]/.test(c2), isHexDigit: (c2) => "string" == typeof c2 && /[0-9A-Fa-f]/.test(c2) };
        let source, parseState, stack, pos, line, column, token, key, root2;
        function internalize(holder, name, reviver) {
          const value2 = holder[name];
          if (null != value2 && "object" == typeof value2)
            if (Array.isArray(value2))
              for (let i = 0; i < value2.length; i++) {
                const key2 = String(i), replacement = internalize(value2, key2, reviver);
                void 0 === replacement ? delete value2[key2] : Object.defineProperty(value2, key2, { value: replacement, writable: true, enumerable: true, configurable: true });
              }
            else
              for (const key2 in value2) {
                const replacement = internalize(value2, key2, reviver);
                void 0 === replacement ? delete value2[key2] : Object.defineProperty(value2, key2, { value: replacement, writable: true, enumerable: true, configurable: true });
              }
          return reviver.call(holder, name, value2);
        }
        let lexState, buffer, doubleQuote, sign, c;
        function lex() {
          for (lexState = "default", buffer = "", doubleQuote = false, sign = 1; ; ) {
            c = peek();
            const token2 = lexStates[lexState]();
            if (token2)
              return token2;
          }
        }
        function peek() {
          if (source[pos])
            return String.fromCodePoint(source.codePointAt(pos));
        }
        function read3() {
          const c2 = peek();
          return "\n" === c2 ? (line++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
        }
        const lexStates = { default() {
          switch (c) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case "":
            case "\uFEFF":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return void read3();
            case "/":
              return read3(), void (lexState = "comment");
            case void 0:
              return read3(), newToken("eof");
          }
          if (!util.isSpaceSeparator(c))
            return lexStates[parseState]();
          read3();
        }, comment() {
          switch (c) {
            case "*":
              return read3(), void (lexState = "multiLineComment");
            case "/":
              return read3(), void (lexState = "singleLineComment");
          }
          throw invalidChar(read3());
        }, multiLineComment() {
          switch (c) {
            case "*":
              return read3(), void (lexState = "multiLineCommentAsterisk");
            case void 0:
              throw invalidChar(read3());
          }
          read3();
        }, multiLineCommentAsterisk() {
          switch (c) {
            case "*":
              return void read3();
            case "/":
              return read3(), void (lexState = "default");
            case void 0:
              throw invalidChar(read3());
          }
          read3(), lexState = "multiLineComment";
        }, singleLineComment() {
          switch (c) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return read3(), void (lexState = "default");
            case void 0:
              return read3(), newToken("eof");
          }
          read3();
        }, value() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read3());
            case "n":
              return read3(), literal2("ull"), newToken("null", null);
            case "t":
              return read3(), literal2("rue"), newToken("boolean", true);
            case "f":
              return read3(), literal2("alse"), newToken("boolean", false);
            case "-":
            case "+":
              return "-" === read3() && (sign = -1), void (lexState = "sign");
            case ".":
              return buffer = read3(), void (lexState = "decimalPointLeading");
            case "0":
              return buffer = read3(), void (lexState = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return buffer = read3(), void (lexState = "decimalInteger");
            case "I":
              return read3(), literal2("nfinity"), newToken("numeric", 1 / 0);
            case "N":
              return read3(), literal2("aN"), newToken("numeric", NaN);
            case '"':
            case "'":
              return doubleQuote = '"' === read3(), buffer = "", void (lexState = "string");
          }
          throw invalidChar(read3());
        }, identifierNameStartEscape() {
          if ("u" !== c)
            throw invalidChar(read3());
          read3();
          const u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
              break;
            default:
              if (!util.isIdStartChar(u))
                throw invalidIdentifier();
          }
          buffer += u, lexState = "identifierName";
        }, identifierName() {
          switch (c) {
            case "$":
            case "_":
            case "":
            case "":
              return void (buffer += read3());
            case "\\":
              return read3(), void (lexState = "identifierNameEscape");
          }
          if (!util.isIdContinueChar(c))
            return newToken("identifier", buffer);
          buffer += read3();
        }, identifierNameEscape() {
          if ("u" !== c)
            throw invalidChar(read3());
          read3();
          const u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
            case "":
            case "":
              break;
            default:
              if (!util.isIdContinueChar(u))
                throw invalidIdentifier();
          }
          buffer += u, lexState = "identifierName";
        }, sign() {
          switch (c) {
            case ".":
              return buffer = read3(), void (lexState = "decimalPointLeading");
            case "0":
              return buffer = read3(), void (lexState = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return buffer = read3(), void (lexState = "decimalInteger");
            case "I":
              return read3(), literal2("nfinity"), newToken("numeric", sign * (1 / 0));
            case "N":
              return read3(), literal2("aN"), newToken("numeric", NaN);
          }
          throw invalidChar(read3());
        }, zero() {
          switch (c) {
            case ".":
              return buffer += read3(), void (lexState = "decimalPoint");
            case "e":
            case "E":
              return buffer += read3(), void (lexState = "decimalExponent");
            case "x":
            case "X":
              return buffer += read3(), void (lexState = "hexadecimal");
          }
          return newToken("numeric", 0 * sign);
        }, decimalInteger() {
          switch (c) {
            case ".":
              return buffer += read3(), void (lexState = "decimalPoint");
            case "e":
            case "E":
              return buffer += read3(), void (lexState = "decimalExponent");
          }
          if (!util.isDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read3();
        }, decimalPointLeading() {
          if (util.isDigit(c))
            return buffer += read3(), void (lexState = "decimalFraction");
          throw invalidChar(read3());
        }, decimalPoint() {
          switch (c) {
            case "e":
            case "E":
              return buffer += read3(), void (lexState = "decimalExponent");
          }
          return util.isDigit(c) ? (buffer += read3(), void (lexState = "decimalFraction")) : newToken("numeric", sign * Number(buffer));
        }, decimalFraction() {
          switch (c) {
            case "e":
            case "E":
              return buffer += read3(), void (lexState = "decimalExponent");
          }
          if (!util.isDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read3();
        }, decimalExponent() {
          switch (c) {
            case "+":
            case "-":
              return buffer += read3(), void (lexState = "decimalExponentSign");
          }
          if (util.isDigit(c))
            return buffer += read3(), void (lexState = "decimalExponentInteger");
          throw invalidChar(read3());
        }, decimalExponentSign() {
          if (util.isDigit(c))
            return buffer += read3(), void (lexState = "decimalExponentInteger");
          throw invalidChar(read3());
        }, decimalExponentInteger() {
          if (!util.isDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read3();
        }, hexadecimal() {
          if (util.isHexDigit(c))
            return buffer += read3(), void (lexState = "hexadecimalInteger");
          throw invalidChar(read3());
        }, hexadecimalInteger() {
          if (!util.isHexDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read3();
        }, string() {
          switch (c) {
            case "\\":
              return read3(), void (buffer += function() {
                switch (peek()) {
                  case "b":
                    return read3(), "\b";
                  case "f":
                    return read3(), "\f";
                  case "n":
                    return read3(), "\n";
                  case "r":
                    return read3(), "\r";
                  case "t":
                    return read3(), "	";
                  case "v":
                    return read3(), "\v";
                  case "0":
                    if (read3(), util.isDigit(peek()))
                      throw invalidChar(read3());
                    return "\0";
                  case "x":
                    return read3(), function() {
                      let buffer2 = "", c2 = peek();
                      if (!util.isHexDigit(c2))
                        throw invalidChar(read3());
                      if (buffer2 += read3(), c2 = peek(), !util.isHexDigit(c2))
                        throw invalidChar(read3());
                      return buffer2 += read3(), String.fromCodePoint(parseInt(buffer2, 16));
                    }();
                  case "u":
                    return read3(), unicodeEscape();
                  case "\n":
                  case "\u2028":
                  case "\u2029":
                    return read3(), "";
                  case "\r":
                    return read3(), "\n" === peek() && read3(), "";
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case void 0:
                    throw invalidChar(read3());
                }
                return read3();
              }());
            case '"':
              return doubleQuote ? (read3(), newToken("string", buffer)) : void (buffer += read3());
            case "'":
              return doubleQuote ? void (buffer += read3()) : (read3(), newToken("string", buffer));
            case "\n":
            case "\r":
              throw invalidChar(read3());
            case "\u2028":
            case "\u2029":
              !function(c2) {
                console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
              }(c);
              break;
            case void 0:
              throw invalidChar(read3());
          }
          buffer += read3();
        }, start() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read3());
          }
          lexState = "value";
        }, beforePropertyName() {
          switch (c) {
            case "$":
            case "_":
              return buffer = read3(), void (lexState = "identifierName");
            case "\\":
              return read3(), void (lexState = "identifierNameStartEscape");
            case "}":
              return newToken("punctuator", read3());
            case '"':
            case "'":
              return doubleQuote = '"' === read3(), void (lexState = "string");
          }
          if (util.isIdStartChar(c))
            return buffer += read3(), void (lexState = "identifierName");
          throw invalidChar(read3());
        }, afterPropertyName() {
          if (":" === c)
            return newToken("punctuator", read3());
          throw invalidChar(read3());
        }, beforePropertyValue() {
          lexState = "value";
        }, afterPropertyValue() {
          switch (c) {
            case ",":
            case "}":
              return newToken("punctuator", read3());
          }
          throw invalidChar(read3());
        }, beforeArrayValue() {
          if ("]" === c)
            return newToken("punctuator", read3());
          lexState = "value";
        }, afterArrayValue() {
          switch (c) {
            case ",":
            case "]":
              return newToken("punctuator", read3());
          }
          throw invalidChar(read3());
        }, end() {
          throw invalidChar(read3());
        } };
        function newToken(type, value2) {
          return { type, value: value2, line, column };
        }
        function literal2(s) {
          for (const c2 of s) {
            if (peek() !== c2)
              throw invalidChar(read3());
            read3();
          }
        }
        function unicodeEscape() {
          let buffer2 = "", count = 4;
          for (; count-- > 0; ) {
            const c2 = peek();
            if (!util.isHexDigit(c2))
              throw invalidChar(read3());
            buffer2 += read3();
          }
          return String.fromCodePoint(parseInt(buffer2, 16));
        }
        const parseStates = { start() {
          if ("eof" === token.type)
            throw invalidEOF();
          push();
        }, beforePropertyName() {
          switch (token.type) {
            case "identifier":
            case "string":
              return key = token.value, void (parseState = "afterPropertyName");
            case "punctuator":
              return void pop();
            case "eof":
              throw invalidEOF();
          }
        }, afterPropertyName() {
          if ("eof" === token.type)
            throw invalidEOF();
          parseState = "beforePropertyValue";
        }, beforePropertyValue() {
          if ("eof" === token.type)
            throw invalidEOF();
          push();
        }, beforeArrayValue() {
          if ("eof" === token.type)
            throw invalidEOF();
          "punctuator" !== token.type || "]" !== token.value ? push() : pop();
        }, afterPropertyValue() {
          if ("eof" === token.type)
            throw invalidEOF();
          switch (token.value) {
            case ",":
              return void (parseState = "beforePropertyName");
            case "}":
              pop();
          }
        }, afterArrayValue() {
          if ("eof" === token.type)
            throw invalidEOF();
          switch (token.value) {
            case ",":
              return void (parseState = "beforeArrayValue");
            case "]":
              pop();
          }
        }, end() {
        } };
        function push() {
          let value2;
          switch (token.type) {
            case "punctuator":
              switch (token.value) {
                case "{":
                  value2 = {};
                  break;
                case "[":
                  value2 = [];
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              value2 = token.value;
          }
          if (void 0 === root2)
            root2 = value2;
          else {
            const parent = stack[stack.length - 1];
            Array.isArray(parent) ? parent.push(value2) : Object.defineProperty(parent, key, { value: value2, writable: true, enumerable: true, configurable: true });
          }
          if (null !== value2 && "object" == typeof value2)
            stack.push(value2), parseState = Array.isArray(value2) ? "beforeArrayValue" : "beforePropertyName";
          else {
            const current2 = stack[stack.length - 1];
            parseState = null == current2 ? "end" : Array.isArray(current2) ? "afterArrayValue" : "afterPropertyValue";
          }
        }
        function pop() {
          stack.pop();
          const current2 = stack[stack.length - 1];
          parseState = null == current2 ? "end" : Array.isArray(current2) ? "afterArrayValue" : "afterPropertyValue";
        }
        function invalidChar(c2) {
          return syntaxError(void 0 === c2 ? `JSON5: invalid end of input at ${line}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
        }
        function invalidEOF() {
          return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
        }
        function invalidIdentifier() {
          return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
        }
        function formatChar(c2) {
          const replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
          if (replacements[c2])
            return replacements[c2];
          if (c2 < " ") {
            const hexString = c2.charCodeAt(0).toString(16);
            return "\\x" + ("00" + hexString).substring(hexString.length);
          }
          return c2;
        }
        function syntaxError(message) {
          const err = new SyntaxError(message);
          return err.lineNumber = line, err.columnNumber = column, err;
        }
        const JSON5 = { parse: function(text, reviver) {
          source = String(text), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key = void 0, root2 = void 0;
          do {
            token = lex(), parseStates[parseState]();
          } while ("eof" !== token.type);
          return "function" == typeof reviver ? internalize({ "": root2 }, "", reviver) : root2;
        }, stringify: function(value2, replacer, space) {
          const stack2 = [];
          let propertyList, replacerFunc, quote, indent = "", gap = "";
          if (null == replacer || "object" != typeof replacer || Array.isArray(replacer) || (space = replacer.space, quote = replacer.quote, replacer = replacer.replacer), "function" == typeof replacer)
            replacerFunc = replacer;
          else if (Array.isArray(replacer)) {
            propertyList = [];
            for (const v of replacer) {
              let item;
              "string" == typeof v ? item = v : ("number" == typeof v || v instanceof String || v instanceof Number) && (item = String(v)), void 0 !== item && propertyList.indexOf(item) < 0 && propertyList.push(item);
            }
          }
          return space instanceof Number ? space = Number(space) : space instanceof String && (space = String(space)), "number" == typeof space ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : "string" == typeof space && (gap = space.substr(0, 10)), serializeProperty("", { "": value2 });
          function serializeProperty(key2, holder) {
            let value3 = holder[key2];
            switch (null != value3 && ("function" == typeof value3.toJSON5 ? value3 = value3.toJSON5(key2) : "function" == typeof value3.toJSON && (value3 = value3.toJSON(key2))), replacerFunc && (value3 = replacerFunc.call(holder, key2, value3)), value3 instanceof Number ? value3 = Number(value3) : value3 instanceof String ? value3 = String(value3) : value3 instanceof Boolean && (value3 = value3.valueOf()), value3) {
              case null:
                return "null";
              case true:
                return "true";
              case false:
                return "false";
            }
            return "string" == typeof value3 ? quoteString(value3) : "number" == typeof value3 ? String(value3) : "object" == typeof value3 ? Array.isArray(value3) ? function(value4) {
              if (stack2.indexOf(value4) >= 0)
                throw TypeError("Converting circular structure to JSON5");
              stack2.push(value4);
              let stepback = indent;
              indent += gap;
              let final, partial = [];
              for (let i = 0; i < value4.length; i++) {
                const propertyString = serializeProperty(String(i), value4);
                partial.push(void 0 !== propertyString ? propertyString : "null");
              }
              if (0 === partial.length)
                final = "[]";
              else if ("" === gap) {
                final = "[" + partial.join(",") + "]";
              } else {
                let separator = ",\n" + indent, properties = partial.join(separator);
                final = "[\n" + indent + properties + ",\n" + stepback + "]";
              }
              return stack2.pop(), indent = stepback, final;
            }(value3) : function(value4) {
              if (stack2.indexOf(value4) >= 0)
                throw TypeError("Converting circular structure to JSON5");
              stack2.push(value4);
              let stepback = indent;
              indent += gap;
              let final, keys2 = propertyList || Object.keys(value4), partial = [];
              for (const key3 of keys2) {
                const propertyString = serializeProperty(key3, value4);
                if (void 0 !== propertyString) {
                  let member = serializeKey(key3) + ":";
                  "" !== gap && (member += " "), member += propertyString, partial.push(member);
                }
              }
              if (0 === partial.length)
                final = "{}";
              else {
                let properties;
                if ("" === gap)
                  properties = partial.join(","), final = "{" + properties + "}";
                else {
                  let separator = ",\n" + indent;
                  properties = partial.join(separator), final = "{\n" + indent + properties + ",\n" + stepback + "}";
                }
              }
              return stack2.pop(), indent = stepback, final;
            }(value3) : void 0;
          }
          function quoteString(value3) {
            const quotes = { "'": 0.1, '"': 0.2 }, replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
            let product = "";
            for (let i = 0; i < value3.length; i++) {
              const c2 = value3[i];
              switch (c2) {
                case "'":
                case '"':
                  quotes[c2]++, product += c2;
                  continue;
                case "\0":
                  if (util.isDigit(value3[i + 1])) {
                    product += "\\x00";
                    continue;
                  }
              }
              if (replacements[c2])
                product += replacements[c2];
              else if (c2 < " ") {
                let hexString = c2.charCodeAt(0).toString(16);
                product += "\\x" + ("00" + hexString).substring(hexString.length);
              } else
                product += c2;
            }
            const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
            return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
          }
          function serializeKey(key2) {
            if (0 === key2.length)
              return quoteString(key2);
            const firstChar = String.fromCodePoint(key2.codePointAt(0));
            if (!util.isIdStartChar(firstChar))
              return quoteString(key2);
            for (let i = firstChar.length; i < key2.length; i++)
              if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i))))
                return quoteString(key2);
            return key2;
          }
        } };
        const __WEBPACK_DEFAULT_EXPORT__ = JSON5;
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/preset-typescript/package.json": (module4) => {
        "use strict";
        module4.exports = JSON.parse('{"name":"@babel/preset-typescript","version":"7.22.5","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.22.5","@babel/helper-validator-option":"^7.22.5","@babel/plugin-syntax-jsx":"^7.22.5","@babel/plugin-transform-modules-commonjs":"^7.22.5","@babel/plugin-transform-typescript":"^7.22.5"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.22.5","@babel/helper-plugin-test-runner":"^7.22.5"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json": (module4) => {
        "use strict";
        module4.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
      } }, __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (void 0 !== cachedModule)
          return cachedModule.exports;
        var module4 = __webpack_module_cache__[moduleId] = { exports: {} };
        return __webpack_modules__[moduleId].call(module4.exports, module4, module4.exports, __webpack_require__), module4.exports;
      }
      __webpack_require__.d = (exports3, definition) => {
        for (var key in definition)
          __webpack_require__.o(definition, key) && !__webpack_require__.o(exports3, key) && Object.defineProperty(exports3, key, { enumerable: true, get: definition[key] });
      }, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), __webpack_require__.r = (exports3) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(exports3, "__esModule", { value: true });
      };
      var __webpack_exports__ = {};
      (() => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, { default: () => transform });
        var lib = __webpack_require__("./node_modules/.pnpm/@babel+core@7.22.6/node_modules/@babel/core/lib/index.js"), external_url_ = __webpack_require__("url"), template_lib = __webpack_require__("./node_modules/.pnpm/@babel+template@7.22.5/node_modules/@babel/template/lib/index.js");
        function TransformImportMetaPlugin(_ctx, opts) {
          return { name: "transform-import-meta", visitor: { Program(path3) {
            const metas = [];
            if (path3.traverse({ MemberExpression(memberExpPath) {
              const { node } = memberExpPath;
              "MetaProperty" === node.object.type && "import" === node.object.meta.name && "meta" === node.object.property.name && "Identifier" === node.property.type && "url" === node.property.name && metas.push(memberExpPath);
            } }), 0 !== metas.length)
              for (const meta of metas)
                meta.replaceWith(template_lib.smart.ast`${opts.filename ? JSON.stringify((0, external_url_.pathToFileURL)(opts.filename)) : "require('url').pathToFileURL(__filename).toString()"}`);
          } } };
        }
        const replaceEnvForRuntime = (template2, property) => template2.expression.ast(`process.env.${property}`);
        function importMetaEnvPlugin({ template: template2, types: types2 }) {
          return { name: "@import-meta-env/babel", visitor: { Identifier(path3) {
            types2.isIdentifier(path3) && types2.isMemberExpression(path3.parentPath) && types2.isMemberExpression(path3.parentPath.node) && types2.isMemberExpression(path3.parentPath.node.object) && (path3.parentPath.computed || types2.isIdentifier(path3.parentPath.node.property) && types2.isIdentifier(path3.parentPath.node.object.property) && "env" === path3.parentPath.node.object.property.name && types2.isMetaProperty(path3.parentPath.node.object.object) && "meta" === path3.parentPath.node.object.object.property.name && "import" === path3.parentPath.node.object.object.meta.name && path3.parentPath.replaceWith(replaceEnvForRuntime(template2, path3.parentPath.node.property.name)));
          } } };
        }
        function transform(opts) {
          var _a, _b, _c, _d, _e, _f;
          const _opts = Object.assign(Object.assign({ babelrc: false, configFile: false, compact: false, retainLines: "boolean" != typeof opts.retainLines || opts.retainLines, filename: "", cwd: "/" }, opts.babel), { plugins: [[__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), { allowTopLevelThis: true }], [__webpack_require__("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js"), { noInterop: true }], [TransformImportMetaPlugin, { filename: opts.filename }], [__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-class-properties/lib/index.js")], [__webpack_require__("./node_modules/.pnpm/@babel+plugin-proposal-export-namespace-from@7.18.9_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-export-namespace-from/lib/index.js")], [importMetaEnvPlugin]] });
          opts.ts && (_opts.plugins.push([__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-transform-typescript/lib/index.js"), { allowDeclareFields: true }]), _opts.plugins.unshift([__webpack_require__("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.22.6/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js")], [__webpack_require__("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.22.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-decorators/lib/index.js"), { legacy: true }]), _opts.plugins.push(__webpack_require__("./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js")), _opts.plugins.push(__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.22.5_@babel+core@7.22.6/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js"))), opts.legacy && (_opts.plugins.push(__webpack_require__("./node_modules/.pnpm/@babel+plugin-proposal-nullish-coalescing-operator@7.18.6_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js")), _opts.plugins.push(__webpack_require__("./node_modules/.pnpm/@babel+plugin-proposal-optional-chaining@7.21.0_@babel+core@7.22.6/node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js"))), opts.babel && Array.isArray(opts.babel.plugins) && (null === (_a = _opts.plugins) || void 0 === _a || _a.push(...opts.babel.plugins));
          try {
            return { code: (null === (_b = (0, lib.transformSync)(opts.source, _opts)) || void 0 === _b ? void 0 : _b.code) || "" };
          } catch (error) {
            return { error, code: "exports.__JITI_ERROR__ = " + JSON.stringify({ filename: opts.filename, line: (null === (_c = error.loc) || void 0 === _c ? void 0 : _c.line) || 0, column: (null === (_d = error.loc) || void 0 === _d ? void 0 : _d.column) || 0, code: null === (_e = error.code) || void 0 === _e ? void 0 : _e.replace("BABEL_", "").replace("PARSE_ERROR", "ParseError"), message: null === (_f = error.message) || void 0 === _f ? void 0 : _f.replace("/: ", "").replace(/\(.+\)\s*$/, "") }) };
          }
        }
      })(), module3.exports = __webpack_exports__.default;
    })();
  }
});

// node_modules/jiti/lib/index.js
var require_lib = __commonJS({
  "node_modules/jiti/lib/index.js"(exports2, module3) {
    function onError(err) {
      throw err;
    }
    module3.exports = function(filename, opts) {
      const jiti2 = require_jiti();
      opts = { onError, ...opts };
      if (!opts.transform) {
        opts.transform = require_babel();
      }
      return jiti2(filename, opts);
    };
  }
});

// node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/merge2/index.js"(exports2, module3) {
    "use strict";
    var Stream = require_stream();
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module3.exports = merge22;
    function merge22() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/fast-glob/out/utils/fs.js
var require_fs2 = __commonJS({
  "node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/fast-glob/out/utils/path.js
var require_path2 = __commonJS({
  "node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPosixPathToPattern = exports2.convertWindowsPathToPattern = exports2.convertPathToPattern = exports2.escapePosixPath = exports2.escapeWindowsPath = exports2.escape = exports2.removeLeadingDotSegment = exports2.makeAbsolute = exports2.unixify = void 0;
    var os = require_os();
    var path3 = require_path();
    var IS_WINDOWS_PLATFORM = os.platform() === "win32";
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([(){}]|^!|[!+@](?=\())/g;
    var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path3.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
    exports2.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapePosixPath = escapePosixPath;
    exports2.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports2.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports2.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports2, module3) {
    module3.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports2, module3) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index2 = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index2 < str.length) {
        if (str[index2] === "*") {
          return true;
        }
        if (str[index2 + 1] === "?" && /[\].+)]/.test(str[index2])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index2] === "[" && str[index2 + 1] !== "]") {
          if (closeSquareIndex < index2) {
            closeSquareIndex = str.indexOf("]", index2);
          }
          if (closeSquareIndex > index2) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index2] === "{" && str[index2 + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index2);
          if (closeCurlyIndex > index2) {
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index2] === "(" && str[index2 + 1] === "?" && /[:!=]/.test(str[index2 + 2]) && str[index2 + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index2);
          if (closeParenIndex > index2) {
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index2] === "(" && str[index2 + 1] !== "|") {
          if (pipeIndex < index2) {
            pipeIndex = str.indexOf("|", index2);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index2] === "\\") {
          var open = str[index2 + 1];
          index2 += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index2);
            if (n !== -1) {
              index2 = n + 1;
            }
          }
          if (str[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index2 = 0;
      while (index2 < str.length) {
        if (/[*?{}()[\]]/.test(str[index2])) {
          return true;
        }
        if (str[index2] === "\\") {
          var open = str[index2 + 1];
          index2 += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index2);
            if (n !== -1) {
              index2 = n + 1;
            }
          }
          if (str[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    module3.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports2, module3) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require_path().posix.dirname;
    var isWin32 = require_os().platform() === "win32";
    var slash2 = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby2 = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module3.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash2) < 0) {
        str = str.replace(backslash, slash2);
      }
      if (enclosure.test(str)) {
        str += slash2;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby2.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat2 = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat2(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat2(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports2, module3) {
    "use strict";
    var utils = require_utils();
    module3.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports2, module3) {
    "use strict";
    module3.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports2, module3) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value2, tok, options) {
      if (!tok.isPadded) {
        return value2;
      }
      let diff2 = Math.abs(tok.maxLen - String(value2).length);
      let relax = options.relaxZeros !== false;
      switch (diff2) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff2}}` : `0{${diff2}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module3.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports2, module3) {
    "use strict";
    var util = require_util();
    var toRegexRange = require_to_regex_range();
    var isObject4 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value2) => toNumber === true ? Number(value2) : String(value2);
    };
    var isValidValue = (value2) => {
      return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value2 = `${input}`;
      let index2 = -1;
      if (value2[0] === "-")
        value2 = value2.slice(1);
      if (value2 === "0")
        return false;
      while (value2[++index2] === "0")
        ;
      return index2 > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format2 = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index2 = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format2(a, index2), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index2++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format2 = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index2 = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format2(a, index2));
        a = descending ? a - step : a + step;
        index2++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject4(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject4(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module3.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports2, module3) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module3.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports2, module3) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue2 = "", stash = "", enclose = false) => {
      let result = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length)
        return queue2;
      if (!queue2.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue2) {
        if (Array.isArray(item)) {
          for (let value2 of item) {
            result.push(append(value2, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue2 = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue2;
      };
      return utils.flatten(walk(ast));
    };
    module3.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/braces/lib/constants.js"(exports2, module3) {
    "use strict";
    module3.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports2, module3) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse5 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index2 = 0;
      let depth = 0;
      let value2;
      let memo = {};
      const advance2 = () => input[index2++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index2 < length) {
        block = stack[stack.length - 1];
        value2 = advance2();
        if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value2 === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value2 : "") + advance2() });
          continue;
        }
        if (value2 === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index2 < length && (next = advance2())) {
            value2 += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value2 += advance2();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value: value2 });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value: value2 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
          let open = value2;
          let next;
          if (options.keepQuotes !== true) {
            value2 = "";
          }
          while (index2 < length && (next = advance2())) {
            if (next === CHAR_BACKSLASH) {
              value2 += next + advance2();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value2 += next;
              break;
            }
            value2 += next;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value: value2 });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value: value2 });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value: value2 });
          block.commas++;
          continue;
        }
        if (value2 === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value: value2 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value2;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value2;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value: value2 });
          continue;
        }
        push({ type: "text", value: value2 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index3 = parent.nodes.indexOf(block);
          parent.nodes.splice(index3, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module3.exports = parse5;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports2, module3) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse5 = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse5(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module3.exports = braces;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports2, module3) {
    "use strict";
    var path3 = require_path();
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module3.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path3.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path3 = require_path();
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path3.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports2, module3) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants3();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index2 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index2 >= length;
      const peek = () => str.charCodeAt(index2 + 1);
      const advance2 = () => {
        prev = code;
        return str.charCodeAt(++index2);
      };
      while (index2 < length) {
        code = advance2();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance2();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance2())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance2()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index2);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index2 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index2 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance2())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance2();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance2())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance2())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance2();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value2 = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value2;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value2 !== "") {
            parts.push(value2);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value2 = input.slice(prevIndex + 1);
          parts.push(value2);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value2;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module3.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports2, module3) {
    "use strict";
    var constants = require_constants3();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value2 = `[${args.join("-")}]`;
      try {
        new RegExp(value2);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value2;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse5 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value2;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance2 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value3 = "", num = 0) => {
        state.consumed += value3;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance2();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value3) => {
        const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value3, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance2(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse5(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value: value2, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m2, esc, chars, first, rest, index2) => {
          if (first === "\\") {
            backslashes = true;
            return m2;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index2 === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m2 : `\\${m2}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m2) => {
              return m2.length % 2 === 0 ? "\\\\" : m2 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value2 = advance2();
        if (value2 === "\0") {
          continue;
        }
        if (value2 === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value2 += "\\";
            push({ type: "text", value: value2 });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value2 += "\\";
            }
          }
          if (opts.unescape === true) {
            value2 = advance2();
          } else {
            value2 += advance2();
          }
          if (state.brackets === 0) {
            push({ type: "text", value: value2 });
            continue;
          }
        }
        if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value2 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance2();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
            value2 = `\\${value2}`;
          }
          if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value2 = `\\${value2}`;
          }
          if (opts.posix === true && value2 === "!" && prev.value === "[") {
            value2 = "^";
          }
          prev.value += value2;
          append({ value: value2 });
          continue;
        }
        if (state.quotes === 1 && value2 !== '"') {
          value2 = utils.escapeRegex(value2);
          prev.value += value2;
          append({ value: value2 });
          continue;
        }
        if (value2 === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value: value2 });
          }
          continue;
        }
        if (value2 === "(") {
          increment("parens");
          push({ type: "paren", value: value2 });
          continue;
        }
        if (value2 === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value2 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value2 = `\\${value2}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value: value2 });
          continue;
        }
        if (value2 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value2 = `/${value2}`;
          }
          prev.value += value2;
          append({ value: value2 });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value2 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value: value2,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value2 === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value: value2, output: value2 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value2 = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value: value2, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value2 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === ",") {
          let output = value2;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value: value2, output });
          continue;
        }
        if (value2 === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value: value2, output: SLASH_LITERAL });
          continue;
        }
        if (value2 === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value2;
            prev.value += value2;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value: value2, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value: value2, output: DOT_LITERAL });
          continue;
        }
        if (value2 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value2);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value2;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value2}`;
            }
            push({ type: "text", value: value2, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value: value2, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value: value2, output: QMARK });
          continue;
        }
        if (value2 === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value2);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value2 === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value2);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value: value2, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value: value2 });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value2 === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value: value2, output: "" });
            continue;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 !== "*") {
          if (value2 === "$" || value2 === "^") {
            value2 = `\\${value2}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value2 += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value2;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value2);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value2);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value2);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value: value2, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value: value2, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value2;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value2;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value2 + advance2());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value2 + advance2());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value2;
          state.output += prev.output;
          state.globstar = true;
          consume(value2);
          continue;
        }
        const token = { type: "star", value: value2, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value2;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse5.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module3.exports = parse5;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module3) {
    "use strict";
    var path3 = require_path();
    var scan = require_scan();
    var parse5 = require_parse2();
    var utils = require_utils2();
    var constants = require_constants3();
    var isObject4 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject4(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format2 = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format2 ? format2(input) : input;
      if (match === false) {
        output = format2 ? format2(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path3.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse5(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse5.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse5(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module3.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports2, module3) {
    "use strict";
    module3.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports2, module3) {
    "use strict";
    var util = require_util();
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys2 = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys2)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module3.exports = micromatch;
  }
});

// node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeDuplicateSlashes = exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path3 = require_path();
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern2(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern2(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern2;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern2(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern2(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern2;
    function isPositivePattern(pattern) {
      return !isNegativePattern2(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern2);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename2 = path3.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename2);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch.braces(pattern, { expand: true, nodupes: true });
      patterns.sort((a, b) => a.length - b.length);
      return patterns.filter((pattern2) => pattern2 !== "");
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/fast-glob/out/utils/stream.js
var require_stream2 = __commonJS({
  "node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var merge22 = require_merge2();
    function merge(streams) {
      const mergedStream = merge22(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs4 = require_fs2();
    exports2.fs = fs4;
    var path3 = require_path2();
    exports2.path = path3;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream2();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  }
});

// node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils3();
    function generate2(input, settings) {
      const patterns = processPatterns(input, settings);
      const ignore2 = processPatterns(settings.ignore, settings);
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore2);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate2;
    function processPatterns(input, settings) {
      let patterns = input;
      if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
      }
      if (settings.baseNameMatch) {
        patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
      }
      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore2) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore2);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read3(path3, settings, callback) {
      settings.fs.lstat(path3, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path3, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read3;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read3(path3, settings) {
      const lstat = settings.fs.lstatSync(path3);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path3);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read3;
  }
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs4 = require_fs();
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs4.lstat,
      stat: fs4.stat,
      lstatSync: fs4.lstatSync,
      statSync: fs4.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs4 = require_fs3();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs4.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path3, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path3, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path3, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync3(path3, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path3, settings);
    }
    exports2.statSync = statSync3;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module3) {
    var promise;
    module3.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports2, module3) {
    module3.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys2;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys2 = Object.keys(tasks);
        results = {};
        pending = keys2.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys2) {
        keys2.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = void 0;
    var fs4 = require_fs4();
    exports2.fs = fs4;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    var common2 = require_common();
    function read3(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read3;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common2.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path3 = common2.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path3, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path: path3,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    var common2 = require_common();
    function read3(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read3;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common2.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common2.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs5 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs4 = require_fs();
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs4.lstat,
      stat: fs4.stat,
      lstatSync: fs4.lstatSync,
      statSync: fs4.statSync,
      readdir: fs4.readdir,
      readdirSync: fs4.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require_path();
    var fsStat = require_out();
    var fs4 = require_fs5();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs4.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path3.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path3, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path3, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path3, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path3, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path3, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports2, module3) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current2 = head;
        if (current2.next) {
          head = current2.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current2.next = null;
        return current2;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module3.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports2, module3) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current2 = queueHead;
        var counter = 0;
        while (current2) {
          current2 = current2.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current2 = queueHead;
        var tasks = [];
        while (current2) {
          tasks.push(current2.value);
          current2 = current2.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value2, done) {
        var current2 = cache.get();
        current2.context = context;
        current2.release = release;
        current2.value = value2;
        current2.callback = done || noop;
        current2.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current2;
            queueTail = current2;
          } else {
            queueHead = current2;
            queueTail = current2;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current2.value, current2.worked);
        }
      }
      function unshift(value2, done) {
        var current2 = cache.get();
        current2.context = context;
        current2.release = release;
        current2.value = value2;
        current2.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current2.next = queueHead;
            queueHead = current2;
          } else {
            queueHead = current2;
            queueTail = current2;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current2.value, current2.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue2 = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue2.push;
      var unshiftCb = queue2.unshift;
      queue2.push = push;
      queue2.unshift = unshift;
      queue2.drained = drained;
      return queue2;
      function push(value2) {
        var p = new Promise(function(resolve3, reject) {
          pushCb(value2, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve3(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value2) {
        var p = new Promise(function(resolve3, reject) {
          unshiftCb(value2, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve3(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue2.idle()) {
          return new Promise(function(resolve3) {
            resolve3();
          });
        }
        var previousDrain = queue2.drain;
        var p = new Promise(function(resolve3) {
          queue2.drain = function() {
            previousDrain();
            resolve3();
          };
        });
        return p;
      }
    }
    module3.exports = fastqueue;
    module3.exports.promise = queueAsPromised;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value2) {
      return filter === null || filter(value2);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common2 = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common2.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common2 = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common2.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common2.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common2.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require_stream();
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common2 = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common2.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common2.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common2.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require_path();
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path3.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream3();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider2 = new sync_1.default(directory, settings);
      return provider2.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider2 = new stream_1.default(directory, settings);
      return provider2.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require_path();
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path3.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/fast-glob/out/readers/stream.js
var require_stream4 = __commonJS({
  "node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require_stream();
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root2, options) {
        return this._walkStream(root2, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index2, _enc, done) => {
          return this._getEntry(filepaths[index2], patterns[index2], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index2 === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve3, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve3(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/fast-glob/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream4();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root2, options) {
        return new Promise((resolve3, reject) => {
          this._walkAsync(root2, options, (error, entries) => {
            if (error === null) {
              resolve3(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve3, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve3(entries));
        });
      }
    };
    exports2.default = ReaderAsync;
  }
});

// node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index2) => {
            const segment = pattern.segments[index2];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory2 = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory2);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory2) {
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory2) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports2.default = EntryFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports2.default = EntryTransformer;
  }
});

// node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require_path();
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path3.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});

// node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root2 = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root2, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root2, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// node_modules/fast-glob/out/providers/stream.js
var require_stream5 = __commonJS({
  "node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require_stream();
    var stream_2 = require_stream4();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root2, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root2, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root2, options) {
        return this._walkSync(root2, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root2, task, options);
        return entries.map(options.transform);
      }
      api(root2, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs4 = require_fs();
    var os = require_os();
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs4.lstat,
      lstatSync: fs4.lstatSync,
      stat: fs4.stat,
      statSync: fs4.statSync,
      readdir: fs4.readdir,
      readdirSync: fs4.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
        this.ignore = [].concat(this.ignore);
      }
      _getValue(option, value2) {
        return option === void 0 ? value2 : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/fast-glob/out/index.js"(exports2, module3) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async6();
    var stream_1 = require_stream5();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput2(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync;
      FastGlob2.globStream = stream;
      FastGlob2.async = FastGlob2;
      function sync(source, options) {
        assertPatternsInput2(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput2(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks2(source, options) {
        assertPatternsInput2(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks2;
      function isDynamicPattern2(source, options) {
        assertPatternsInput2(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source) {
        assertPatternsInput2(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput2(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix;
      (function(posix2) {
        function escapePath2(source) {
          assertPatternsInput2(source);
          return utils.path.escapePosixPath(source);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput2(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
      let win32;
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput2(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput2(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider2 = new _Provider(settings);
      return tasks.map(provider2.read, provider2);
    }
    function assertPatternsInput2(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module3.exports = FastGlob;
  }
});

// node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/path-type/index.js"(exports2) {
    "use strict";
    var { promisify } = require_util();
    var fs4 = require_fs();
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs4[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs4[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/dir-glob/index.js
var require_dir_glob = __commonJS({
  "node_modules/dir-glob/index.js"(exports2, module3) {
    "use strict";
    var path3 = require_path();
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path3.isAbsolute(pth) ? pth : path3.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path3.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path3.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path3.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path3.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path3.posix.join(directory, "**")];
    };
    module3.exports = async (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory2 = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory2 ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module3.exports.sync = (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  }
});

// node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports2, module3) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object, key, value2) => Object.defineProperty(object, key, { value: value2 });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index2, str) => index2 + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current2) => prev.replace(current2[0], current2[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path3, originalPath, doThrow) => {
      if (!isString(path3)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path3) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path3)) {
        const r2 = "`path.relative()`d";
        return doThrow(
          `path should be a ${r2} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path3) => REGEX_TEST_INVALID_PATH.test(path3);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path3, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path3);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path3 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path3,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path3, cache, checkUnignored, slices);
      }
      _t(path3, cache, checkUnignored, slices) {
        if (path3 in cache) {
          return cache[path3];
        }
        if (!slices) {
          slices = path3.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path3] = this._testOne(path3, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path3] = parent.ignored ? parent : this._testOne(path3, checkUnignored);
      }
      ignores(path3) {
        return this._test(path3, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path3) => !this.ignores(path3);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path3) {
        return this._test(path3, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path3) => checkPath(path3 && checkPath.convert(path3), path3, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module3.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path3) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path3) || isNotRelative(path3);
    }
  }
});

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports2, module3) {
    module3.exports = {
      name: "dotenv",
      version: "16.3.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://github.com/motdotla/dotenv?sponsor=1",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module3) {
    var fs4 = require_fs();
    var path3 = require_path();
    var os = require_os();
    var crypto = require_crypto();
    var packageJson = require_package();
    var version2 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse5(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value2 = match[2] || "";
        value2 = value2.trim();
        const maybeQuote = value2[0];
        value2 = value2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value2 = value2.replace(/\\n/g, "\n");
          value2 = value2.replace(/\\r/g, "\r");
        }
        obj[key] = value2;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      }
      const keys2 = _dotenvKey(options).split(",");
      const length = keys2.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys2[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version2}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version2}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version2}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          throw new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        throw new Error("INVALID_DOTENV_KEY: Missing key part");
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        throw new Error("INVALID_DOTENV_KEY: Missing environment part");
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let dotenvPath = path3.resolve(process.cwd(), ".env");
      if (options && options.path && options.path.length > 0) {
        dotenvPath = options.path;
      }
      return dotenvPath.endsWith(".vault") ? dotenvPath : `${dotenvPath}.vault`;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path3.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      let dotenvPath = path3.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options) {
        if (options.path != null) {
          dotenvPath = _resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
      }
      try {
        const parsed = DotenvModule.parse(fs4.readFileSync(dotenvPath, { encoding }));
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return { parsed };
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${dotenvPath} ${e.message}`);
        }
        return { error: e };
      }
    }
    function config(options) {
      const vaultPath = _vaultPath(options);
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      if (!fs4.existsSync(vaultPath)) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.slice(0, 12);
      const authTag = ciphertext.slice(-16);
      ciphertext = ciphertext.slice(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const msg = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
          throw new Error(msg);
        } else if (decryptionFailed) {
          const msg = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
          throw new Error(msg);
        } else {
          console.error("Error: ", error.code);
          console.error("Error: ", error.message);
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse5,
      populate
    };
    module3.exports.configDotenv = DotenvModule.configDotenv;
    module3.exports._configVault = DotenvModule._configVault;
    module3.exports._parseVault = DotenvModule._parseVault;
    module3.exports.config = DotenvModule.config;
    module3.exports.decrypt = DotenvModule.decrypt;
    module3.exports.parse = DotenvModule.parse;
    module3.exports.populate = DotenvModule.populate;
    module3.exports = DotenvModule;
  }
});

// node_modules/flat/index.js
var require_flat = __commonJS({
  "node_modules/flat/index.js"(exports2, module3) {
    module3.exports = flatten;
    flatten.flatten = flatten;
    flatten.unflatten = unflatten;
    function isBuffer2(obj) {
      return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function keyIdentity(key) {
      return key;
    }
    function flatten(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const maxDepth = opts.maxDepth;
      const transformKey = opts.transformKey || keyIdentity;
      const output = {};
      function step(object, prev, currentDepth) {
        currentDepth = currentDepth || 1;
        Object.keys(object).forEach(function(key) {
          const value2 = object[key];
          const isarray = opts.safe && Array.isArray(value2);
          const type = Object.prototype.toString.call(value2);
          const isbuffer = isBuffer2(value2);
          const isobject = type === "[object Object]" || type === "[object Array]";
          const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
          if (!isarray && !isbuffer && isobject && Object.keys(value2).length && (!opts.maxDepth || currentDepth < maxDepth)) {
            return step(value2, newKey, currentDepth + 1);
          }
          output[newKey] = value2;
        });
      }
      step(target);
      return output;
    }
    function unflatten(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const overwrite = opts.overwrite || false;
      const transformKey = opts.transformKey || keyIdentity;
      const result = {};
      const isbuffer = isBuffer2(target);
      if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
        return target;
      }
      function getkey(key) {
        const parsedKey = Number(key);
        return isNaN(parsedKey) || key.indexOf(".") !== -1 || opts.object ? key : parsedKey;
      }
      function addKeys(keyPrefix, recipient, target2) {
        return Object.keys(target2).reduce(function(result2, key) {
          result2[keyPrefix + delimiter + key] = target2[key];
          return result2;
        }, recipient);
      }
      function isEmpty(val) {
        const type = Object.prototype.toString.call(val);
        const isArray3 = type === "[object Array]";
        const isObject4 = type === "[object Object]";
        if (!val) {
          return true;
        } else if (isArray3) {
          return !val.length;
        } else if (isObject4) {
          return !Object.keys(val).length;
        }
      }
      target = Object.keys(target).reduce(function(result2, key) {
        const type = Object.prototype.toString.call(target[key]);
        const isObject4 = type === "[object Object]" || type === "[object Array]";
        if (!isObject4 || isEmpty(target[key])) {
          result2[key] = target[key];
          return result2;
        } else {
          return addKeys(
            key,
            result2,
            flatten(target[key], opts)
          );
        }
      }, {});
      Object.keys(target).forEach(function(key) {
        const split = key.split(delimiter).map(transformKey);
        let key1 = getkey(split.shift());
        let key2 = getkey(split[0]);
        let recipient = result;
        while (key2 !== void 0) {
          if (key1 === "__proto__") {
            return;
          }
          const type = Object.prototype.toString.call(recipient[key1]);
          const isobject = type === "[object Object]" || type === "[object Array]";
          if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
            return;
          }
          if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
            recipient[key1] = typeof key2 === "number" && !opts.object ? [] : {};
          }
          recipient = recipient[key1];
          if (split.length > 0) {
            key1 = getkey(split.shift());
            key2 = getkey(split[0]);
          }
        }
        recipient[key1] = unflatten(target[key], opts);
      });
      return result;
    }
  }
});

// node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/index.js"(exports2, module3) {
    "use strict";
    var fs4 = require_fs();
    var { Readable } = require_stream();
    var sysPath = require_path();
    var { promisify } = require_util();
    var picomatch = require_picomatch2();
    var readdir = promisify(fs4.readdir);
    var stat = promisify(fs4.stat);
    var lstat = promisify(fs4.lstat);
    var realpath = promisify(fs4.realpath);
    var BANG = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
    var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    var normalizeFilter = (filter) => {
      if (filter === void 0)
        return;
      if (typeof filter === "function")
        return filter;
      if (typeof filter === "string") {
        const glob = picomatch(filter.trim());
        return (entry) => glob(entry.basename);
      }
      if (Array.isArray(filter)) {
        const positive = [];
        const negative = [];
        for (const item of filter) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG) {
            negative.push(picomatch(trimmed.slice(1)));
          } else {
            positive.push(picomatch(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry) => positive.some((f) => f(entry.basename)) && !negative.some((f) => f(entry.basename));
          }
          return (entry) => !negative.some((f) => f(entry.basename));
        }
        return (entry) => positive.some((f) => f(entry.basename));
      }
    };
    var ReaddirpStream = class extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path3) => true,
          directoryFilter: (path3) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options.highWaterMark || 4096
        });
        const opts = { ...ReaddirpStream.defaultOptions, ...options };
        const { root: root2, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        if (wantBigintFsStats) {
          this._stat = (path3) => statMethod(path3, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath.resolve(root2);
        this._isDirent = "Dirent" in fs4 && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root2, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path3, depth, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path3));
              for (const entry of await Promise.all(slice)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path3, depth) {
        let files;
        try {
          files = await readdir(path3, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path: path3 };
      }
      async _formatEntry(dirent, path3) {
        let entry;
        try {
          const basename2 = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath.resolve(sysPath.join(path3, basename2));
          entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename: basename2 };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        const stats = entry && entry[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await realpath(full);
            const entryRealPathStats = await lstat(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp = (root2, options = {}) => {
      let type = options.entryType || options.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options.type = type;
      if (!root2) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root2 !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options.root = root2;
      return new ReaddirpStream(options);
    };
    var readdirpPromise = (root2, options = {}) => {
      return new Promise((resolve3, reject) => {
        const files = [];
        readdirp(root2, options).on("data", (entry) => files.push(entry)).on("end", () => resolve3(files)).on("error", (error) => reject(error));
      });
    };
    readdirp.promise = readdirpPromise;
    readdirp.ReaddirpStream = ReaddirpStream;
    readdirp.default = readdirp;
    module3.exports = readdirp;
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/normalize-path/index.js"(exports2, module3) {
    module3.exports = function(path3, stripTrailing) {
      if (typeof path3 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path3 === "\\" || path3 === "/")
        return "/";
      var len = path3.length;
      if (len <= 1)
        return path3;
      var prefix = "";
      if (len > 4 && path3[3] === "\\") {
        var ch = path3[2];
        if ((ch === "?" || ch === ".") && path3.slice(0, 2) === "\\\\") {
          path3 = path3.slice(2);
          prefix = "//";
        }
      }
      var segs = path3.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "node_modules/anymatch/index.js"(exports2, module3) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var picomatch = require_picomatch2();
    var normalizePath = require_normalize_path();
    var BANG = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher, options) => {
      if (typeof matcher === "function") {
        return matcher;
      }
      if (typeof matcher === "string") {
        const glob = picomatch(matcher, options);
        return (string) => matcher === string || glob(string);
      }
      if (matcher instanceof RegExp) {
        return (string) => matcher.test(string);
      }
      return (string) => false;
    };
    var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path3 = normalizePath(_path, false);
      for (let index2 = 0; index2 < negPatterns.length; index2++) {
        const nglob = negPatterns[index2];
        if (nglob(path3)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path3].concat(args.slice(1));
      for (let index2 = 0; index2 < patterns.length; index2++) {
        const pattern = patterns[index2];
        if (isList ? pattern(...applied) : pattern(path3)) {
          return returnIndex ? index2 : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options === "boolean" ? { returnIndex: options } : options;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch.default = anymatch;
    module3.exports = anymatch;
  }
});

// node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/binary-extensions/binary-extensions.json"(exports2, module3) {
    module3.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "node_modules/binary-extensions/index.js"(exports2, module3) {
    module3.exports = require_binary_extensions();
  }
});

// node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/is-binary-path/index.js"(exports2, module3) {
    "use strict";
    var path3 = require_path();
    var binaryExtensions = require_binary_extensions2();
    var extensions = new Set(binaryExtensions);
    module3.exports = (filePath) => extensions.has(path3.extname(filePath).slice(1).toLowerCase());
  }
});

// node_modules/chokidar/lib/constants.js
var require_constants5 = __commonJS({
  "node_modules/chokidar/lib/constants.js"(exports2) {
    "use strict";
    var { sep } = require_path();
    var { platform: platform2 } = process;
    var os = require_os();
    exports2.EV_ALL = "all";
    exports2.EV_READY = "ready";
    exports2.EV_ADD = "add";
    exports2.EV_CHANGE = "change";
    exports2.EV_ADD_DIR = "addDir";
    exports2.EV_UNLINK = "unlink";
    exports2.EV_UNLINK_DIR = "unlinkDir";
    exports2.EV_RAW = "raw";
    exports2.EV_ERROR = "error";
    exports2.STR_DATA = "data";
    exports2.STR_END = "end";
    exports2.STR_CLOSE = "close";
    exports2.FSEVENT_CREATED = "created";
    exports2.FSEVENT_MODIFIED = "modified";
    exports2.FSEVENT_DELETED = "deleted";
    exports2.FSEVENT_MOVED = "moved";
    exports2.FSEVENT_CLONED = "cloned";
    exports2.FSEVENT_UNKNOWN = "unknown";
    exports2.FSEVENT_TYPE_FILE = "file";
    exports2.FSEVENT_TYPE_DIRECTORY = "directory";
    exports2.FSEVENT_TYPE_SYMLINK = "symlink";
    exports2.KEY_LISTENERS = "listeners";
    exports2.KEY_ERR = "errHandlers";
    exports2.KEY_RAW = "rawEmitters";
    exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
    exports2.DOT_SLASH = `.${sep}`;
    exports2.BACK_SLASH_RE = /\\/g;
    exports2.DOUBLE_SLASH_RE = /\/\//;
    exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports2.REPLACER_RE = /^\.[/\\]/;
    exports2.SLASH = "/";
    exports2.SLASH_SLASH = "//";
    exports2.BRACE_START = "{";
    exports2.BANG = "!";
    exports2.ONE_DOT = ".";
    exports2.TWO_DOTS = "..";
    exports2.STAR = "*";
    exports2.GLOBSTAR = "**";
    exports2.ROOT_GLOBSTAR = "/**/*";
    exports2.SLASH_GLOBSTAR = "/**";
    exports2.DIR_SUFFIX = "Dir";
    exports2.ANYMATCH_OPTS = { dot: true };
    exports2.STRING_TYPE = "string";
    exports2.FUNCTION_TYPE = "function";
    exports2.EMPTY_STR = "";
    exports2.EMPTY_FN = () => {
    };
    exports2.IDENTITY_FN = (val) => val;
    exports2.isWindows = platform2 === "win32";
    exports2.isMacos = platform2 === "darwin";
    exports2.isLinux = platform2 === "linux";
    exports2.isIBMi = os.type() === "OS400";
  }
});

// node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "node_modules/chokidar/lib/nodefs-handler.js"(exports2, module3) {
    "use strict";
    var fs4 = require_fs();
    var sysPath = require_path();
    var { promisify } = require_util();
    var isBinaryPath = require_is_binary_path();
    var {
      isWindows: isWindows3,
      isLinux: isLinux2,
      EMPTY_FN,
      EMPTY_STR,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE,
      EV_ADD,
      EV_ADD_DIR,
      EV_ERROR,
      STR_DATA,
      STR_END,
      BRACE_START,
      STAR
    } = require_constants5();
    var THROTTLE_MODE_WATCH = "watch";
    var open = promisify(fs4.open);
    var stat = promisify(fs4.stat);
    var lstat = promisify(fs4.lstat);
    var close = promisify(fs4.close);
    var fsrealpath = promisify(fs4.realpath);
    var statMethods = { lstat, stat };
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set = cont[key];
      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path3, options, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path3);
        emitRaw(rawEvent, evPath, { watchedPath: path3 });
        if (evPath && path3 !== evPath) {
          fsWatchBroadcast(
            sysPath.resolve(path3, evPath),
            KEY_LISTENERS,
            sysPath.join(path3, evPath)
          );
        }
      };
      try {
        return fs4.watch(path3, options, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path3, fullPath, options, handlers) => {
      const { listener, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(
          path3,
          options,
          listener,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path3,
          options,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher)
          return;
        watcher.on(EV_ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows3 && error.code === "EPERM") {
            try {
              const fd = await open(path3, "r");
              await close(fd);
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path3, fullPath, options, handlers) => {
      const { listener, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      let listeners = /* @__PURE__ */ new Set();
      let rawEmitters = /* @__PURE__ */ new Set();
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        listeners = cont.listeners;
        rawEmitters = cont.rawEmitters;
        fs4.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options,
          watcher: fs4.watchFile(fullPath, options, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path3, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs4.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path3, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path3);
        const basename2 = sysPath.basename(path3);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename2);
        const absolutePath = sysPath.resolve(path3);
        const options = { persistent: opts.persistent };
        if (!listener)
          listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          options.interval = opts.enableBinaryInterval && isBinaryPath(basename2) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path3, absolutePath, options, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path3, absolutePath, options, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname3 = sysPath.dirname(file);
        const basename2 = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname3);
        let prevStats = stats;
        if (parent.has(basename2))
          return;
        const listener = async (path3, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat(file);
              if (this.fsw.closed)
                return;
              const at2 = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats2);
              }
              if (isLinux2 && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path3);
                prevStats = newStats2;
                this.fsw._addPathCloser(path3, this._watchWithNodeFs(file, listener));
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname3, basename2);
            }
          } else if (parent.has(basename2)) {
            const at2 = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD, file, 0))
            return;
          this.fsw._emit(EV_ADD, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry, directory, path3, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path3);
          } catch (e) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE, path3, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD, path3, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, EMPTY_STR);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current2 = /* @__PURE__ */ new Set();
        let stream = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry),
          depth: 0
        }).on(STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const item = entry.path;
          let path3 = sysPath.join(directory, item);
          current2.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path3, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path3 = sysPath.join(dir, sysPath.relative(dir, path3));
            this._addToNodeFs(path3, initialAdd, wh, depth + 1);
          }
        }).on(EV_ERROR, this._boundHandleError);
        return new Promise(
          (resolve3) => stream.once(STR_END, () => {
            if (this.fsw.closed) {
              stream = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve3();
            previous.getChildren().filter((item) => {
              return item !== directory && !current2.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path3, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path3) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path3, depth);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path3.includes(STAR) && !path3.includes(BRACE_START);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path3);
            const targetPath = follow ? await fsrealpath(path3) : path3;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path3) : path3;
            if (this.fsw.closed)
              return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path3, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path3), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path3, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path3;
          }
        }
      }
    };
    module3.exports = NodeFsHandler;
  }
});

// vite:cjs-external-facade:fsevents
import * as m from "fsevents";
var require_fsevents = __commonJS({
  "vite:cjs-external-facade:fsevents"(exports2, module3) {
    module3.exports = m;
  }
});

// node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "node_modules/chokidar/lib/fsevents-handler.js"(exports2, module3) {
    "use strict";
    var fs4 = require_fs();
    var sysPath = require_path();
    var { promisify } = require_util();
    var fsevents;
    try {
      fsevents = require_fsevents();
    } catch (error) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj = Number.parseInt(mtch[1], 10);
        const min = Number.parseInt(mtch[2], 10);
        if (maj === 8 && min < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD,
      EV_CHANGE,
      EV_ADD_DIR,
      EV_UNLINK,
      EV_ERROR,
      STR_DATA,
      STR_END,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      // FSEVENT_CLONED,
      FSEVENT_UNKNOWN,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE,
      EMPTY_FN,
      IDENTITY_FN
    } = require_constants5();
    var Depth = (value2) => isNaN(value2) ? {} : { depth: value2 };
    var stat = promisify(fs4.stat);
    var lstat = promisify(fs4.lstat);
    var realpath = promisify(fs4.realpath);
    var statMethods = { stat, lstat };
    var FSEventsWatchers = /* @__PURE__ */ new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path3, callback) => {
      const stop = fsevents.watch(path3, callback);
      return { stop };
    };
    function setFSEventsListener(path3, realPath, listener, rawEmitter) {
      let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
      const parentPath = sysPath.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath.resolve(path3);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
          listener(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list) => {
              list(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate = (path3) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path3) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path3, root2) => {
      let i = 0;
      while (!path3.indexOf(root2) && (path3 = sysPath.dirname(path3)) !== root2)
        i++;
      return i;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler = class {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path3, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path3, stats)) {
          ipaths.add(path3);
          if (stats && stats.isDirectory()) {
            ipaths.add(path3 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path3);
        ipaths.delete(path3 + ROOT_GLOBSTAR);
      }
      addOrChange(path3, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path3, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path3, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat(path3);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path3, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path3, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error) {
          if (error.code === "EACCES") {
            this.addOrChange(path3, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path3, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path3, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path3))
          return;
        if (event === EV_UNLINK) {
          const isDirectory2 = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory2 || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory2);
          }
        } else {
          if (event === EV_ADD) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path3);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path3, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path3);
          if (eventName === EV_ADD_DIR)
            this._addToFsEvents(path3, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path3 = transform(sysPath.join(
            watchPath,
            sysPath.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path3))
            return;
          const parent = sysPath.dirname(path3);
          const item = sysPath.basename(path3);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path3 : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE) {
              let stats;
              try {
                stats = await stat(path3);
              } catch (error) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path3, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path3, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path3, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path3, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path3, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path3, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path3) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path3.replace(linkTarget, linkPath);
            } else if (path3 !== DOT_SLASH) {
              aliasedPath = sysPath.join(linkPath, path3);
            }
            return transform(aliasedPath);
          }, false, curDepth);
        } catch (error) {
          if (this.fsw._handleError(error)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp2 = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp2));
        const base = sysPath.basename(pp2);
        if (isDir)
          this.fsw._getWatchedDir(pp2);
        if (dirObj.has(base))
          return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp2, stats);
        }
      }
      initWatch(realPath, path3, wh, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path3, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path3, transform, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path3);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter)
              this.emitAdd(processPath(path3), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry) => wh.filterPath(entry),
              directoryFilter: (entry) => wh.filterDir(entry),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry.stats.isDirectory() && !wh.filterPath(entry))
                return;
              const joinedPath = sysPath.join(wh.watchPath, entry.path);
              const { fullPath } = entry;
              if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error) {
          if (!error || this.fsw._handleError(error)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform === FUNCTION_TYPE) {
            this.initWatch(void 0, path3, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh.watchPath);
            } catch (e) {
            }
            this.initWatch(realPath, path3, wh, processPath);
          }
        }
      }
    };
    module3.exports = FsEventsHandler;
    module3.exports.canUse = canUse;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports2) {
    "use strict";
    var { EventEmitter } = require_events();
    var fs4 = require_fs();
    var sysPath = require_path();
    var { promisify } = require_util();
    var readdirp = require_readdirp();
    var anymatch = require_anymatch().default;
    var globParent = require_glob_parent();
    var isGlob = require_is_glob();
    var braces = require_braces();
    var normalizePath = require_normalize_path();
    var NodeFsHandler = require_nodefs_handler();
    var FsEventsHandler = require_fsevents_handler();
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows: isWindows3,
      isMacos,
      isIBMi
    } = require_constants5();
    var stat = promisify(fs4.stat);
    var readdir = promisify(fs4.readdir);
    var arrify = (value2 = []) => Array.isArray(value2) ? value2 : [value2];
    var flatten = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path3) => toUnix(sysPath.normalize(toUnix(path3)));
    var normalizeIgnored = (cwd = EMPTY_STR) => (path3) => {
      if (typeof path3 !== STRING_TYPE)
        return path3;
      return normalizePathToUnix(sysPath.isAbsolute(path3) ? path3 : sysPath.join(cwd, path3));
    };
    var getAbsolutePath = (path3, cwd) => {
      if (sysPath.isAbsolute(path3)) {
        return path3;
      }
      if (path3.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path3.slice(1));
      }
      return sysPath.join(cwd, path3);
    };
    var undef = (opts, key) => opts[key] === void 0;
    var DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path3, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path3 = path3.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path3;
        if (path3 === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path3, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path3);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry.fullPath;
      }
      entryPath(entry) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
        );
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path3) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path3.includes(BRACE_START) ? braces.expand(path3) : [path3];
        expandedPath.forEach((path4) => {
          parts.push(sysPath.relative(this.watchPath, path4).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    var FSWatcher = class extends EventEmitter {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path3) => {
            const absPath = getAbsolutePath(path3, cwd);
            if (disableGlobbing || !isGlob(path3)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path3) => {
          if (path3.startsWith(BANG)) {
            this._ignoredPaths.add(path3.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path3);
          this._ignoredPaths.delete(path3 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path3) => this._fsEventsHandler._addToFsEvents(path3));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path3) => {
              const res = await this._nodeFsHandler._addToNodeFs(path3, !_internal, 0, 0, _origAdd);
              if (res)
                this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path3) => {
          if (!sysPath.isAbsolute(path3) && !this._closers.has(path3)) {
            if (cwd)
              path3 = sysPath.join(cwd, path3);
            path3 = sysPath.resolve(path3);
          }
          this._closePath(path3);
          this._ignoredPaths.add(path3);
          if (this._watched.has(path3)) {
            this._ignoredPaths.add(path3 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise)
            closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path3, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows3)
          path3 = sysPath.normalize(path3);
        if (opts.cwd)
          path3 = sysPath.relative(opts.cwd, path3);
        const args = [event, path3];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path3))) {
          pw.lastChange = /* @__PURE__ */ new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path3, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path4) => {
                this.emit(...entry);
                this.emit(EV_ALL, ...entry);
                this._pendingUnlinks.delete(path4);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path3)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path3);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path3, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path3, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path3) : path3;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error);
        }
        return error || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path3, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path3);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path3);
          const count = item ? item.count : 0;
          action.delete(path3);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path3, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path3, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path3;
        if (this.options.cwd && !sysPath.isAbsolute(path3)) {
          fullPath = sysPath.join(this.options.cwd, path3);
        }
        const now = /* @__PURE__ */ new Date();
        const awaitWriteFinish = (prevStat) => {
          fs4.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path3)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(/* @__PURE__ */ new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path3).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path3);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path3);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path3)) {
          this._pendingWrites.set(path3, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path3);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path3, stats) {
        if (this.options.atomic && DOT_RE.test(path3))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path4) => typeof path4 === STRING_TYPE && !isGlob(path4)).map((path4) => path4 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path3, stats]);
      }
      _isntIgnored(path3, stat2) {
        return !this._isIgnored(path3, stat2);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path3, depth) {
        const watchPath = depth || this.options.disableGlobbing || !isGlob(path3) ? path3 : globParent(path3);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path3, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory2) {
        const path3 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path3);
        isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path3) || this._watched.has(fullPath);
        if (!this._throttle("remove", path3, 100))
          return;
        if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path3);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path3, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path3;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path3);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path3);
        this._watched.delete(fullPath);
        const eventName = isDirectory2 ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path3))
          this._emit(eventName, path3);
        if (!this.options.useFsEvents) {
          this._closePath(path3);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path3) {
        this._closeFile(path3);
        const dir = sysPath.dirname(path3);
        this._getWatchedDir(dir).remove(sysPath.basename(path3));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path3) {
        const closers = this._closers.get(path3);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path3);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path3, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path3);
        if (!list) {
          list = [];
          this._closers.set(path3, list);
        }
        list.push(closer);
      }
      _readdirp(root2, opts) {
        if (this.closed)
          return;
        const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream = readdirp(root2, options);
        this._streams.add(stream);
        stream.once(STR_CLOSE, () => {
          stream = void 0;
        });
        stream.once(STR_END, () => {
          if (stream) {
            this._streams.delete(stream);
            stream = void 0;
          }
        });
        return stream;
      }
    };
    exports2.FSWatcher = FSWatcher;
    var watch2 = (paths, options) => {
      const watcher = new FSWatcher(options);
      watcher.add(paths);
      return watcher;
    };
    exports2.watch = watch2;
  }
});

// node_modules/tapable/lib/Hook.js
var require_Hook = __commonJS({
  "node_modules/tapable/lib/Hook.js"(exports2, module3) {
    "use strict";
    var Hook = class {
      constructor(args) {
        if (!Array.isArray(args))
          args = [];
        this._args = args;
        this.taps = [];
        this.interceptors = [];
        this.call = this._call;
        this.promise = this._promise;
        this.callAsync = this._callAsync;
        this._x = void 0;
      }
      compile(options) {
        throw new Error("Abstract: should be overriden");
      }
      _createCall(type) {
        return this.compile({
          taps: this.taps,
          interceptors: this.interceptors,
          args: this._args,
          type
        });
      }
      tap(options, fn) {
        if (typeof options === "string")
          options = { name: options };
        if (typeof options !== "object" || options === null)
          throw new Error(
            "Invalid arguments to tap(options: Object, fn: function)"
          );
        options = Object.assign({ type: "sync", fn }, options);
        if (typeof options.name !== "string" || options.name === "")
          throw new Error("Missing name for tap");
        options = this._runRegisterInterceptors(options);
        this._insert(options);
      }
      tapAsync(options, fn) {
        if (typeof options === "string")
          options = { name: options };
        if (typeof options !== "object" || options === null)
          throw new Error(
            "Invalid arguments to tapAsync(options: Object, fn: function)"
          );
        options = Object.assign({ type: "async", fn }, options);
        if (typeof options.name !== "string" || options.name === "")
          throw new Error("Missing name for tapAsync");
        options = this._runRegisterInterceptors(options);
        this._insert(options);
      }
      tapPromise(options, fn) {
        if (typeof options === "string")
          options = { name: options };
        if (typeof options !== "object" || options === null)
          throw new Error(
            "Invalid arguments to tapPromise(options: Object, fn: function)"
          );
        options = Object.assign({ type: "promise", fn }, options);
        if (typeof options.name !== "string" || options.name === "")
          throw new Error("Missing name for tapPromise");
        options = this._runRegisterInterceptors(options);
        this._insert(options);
      }
      _runRegisterInterceptors(options) {
        for (const interceptor of this.interceptors) {
          if (interceptor.register) {
            const newOptions = interceptor.register(options);
            if (newOptions !== void 0)
              options = newOptions;
          }
        }
        return options;
      }
      withOptions(options) {
        const mergeOptions = (opt) => Object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);
        options = Object.assign({}, options, this._withOptions);
        const base = this._withOptionsBase || this;
        const newHook = Object.create(base);
        newHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn), newHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn);
        newHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn);
        newHook._withOptions = options;
        newHook._withOptionsBase = base;
        return newHook;
      }
      isUsed() {
        return this.taps.length > 0 || this.interceptors.length > 0;
      }
      intercept(interceptor) {
        this._resetCompilation();
        this.interceptors.push(Object.assign({}, interceptor));
        if (interceptor.register) {
          for (let i = 0; i < this.taps.length; i++)
            this.taps[i] = interceptor.register(this.taps[i]);
        }
      }
      _resetCompilation() {
        this.call = this._call;
        this.callAsync = this._callAsync;
        this.promise = this._promise;
      }
      _insert(item) {
        this._resetCompilation();
        let before;
        if (typeof item.before === "string")
          before = /* @__PURE__ */ new Set([item.before]);
        else if (Array.isArray(item.before)) {
          before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === "number")
          stage = item.stage;
        let i = this.taps.length;
        while (i > 0) {
          i--;
          const x = this.taps[i];
          this.taps[i + 1] = x;
          const xStage = x.stage || 0;
          if (before) {
            if (before.has(x.name)) {
              before.delete(x.name);
              continue;
            }
            if (before.size > 0) {
              continue;
            }
          }
          if (xStage > stage) {
            continue;
          }
          i++;
          break;
        }
        this.taps[i] = item;
      }
    };
    function createCompileDelegate(name, type) {
      return function lazyCompileHook(...args) {
        this[name] = this._createCall(type);
        return this[name](...args);
      };
    }
    Object.defineProperties(Hook.prototype, {
      _call: {
        value: createCompileDelegate("call", "sync"),
        configurable: true,
        writable: true
      },
      _promise: {
        value: createCompileDelegate("promise", "promise"),
        configurable: true,
        writable: true
      },
      _callAsync: {
        value: createCompileDelegate("callAsync", "async"),
        configurable: true,
        writable: true
      }
    });
    module3.exports = Hook;
  }
});

// node_modules/tapable/lib/HookCodeFactory.js
var require_HookCodeFactory = __commonJS({
  "node_modules/tapable/lib/HookCodeFactory.js"(exports2, module3) {
    "use strict";
    var HookCodeFactory = class {
      constructor(config) {
        this.config = config;
        this.options = void 0;
        this._args = void 0;
      }
      create(options) {
        this.init(options);
        let fn;
        switch (this.options.type) {
          case "sync":
            fn = new Function(
              this.args(),
              '"use strict";\n' + this.header() + this.content({
                onError: (err) => `throw ${err};
`,
                onResult: (result) => `return ${result};
`,
                resultReturns: true,
                onDone: () => "",
                rethrowIfPossible: true
              })
            );
            break;
          case "async":
            fn = new Function(
              this.args({
                after: "_callback"
              }),
              '"use strict";\n' + this.header() + this.content({
                onError: (err) => `_callback(${err});
`,
                onResult: (result) => `_callback(null, ${result});
`,
                onDone: () => "_callback();\n"
              })
            );
            break;
          case "promise":
            let errorHelperUsed = false;
            const content = this.content({
              onError: (err) => {
                errorHelperUsed = true;
                return `_error(${err});
`;
              },
              onResult: (result) => `_resolve(${result});
`,
              onDone: () => "_resolve();\n"
            });
            let code = "";
            code += '"use strict";\n';
            code += "return new Promise((_resolve, _reject) => {\n";
            if (errorHelperUsed) {
              code += "var _sync = true;\n";
              code += "function _error(_err) {\n";
              code += "if(_sync)\n";
              code += "_resolve(Promise.resolve().then(() => { throw _err; }));\n";
              code += "else\n";
              code += "_reject(_err);\n";
              code += "};\n";
            }
            code += this.header();
            code += content;
            if (errorHelperUsed) {
              code += "_sync = false;\n";
            }
            code += "});\n";
            fn = new Function(this.args(), code);
            break;
        }
        this.deinit();
        return fn;
      }
      setup(instance, options) {
        instance._x = options.taps.map((t) => t.fn);
      }
      /**
       * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
       */
      init(options) {
        this.options = options;
        this._args = options.args.slice();
      }
      deinit() {
        this.options = void 0;
        this._args = void 0;
      }
      header() {
        let code = "";
        if (this.needContext()) {
          code += "var _context = {};\n";
        } else {
          code += "var _context;\n";
        }
        code += "var _x = this._x;\n";
        if (this.options.interceptors.length > 0) {
          code += "var _taps = this.taps;\n";
          code += "var _interceptors = this.interceptors;\n";
        }
        for (let i = 0; i < this.options.interceptors.length; i++) {
          const interceptor = this.options.interceptors[i];
          if (interceptor.call) {
            code += `${this.getInterceptor(i)}.call(${this.args({
              before: interceptor.context ? "_context" : void 0
            })});
`;
          }
        }
        return code;
      }
      needContext() {
        for (const tap of this.options.taps)
          if (tap.context)
            return true;
        return false;
      }
      callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = "";
        let hasTapCached = false;
        for (let i = 0; i < this.options.interceptors.length; i++) {
          const interceptor = this.options.interceptors[i];
          if (interceptor.tap) {
            if (!hasTapCached) {
              code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};
`;
              hasTapCached = true;
            }
            code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});
`;
          }
        }
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};
`;
        const tap = this.options.taps[tapIndex];
        switch (tap.type) {
          case "sync":
            if (!rethrowIfPossible) {
              code += `var _hasError${tapIndex} = false;
`;
              code += "try {\n";
            }
            if (onResult) {
              code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                before: tap.context ? "_context" : void 0
              })});
`;
            } else {
              code += `_fn${tapIndex}(${this.args({
                before: tap.context ? "_context" : void 0
              })});
`;
            }
            if (!rethrowIfPossible) {
              code += "} catch(_err) {\n";
              code += `_hasError${tapIndex} = true;
`;
              code += onError("_err");
              code += "}\n";
              code += `if(!_hasError${tapIndex}) {
`;
            }
            if (onResult) {
              code += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              code += onDone();
            }
            if (!rethrowIfPossible) {
              code += "}\n";
            }
            break;
          case "async":
            let cbCode = "";
            if (onResult)
              cbCode += `(_err${tapIndex}, _result${tapIndex}) => {
`;
            else
              cbCode += `_err${tapIndex} => {
`;
            cbCode += `if(_err${tapIndex}) {
`;
            cbCode += onError(`_err${tapIndex}`);
            cbCode += "} else {\n";
            if (onResult) {
              cbCode += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              cbCode += onDone();
            }
            cbCode += "}\n";
            cbCode += "}";
            code += `_fn${tapIndex}(${this.args({
              before: tap.context ? "_context" : void 0,
              after: cbCode
            })});
`;
            break;
          case "promise":
            code += `var _hasResult${tapIndex} = false;
`;
            code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
              before: tap.context ? "_context" : void 0
            })});
`;
            code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)
`;
            code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');
`;
            code += `_promise${tapIndex}.then(_result${tapIndex} => {
`;
            code += `_hasResult${tapIndex} = true;
`;
            if (onResult) {
              code += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              code += onDone();
            }
            code += `}, _err${tapIndex} => {
`;
            code += `if(_hasResult${tapIndex}) throw _err${tapIndex};
`;
            code += onError(`_err${tapIndex}`);
            code += "});\n";
            break;
        }
        return code;
      }
      callTapsSeries({
        onError,
        onResult,
        resultReturns,
        onDone,
        doneReturns,
        rethrowIfPossible
      }) {
        if (this.options.taps.length === 0)
          return onDone();
        const firstAsync = this.options.taps.findIndex((t) => t.type !== "sync");
        const somethingReturns = resultReturns || doneReturns || false;
        let code = "";
        let current2 = onDone;
        for (let j = this.options.taps.length - 1; j >= 0; j--) {
          const i = j;
          const unroll = current2 !== onDone && this.options.taps[i].type !== "sync";
          if (unroll) {
            code += `function _next${i}() {
`;
            code += current2();
            code += `}
`;
            current2 = () => `${somethingReturns ? "return " : ""}_next${i}();
`;
          }
          const done = current2;
          const doneBreak = (skipDone) => {
            if (skipDone)
              return "";
            return onDone();
          };
          const content = this.callTap(i, {
            onError: (error) => onError(i, error, done, doneBreak),
            onResult: onResult && ((result) => {
              return onResult(i, result, done, doneBreak);
            }),
            onDone: !onResult && done,
            rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
          });
          current2 = () => content;
        }
        code += current2();
        return code;
      }
      callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        if (this.options.taps.length === 0)
          return onDone();
        const syncOnly = this.options.taps.every((t) => t.type === "sync");
        let code = "";
        if (!syncOnly) {
          code += "var _looper = () => {\n";
          code += "var _loopAsync = false;\n";
        }
        code += "var _loop;\n";
        code += "do {\n";
        code += "_loop = false;\n";
        for (let i = 0; i < this.options.interceptors.length; i++) {
          const interceptor = this.options.interceptors[i];
          if (interceptor.loop) {
            code += `${this.getInterceptor(i)}.loop(${this.args({
              before: interceptor.context ? "_context" : void 0
            })});
`;
          }
        }
        code += this.callTapsSeries({
          onError,
          onResult: (i, result, next, doneBreak) => {
            let code2 = "";
            code2 += `if(${result} !== undefined) {
`;
            code2 += "_loop = true;\n";
            if (!syncOnly)
              code2 += "if(_loopAsync) _looper();\n";
            code2 += doneBreak(true);
            code2 += `} else {
`;
            code2 += next();
            code2 += `}
`;
            return code2;
          },
          onDone: onDone && (() => {
            let code2 = "";
            code2 += "if(!_loop) {\n";
            code2 += onDone();
            code2 += "}\n";
            return code2;
          }),
          rethrowIfPossible: rethrowIfPossible && syncOnly
        });
        code += "} while(_loop);\n";
        if (!syncOnly) {
          code += "_loopAsync = true;\n";
          code += "};\n";
          code += "_looper();\n";
        }
        return code;
      }
      callTapsParallel({
        onError,
        onResult,
        onDone,
        rethrowIfPossible,
        onTap = (i, run) => run()
      }) {
        if (this.options.taps.length <= 1) {
          return this.callTapsSeries({
            onError,
            onResult,
            onDone,
            rethrowIfPossible
          });
        }
        let code = "";
        code += "do {\n";
        code += `var _counter = ${this.options.taps.length};
`;
        if (onDone) {
          code += "var _done = () => {\n";
          code += onDone();
          code += "};\n";
        }
        for (let i = 0; i < this.options.taps.length; i++) {
          const done = () => {
            if (onDone)
              return "if(--_counter === 0) _done();\n";
            else
              return "--_counter;";
          };
          const doneBreak = (skipDone) => {
            if (skipDone || !onDone)
              return "_counter = 0;\n";
            else
              return "_counter = 0;\n_done();\n";
          };
          code += "if(_counter <= 0) break;\n";
          code += onTap(
            i,
            () => this.callTap(i, {
              onError: (error) => {
                let code2 = "";
                code2 += "if(_counter > 0) {\n";
                code2 += onError(i, error, done, doneBreak);
                code2 += "}\n";
                return code2;
              },
              onResult: onResult && ((result) => {
                let code2 = "";
                code2 += "if(_counter > 0) {\n";
                code2 += onResult(i, result, done, doneBreak);
                code2 += "}\n";
                return code2;
              }),
              onDone: !onResult && (() => {
                return done();
              }),
              rethrowIfPossible
            }),
            done,
            doneBreak
          );
        }
        code += "} while(false);\n";
        return code;
      }
      args({ before, after } = {}) {
        let allArgs = this._args;
        if (before)
          allArgs = [before].concat(allArgs);
        if (after)
          allArgs = allArgs.concat(after);
        if (allArgs.length === 0) {
          return "";
        } else {
          return allArgs.join(", ");
        }
      }
      getTapFn(idx) {
        return `_x[${idx}]`;
      }
      getTap(idx) {
        return `_taps[${idx}]`;
      }
      getInterceptor(idx) {
        return `_interceptors[${idx}]`;
      }
    };
    module3.exports = HookCodeFactory;
  }
});

// node_modules/tapable/lib/SyncBailHook.js
var require_SyncBailHook = __commonJS({
  "node_modules/tapable/lib/SyncBailHook.js"(exports2, module3) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onResult: (i, result, next) => `if(${result} !== undefined) {
${onResult(
            result
          )};
} else {
${next()}}
`,
          resultReturns,
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncBailHookCodeFactory();
    var SyncBailHook = class extends Hook {
      tapAsync() {
        throw new Error("tapAsync is not supported on a SyncBailHook");
      }
      tapPromise() {
        throw new Error("tapPromise is not supported on a SyncBailHook");
      }
      compile(options) {
        factory.setup(this, options);
        return factory.create(options);
      }
    };
    module3.exports = SyncBailHook;
  }
});

// node_modules/tapable/lib/Tapable.js
var require_Tapable = __commonJS({
  "node_modules/tapable/lib/Tapable.js"(exports2, module3) {
    "use strict";
    var util = require_util();
    var SyncBailHook = require_SyncBailHook();
    function Tapable() {
      this._pluginCompat = new SyncBailHook(["options"]);
      this._pluginCompat.tap(
        {
          name: "Tapable camelCase",
          stage: 100
        },
        (options) => {
          options.names.add(
            options.name.replace(/[- ]([a-z])/g, (str, ch) => ch.toUpperCase())
          );
        }
      );
      this._pluginCompat.tap(
        {
          name: "Tapable this.hooks",
          stage: 200
        },
        (options) => {
          let hook;
          for (const name of options.names) {
            hook = this.hooks[name];
            if (hook !== void 0) {
              break;
            }
          }
          if (hook !== void 0) {
            const tapOpt = {
              name: options.fn.name || "unnamed compat plugin",
              stage: options.stage || 0
            };
            if (options.async)
              hook.tapAsync(tapOpt, options.fn);
            else
              hook.tap(tapOpt, options.fn);
            return true;
          }
        }
      );
    }
    module3.exports = Tapable;
    Tapable.addCompatLayer = function addCompatLayer(instance) {
      Tapable.call(instance);
      instance.plugin = Tapable.prototype.plugin;
      instance.apply = Tapable.prototype.apply;
    };
    Tapable.prototype.plugin = util.deprecate(function plugin(name, fn) {
      if (Array.isArray(name)) {
        name.forEach(function(name2) {
          this.plugin(name2, fn);
        }, this);
        return;
      }
      const result = this._pluginCompat.call({
        name,
        fn,
        names: /* @__PURE__ */ new Set([name])
      });
      if (!result) {
        throw new Error(
          `Plugin could not be registered at '${name}'. Hook was not found.
BREAKING CHANGE: There need to exist a hook at 'this.hooks'. To create a compatibility layer for this hook, hook into 'this._pluginCompat'.`
        );
      }
    }, "Tapable.plugin is deprecated. Use new API on `.hooks` instead");
    Tapable.prototype.apply = util.deprecate(function apply2() {
      for (var i = 0; i < arguments.length; i++) {
        arguments[i].apply(this);
      }
    }, "Tapable.apply is deprecated. Call apply on the plugin directly instead");
  }
});

// node_modules/tapable/lib/SyncHook.js
var require_SyncHook = __commonJS({
  "node_modules/tapable/lib/SyncHook.js"(exports2, module3) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncHookCodeFactory();
    var SyncHook = class extends Hook {
      tapAsync() {
        throw new Error("tapAsync is not supported on a SyncHook");
      }
      tapPromise() {
        throw new Error("tapPromise is not supported on a SyncHook");
      }
      compile(options) {
        factory.setup(this, options);
        return factory.create(options);
      }
    };
    module3.exports = SyncHook;
  }
});

// node_modules/tapable/lib/AsyncSeriesBailHook.js
var require_AsyncSeriesBailHook = __commonJS({
  "node_modules/tapable/lib/AsyncSeriesBailHook.js"(exports2, module3) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onResult: (i, result, next) => `if(${result} !== undefined) {
${onResult(
            result
          )};
} else {
${next()}}
`,
          resultReturns,
          onDone
        });
      }
    };
    var factory = new AsyncSeriesBailHookCodeFactory();
    var AsyncSeriesBailHook = class extends Hook {
      compile(options) {
        factory.setup(this, options);
        return factory.create(options);
      }
    };
    Object.defineProperties(AsyncSeriesBailHook.prototype, {
      _call: { value: void 0, configurable: true, writable: true }
    });
    module3.exports = AsyncSeriesBailHook;
  }
});

// node_modules/tapable/lib/AsyncSeriesHook.js
var require_AsyncSeriesHook = __commonJS({
  "node_modules/tapable/lib/AsyncSeriesHook.js"(exports2, module3) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onDone
        });
      }
    };
    var factory = new AsyncSeriesHookCodeFactory();
    var AsyncSeriesHook = class extends Hook {
      compile(options) {
        factory.setup(this, options);
        return factory.create(options);
      }
    };
    Object.defineProperties(AsyncSeriesHook.prototype, {
      _call: { value: void 0, configurable: true, writable: true }
    });
    module3.exports = AsyncSeriesHook;
  }
});

// node_modules/enhanced-resolve/lib/createInnerContext.js
var require_createInnerContext = __commonJS({
  "node_modules/enhanced-resolve/lib/createInnerContext.js"(exports2, module3) {
    "use strict";
    module3.exports = function createInnerContext(options, message, messageOptional) {
      let messageReported = false;
      const childContext = {
        log: (() => {
          if (!options.log)
            return void 0;
          if (!message)
            return options.log;
          const logFunction = (msg) => {
            if (!messageReported) {
              options.log(message);
              messageReported = true;
            }
            options.log("  " + msg);
          };
          return logFunction;
        })(),
        stack: options.stack,
        missing: options.missing
      };
      return childContext;
    };
  }
});

// node_modules/memory-fs/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/memory-fs/lib/normalize.js"(exports2, module3) {
    "use strict";
    module3.exports = function normalize2(path3) {
      var parts = path3.split(/(\\+|\/+)/);
      if (parts.length === 1)
        return path3;
      var result = [];
      var absolutePathStart = 0;
      for (var i = 0, sep = false; i < parts.length; i += 1, sep = !sep) {
        var part = parts[i];
        if (i === 0 && /^([A-Z]:)?$/i.test(part)) {
          result.push(part);
          absolutePathStart = 2;
        } else if (sep) {
          if (i === 1 && parts[0].length === 0 && part === "\\\\") {
            result.push(part);
          } else {
            result.push(part[0]);
          }
        } else if (part === "..") {
          switch (result.length) {
            case 0:
              result.push(part);
              break;
            case 2:
              if (result[0] !== ".") {
                i += 1;
                sep = !sep;
                result.length = absolutePathStart;
              } else {
                result.length = 0;
                result.push(part);
              }
              break;
            case 4:
              if (absolutePathStart === 0) {
                result.length -= 3;
              } else {
                i += 1;
                sep = !sep;
                result.length = 2;
              }
              break;
            default:
              result.length -= 3;
              break;
          }
        } else if (part === ".") {
          switch (result.length) {
            case 0:
              result.push(part);
              break;
            case 2:
              if (absolutePathStart === 0) {
                result.length -= 1;
              } else {
                i += 1;
                sep = !sep;
              }
              break;
            default:
              result.length -= 1;
              break;
          }
        } else if (part) {
          result.push(part);
        }
      }
      if (result.length === 1 && /^[A-Za-z]:$/.test(result[0]))
        return result[0] + "\\";
      return result.join("");
    };
  }
});

// node_modules/memory-fs/lib/join.js
var require_join = __commonJS({
  "node_modules/memory-fs/lib/join.js"(exports2, module3) {
    "use strict";
    var normalize2 = require_normalize();
    var absoluteWinRegExp = /^[A-Z]:([\\\/]|$)/i;
    var absoluteNixRegExp = /^\//i;
    module3.exports = function join2(path3, request) {
      if (!request)
        return normalize2(path3);
      if (absoluteWinRegExp.test(request))
        return normalize2(request.replace(/\//g, "\\"));
      if (absoluteNixRegExp.test(request))
        return normalize2(request);
      if (path3 == "/")
        return normalize2(path3 + request);
      if (absoluteWinRegExp.test(path3))
        return normalize2(path3.replace(/\//g, "\\") + "\\" + request.replace(/\//g, "\\"));
      if (absoluteNixRegExp.test(path3))
        return normalize2(path3 + "/" + request);
      return normalize2(path3 + "/" + request);
    };
  }
});

// node_modules/enhanced-resolve/lib/Resolver.js
var require_Resolver = __commonJS({
  "node_modules/enhanced-resolve/lib/Resolver.js"(exports2, module3) {
    "use strict";
    var util = require_util();
    var Tapable = require_Tapable();
    var SyncHook = require_SyncHook();
    var AsyncSeriesBailHook = require_AsyncSeriesBailHook();
    var AsyncSeriesHook = require_AsyncSeriesHook();
    var createInnerContext = require_createInnerContext();
    var REGEXP_NOT_MODULE = /^\.$|^\.[\\/]|^\.\.$|^\.\.[\\/]|^\/|^[A-Z]:[\\/]/i;
    var REGEXP_DIRECTORY = /[\\/]$/i;
    var memoryFsJoin = require_join();
    var memoizedJoin = /* @__PURE__ */ new Map();
    var memoryFsNormalize = require_normalize();
    function withName(name, hook) {
      hook.name = name;
      return hook;
    }
    function toCamelCase(str) {
      return str.replace(/-([a-z])/g, (str2) => str2.substr(1).toUpperCase());
    }
    var deprecatedPushToMissing = util.deprecate((set, item) => {
      set.add(item);
    }, "Resolver: 'missing' is now a Set. Use add instead of push.");
    var deprecatedResolveContextInCallback = util.deprecate((x) => {
      return x;
    }, "Resolver: The callback argument was splitted into resolveContext and callback.");
    var deprecatedHookAsString = util.deprecate((x) => {
      return x;
    }, "Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.");
    var Resolver = class extends Tapable {
      constructor(fileSystem) {
        super();
        this.fileSystem = fileSystem;
        this.hooks = {
          resolveStep: withName("resolveStep", new SyncHook(["hook", "request"])),
          noResolve: withName("noResolve", new SyncHook(["request", "error"])),
          resolve: withName(
            "resolve",
            new AsyncSeriesBailHook(["request", "resolveContext"])
          ),
          result: new AsyncSeriesHook(["result", "resolveContext"])
        };
        this._pluginCompat.tap("Resolver: before/after", (options) => {
          if (/^before-/.test(options.name)) {
            options.name = options.name.substr(7);
            options.stage = -10;
          } else if (/^after-/.test(options.name)) {
            options.name = options.name.substr(6);
            options.stage = 10;
          }
        });
        this._pluginCompat.tap("Resolver: step hooks", (options) => {
          const name = options.name;
          const stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);
          if (stepHook) {
            options.async = true;
            this.ensureHook(name);
            const fn = options.fn;
            options.fn = (request, resolverContext, callback) => {
              const innerCallback = (err, result) => {
                if (err)
                  return callback(err);
                if (result !== void 0)
                  return callback(null, result);
                callback();
              };
              for (const key in resolverContext) {
                innerCallback[key] = resolverContext[key];
              }
              fn.call(this, request, innerCallback);
            };
          }
        });
      }
      ensureHook(name) {
        if (typeof name !== "string")
          return name;
        name = toCamelCase(name);
        if (/^before/.test(name)) {
          return this.ensureHook(
            name[6].toLowerCase() + name.substr(7)
          ).withOptions({
            stage: -10
          });
        }
        if (/^after/.test(name)) {
          return this.ensureHook(
            name[5].toLowerCase() + name.substr(6)
          ).withOptions({
            stage: 10
          });
        }
        const hook = this.hooks[name];
        if (!hook) {
          return this.hooks[name] = withName(
            name,
            new AsyncSeriesBailHook(["request", "resolveContext"])
          );
        }
        return hook;
      }
      getHook(name) {
        if (typeof name !== "string")
          return name;
        name = toCamelCase(name);
        if (/^before/.test(name)) {
          return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({
            stage: -10
          });
        }
        if (/^after/.test(name)) {
          return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({
            stage: 10
          });
        }
        const hook = this.hooks[name];
        if (!hook) {
          throw new Error(`Hook ${name} doesn't exist`);
        }
        return hook;
      }
      resolveSync(context, path3, request) {
        let err, result, sync = false;
        this.resolve(context, path3, request, {}, (e, r2) => {
          err = e;
          result = r2;
          sync = true;
        });
        if (!sync)
          throw new Error(
            "Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!"
          );
        if (err)
          throw err;
        return result;
      }
      resolve(context, path3, request, resolveContext, callback) {
        if (typeof callback !== "function") {
          callback = deprecatedResolveContextInCallback(resolveContext);
        }
        const obj = {
          context,
          path: path3,
          request
        };
        const message = "resolve '" + request + "' in '" + path3 + "'";
        return this.doResolve(
          this.hooks.resolve,
          obj,
          message,
          {
            missing: resolveContext.missing,
            stack: resolveContext.stack
          },
          (err, result) => {
            if (!err && result) {
              return callback(
                null,
                result.path === false ? false : result.path + (result.query || ""),
                result
              );
            }
            const localMissing = /* @__PURE__ */ new Set();
            localMissing.push = (item) => deprecatedPushToMissing(localMissing, item);
            const log = [];
            return this.doResolve(
              this.hooks.resolve,
              obj,
              message,
              {
                log: (msg) => {
                  if (resolveContext.log) {
                    resolveContext.log(msg);
                  }
                  log.push(msg);
                },
                missing: localMissing,
                stack: resolveContext.stack
              },
              (err2, result2) => {
                if (err2)
                  return callback(err2);
                const error = new Error("Can't " + message);
                error.details = log.join("\n");
                error.missing = Array.from(localMissing);
                this.hooks.noResolve.call(obj, error);
                return callback(error);
              }
            );
          }
        );
      }
      doResolve(hook, request, message, resolveContext, callback) {
        if (typeof callback !== "function") {
          callback = deprecatedResolveContextInCallback(resolveContext);
        }
        if (typeof hook === "string") {
          const name = toCamelCase(hook);
          hook = deprecatedHookAsString(this.hooks[name]);
          if (!hook) {
            throw new Error(`Hook "${name}" doesn't exist`);
          }
        }
        if (typeof callback !== "function")
          throw new Error("callback is not a function " + Array.from(arguments));
        if (!resolveContext)
          throw new Error(
            "resolveContext is not an object " + Array.from(arguments)
          );
        const stackLine = hook.name + ": (" + request.path + ") " + (request.request || "") + (request.query || "") + (request.directory ? " directory" : "") + (request.module ? " module" : "");
        let newStack;
        if (resolveContext.stack) {
          newStack = new Set(resolveContext.stack);
          if (resolveContext.stack.has(stackLine)) {
            const recursionError = new Error(
              "Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  ")
            );
            recursionError.recursion = true;
            if (resolveContext.log)
              resolveContext.log("abort resolving because of recursion");
            return callback(recursionError);
          }
          newStack.add(stackLine);
        } else {
          newStack = /* @__PURE__ */ new Set([stackLine]);
        }
        this.hooks.resolveStep.call(hook, request);
        if (hook.isUsed()) {
          const innerContext = createInnerContext(
            {
              log: resolveContext.log,
              missing: resolveContext.missing,
              stack: newStack
            },
            message
          );
          return hook.callAsync(request, innerContext, (err, result) => {
            if (err)
              return callback(err);
            if (result)
              return callback(null, result);
            callback();
          });
        } else {
          callback();
        }
      }
      parse(identifier) {
        if (identifier === "")
          return null;
        const part = {
          request: "",
          query: "",
          module: false,
          directory: false,
          file: false
        };
        const idxQuery = identifier.indexOf("?");
        if (idxQuery === 0) {
          part.query = identifier;
        } else if (idxQuery > 0) {
          part.request = identifier.slice(0, idxQuery);
          part.query = identifier.slice(idxQuery);
        } else {
          part.request = identifier;
        }
        if (part.request) {
          part.module = this.isModule(part.request);
          part.directory = this.isDirectory(part.request);
          if (part.directory) {
            part.request = part.request.substr(0, part.request.length - 1);
          }
        }
        return part;
      }
      isModule(path3) {
        return !REGEXP_NOT_MODULE.test(path3);
      }
      isDirectory(path3) {
        return REGEXP_DIRECTORY.test(path3);
      }
      join(path3, request) {
        let cacheEntry;
        let pathCache = memoizedJoin.get(path3);
        if (typeof pathCache === "undefined") {
          memoizedJoin.set(path3, pathCache = /* @__PURE__ */ new Map());
        } else {
          cacheEntry = pathCache.get(request);
          if (typeof cacheEntry !== "undefined")
            return cacheEntry;
        }
        cacheEntry = memoryFsJoin(path3, request);
        pathCache.set(request, cacheEntry);
        return cacheEntry;
      }
      normalize(path3) {
        return memoryFsNormalize(path3);
      }
    };
    module3.exports = Resolver;
  }
});

// node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js
var require_SyncAsyncFileSystemDecorator = __commonJS({
  "node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js"(exports2, module3) {
    "use strict";
    function SyncAsyncFileSystemDecorator(fs4) {
      this.fs = fs4;
      if (fs4.statSync) {
        this.stat = function(arg, callback) {
          let result;
          try {
            result = fs4.statSync(arg);
          } catch (e) {
            return callback(e);
          }
          callback(null, result);
        };
      }
      if (fs4.readdirSync) {
        this.readdir = function(arg, callback) {
          let result;
          try {
            result = fs4.readdirSync(arg);
          } catch (e) {
            return callback(e);
          }
          callback(null, result);
        };
      }
      if (fs4.readFileSync) {
        this.readFile = function(arg, callback) {
          let result;
          try {
            result = fs4.readFileSync(arg);
          } catch (e) {
            return callback(e);
          }
          callback(null, result);
        };
      }
      if (fs4.readlinkSync) {
        this.readlink = function(arg, callback) {
          let result;
          try {
            result = fs4.readlinkSync(arg);
          } catch (e) {
            return callback(e);
          }
          callback(null, result);
        };
      }
      if (fs4.readJsonSync) {
        this.readJson = function(arg, callback) {
          let result;
          try {
            result = fs4.readJsonSync(arg);
          } catch (e) {
            return callback(e);
          }
          callback(null, result);
        };
      }
    }
    module3.exports = SyncAsyncFileSystemDecorator;
  }
});

// node_modules/enhanced-resolve/lib/ParsePlugin.js
var require_ParsePlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ParsePlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class ParsePlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ParsePlugin", (request, resolveContext, callback) => {
          const parsed = resolver.parse(request.request);
          const obj = Object.assign({}, request, parsed);
          if (request.query && !parsed.query) {
            obj.query = request.query;
          }
          if (parsed && resolveContext.log) {
            if (parsed.module)
              resolveContext.log("Parsed request is a module");
            if (parsed.directory)
              resolveContext.log("Parsed request is a directory");
          }
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/forEachBail.js
var require_forEachBail = __commonJS({
  "node_modules/enhanced-resolve/lib/forEachBail.js"(exports2, module3) {
    "use strict";
    module3.exports = function forEachBail(array, iterator, callback) {
      if (array.length === 0)
        return callback();
      let currentPos = array.length;
      let currentResult;
      let done = [];
      for (let i = 0; i < array.length; i++) {
        const itCb = createIteratorCallback(i);
        iterator(array[i], itCb);
        if (currentPos === 0)
          break;
      }
      function createIteratorCallback(i) {
        return (...args) => {
          if (i >= currentPos)
            return;
          done.push(i);
          if (args.length > 0) {
            currentPos = i + 1;
            done = done.filter((item) => {
              return item <= i;
            });
            currentResult = args;
          }
          if (done.length === currentPos) {
            callback.apply(null, currentResult);
            currentPos = 0;
          }
        };
      }
    };
    module3.exports.withIndex = function forEachBailWithIndex(array, iterator, callback) {
      if (array.length === 0)
        return callback();
      let currentPos = array.length;
      let currentResult;
      let done = [];
      for (let i = 0; i < array.length; i++) {
        const itCb = createIteratorCallback(i);
        iterator(array[i], i, itCb);
        if (currentPos === 0)
          break;
      }
      function createIteratorCallback(i) {
        return (...args) => {
          if (i >= currentPos)
            return;
          done.push(i);
          if (args.length > 0) {
            currentPos = i + 1;
            done = done.filter((item) => {
              return item <= i;
            });
            currentResult = args;
          }
          if (done.length === currentPos) {
            callback.apply(null, currentResult);
            currentPos = 0;
          }
        };
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/DescriptionFileUtils.js
var require_DescriptionFileUtils = __commonJS({
  "node_modules/enhanced-resolve/lib/DescriptionFileUtils.js"(exports2) {
    "use strict";
    var forEachBail = require_forEachBail();
    function loadDescriptionFile(resolver, directory, filenames, resolveContext, callback) {
      (function findDescriptionFile() {
        forEachBail(
          filenames,
          (filename, callback2) => {
            const descriptionFilePath = resolver.join(directory, filename);
            if (resolver.fileSystem.readJson) {
              resolver.fileSystem.readJson(descriptionFilePath, (err, content) => {
                if (err) {
                  if (typeof err.code !== "undefined")
                    return callback2();
                  return onJson(err);
                }
                onJson(null, content);
              });
            } else {
              resolver.fileSystem.readFile(descriptionFilePath, (err, content) => {
                if (err)
                  return callback2();
                let json;
                try {
                  json = JSON.parse(content);
                } catch (e) {
                  onJson(e);
                }
                onJson(null, json);
              });
            }
            function onJson(err, content) {
              if (err) {
                if (resolveContext.log)
                  resolveContext.log(
                    descriptionFilePath + " (directory description file): " + err
                  );
                else
                  err.message = descriptionFilePath + " (directory description file): " + err;
                return callback2(err);
              }
              callback2(null, {
                content,
                directory,
                path: descriptionFilePath
              });
            }
          },
          (err, result) => {
            if (err)
              return callback(err);
            if (result) {
              return callback(null, result);
            } else {
              directory = cdUp(directory);
              if (!directory) {
                return callback();
              } else {
                return findDescriptionFile();
              }
            }
          }
        );
      })();
    }
    function getField(content, field) {
      if (!content)
        return void 0;
      if (Array.isArray(field)) {
        let current2 = content;
        for (let j = 0; j < field.length; j++) {
          if (current2 === null || typeof current2 !== "object") {
            current2 = null;
            break;
          }
          current2 = current2[field[j]];
        }
        if (typeof current2 === "object") {
          return current2;
        }
      } else {
        if (typeof content[field] === "object") {
          return content[field];
        }
      }
    }
    function cdUp(directory) {
      if (directory === "/")
        return null;
      const i = directory.lastIndexOf("/"), j = directory.lastIndexOf("\\");
      const p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
      if (p < 0)
        return null;
      return directory.substr(0, p || 1);
    }
    exports2.loadDescriptionFile = loadDescriptionFile;
    exports2.getField = getField;
    exports2.cdUp = cdUp;
  }
});

// node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js
var require_DescriptionFilePlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js"(exports2, module3) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    module3.exports = class DescriptionFilePlugin {
      constructor(source, filenames, target) {
        this.source = source;
        this.filenames = [].concat(filenames);
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "DescriptionFilePlugin",
          (request, resolveContext, callback) => {
            const directory = request.path;
            DescriptionFileUtils.loadDescriptionFile(
              resolver,
              directory,
              this.filenames,
              resolveContext,
              (err, result) => {
                if (err)
                  return callback(err);
                if (!result) {
                  if (resolveContext.missing) {
                    this.filenames.forEach((filename) => {
                      resolveContext.missing.add(
                        resolver.join(directory, filename)
                      );
                    });
                  }
                  if (resolveContext.log)
                    resolveContext.log("No description file found");
                  return callback();
                }
                const relativePath = "." + request.path.substr(result.directory.length).replace(/\\/g, "/");
                const obj = Object.assign({}, request, {
                  descriptionFilePath: result.path,
                  descriptionFileData: result.content,
                  descriptionFileRoot: result.directory,
                  relativePath
                });
                resolver.doResolve(
                  target,
                  obj,
                  "using description file: " + result.path + " (relative path: " + relativePath + ")",
                  resolveContext,
                  (err2, result2) => {
                    if (err2)
                      return callback(err2);
                    if (result2 === void 0)
                      return callback(null, null);
                    callback(null, result2);
                  }
                );
              }
            );
          }
        );
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/NextPlugin.js
var require_NextPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/NextPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class NextPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("NextPlugin", (request, resolveContext, callback) => {
          resolver.doResolve(target, request, null, resolveContext, callback);
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/TryNextPlugin.js
var require_TryNextPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/TryNextPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class TryNextPlugin {
      constructor(source, message, target) {
        this.source = source;
        this.message = message;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("TryNextPlugin", (request, resolveContext, callback) => {
          resolver.doResolve(
            target,
            request,
            this.message,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/ModuleKindPlugin.js
var require_ModuleKindPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ModuleKindPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class ModuleKindPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModuleKindPlugin", (request, resolveContext, callback) => {
          if (!request.module)
            return callback();
          const obj = Object.assign({}, request);
          delete obj.module;
          resolver.doResolve(
            target,
            obj,
            "resolve as module",
            resolveContext,
            (err, result) => {
              if (err)
                return callback(err);
              if (result === void 0)
                return callback(null, null);
              callback(null, result);
            }
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/FileKindPlugin.js
var require_FileKindPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/FileKindPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class FileKindPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("FileKindPlugin", (request, resolveContext, callback) => {
          if (request.directory)
            return callback();
          const obj = Object.assign({}, request);
          delete obj.directory;
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/JoinRequestPlugin.js
var require_JoinRequestPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/JoinRequestPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class JoinRequestPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("JoinRequestPlugin", (request, resolveContext, callback) => {
          const obj = Object.assign({}, request, {
            path: resolver.join(request.path, request.request),
            relativePath: request.relativePath && resolver.join(request.relativePath, request.request),
            request: void 0
          });
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/getPaths.js
var require_getPaths = __commonJS({
  "node_modules/enhanced-resolve/lib/getPaths.js"(exports2, module3) {
    "use strict";
    module3.exports = function getPaths(path3) {
      const parts = path3.split(/(.*?[\\/]+)/);
      const paths = [path3];
      const seqments = [parts[parts.length - 1]];
      let part = parts[parts.length - 1];
      path3 = path3.substr(0, path3.length - part.length - 1);
      for (let i = parts.length - 2; i > 2; i -= 2) {
        paths.push(path3);
        part = parts[i];
        path3 = path3.substr(0, path3.length - part.length) || "/";
        seqments.push(part.substr(0, part.length - 1));
      }
      part = parts[1];
      seqments.push(part);
      paths.push(part);
      return {
        paths,
        seqments
      };
    };
    module3.exports.basename = function basename2(path3) {
      const i = path3.lastIndexOf("/"), j = path3.lastIndexOf("\\");
      const p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
      if (p < 0)
        return null;
      const s = path3.substr(p + 1);
      return s;
    };
  }
});

// node_modules/enhanced-resolve/lib/ModulesInHierachicDirectoriesPlugin.js
var require_ModulesInHierachicDirectoriesPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ModulesInHierachicDirectoriesPlugin.js"(exports2, module3) {
    "use strict";
    var forEachBail = require_forEachBail();
    var getPaths = require_getPaths();
    module3.exports = class ModulesInHierachicDirectoriesPlugin {
      constructor(source, directories, target) {
        this.source = source;
        this.directories = [].concat(directories);
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "ModulesInHierachicDirectoriesPlugin",
          (request, resolveContext, callback) => {
            const fs4 = resolver.fileSystem;
            const addrs = getPaths(request.path).paths.map((p) => {
              return this.directories.map((d) => resolver.join(p, d));
            }).reduce((array, p) => {
              array.push.apply(array, p);
              return array;
            }, []);
            forEachBail(
              addrs,
              (addr, callback2) => {
                fs4.stat(addr, (err, stat) => {
                  if (!err && stat && stat.isDirectory()) {
                    const obj = Object.assign({}, request, {
                      path: addr,
                      request: "./" + request.request
                    });
                    const message = "looking for modules in " + addr;
                    return resolver.doResolve(
                      target,
                      obj,
                      message,
                      resolveContext,
                      callback2
                    );
                  }
                  if (resolveContext.log)
                    resolveContext.log(
                      addr + " doesn't exist or is not a directory"
                    );
                  if (resolveContext.missing)
                    resolveContext.missing.add(addr);
                  return callback2();
                });
              },
              callback
            );
          }
        );
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js
var require_ModulesInRootPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class ModulesInRootPlugin {
      constructor(source, path3, target) {
        this.source = source;
        this.path = path3;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModulesInRootPlugin", (request, resolveContext, callback) => {
          const obj = Object.assign({}, request, {
            path: this.path,
            request: "./" + request.request
          });
          resolver.doResolve(
            target,
            obj,
            "looking for modules in " + this.path,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/AliasPlugin.js
var require_AliasPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/AliasPlugin.js"(exports2, module3) {
    "use strict";
    function startsWith(string, searchString) {
      const stringLength = string.length;
      const searchLength = searchString.length;
      if (searchLength > stringLength) {
        return false;
      }
      let index2 = -1;
      while (++index2 < searchLength) {
        if (string.charCodeAt(index2) !== searchString.charCodeAt(index2)) {
          return false;
        }
      }
      return true;
    }
    module3.exports = class AliasPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = Array.isArray(options) ? options : [options];
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AliasPlugin", (request, resolveContext, callback) => {
          const innerRequest = request.request || request.path;
          if (!innerRequest)
            return callback();
          for (const item of this.options) {
            if (innerRequest === item.name || !item.onlyModule && startsWith(innerRequest, item.name + "/")) {
              if (innerRequest !== item.alias && !startsWith(innerRequest, item.alias + "/")) {
                const newRequestStr = item.alias + innerRequest.substr(item.name.length);
                const obj = Object.assign({}, request, {
                  request: newRequestStr
                });
                return resolver.doResolve(
                  target,
                  obj,
                  "aliased with mapping '" + item.name + "': '" + item.alias + "' to '" + newRequestStr + "'",
                  resolveContext,
                  (err, result) => {
                    if (err)
                      return callback(err);
                    if (result === void 0)
                      return callback(null, null);
                    callback(null, result);
                  }
                );
              }
            }
          }
          return callback();
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/getInnerRequest.js
var require_getInnerRequest = __commonJS({
  "node_modules/enhanced-resolve/lib/getInnerRequest.js"(exports2, module3) {
    "use strict";
    module3.exports = function getInnerRequest(resolver, request) {
      if (typeof request.__innerRequest === "string" && request.__innerRequest_request === request.request && request.__innerRequest_relativePath === request.relativePath)
        return request.__innerRequest;
      let innerRequest;
      if (request.request) {
        innerRequest = request.request;
        if (/^\.\.?\//.test(innerRequest) && request.relativePath) {
          innerRequest = resolver.join(request.relativePath, innerRequest);
        }
      } else {
        innerRequest = request.relativePath;
      }
      request.__innerRequest_request = request.request;
      request.__innerRequest_relativePath = request.relativePath;
      return request.__innerRequest = innerRequest;
    };
  }
});

// node_modules/enhanced-resolve/lib/AliasFieldPlugin.js
var require_AliasFieldPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/AliasFieldPlugin.js"(exports2, module3) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var getInnerRequest = require_getInnerRequest();
    module3.exports = class AliasFieldPlugin {
      constructor(source, field, target) {
        this.source = source;
        this.field = field;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AliasFieldPlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFileData)
            return callback();
          const innerRequest = getInnerRequest(resolver, request);
          if (!innerRequest)
            return callback();
          const fieldData = DescriptionFileUtils.getField(
            request.descriptionFileData,
            this.field
          );
          if (typeof fieldData !== "object") {
            if (resolveContext.log)
              resolveContext.log(
                "Field '" + this.field + "' doesn't contain a valid alias configuration"
              );
            return callback();
          }
          const data1 = fieldData[innerRequest];
          const data2 = fieldData[innerRequest.replace(/^\.\//, "")];
          const data3 = typeof data1 !== "undefined" ? data1 : data2;
          if (data3 === innerRequest)
            return callback();
          if (data3 === void 0)
            return callback();
          if (data3 === false) {
            const ignoreObj = Object.assign({}, request, {
              path: false
            });
            return callback(null, ignoreObj);
          }
          const obj = Object.assign({}, request, {
            path: request.descriptionFileRoot,
            request: data3
          });
          resolver.doResolve(
            target,
            obj,
            "aliased from description file " + request.descriptionFilePath + " with mapping '" + innerRequest + "' to '" + data3 + "'",
            resolveContext,
            (err, result) => {
              if (err)
                return callback(err);
              if (result === void 0)
                return callback(null, null);
              callback(null, result);
            }
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/globToRegExp.js
var require_globToRegExp = __commonJS({
  "node_modules/enhanced-resolve/lib/globToRegExp.js"(exports2) {
    "use strict";
    function globToRegExp(glob) {
      if (/^\(.+\)$/.test(glob)) {
        return new RegExp(glob.substr(1, glob.length - 2));
      }
      const tokens = tokenize(glob);
      const process3 = createRoot();
      const regExpStr = tokens.map(process3).join("");
      return new RegExp("^" + regExpStr + "$");
    }
    var SIMPLE_TOKENS = {
      "@(": "one",
      "?(": "zero-one",
      "+(": "one-many",
      "*(": "zero-many",
      "|": "segment-sep",
      "/**/": "any-path-segments",
      "**": "any-path",
      "*": "any-path-segment",
      "?": "any-char",
      "{": "or",
      "/": "path-sep",
      ",": "comma",
      ")": "closing-segment",
      "}": "closing-or"
    };
    function tokenize(glob) {
      return glob.split(
        /([@?+*]\(|\/\*\*\/|\*\*|[?*]|\[[!^]?(?:[^\]\\]|\\.)+\]|\{|,|\/|[|)}])/g
      ).map((item) => {
        if (!item)
          return null;
        const t = SIMPLE_TOKENS[item];
        if (t) {
          return {
            type: t
          };
        }
        if (item[0] === "[") {
          if (item[1] === "^" || item[1] === "!") {
            return {
              type: "inverted-char-set",
              value: item.substr(2, item.length - 3)
            };
          } else {
            return {
              type: "char-set",
              value: item.substr(1, item.length - 2)
            };
          }
        }
        return {
          type: "string",
          value: item
        };
      }).filter(Boolean).concat({
        type: "end"
      });
    }
    function createRoot() {
      const inOr = [];
      const process3 = createSeqment();
      let initial = true;
      return function(token) {
        switch (token.type) {
          case "or":
            inOr.push(initial);
            return "(";
          case "comma":
            if (inOr.length) {
              initial = inOr[inOr.length - 1];
              return "|";
            } else {
              return process3(
                {
                  type: "string",
                  value: ","
                },
                initial
              );
            }
          case "closing-or":
            if (inOr.length === 0)
              throw new Error("Unmatched '}'");
            inOr.pop();
            return ")";
          case "end":
            if (inOr.length)
              throw new Error("Unmatched '{'");
            return process3(token, initial);
          default: {
            const result = process3(token, initial);
            initial = false;
            return result;
          }
        }
      };
    }
    function createSeqment() {
      const inSeqment = [];
      const process3 = createSimple();
      return function(token, initial) {
        switch (token.type) {
          case "one":
          case "one-many":
          case "zero-many":
          case "zero-one":
            inSeqment.push(token.type);
            return "(";
          case "segment-sep":
            if (inSeqment.length) {
              return "|";
            } else {
              return process3(
                {
                  type: "string",
                  value: "|"
                },
                initial
              );
            }
          case "closing-segment": {
            const segment = inSeqment.pop();
            switch (segment) {
              case "one":
                return ")";
              case "one-many":
                return ")+";
              case "zero-many":
                return ")*";
              case "zero-one":
                return ")?";
            }
            throw new Error("Unexcepted segment " + segment);
          }
          case "end":
            if (inSeqment.length > 0) {
              throw new Error("Unmatched segment, missing ')'");
            }
            return process3(token, initial);
          default:
            return process3(token, initial);
        }
      };
    }
    function createSimple() {
      return function(token, initial) {
        switch (token.type) {
          case "path-sep":
            return "[\\\\/]+";
          case "any-path-segments":
            return "[\\\\/]+(?:(.+)[\\\\/]+)?";
          case "any-path":
            return "(.*)";
          case "any-path-segment":
            if (initial) {
              return "\\.[\\\\/]+(?:.*[\\\\/]+)?([^\\\\/]+)";
            } else {
              return "([^\\\\/]*)";
            }
          case "any-char":
            return "[^\\\\/]";
          case "inverted-char-set":
            return "[^" + token.value + "]";
          case "char-set":
            return "[" + token.value + "]";
          case "string":
            return token.value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          case "end":
            return "";
          default:
            throw new Error("Unsupported token '" + token.type + "'");
        }
      };
    }
    exports2.globToRegExp = globToRegExp;
  }
});

// node_modules/enhanced-resolve/lib/concord.js
var require_concord = __commonJS({
  "node_modules/enhanced-resolve/lib/concord.js"(exports2) {
    "use strict";
    var globToRegExp = require_globToRegExp().globToRegExp;
    function parseType(type) {
      const items = type.split("+");
      const t = items.shift();
      return {
        type: t === "*" ? null : t,
        features: items
      };
    }
    function isTypeMatched(baseType, testedType) {
      if (typeof baseType === "string")
        baseType = parseType(baseType);
      if (typeof testedType === "string")
        testedType = parseType(testedType);
      if (testedType.type && testedType.type !== baseType.type)
        return false;
      return testedType.features.every((requiredFeature) => {
        return baseType.features.indexOf(requiredFeature) >= 0;
      });
    }
    function isResourceTypeMatched(baseType, testedType) {
      baseType = baseType.split("/");
      testedType = testedType.split("/");
      if (baseType.length !== testedType.length)
        return false;
      for (let i = 0; i < baseType.length; i++) {
        if (!isTypeMatched(baseType[i], testedType[i]))
          return false;
      }
      return true;
    }
    function isResourceTypeSupported(context, type) {
      return context.supportedResourceTypes && context.supportedResourceTypes.some((supportedType) => {
        return isResourceTypeMatched(supportedType, type);
      });
    }
    function isEnvironment(context, env) {
      return context.environments && context.environments.every((environment) => {
        return isTypeMatched(environment, env);
      });
    }
    var globCache = {};
    function getGlobRegExp(glob) {
      const regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));
      return regExp;
    }
    function matchGlob(glob, relativePath) {
      const regExp = getGlobRegExp(glob);
      return regExp.exec(relativePath);
    }
    function isGlobMatched(glob, relativePath) {
      return !!matchGlob(glob, relativePath);
    }
    function isConditionMatched(context, condition) {
      const items = condition.split("|");
      return items.some(function testFn(item) {
        item = item.trim();
        const inverted = /^!/.test(item);
        if (inverted)
          return !testFn(item.substr(1));
        if (/^[a-z]+:/.test(item)) {
          const match = /^([a-z]+):\s*/.exec(item);
          const value2 = item.substr(match[0].length);
          const name = match[1];
          switch (name) {
            case "referrer":
              return isGlobMatched(value2, context.referrer);
            default:
              return false;
          }
        } else if (item.indexOf("/") >= 0) {
          return isResourceTypeSupported(context, item);
        } else {
          return isEnvironment(context, item);
        }
      });
    }
    function isKeyMatched(context, key) {
      for (; ; ) {
        const match = /^\[([^\]]+)\]\s*/.exec(key);
        if (!match)
          return key;
        key = key.substr(match[0].length);
        const condition = match[1];
        if (!isConditionMatched(context, condition)) {
          return false;
        }
      }
    }
    function getField(context, configuration, field) {
      let value2;
      Object.keys(configuration).forEach((key) => {
        const pureKey = isKeyMatched(context, key);
        if (pureKey === field) {
          value2 = configuration[key];
        }
      });
      return value2;
    }
    function getMain(context, configuration) {
      return getField(context, configuration, "main");
    }
    function getExtensions(context, configuration) {
      return getField(context, configuration, "extensions");
    }
    function matchModule(context, configuration, request) {
      const modulesField = getField(context, configuration, "modules");
      if (!modulesField)
        return request;
      let newRequest = request;
      const keys2 = Object.keys(modulesField);
      let iteration = 0;
      let match;
      let index2;
      for (let i = 0; i < keys2.length; i++) {
        const key = keys2[i];
        const pureKey = isKeyMatched(context, key);
        match = matchGlob(pureKey, newRequest);
        if (match) {
          const value2 = modulesField[key];
          if (typeof value2 !== "string") {
            return value2;
          } else if (/^\(.+\)$/.test(pureKey)) {
            newRequest = newRequest.replace(getGlobRegExp(pureKey), value2);
          } else {
            index2 = 1;
            newRequest = value2.replace(/(\/?\*)?\*/g, replaceMatcher);
          }
          i = -1;
          if (iteration++ > keys2.length) {
            throw new Error("Request '" + request + "' matches recursively");
          }
        }
      }
      return newRequest;
      function replaceMatcher(find) {
        switch (find) {
          case "/**": {
            const m2 = match[index2++];
            return m2 ? "/" + m2 : "";
          }
          case "**":
          case "*":
            return match[index2++];
        }
      }
    }
    function matchType(context, configuration, relativePath) {
      const typesField = getField(context, configuration, "types");
      if (!typesField)
        return void 0;
      let type;
      Object.keys(typesField).forEach((key) => {
        const pureKey = isKeyMatched(context, key);
        if (isGlobMatched(pureKey, relativePath)) {
          const value2 = typesField[key];
          if (!type && /\/\*$/.test(value2))
            throw new Error(
              "value ('" + value2 + "') of key '" + key + "' contains '*', but there is no previous value defined"
            );
          type = value2.replace(/\/\*$/, "/" + type);
        }
      });
      return type;
    }
    exports2.parseType = parseType;
    exports2.isTypeMatched = isTypeMatched;
    exports2.isResourceTypeSupported = isResourceTypeSupported;
    exports2.isEnvironment = isEnvironment;
    exports2.isGlobMatched = isGlobMatched;
    exports2.isConditionMatched = isConditionMatched;
    exports2.isKeyMatched = isKeyMatched;
    exports2.getField = getField;
    exports2.getMain = getMain;
    exports2.getExtensions = getExtensions;
    exports2.matchModule = matchModule;
    exports2.matchType = matchType;
  }
});

// node_modules/enhanced-resolve/lib/ConcordExtensionsPlugin.js
var require_ConcordExtensionsPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ConcordExtensionsPlugin.js"(exports2, module3) {
    "use strict";
    var concord = require_concord();
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var forEachBail = require_forEachBail();
    module3.exports = class ConcordExtensionsPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "ConcordExtensionsPlugin",
          (request, resolveContext, callback) => {
            const concordField = DescriptionFileUtils.getField(
              request.descriptionFileData,
              "concord"
            );
            if (!concordField)
              return callback();
            const extensions = concord.getExtensions(
              request.context,
              concordField
            );
            if (!extensions)
              return callback();
            forEachBail(
              extensions,
              (appending, callback2) => {
                const obj = Object.assign({}, request, {
                  path: request.path + appending,
                  relativePath: request.relativePath && request.relativePath + appending
                });
                resolver.doResolve(
                  target,
                  obj,
                  "concord extension: " + appending,
                  resolveContext,
                  callback2
                );
              },
              (err, result) => {
                if (err)
                  return callback(err);
                if (result === void 0)
                  return callback(null, null);
                callback(null, result);
              }
            );
          }
        );
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/ConcordMainPlugin.js
var require_ConcordMainPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ConcordMainPlugin.js"(exports2, module3) {
    "use strict";
    var path3 = require_path();
    var concord = require_concord();
    var DescriptionFileUtils = require_DescriptionFileUtils();
    module3.exports = class ConcordMainPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ConcordMainPlugin", (request, resolveContext, callback) => {
          if (request.path !== request.descriptionFileRoot)
            return callback();
          const concordField = DescriptionFileUtils.getField(
            request.descriptionFileData,
            "concord"
          );
          if (!concordField)
            return callback();
          const mainModule = concord.getMain(request.context, concordField);
          if (!mainModule)
            return callback();
          const obj = Object.assign({}, request, {
            request: mainModule
          });
          const filename = path3.basename(request.descriptionFilePath);
          return resolver.doResolve(
            target,
            obj,
            "use " + mainModule + " from " + filename,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/ConcordModulesPlugin.js
var require_ConcordModulesPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ConcordModulesPlugin.js"(exports2, module3) {
    "use strict";
    var concord = require_concord();
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var getInnerRequest = require_getInnerRequest();
    module3.exports = class ConcordModulesPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ConcordModulesPlugin", (request, resolveContext, callback) => {
          const innerRequest = getInnerRequest(resolver, request);
          if (!innerRequest)
            return callback();
          const concordField = DescriptionFileUtils.getField(
            request.descriptionFileData,
            "concord"
          );
          if (!concordField)
            return callback();
          const data2 = concord.matchModule(
            request.context,
            concordField,
            innerRequest
          );
          if (data2 === innerRequest)
            return callback();
          if (data2 === void 0)
            return callback();
          if (data2 === false) {
            const ignoreObj = Object.assign({}, request, {
              path: false
            });
            return callback(null, ignoreObj);
          }
          const obj = Object.assign({}, request, {
            path: request.descriptionFileRoot,
            request: data2
          });
          resolver.doResolve(
            target,
            obj,
            "aliased from description file " + request.descriptionFilePath + " with mapping '" + innerRequest + "' to '" + data2 + "'",
            resolveContext,
            (err, result) => {
              if (err)
                return callback(err);
              if (result === void 0)
                return callback(null, null);
              callback(null, result);
            }
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js
var require_DirectoryExistsPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class DirectoryExistsPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync(
          "DirectoryExistsPlugin",
          (request, resolveContext, callback) => {
            const fs4 = resolver.fileSystem;
            const directory = request.path;
            fs4.stat(directory, (err, stat) => {
              if (err || !stat) {
                if (resolveContext.missing)
                  resolveContext.missing.add(directory);
                if (resolveContext.log)
                  resolveContext.log(directory + " doesn't exist");
                return callback();
              }
              if (!stat.isDirectory()) {
                if (resolveContext.missing)
                  resolveContext.missing.add(directory);
                if (resolveContext.log)
                  resolveContext.log(directory + " is not a directory");
                return callback();
              }
              resolver.doResolve(
                target,
                request,
                "existing directory",
                resolveContext,
                callback
              );
            });
          }
        );
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/FileExistsPlugin.js
var require_FileExistsPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/FileExistsPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class FileExistsPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs4 = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("FileExistsPlugin", (request, resolveContext, callback) => {
          const file = request.path;
          fs4.stat(file, (err, stat) => {
            if (err || !stat) {
              if (resolveContext.missing)
                resolveContext.missing.add(file);
              if (resolveContext.log)
                resolveContext.log(file + " doesn't exist");
              return callback();
            }
            if (!stat.isFile()) {
              if (resolveContext.missing)
                resolveContext.missing.add(file);
              if (resolveContext.log)
                resolveContext.log(file + " is not a file");
              return callback();
            }
            resolver.doResolve(
              target,
              request,
              "existing file: " + file,
              resolveContext,
              callback
            );
          });
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/SymlinkPlugin.js
var require_SymlinkPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/SymlinkPlugin.js"(exports2, module3) {
    "use strict";
    var getPaths = require_getPaths();
    var forEachBail = require_forEachBail();
    module3.exports = class SymlinkPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs4 = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("SymlinkPlugin", (request, resolveContext, callback) => {
          const pathsResult = getPaths(request.path);
          const pathSeqments = pathsResult.seqments;
          const paths = pathsResult.paths;
          let containsSymlink = false;
          forEachBail.withIndex(
            paths,
            (path3, idx, callback2) => {
              fs4.readlink(path3, (err, result) => {
                if (!err && result) {
                  pathSeqments[idx] = result;
                  containsSymlink = true;
                  if (/^(\/|[a-zA-Z]:($|\\))/.test(result))
                    return callback2(null, idx);
                }
                callback2();
              });
            },
            (err, idx) => {
              if (!containsSymlink)
                return callback();
              const resultSeqments = typeof idx === "number" ? pathSeqments.slice(0, idx + 1) : pathSeqments.slice();
              const result = resultSeqments.reverse().reduce((a, b) => {
                return resolver.join(a, b);
              });
              const obj = Object.assign({}, request, {
                path: result
              });
              resolver.doResolve(
                target,
                obj,
                "resolved symlink to " + result,
                resolveContext,
                callback
              );
            }
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/MainFieldPlugin.js
var require_MainFieldPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/MainFieldPlugin.js"(exports2, module3) {
    "use strict";
    var path3 = require_path();
    module3.exports = class MainFieldPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("MainFieldPlugin", (request, resolveContext, callback) => {
          if (request.path !== request.descriptionFileRoot)
            return callback();
          if (request.alreadyTriedMainField === request.descriptionFilePath)
            return callback();
          const content = request.descriptionFileData;
          const filename = path3.basename(request.descriptionFilePath);
          let mainModule;
          const field = this.options.name;
          if (Array.isArray(field)) {
            let current2 = content;
            for (let j = 0; j < field.length; j++) {
              if (current2 === null || typeof current2 !== "object") {
                current2 = null;
                break;
              }
              current2 = current2[field[j]];
            }
            if (typeof current2 === "string") {
              mainModule = current2;
            }
          } else {
            if (typeof content[field] === "string") {
              mainModule = content[field];
            }
          }
          if (!mainModule)
            return callback();
          if (this.options.forceRelative && !/^\.\.?\//.test(mainModule))
            mainModule = "./" + mainModule;
          const obj = Object.assign({}, request, {
            request: mainModule,
            alreadyTriedMainField: request.descriptionFilePath
          });
          return resolver.doResolve(
            target,
            obj,
            "use " + mainModule + " from " + this.options.name + " in " + filename,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/UseFilePlugin.js
var require_UseFilePlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/UseFilePlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class UseFilePlugin {
      constructor(source, filename, target) {
        this.source = source;
        this.filename = filename;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UseFilePlugin", (request, resolveContext, callback) => {
          const filePath = resolver.join(request.path, this.filename);
          const obj = Object.assign({}, request, {
            path: filePath,
            relativePath: request.relativePath && resolver.join(request.relativePath, this.filename)
          });
          resolver.doResolve(
            target,
            obj,
            "using path: " + filePath,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/AppendPlugin.js
var require_AppendPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/AppendPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class AppendPlugin {
      constructor(source, appending, target) {
        this.source = source;
        this.appending = appending;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AppendPlugin", (request, resolveContext, callback) => {
          const obj = Object.assign({}, request, {
            path: request.path + this.appending,
            relativePath: request.relativePath && request.relativePath + this.appending
          });
          resolver.doResolve(
            target,
            obj,
            this.appending,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/RootPlugin.js
var require_RootPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/RootPlugin.js"(exports2, module3) {
    "use strict";
    var RootPlugin = class {
      /**
       * @param {string | ResolveStepHook} source source hook
       * @param {Array<string>} root roots
       * @param {string | ResolveStepHook} target target hook
       * @param {boolean=} ignoreErrors ignore error during resolving of root paths
       */
      constructor(source, root2, target, ignoreErrors) {
        this.root = root2;
        this.source = source;
        this.target = target;
        this._ignoreErrors = ignoreErrors;
      }
      /**
       * @param {Resolver} resolver the resolver
       * @returns {void}
       */
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("RootPlugin", (request, resolveContext, callback) => {
          const req = request.request;
          if (!req)
            return callback();
          if (!req.startsWith("/"))
            return callback();
          const path3 = resolver.join(this.root, req.slice(1));
          const obj = Object.assign(request, {
            path: path3,
            relativePath: request.relativePath && path3
          });
          resolver.doResolve(
            target,
            obj,
            `root path ${this.root}`,
            resolveContext,
            this._ignoreErrors ? (err, result) => {
              if (err) {
                if (resolveContext.log) {
                  resolveContext.log(
                    `Ignored fatal error while resolving root path:
${err}`
                  );
                }
                return callback();
              }
              if (result)
                return callback(null, result);
              callback();
            } : callback
          );
        });
      }
    };
    module3.exports = RootPlugin;
  }
});

// node_modules/enhanced-resolve/lib/RestrictionsPlugin.js
var require_RestrictionsPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/RestrictionsPlugin.js"(exports2, module3) {
    "use strict";
    var slashCode = "/".charCodeAt(0);
    var backslashCode = "\\".charCodeAt(0);
    var isInside = (path3, parent) => {
      if (!path3.startsWith(parent))
        return false;
      if (path3.length === parent.length)
        return true;
      const charCode = path3.charCodeAt(parent.length);
      return charCode === slashCode || charCode === backslashCode;
    };
    module3.exports = class RestrictionsPlugin {
      constructor(source, restrictions) {
        this.source = source;
        this.restrictions = restrictions;
      }
      apply(resolver) {
        resolver.getHook(this.source).tapAsync("RestrictionsPlugin", (request, resolveContext, callback) => {
          if (typeof request.path === "string") {
            const path3 = request.path;
            for (let i = 0; i < this.restrictions.length; i++) {
              const rule = this.restrictions[i];
              if (typeof rule === "string") {
                if (!isInside(path3, rule)) {
                  if (resolveContext.log) {
                    resolveContext.log(
                      `${path3} is not inside of the restriction ${rule}`
                    );
                  }
                  return callback(null, null);
                }
              } else if (!rule.test(path3)) {
                if (resolveContext.log) {
                  resolveContext.log(
                    `${path3} doesn't match the restriction ${rule}`
                  );
                }
                return callback(null, null);
              }
            }
          }
          callback();
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/ResultPlugin.js
var require_ResultPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ResultPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class ResultPlugin {
      constructor(source) {
        this.source = source;
      }
      apply(resolver) {
        this.source.tapAsync(
          "ResultPlugin",
          (request, resolverContext, callback) => {
            const obj = Object.assign({}, request);
            if (resolverContext.log)
              resolverContext.log("reporting result " + obj.path);
            resolver.hooks.result.callAsync(obj, resolverContext, (err) => {
              if (err)
                return callback(err);
              callback(null, obj);
            });
          }
        );
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/ModuleAppendPlugin.js
var require_ModuleAppendPlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/ModuleAppendPlugin.js"(exports2, module3) {
    "use strict";
    module3.exports = class ModuleAppendPlugin {
      constructor(source, appending, target) {
        this.source = source;
        this.appending = appending;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModuleAppendPlugin", (request, resolveContext, callback) => {
          const i = request.request.indexOf("/"), j = request.request.indexOf("\\");
          const p = i < 0 ? j : j < 0 ? i : i < j ? i : j;
          let moduleName, remainingRequest;
          if (p < 0) {
            moduleName = request.request;
            remainingRequest = "";
          } else {
            moduleName = request.request.substr(0, p);
            remainingRequest = request.request.substr(p);
          }
          if (moduleName === "." || moduleName === "..")
            return callback();
          const moduleFinalName = moduleName + this.appending;
          const obj = Object.assign({}, request, {
            request: moduleFinalName + remainingRequest
          });
          resolver.doResolve(
            target,
            obj,
            "module variation " + moduleFinalName,
            resolveContext,
            callback
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js
var require_UnsafeCachePlugin = __commonJS({
  "node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js"(exports2, module3) {
    "use strict";
    function getCacheId(request, withContext) {
      return JSON.stringify({
        context: withContext ? request.context : "",
        path: request.path,
        query: request.query,
        request: request.request
      });
    }
    module3.exports = class UnsafeCachePlugin {
      constructor(source, filterPredicate, cache, withContext, target) {
        this.source = source;
        this.filterPredicate = filterPredicate;
        this.withContext = withContext;
        this.cache = cache || {};
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UnsafeCachePlugin", (request, resolveContext, callback) => {
          if (!this.filterPredicate(request))
            return callback();
          const cacheId = getCacheId(request, this.withContext);
          const cacheEntry = this.cache[cacheId];
          if (cacheEntry) {
            return callback(null, cacheEntry);
          }
          resolver.doResolve(
            target,
            request,
            null,
            resolveContext,
            (err, result) => {
              if (err)
                return callback(err);
              if (result)
                return callback(null, this.cache[cacheId] = result);
              callback();
            }
          );
        });
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/ResolverFactory.js
var require_ResolverFactory = __commonJS({
  "node_modules/enhanced-resolve/lib/ResolverFactory.js"(exports2) {
    "use strict";
    var Resolver = require_Resolver();
    var SyncAsyncFileSystemDecorator = require_SyncAsyncFileSystemDecorator();
    var ParsePlugin = require_ParsePlugin();
    var DescriptionFilePlugin = require_DescriptionFilePlugin();
    var NextPlugin = require_NextPlugin();
    var TryNextPlugin = require_TryNextPlugin();
    var ModuleKindPlugin = require_ModuleKindPlugin();
    var FileKindPlugin = require_FileKindPlugin();
    var JoinRequestPlugin = require_JoinRequestPlugin();
    var ModulesInHierachicDirectoriesPlugin = require_ModulesInHierachicDirectoriesPlugin();
    var ModulesInRootPlugin = require_ModulesInRootPlugin();
    var AliasPlugin = require_AliasPlugin();
    var AliasFieldPlugin = require_AliasFieldPlugin();
    var ConcordExtensionsPlugin = require_ConcordExtensionsPlugin();
    var ConcordMainPlugin = require_ConcordMainPlugin();
    var ConcordModulesPlugin = require_ConcordModulesPlugin();
    var DirectoryExistsPlugin = require_DirectoryExistsPlugin();
    var FileExistsPlugin = require_FileExistsPlugin();
    var SymlinkPlugin = require_SymlinkPlugin();
    var MainFieldPlugin = require_MainFieldPlugin();
    var UseFilePlugin = require_UseFilePlugin();
    var AppendPlugin = require_AppendPlugin();
    var RootPlugin = require_RootPlugin();
    var RestrictionsPlugin = require_RestrictionsPlugin();
    var ResultPlugin = require_ResultPlugin();
    var ModuleAppendPlugin = require_ModuleAppendPlugin();
    var UnsafeCachePlugin = require_UnsafeCachePlugin();
    exports2.createResolver = function(options) {
      let modules = options.modules || ["node_modules"];
      const descriptionFiles = options.descriptionFiles || ["package.json"];
      const plugins = options.plugins && options.plugins.slice() || [];
      let mainFields = options.mainFields || ["main"];
      const aliasFields = options.aliasFields || [];
      const mainFiles = options.mainFiles || ["index"];
      let extensions = options.extensions || [".js", ".json", ".node"];
      const enforceExtension = options.enforceExtension || false;
      let moduleExtensions = options.moduleExtensions || [];
      const enforceModuleExtension = options.enforceModuleExtension || false;
      let alias = options.alias || [];
      const symlinks = typeof options.symlinks !== "undefined" ? options.symlinks : true;
      const resolveToContext = options.resolveToContext || false;
      const roots = options.roots || [];
      const ignoreRootsErrors = options.ignoreRootsErrors || false;
      const preferAbsolute = options.preferAbsolute || false;
      const restrictions = options.restrictions || [];
      let unsafeCache = options.unsafeCache || false;
      const cacheWithContext = typeof options.cacheWithContext !== "undefined" ? options.cacheWithContext : true;
      const enableConcord = options.concord || false;
      const cachePredicate = options.cachePredicate || function() {
        return true;
      };
      const fileSystem = options.fileSystem;
      const useSyncFileSystemCalls = options.useSyncFileSystemCalls;
      let resolver = options.resolver;
      if (!resolver) {
        resolver = new Resolver(
          useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(fileSystem) : fileSystem
        );
      }
      extensions = [].concat(extensions);
      moduleExtensions = [].concat(moduleExtensions);
      modules = mergeFilteredToArray([].concat(modules), (item) => {
        return !isAbsolutePath(item);
      });
      mainFields = mainFields.map((item) => {
        if (typeof item === "string" || Array.isArray(item)) {
          item = {
            name: item,
            forceRelative: true
          };
        }
        return item;
      });
      if (typeof alias === "object" && !Array.isArray(alias)) {
        alias = Object.keys(alias).map((key) => {
          let onlyModule = false;
          let obj = alias[key];
          if (/\$$/.test(key)) {
            onlyModule = true;
            key = key.substr(0, key.length - 1);
          }
          if (typeof obj === "string") {
            obj = {
              alias: obj
            };
          }
          obj = Object.assign(
            {
              name: key,
              onlyModule
            },
            obj
          );
          return obj;
        });
      }
      if (unsafeCache && typeof unsafeCache !== "object") {
        unsafeCache = {};
      }
      resolver.ensureHook("resolve");
      resolver.ensureHook("parsedResolve");
      resolver.ensureHook("describedResolve");
      resolver.ensureHook("rawModule");
      resolver.ensureHook("module");
      resolver.ensureHook("relative");
      resolver.ensureHook("describedRelative");
      resolver.ensureHook("directory");
      resolver.ensureHook("existingDirectory");
      resolver.ensureHook("undescribedRawFile");
      resolver.ensureHook("rawFile");
      resolver.ensureHook("file");
      resolver.ensureHook("existingFile");
      resolver.ensureHook("resolved");
      if (unsafeCache) {
        plugins.push(
          new UnsafeCachePlugin(
            "resolve",
            cachePredicate,
            unsafeCache,
            cacheWithContext,
            "new-resolve"
          )
        );
        plugins.push(new ParsePlugin("new-resolve", "parsed-resolve"));
      } else {
        plugins.push(new ParsePlugin("resolve", "parsed-resolve"));
      }
      plugins.push(
        new DescriptionFilePlugin(
          "parsed-resolve",
          descriptionFiles,
          "described-resolve"
        )
      );
      plugins.push(new NextPlugin("after-parsed-resolve", "described-resolve"));
      if (alias.length > 0)
        plugins.push(new AliasPlugin("described-resolve", alias, "resolve"));
      if (enableConcord) {
        plugins.push(new ConcordModulesPlugin("described-resolve", {}, "resolve"));
      }
      aliasFields.forEach((item) => {
        plugins.push(new AliasFieldPlugin("described-resolve", item, "resolve"));
      });
      plugins.push(new ModuleKindPlugin("after-described-resolve", "raw-module"));
      if (preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-described-resolve", "relative"));
      }
      roots.forEach((root2) => {
        plugins.push(
          new RootPlugin(
            "after-described-resolve",
            root2,
            "relative",
            ignoreRootsErrors
          )
        );
      });
      if (!preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-described-resolve", "relative"));
      }
      moduleExtensions.forEach((item) => {
        plugins.push(new ModuleAppendPlugin("raw-module", item, "module"));
      });
      if (!enforceModuleExtension)
        plugins.push(new TryNextPlugin("raw-module", null, "module"));
      modules.forEach((item) => {
        if (Array.isArray(item))
          plugins.push(
            new ModulesInHierachicDirectoriesPlugin("module", item, "resolve")
          );
        else
          plugins.push(new ModulesInRootPlugin("module", item, "resolve"));
      });
      plugins.push(
        new DescriptionFilePlugin(
          "relative",
          descriptionFiles,
          "described-relative"
        )
      );
      plugins.push(new NextPlugin("after-relative", "described-relative"));
      plugins.push(new FileKindPlugin("described-relative", "raw-file"));
      plugins.push(
        new TryNextPlugin("described-relative", "as directory", "directory")
      );
      plugins.push(new DirectoryExistsPlugin("directory", "existing-directory"));
      if (resolveToContext) {
        plugins.push(new NextPlugin("existing-directory", "resolved"));
      } else {
        if (enableConcord) {
          plugins.push(new ConcordMainPlugin("existing-directory", {}, "resolve"));
        }
        mainFields.forEach((item) => {
          plugins.push(new MainFieldPlugin("existing-directory", item, "resolve"));
        });
        mainFiles.forEach((item) => {
          plugins.push(
            new UseFilePlugin("existing-directory", item, "undescribed-raw-file")
          );
        });
        plugins.push(
          new DescriptionFilePlugin(
            "undescribed-raw-file",
            descriptionFiles,
            "raw-file"
          )
        );
        plugins.push(new NextPlugin("after-undescribed-raw-file", "raw-file"));
        if (!enforceExtension) {
          plugins.push(new TryNextPlugin("raw-file", "no extension", "file"));
        }
        if (enableConcord) {
          plugins.push(new ConcordExtensionsPlugin("raw-file", {}, "file"));
        }
        extensions.forEach((item) => {
          plugins.push(new AppendPlugin("raw-file", item, "file"));
        });
        if (alias.length > 0)
          plugins.push(new AliasPlugin("file", alias, "resolve"));
        if (enableConcord) {
          plugins.push(new ConcordModulesPlugin("file", {}, "resolve"));
        }
        aliasFields.forEach((item) => {
          plugins.push(new AliasFieldPlugin("file", item, "resolve"));
        });
        if (symlinks)
          plugins.push(new SymlinkPlugin("file", "relative"));
        plugins.push(new FileExistsPlugin("file", "existing-file"));
        plugins.push(new NextPlugin("existing-file", "resolved"));
      }
      if (restrictions.length > 0) {
        plugins.push(new RestrictionsPlugin(resolver.hooks.resolved, restrictions));
      }
      plugins.push(new ResultPlugin(resolver.hooks.resolved));
      plugins.forEach((plugin) => {
        plugin.apply(resolver);
      });
      return resolver;
    };
    function mergeFilteredToArray(array, filter) {
      return array.reduce((array2, item) => {
        if (filter(item)) {
          const lastElement = array2[array2.length - 1];
          if (Array.isArray(lastElement)) {
            lastElement.push(item);
          } else {
            array2.push([item]);
          }
          return array2;
        } else {
          array2.push(item);
          return array2;
        }
      }, []);
    }
    function isAbsolutePath(path3) {
      return /^[A-Z]:|^\//.test(path3);
    }
  }
});

// browser-external:constants
var require_constants6 = __commonJS({
  "browser-external:constants"(exports2, module3) {
    module3.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module3) {
    var constants = require_constants6();
    var origCwd = process.cwd;
    var cwd = null;
    var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module3.exports = patch;
    function patch(fs4) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs4);
      }
      if (!fs4.lutimes) {
        patchLutimes(fs4);
      }
      fs4.chown = chownFix(fs4.chown);
      fs4.fchown = chownFix(fs4.fchown);
      fs4.lchown = chownFix(fs4.lchown);
      fs4.chmod = chmodFix(fs4.chmod);
      fs4.fchmod = chmodFix(fs4.fchmod);
      fs4.lchmod = chmodFix(fs4.lchmod);
      fs4.chownSync = chownFixSync(fs4.chownSync);
      fs4.fchownSync = chownFixSync(fs4.fchownSync);
      fs4.lchownSync = chownFixSync(fs4.lchownSync);
      fs4.chmodSync = chmodFixSync(fs4.chmodSync);
      fs4.fchmodSync = chmodFixSync(fs4.fchmodSync);
      fs4.lchmodSync = chmodFixSync(fs4.lchmodSync);
      fs4.stat = statFix(fs4.stat);
      fs4.fstat = statFix(fs4.fstat);
      fs4.lstat = statFix(fs4.lstat);
      fs4.statSync = statFixSync(fs4.statSync);
      fs4.fstatSync = statFixSync(fs4.fstatSync);
      fs4.lstatSync = statFixSync(fs4.lstatSync);
      if (fs4.chmod && !fs4.lchmod) {
        fs4.lchmod = function(path3, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs4.lchmodSync = function() {
        };
      }
      if (fs4.chown && !fs4.lchown) {
        fs4.lchown = function(path3, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs4.lchownSync = function() {
        };
      }
      if (platform2 === "win32") {
        fs4.rename = typeof fs4.rename !== "function" ? fs4.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs4.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs4.rename);
      }
      fs4.read = typeof fs4.read !== "function" ? fs4.read : function(fs$read) {
        function read3(fd, buffer, offset2, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs4, fd, buffer, offset2, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs4, fd, buffer, offset2, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read3, fs$read);
        return read3;
      }(fs4.read);
      fs4.readSync = typeof fs4.readSync !== "function" ? fs4.readSync : function(fs$readSync) {
        return function(fd, buffer, offset2, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs4, fd, buffer, offset2, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs4.readSync);
      function patchLchmod(fs5) {
        fs5.lchmod = function(path3, mode, callback) {
          fs5.open(
            path3,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs5.fchmod(fd, mode, function(err2) {
                fs5.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs5.lchmodSync = function(path3, mode) {
          var fd = fs5.openSync(path3, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs5.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs5.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs5.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs5) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs5.futimes) {
          fs5.lutimes = function(path3, at2, mt, cb) {
            fs5.open(path3, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs5.futimes(fd, at2, mt, function(er2) {
                fs5.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs5.lutimesSync = function(path3, at2, mt) {
            var fd = fs5.openSync(path3, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs5.futimesSync(fd, at2, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs5.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs5.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs5.futimes) {
          fs5.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs5.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs4, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs4, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs4, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs4, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs4, target, options, callback) : orig.call(fs4, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs4, target, options) : orig.call(fs4, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module3) {
    var Stream = require_stream().Stream;
    module3.exports = legacy;
    function legacy(fs4) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path3, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path3, options);
        Stream.call(this);
        var self2 = this;
        this.path = path3;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index2 = 0, length = keys2.length; index2 < length; index2++) {
          var key = keys2[index2];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs4.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path3, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path3, options);
        Stream.call(this);
        this.path = path3;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index2 = 0, length = keys2.length; index2 < length; index2++) {
          var key = keys2[index2];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs4.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module3) {
    "use strict";
    module3.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module3) {
    var fs4 = require_fs();
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require_util();
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue3) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue3;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m2 = util.format.apply(util, arguments);
        m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
        console.error(m2);
      };
    if (!fs4[gracefulQueue]) {
      queue2 = global[gracefulQueue] || [];
      publishQueue(fs4, queue2);
      fs4.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs4, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs4.close);
      fs4.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs4, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs4.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs4[gracefulQueue]);
          require_assert().equal(fs4[gracefulQueue].length, 0);
        });
      }
    }
    var queue2;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs4[gracefulQueue]);
    }
    module3.exports = patch(clone(fs4));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs4.__patched) {
      module3.exports = patch(fs4);
      fs4.__patched = true;
    }
    function patch(fs5) {
      polyfills(fs5);
      fs5.gracefulify = patch;
      fs5.createReadStream = createReadStream;
      fs5.createWriteStream = createWriteStream;
      var fs$readFile = fs5.readFile;
      fs5.readFile = readFile;
      function readFile(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path3, options, cb);
        function go$readFile(path4, options2, cb2, startTime) {
          return fs$readFile(path4, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path4, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs5.writeFile;
      fs5.writeFile = writeFile;
      function writeFile(path3, data2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path3, data2, options, cb);
        function go$writeFile(path4, data3, options2, cb2, startTime) {
          return fs$writeFile(path4, data3, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path4, data3, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs5.appendFile;
      if (fs$appendFile)
        fs5.appendFile = appendFile;
      function appendFile(path3, data2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path3, data2, options, cb);
        function go$appendFile(path4, data3, options2, cb2, startTime) {
          return fs$appendFile(path4, data3, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path4, data3, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs5.copyFile;
      if (fs$copyFile)
        fs5.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs5.readdir;
      fs5.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, options2, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path3, options, cb);
        function fs$readdirCallback(path4, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path4, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs5);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs5.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs5.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs5, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs5, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs5, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs5, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path3, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path3, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path3, options) {
        return new fs5.ReadStream(path3, options);
      }
      function createWriteStream(path3, options) {
        return new fs5.WriteStream(path3, options);
      }
      var fs$open = fs5.open;
      fs5.open = open;
      function open(path3, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path3, flags, mode, cb);
        function go$open(path4, flags2, mode2, cb2, startTime) {
          return fs$open(path4, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path4, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs5;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs4[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs4[gracefulQueue].length; ++i) {
        if (fs4[gracefulQueue][i].length > 2) {
          fs4[gracefulQueue][i][3] = now;
          fs4[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs4[gracefulQueue].length === 0)
        return;
      var elem = fs4[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs4[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/enhanced-resolve/lib/NodeJsInputFileSystem.js
var require_NodeJsInputFileSystem = __commonJS({
  "node_modules/enhanced-resolve/lib/NodeJsInputFileSystem.js"(exports2, module3) {
    "use strict";
    var fs4 = require_graceful_fs();
    var NodeJsInputFileSystem = class {
      readdir(path3, callback) {
        fs4.readdir(path3, (err, files) => {
          callback(
            err,
            files && files.map((file) => {
              return file.normalize ? file.normalize("NFC") : file;
            })
          );
        });
      }
      readdirSync(path3) {
        const files = fs4.readdirSync(path3);
        return files && files.map((file) => {
          return file.normalize ? file.normalize("NFC") : file;
        });
      }
    };
    var fsMethods = [
      "stat",
      "statSync",
      "readFile",
      "readFileSync",
      "readlink",
      "readlinkSync"
    ];
    for (const key of fsMethods) {
      Object.defineProperty(NodeJsInputFileSystem.prototype, key, {
        configurable: true,
        writable: true,
        value: fs4[key].bind(fs4)
      });
    }
    module3.exports = NodeJsInputFileSystem;
  }
});

// node_modules/enhanced-resolve/lib/CachedInputFileSystem.js
var require_CachedInputFileSystem = __commonJS({
  "node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"(exports2, module3) {
    "use strict";
    var Storage = class {
      constructor(duration) {
        this.duration = duration;
        this.running = /* @__PURE__ */ new Map();
        this.data = /* @__PURE__ */ new Map();
        this.levels = [];
        if (duration > 0) {
          this.levels.push(
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set(),
            /* @__PURE__ */ new Set()
          );
          for (let i = 8e3; i < duration; i += 500)
            this.levels.push(/* @__PURE__ */ new Set());
        }
        this.count = 0;
        this.interval = null;
        this.needTickCheck = false;
        this.nextTick = null;
        this.passive = true;
        this.tick = this.tick.bind(this);
      }
      ensureTick() {
        if (!this.interval && this.duration > 0 && !this.nextTick)
          this.interval = setInterval(
            this.tick,
            Math.floor(this.duration / this.levels.length)
          );
      }
      finished(name, err, result) {
        const callbacks = this.running.get(name);
        this.running.delete(name);
        if (this.duration > 0) {
          this.data.set(name, [err, result]);
          const levelData = this.levels[0];
          this.count -= levelData.size;
          levelData.add(name);
          this.count += levelData.size;
          this.ensureTick();
        }
        for (let i = 0; i < callbacks.length; i++) {
          callbacks[i](err, result);
        }
      }
      finishedSync(name, err, result) {
        if (this.duration > 0) {
          this.data.set(name, [err, result]);
          const levelData = this.levels[0];
          this.count -= levelData.size;
          levelData.add(name);
          this.count += levelData.size;
          this.ensureTick();
        }
      }
      provide(name, provider2, callback) {
        if (typeof name !== "string") {
          callback(new TypeError("path must be a string"));
          return;
        }
        let running = this.running.get(name);
        if (running) {
          running.push(callback);
          return;
        }
        if (this.duration > 0) {
          this.checkTicks();
          const data2 = this.data.get(name);
          if (data2) {
            return process.nextTick(() => {
              callback.apply(null, data2);
            });
          }
        }
        this.running.set(name, running = [callback]);
        provider2(name, (err, result) => {
          this.finished(name, err, result);
        });
      }
      provideSync(name, provider2) {
        if (typeof name !== "string") {
          throw new TypeError("path must be a string");
        }
        if (this.duration > 0) {
          this.checkTicks();
          const data2 = this.data.get(name);
          if (data2) {
            if (data2[0])
              throw data2[0];
            return data2[1];
          }
        }
        let result;
        try {
          result = provider2(name);
        } catch (e) {
          this.finishedSync(name, e);
          throw e;
        }
        this.finishedSync(name, null, result);
        return result;
      }
      tick() {
        const decay = this.levels.pop();
        for (let item of decay) {
          this.data.delete(item);
        }
        this.count -= decay.size;
        decay.clear();
        this.levels.unshift(decay);
        if (this.count === 0) {
          clearInterval(this.interval);
          this.interval = null;
          this.nextTick = null;
          return true;
        } else if (this.nextTick) {
          this.nextTick += Math.floor(this.duration / this.levels.length);
          const time = (/* @__PURE__ */ new Date()).getTime();
          if (this.nextTick > time) {
            this.nextTick = null;
            this.interval = setInterval(
              this.tick,
              Math.floor(this.duration / this.levels.length)
            );
            return true;
          }
        } else if (this.passive) {
          clearInterval(this.interval);
          this.interval = null;
          this.nextTick = (/* @__PURE__ */ new Date()).getTime() + Math.floor(this.duration / this.levels.length);
        } else {
          this.passive = true;
        }
      }
      checkTicks() {
        this.passive = false;
        if (this.nextTick) {
          while (!this.tick())
            ;
        }
      }
      purge(what) {
        if (!what) {
          this.count = 0;
          clearInterval(this.interval);
          this.nextTick = null;
          this.data.clear();
          this.levels.forEach((level) => {
            level.clear();
          });
        } else if (typeof what === "string") {
          for (let key of this.data.keys()) {
            if (key.startsWith(what))
              this.data.delete(key);
          }
        } else {
          for (let i = what.length - 1; i >= 0; i--) {
            this.purge(what[i]);
          }
        }
      }
    };
    module3.exports = class CachedInputFileSystem {
      constructor(fileSystem, duration) {
        this.fileSystem = fileSystem;
        this._statStorage = new Storage(duration);
        this._readdirStorage = new Storage(duration);
        this._readFileStorage = new Storage(duration);
        this._readJsonStorage = new Storage(duration);
        this._readlinkStorage = new Storage(duration);
        this._stat = this.fileSystem.stat ? this.fileSystem.stat.bind(this.fileSystem) : null;
        if (!this._stat)
          this.stat = null;
        this._statSync = this.fileSystem.statSync ? this.fileSystem.statSync.bind(this.fileSystem) : null;
        if (!this._statSync)
          this.statSync = null;
        this._readdir = this.fileSystem.readdir ? this.fileSystem.readdir.bind(this.fileSystem) : null;
        if (!this._readdir)
          this.readdir = null;
        this._readdirSync = this.fileSystem.readdirSync ? this.fileSystem.readdirSync.bind(this.fileSystem) : null;
        if (!this._readdirSync)
          this.readdirSync = null;
        this._readFile = this.fileSystem.readFile ? this.fileSystem.readFile.bind(this.fileSystem) : null;
        if (!this._readFile)
          this.readFile = null;
        this._readFileSync = this.fileSystem.readFileSync ? this.fileSystem.readFileSync.bind(this.fileSystem) : null;
        if (!this._readFileSync)
          this.readFileSync = null;
        if (this.fileSystem.readJson) {
          this._readJson = this.fileSystem.readJson.bind(this.fileSystem);
        } else if (this.readFile) {
          this._readJson = (path3, callback) => {
            this.readFile(path3, (err, buffer) => {
              if (err)
                return callback(err);
              let data2;
              try {
                data2 = JSON.parse(buffer.toString("utf-8"));
              } catch (e) {
                return callback(e);
              }
              callback(null, data2);
            });
          };
        } else {
          this.readJson = null;
        }
        if (this.fileSystem.readJsonSync) {
          this._readJsonSync = this.fileSystem.readJsonSync.bind(this.fileSystem);
        } else if (this.readFileSync) {
          this._readJsonSync = (path3) => {
            const buffer = this.readFileSync(path3);
            const data2 = JSON.parse(buffer.toString("utf-8"));
            return data2;
          };
        } else {
          this.readJsonSync = null;
        }
        this._readlink = this.fileSystem.readlink ? this.fileSystem.readlink.bind(this.fileSystem) : null;
        if (!this._readlink)
          this.readlink = null;
        this._readlinkSync = this.fileSystem.readlinkSync ? this.fileSystem.readlinkSync.bind(this.fileSystem) : null;
        if (!this._readlinkSync)
          this.readlinkSync = null;
      }
      stat(path3, callback) {
        this._statStorage.provide(path3, this._stat, callback);
      }
      readdir(path3, callback) {
        this._readdirStorage.provide(path3, this._readdir, callback);
      }
      readFile(path3, callback) {
        this._readFileStorage.provide(path3, this._readFile, callback);
      }
      readJson(path3, callback) {
        this._readJsonStorage.provide(path3, this._readJson, callback);
      }
      readlink(path3, callback) {
        this._readlinkStorage.provide(path3, this._readlink, callback);
      }
      statSync(path3) {
        return this._statStorage.provideSync(path3, this._statSync);
      }
      readdirSync(path3) {
        return this._readdirStorage.provideSync(path3, this._readdirSync);
      }
      readFileSync(path3) {
        return this._readFileStorage.provideSync(path3, this._readFileSync);
      }
      readJsonSync(path3) {
        return this._readJsonStorage.provideSync(path3, this._readJsonSync);
      }
      readlinkSync(path3) {
        return this._readlinkStorage.provideSync(path3, this._readlinkSync);
      }
      purge(what) {
        this._statStorage.purge(what);
        this._readdirStorage.purge(what);
        this._readFileStorage.purge(what);
        this._readlinkStorage.purge(what);
        this._readJsonStorage.purge(what);
      }
    };
  }
});

// node_modules/enhanced-resolve/lib/node.js
var require_node = __commonJS({
  "node_modules/enhanced-resolve/lib/node.js"(exports2, module3) {
    "use strict";
    var ResolverFactory = require_ResolverFactory();
    var NodeJsInputFileSystem = require_NodeJsInputFileSystem();
    var CachedInputFileSystem = require_CachedInputFileSystem();
    var nodeFileSystem = new CachedInputFileSystem(
      new NodeJsInputFileSystem(),
      4e3
    );
    var nodeContext = {
      environments: ["node+es3+es5+process+native"]
    };
    var asyncResolver = ResolverFactory.createResolver({
      extensions: [".js", ".json", ".node"],
      fileSystem: nodeFileSystem
    });
    module3.exports = function resolve3(context, path3, request, resolveContext, callback) {
      if (typeof context === "string") {
        callback = resolveContext;
        resolveContext = request;
        request = path3;
        path3 = context;
        context = nodeContext;
      }
      if (typeof callback !== "function") {
        callback = resolveContext;
      }
      asyncResolver.resolve(context, path3, request, resolveContext, callback);
    };
    var syncResolver = ResolverFactory.createResolver({
      extensions: [".js", ".json", ".node"],
      useSyncFileSystemCalls: true,
      fileSystem: nodeFileSystem
    });
    module3.exports.sync = function resolveSync2(context, path3, request) {
      if (typeof context === "string") {
        request = path3;
        path3 = context;
        context = nodeContext;
      }
      return syncResolver.resolveSync(context, path3, request);
    };
    var asyncContextResolver = ResolverFactory.createResolver({
      extensions: [".js", ".json", ".node"],
      resolveToContext: true,
      fileSystem: nodeFileSystem
    });
    module3.exports.context = function resolveContext(context, path3, request, resolveContext, callback) {
      if (typeof context === "string") {
        callback = resolveContext;
        resolveContext = request;
        request = path3;
        path3 = context;
        context = nodeContext;
      }
      if (typeof callback !== "function") {
        callback = resolveContext;
      }
      asyncContextResolver.resolve(
        context,
        path3,
        request,
        resolveContext,
        callback
      );
    };
    var syncContextResolver = ResolverFactory.createResolver({
      extensions: [".js", ".json", ".node"],
      resolveToContext: true,
      useSyncFileSystemCalls: true,
      fileSystem: nodeFileSystem
    });
    module3.exports.context.sync = function resolveContextSync(context, path3, request) {
      if (typeof context === "string") {
        request = path3;
        path3 = context;
        context = nodeContext;
      }
      return syncContextResolver.resolveSync(context, path3, request);
    };
    var asyncLoaderResolver = ResolverFactory.createResolver({
      extensions: [".js", ".json", ".node"],
      moduleExtensions: ["-loader"],
      mainFields: ["loader", "main"],
      fileSystem: nodeFileSystem
    });
    module3.exports.loader = function resolveLoader(context, path3, request, resolveContext, callback) {
      if (typeof context === "string") {
        callback = resolveContext;
        resolveContext = request;
        request = path3;
        path3 = context;
        context = nodeContext;
      }
      if (typeof callback !== "function") {
        callback = resolveContext;
      }
      asyncLoaderResolver.resolve(context, path3, request, resolveContext, callback);
    };
    var syncLoaderResolver = ResolverFactory.createResolver({
      extensions: [".js", ".json", ".node"],
      moduleExtensions: ["-loader"],
      mainFields: ["loader", "main"],
      useSyncFileSystemCalls: true,
      fileSystem: nodeFileSystem
    });
    module3.exports.loader.sync = function resolveLoaderSync(context, path3, request) {
      if (typeof context === "string") {
        request = path3;
        path3 = context;
        context = nodeContext;
      }
      return syncLoaderResolver.resolveSync(context, path3, request);
    };
    module3.exports.create = function create(options) {
      options = Object.assign(
        {
          fileSystem: nodeFileSystem
        },
        options
      );
      const resolver = ResolverFactory.createResolver(options);
      return function(context, path3, request, resolveContext, callback) {
        if (typeof context === "string") {
          callback = resolveContext;
          resolveContext = request;
          request = path3;
          path3 = context;
          context = nodeContext;
        }
        if (typeof callback !== "function") {
          callback = resolveContext;
        }
        resolver.resolve(context, path3, request, resolveContext, callback);
      };
    };
    module3.exports.create.sync = function createSync(options) {
      options = Object.assign(
        {
          useSyncFileSystemCalls: true,
          fileSystem: nodeFileSystem
        },
        options
      );
      const resolver = ResolverFactory.createResolver(options);
      return function(context, path3, request) {
        if (typeof context === "string") {
          request = path3;
          path3 = context;
          context = nodeContext;
        }
        return resolver.resolveSync(context, path3, request);
      };
    };
    module3.exports.ResolverFactory = ResolverFactory;
    module3.exports.NodeJsInputFileSystem = NodeJsInputFileSystem;
    module3.exports.CachedInputFileSystem = CachedInputFileSystem;
  }
});

// node_modules/postcss-import-resolver/index.js
var require_postcss_import_resolver = __commonJS({
  "node_modules/postcss-import-resolver/index.js"(exports2, module3) {
    var {
      NodeJsInputFileSystem,
      CachedInputFileSystem,
      ResolverFactory
    } = require_node();
    module3.exports = (config = {}) => {
      const defaultConfig = {
        extensions: [".css"],
        mainFields: ["style", "main"],
        modules: ["node_modules"],
        fileSystem: config.fileSystem ? null : new CachedInputFileSystem(new NodeJsInputFileSystem(), 4e3),
        useSyncFileSystemCalls: true
      };
      const resolver = ResolverFactory.createResolver(
        Object.assign(defaultConfig, config)
      );
      return (id, basedir) => resolver.resolveSync({}, basedir, id);
    };
  }
});

// node_modules/hash-sum/hash-sum.js
var require_hash_sum = __commonJS({
  "node_modules/hash-sum/hash-sum.js"(exports2, module3) {
    "use strict";
    function pad(hash2, len) {
      while (hash2.length < len) {
        hash2 = "0" + hash2;
      }
      return hash2;
    }
    function fold(hash2, text) {
      var i;
      var chr;
      var len;
      if (text.length === 0) {
        return hash2;
      }
      for (i = 0, len = text.length; i < len; i++) {
        chr = text.charCodeAt(i);
        hash2 = (hash2 << 5) - hash2 + chr;
        hash2 |= 0;
      }
      return hash2 < 0 ? hash2 * -2 : hash2;
    }
    function foldObject(hash2, o, seen) {
      return Object.keys(o).sort().reduce(foldKey, hash2);
      function foldKey(hash3, key) {
        return foldValue(hash3, o[key], key, seen);
      }
    }
    function foldValue(input, value2, key, seen) {
      var hash2 = fold(fold(fold(input, key), toString3(value2)), typeof value2);
      if (value2 === null) {
        return fold(hash2, "null");
      }
      if (value2 === void 0) {
        return fold(hash2, "undefined");
      }
      if (typeof value2 === "object" || typeof value2 === "function") {
        if (seen.indexOf(value2) !== -1) {
          return fold(hash2, "[Circular]" + key);
        }
        seen.push(value2);
        var objHash = foldObject(hash2, value2, seen);
        if (!("valueOf" in value2) || typeof value2.valueOf !== "function") {
          return objHash;
        }
        try {
          return fold(objHash, String(value2.valueOf()));
        } catch (err) {
          return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
        }
      }
      return fold(hash2, value2.toString());
    }
    function toString3(o) {
      return Object.prototype.toString.call(o);
    }
    function sum(o) {
      return pad(foldValue(0, o, "", []).toString(16), 8);
    }
    module3.exports = sum;
  }
});

// node_modules/@nuxt/kit/dist/index.mjs
var import_node_fs7 = __toESM(require_node_fs(), 1);
var import_node_perf_hooks = __toESM(require_node_perf_hooks(), 1);

// node_modules/untyped/dist/shared/untyped.bd7ca8a5.mjs
function defineUntypedSchema(options) {
  return options;
}
function getType(val) {
  const type = typeof val;
  if (type === "undefined" || val === null) {
    return void 0;
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return type;
}
function isObject(val) {
  return val !== null && !Array.isArray(val) && typeof val === "object";
}
function nonEmpty(arr) {
  return arr.filter(Boolean);
}
function unique(arr) {
  return [...new Set(arr)];
}
function joinPath(a, b = "", sep = ".") {
  return a ? a + sep + b : b;
}
function setValue(obj, path3, val) {
  const keys2 = path3.split(".");
  const _key = keys2.pop();
  for (const key of keys2) {
    if (!obj || typeof obj !== "object") {
      return;
    }
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (_key) {
    if (!obj || typeof obj !== "object") {
      return;
    }
    obj[_key] = val;
  }
}
function getValue(obj, path3) {
  for (const key of path3.split(".")) {
    if (!obj || typeof obj !== "object" || !(key in obj)) {
      return;
    }
    obj = obj[key];
  }
  return obj;
}

// node_modules/untyped/dist/shared/untyped.3f3c0215.mjs
async function resolveSchema(obj, defaults3, options = {}) {
  const schema = await _resolveSchema(obj, "", {
    root: obj,
    defaults: defaults3,
    resolveCache: {},
    ignoreDefaults: options.ignoreDefaults
  });
  return schema;
}
async function _resolveSchema(input, id, ctx) {
  if (id in ctx.resolveCache) {
    return ctx.resolveCache[id];
  }
  const schemaId = "#" + id.replace(/\./g, "/");
  if (!isObject(input)) {
    const safeInput = Array.isArray(input) ? [...input] : input;
    const schema2 = {
      type: getType(input),
      id: schemaId,
      default: ctx.ignoreDefaults ? void 0 : safeInput
    };
    normalizeSchema(schema2, { ignoreDefaults: ctx.ignoreDefaults });
    ctx.resolveCache[id] = schema2;
    if (ctx.defaults && getValue(ctx.defaults, id) === void 0) {
      setValue(ctx.defaults, id, schema2.default);
    }
    return schema2;
  }
  const node = { ...input };
  const schema = ctx.resolveCache[id] = {
    ...node.$schema,
    id: schemaId
  };
  for (const key in node) {
    if (key === "$resolve" || key === "$schema" || key === "$default") {
      continue;
    }
    schema.properties = schema.properties || {};
    if (!schema.properties[key]) {
      const child = schema.properties[key] = await _resolveSchema(
        node[key],
        joinPath(id, key),
        ctx
      );
      if (Array.isArray(child.tags) && child.tags.includes("@required")) {
        schema.required = schema.required || [];
        if (!schema.required.includes(key)) {
          schema.required.push(key);
        }
      }
    }
  }
  if (!ctx.ignoreDefaults) {
    if (ctx.defaults) {
      schema.default = getValue(ctx.defaults, id);
    }
    if (schema.default === void 0 && "$default" in node) {
      schema.default = node.$default;
    }
    if (typeof node.$resolve === "function") {
      schema.default = await node.$resolve(schema.default, async (key) => {
        return (await _resolveSchema(getValue(ctx.root, key), key, ctx)).default;
      });
    }
  }
  if (ctx.defaults) {
    setValue(ctx.defaults, id, schema.default);
  }
  if (!schema.type) {
    schema.type = getType(schema.default) || (schema.properties ? "object" : "any");
  }
  normalizeSchema(schema, { ignoreDefaults: ctx.ignoreDefaults });
  if (ctx.defaults && getValue(ctx.defaults, id) === void 0) {
    setValue(ctx.defaults, id, schema.default);
  }
  return schema;
}
async function applyDefaults(ref2, input) {
  await resolveSchema(ref2, input);
  return input;
}
function normalizeSchema(schema, options) {
  if (schema.type === "array" && !("items" in schema)) {
    schema.items = {
      type: nonEmpty(unique(schema.default.map((i) => getType(i))))
    };
    if (schema.items.type) {
      if (schema.items.type.length === 0) {
        schema.items.type = "any";
      } else if (schema.items.type.length === 1) {
        schema.items.type = schema.items.type[0];
      }
    }
  }
  if (!options.ignoreDefaults && schema.default === void 0 && ("properties" in schema || schema.type === "object" || schema.type === "any")) {
    const propsWithDefaults = Object.entries(schema.properties || {}).filter(([, prop]) => "default" in prop).map(([key, value2]) => [key, value2.default]);
    schema.default = Object.fromEntries(propsWithDefaults);
  }
}

// node_modules/consola/dist/core.mjs
var LogLevels = {
  silent: Number.NEGATIVE_INFINITY,
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  ready: 3,
  start: 3,
  box: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
var LogTypes = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  // Level 1
  warn: {
    level: LogLevels.warn
  },
  // Level 2
  log: {
    level: LogLevels.log
  },
  // Level 3
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  // Level 4
  debug: {
    level: LogLevels.debug
  },
  // Level 5
  trace: {
    level: LogLevels.trace
  },
  // Verbose
  verbose: {
    level: LogLevels.verbose
  }
};
function isObject2(value2) {
  return value2 !== null && typeof value2 === "object";
}
function _defu(baseObject, defaults3, namespace = ".", merger) {
  if (!isObject2(defaults3)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults3);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value2 = baseObject[key];
    if (value2 === null || value2 === void 0) {
      continue;
    }
    if (merger && merger(object, key, value2, namespace)) {
      continue;
    }
    if (Array.isArray(value2) && Array.isArray(object[key])) {
      object[key] = [...value2, ...object[key]];
    } else if (isObject2(value2) && isObject2(object[key])) {
      object[key] = _defu(
        value2,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value2;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
var defu2 = createDefu();
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}
var paused = false;
var queue = [];
var Consola = class {
  constructor(options = {}) {
    const types2 = options.types || LogTypes;
    this.options = defu2(
      {
        ...options,
        defaults: { ...options.defaults },
        level: _normalizeLogLevel(options.level, types2),
        reporters: [...options.reporters || []]
      },
      {
        types: LogTypes,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: true,
          colors: false,
          compact: true
        }
      }
    );
    for (const type in types2) {
      const defaults3 = {
        type,
        ...this.options.defaults,
        ...types2[type]
      };
      this[type] = this._wrapLogFn(defaults3);
      this[type].raw = this._wrapLogFn(
        defaults3,
        true
      );
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  get level() {
    return this.options.level;
  }
  set level(level) {
    this.options.level = _normalizeLogLevel(
      level,
      this.options.types,
      this.options.level
    );
  }
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  create(options) {
    const instance = new Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  withDefaults(defaults3) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults3
      }
    });
  }
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  removeReporter(reporter) {
    if (reporter) {
      const i = this.options.reporters.indexOf(reporter);
      if (i >= 0) {
        return this.options.reporters.splice(i, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data2) => {
      this[type].raw(String(data2).trim());
    };
  }
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  pauseLogs() {
    paused = true;
  }
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults3, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults3, args, isRaw]);
        return;
      }
      return this._logFn(defaults3, args, isRaw);
    };
  }
  _logFn(defaults3, args, isRaw) {
    if ((defaults3.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...defaults3,
      level: _normalizeLogLevel(defaults3.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split("\n");
      }
      logObj.args.push("\n" + logObj.additional.join("\n"));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(
              resolveLog,
              this.options.throttle
            );
            return;
          }
        }
      } catch {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
};
function _normalizeLogLevel(input, types2 = {}, defaultLevel = 3) {
  if (input === void 0) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types2[input] && types2[input].level !== void 0) {
    return types2[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola(options = {}) {
  return new Consola(options);
}

// node_modules/consola/dist/browser.mjs
var BrowserReporter = class {
  constructor(options) {
    this.options = { ...options };
    this.defaultColor = "#7f8c8d";
    this.levelColorMap = {
      0: "#c0392b",
      // Red
      1: "#f39c12",
      // Yellow
      3: "#00BCD4"
      // Cyan
    };
    this.typeColorMap = {
      success: "#2ecc71"
      // Green
    };
  }
  _getLogFn(level) {
    if (level < 1) {
      return console.__error || console.error;
    }
    if (level === 1) {
      return console.__warn || console.warn;
    }
    return console.__log || console.log;
  }
  log(logObj) {
    const consoleLogFn = this._getLogFn(logObj.level);
    const type = logObj.type === "log" ? "" : logObj.type;
    const tag = logObj.tag || "";
    const color = this.typeColorMap[logObj.type] || this.levelColorMap[logObj.level] || this.defaultColor;
    const style = `
      background: ${color};
      border-radius: 0.5em;
      color: white;
      font-weight: bold;
      padding: 2px 0.5em;
    `;
    const badge = `%c${[tag, type].filter(Boolean).join(":")}`;
    if (typeof logObj.args[0] === "string") {
      consoleLogFn(
        `${badge}%c ${logObj.args[0]}`,
        style,
        // Empty string as style resets to default console style
        "",
        ...logObj.args.slice(1)
      );
    } else {
      consoleLogFn(badge, style, ...logObj.args);
    }
  }
};
function createConsola2(options = {}) {
  const consola2 = createConsola({
    reporters: options.reporters || [new BrowserReporter({})],
    prompt(message, options2 = {}) {
      if (options2.type === "confirm") {
        return Promise.resolve(confirm(message));
      }
      return Promise.resolve(prompt(message));
    },
    ...options
  });
  return consola2;
}
var consola = createConsola2();

// node_modules/unctx/dist/index.mjs
function createContext(opts = {}) {
  let currentInstance;
  let isSingleton = false;
  const checkConflict = (instance) => {
    if (currentInstance && currentInstance !== instance) {
      throw new Error("Context conflict");
    }
  };
  let als;
  if (opts.asyncContext) {
    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;
    if (_AsyncLocalStorage) {
      als = new _AsyncLocalStorage();
    } else {
      console.warn("[unctx] `AsyncLocalStorage` is not provided.");
    }
  }
  const _getCurrentInstance = () => {
    if (als && currentInstance === void 0) {
      const instance = als.getStore();
      if (instance !== void 0) {
        return instance;
      }
    }
    return currentInstance;
  };
  return {
    use: () => {
      const _instance = _getCurrentInstance();
      if (_instance === void 0) {
        throw new Error("Context is not available");
      }
      return _instance;
    },
    tryUse: () => {
      return _getCurrentInstance();
    },
    set: (instance, replace) => {
      if (!replace) {
        checkConflict(instance);
      }
      currentInstance = instance;
      isSingleton = true;
    },
    unset: () => {
      currentInstance = void 0;
      isSingleton = false;
    },
    call: (instance, callback) => {
      checkConflict(instance);
      currentInstance = instance;
      try {
        return als ? als.run(instance, callback) : callback();
      } finally {
        if (!isSingleton) {
          currentInstance = void 0;
        }
      }
    },
    async callAsync(instance, callback) {
      currentInstance = instance;
      const onRestore = () => {
        currentInstance = instance;
      };
      const onLeave = () => currentInstance === instance ? onRestore : void 0;
      asyncHandlers.add(onLeave);
      try {
        const r2 = als ? als.run(instance, callback) : callback();
        if (!isSingleton) {
          currentInstance = void 0;
        }
        return await r2;
      } finally {
        asyncHandlers.delete(onLeave);
      }
    }
  };
}
function createNamespace(defaultOpts = {}) {
  const contexts = {};
  return {
    get(key, opts = {}) {
      if (!contexts[key]) {
        contexts[key] = createContext({ ...defaultOpts, ...opts });
      }
      contexts[key];
      return contexts[key];
    }
  };
}
var _globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
var globalKey = "__unctx__";
var defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());
var getContext = (key, opts = {}) => defaultNamespace.get(key, opts);
var asyncHandlersKey = "__unctx_async_handlers__";
var asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());

// node_modules/@nuxt/kit/dist/index.mjs
var import_satisfies = __toESM(require_satisfies(), 1);

// node_modules/knitwork/dist/index.mjs
function genString(input, options = {}) {
  const string_ = JSON.stringify(input);
  if (!options.singleQuotes) {
    return JSON.stringify(input);
  }
  return `'${escapeString(string_)}'`;
}
var NEEDS_ESCAPE_RE = /[\n\r'\\\u2028\u2029]/;
var QUOTE_NEWLINE_RE = /([\n\r'\u2028\u2029])/g;
var BACKSLASH_RE = /\\/g;
function escapeString(id) {
  if (!NEEDS_ESCAPE_RE.test(id)) {
    return id;
  }
  return id.replace(BACKSLASH_RE, "\\\\").replace(QUOTE_NEWLINE_RE, "\\$1");
}
function genImport(specifier, imports, options = {}) {
  return _genStatement("import", specifier, imports, options);
}
function _genStatement(type, specifier, names, options = {}) {
  const specifierString = genString(specifier, options);
  if (!names) {
    return `${type} ${specifierString};`;
  }
  const nameArray = Array.isArray(names);
  const _names = (nameArray ? names : [names]).map((index2) => {
    if (typeof index2 === "string") {
      return { name: index2 };
    }
    if (index2.name === index2.as) {
      index2 = { name: index2.name };
    }
    return index2;
  });
  const namesString = _names.map((index2) => index2.as ? `${index2.name} as ${index2.as}` : index2.name).join(", ");
  if (nameArray) {
    return `${type} { ${namesString} } from ${genString(specifier, options)}${_genAssertClause(type, options.assert)};`;
  }
  return `${type} ${namesString} from ${genString(specifier, options)}${_genAssertClause(type, options.assert)};`;
}
function _genAssertClause(type, assert2) {
  if (type === "import type" || type === "export type") {
    return "";
  }
  if (!assert2 || typeof assert2 !== "object") {
    return "";
  }
  return ` assert { type: ${genString(assert2.type)} }`;
}
function genDynamicImport(specifier, options = {}) {
  const commentString = options.comment ? ` /* ${options.comment} */` : "";
  const wrapperString = options.wrapper === false ? "" : "() => ";
  const ineropString = options.interopDefault ? ".then(m => m.default || m)" : "";
  const optionsString = _genDynamicImportOptions(options);
  return `${wrapperString}import(${genString(specifier, options)}${commentString}${optionsString})${ineropString}`;
}
function _genDynamicImportOptions(options = {}) {
  return options.assert && typeof options.assert === "object" ? `, { assert: { type: ${genString(options.assert.type)} } }` : "";
}
function genSafeVariableName(name) {
  if (reservedNames.has(name)) {
    return `_${name}`;
  }
  return name.replace(/^\d/, (r2) => `_${r2}`).replace(/\W/g, (r2) => "_" + r2.charCodeAt(0));
}
var reservedNames = /* @__PURE__ */ new Set([
  "Infinity",
  "NaN",
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "undefined",
  "var",
  "void",
  "while",
  "with",
  "yield"
]);

// node_modules/@nuxt/kit/dist/index.mjs
var import_node_url3 = __toESM(require_node_url(), 1);

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) {
      return false;
    }
    pos += set[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
  if (options === void 0)
    options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports2 = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports2);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports2) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports2);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node === void 0)
    node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value2.params.length !== 0) {
    this.raiseRecoverable(value2.start, "getter should have no params");
  }
  if (method.kind === "set" && value2.params.length !== 1) {
    this.raiseRecoverable(value2.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value2.params[0].type === "RestElement") {
    this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports2) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports2, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports2) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports2);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports2, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports2, node.declaration.declarations);
    } else {
      this.checkExport(exports2, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports2);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports2, name, pos) {
  if (!exports2) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports2, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports2[name] = true;
};
pp$8.checkPatternExport = function(exports2, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports2, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports2, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports2, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports2, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports2, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports2, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports2, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports2, decls) {
  if (!exports2) {
    return;
  }
  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this.checkPatternExport(exports2, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports2) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports2,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports2) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports2));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value2 = this.value;
      node = this.parseLiteral(value2.value);
      node.regex = { pattern: value2.pattern, flags: value2.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta = this.parseIdent(true);
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    node.meta = meta;
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value2) {
  var node = this.startNode();
  node.value = value2;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
  ecmaVersion = list[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
    return c;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0)
    forceU = false;
  var pos = this.pos;
  for (var i = 0, list = chs; i < list.length; i += 1) {
    var ch = list[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];
    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true;
    }
    if (n <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value2 = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value2)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value2 = null;
  try {
    value2 = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.10.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};

// node_modules/mlly/dist/index.mjs
var import_node_module = __toESM(require_node_module(), 1);
var import_node_fs2 = __toESM(require_node_fs(), 1);
var import_node_url = __toESM(require_node_url(), 1);

// node_modules/ufo/dist/index.mjs
var r = String.fromCharCode;
var TRAILING_SLASH_RE = /\/$|\/\?/;
function hasTrailingSlash(input = "", queryParameters = false) {
  if (!queryParameters) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withTrailingSlash(input = "", queryParameters = false) {
  if (!queryParameters) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  const [s0, ...s] = input.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "");
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withoutLeadingSlash(input = "") {
  return (hasLeadingSlash(input) ? input.slice(1) : input) || "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
var JOIN_LEADING_SLASH_RE = /^\.?\//;
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}

// node_modules/pkg-types/dist/index.mjs
var import_node_fs = __toESM(require_node_fs(), 1);
var defaultFindOptions = {
  startingFrom: ".",
  rootPattern: /^node_modules$/,
  reverse: false,
  test: (filePath) => {
    try {
      if ((0, import_node_fs.statSync)(filePath).isFile()) {
        return true;
      }
    } catch {
    }
  }
};
async function findFile(filename, _options = {}) {
  const options = { ...defaultFindOptions, ..._options };
  const basePath = resolve(options.startingFrom);
  const leadingSlash = basePath[0] === "/";
  const segments = basePath.split("/").filter(Boolean);
  if (leadingSlash) {
    segments[0] = "/" + segments[0];
  }
  let root2 = segments.findIndex((r2) => r2.match(options.rootPattern));
  if (root2 === -1) {
    root2 = 0;
  }
  if (!options.reverse) {
    for (let index2 = segments.length; index2 > root2; index2--) {
      const filePath = join(...segments.slice(0, index2), filename);
      if (await options.test(filePath)) {
        return filePath;
      }
    }
  } else {
    for (let index2 = root2 + 1; index2 <= segments.length; index2++) {
      const filePath = join(...segments.slice(0, index2), filename);
      if (await options.test(filePath)) {
        return filePath;
      }
    }
  }
  throw new Error(
    `Cannot find matching ${filename} in ${options.startingFrom} or parent directories`
  );
}
function findNearestFile(filename, _options = {}) {
  return findFile(filename, _options);
}
var lockFiles = [
  "yarn.lock",
  "package-lock.json",
  "pnpm-lock.yaml",
  "npm-shrinkwrap.json",
  "bun.lockb"
];
async function resolveLockfile(id = process.cwd(), options = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, options);
  const _options = { startingFrom: resolvedPath, ...options };
  for (const lockFile of lockFiles) {
    try {
      return await findNearestFile(lockFile, _options);
    } catch {
    }
  }
  throw new Error("No lockfile found from " + id);
}
async function findWorkspaceDir(id = process.cwd(), options = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, options);
  const _options = { startingFrom: resolvedPath, ...options };
  try {
    const r2 = await findNearestFile(".git/config", _options);
    return resolve(r2, "../..");
  } catch {
  }
  try {
    const r2 = await resolveLockfile(resolvedPath, {
      ..._options,
      reverse: true
    });
    return dirname(r2);
  } catch {
  }
  try {
    const r2 = await findFile(resolvedPath, _options);
    return dirname(r2);
  } catch {
  }
  throw new Error("Cannot detect workspace root from " + id);
}

// node_modules/mlly/dist/index.mjs
var import_node_assert = __toESM(require_node_assert(), 1);
var import_node_process = __toESM(require_node_process(), 1);
var import_node_path = __toESM(require_node_path(), 1);
var import_node_v8 = __toESM(require_node_v8(), 1);
var import_node_util = __toESM(require_node_util(), 1);
var BUILTIN_MODULES = new Set(import_node_module.builtinModules);
function normalizeSlash(string_) {
  return string_.replace(/\\/g, "/");
}
function pcall(function_, ...arguments_) {
  try {
    return Promise.resolve(function_(...arguments_)).catch(
      (error) => perr(error)
    );
  } catch (error) {
    return perr(error);
  }
}
function perr(_error) {
  const error = new Error(_error);
  error.code = _error.code;
  Error.captureStackTrace(error, pcall);
  return Promise.reject(error);
}
var isWindows = import_node_process.default.platform === "win32";
var own$1 = {}.hasOwnProperty;
var classRegExp = /^([A-Z][a-z\d]*)+$/;
var kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
var codes = {};
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError(
  "ERR_INVALID_ARG_TYPE",
  /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */
  (name, expected, actual) => {
    (0, import_node_assert.default)(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name.endsWith(" argument")) {
      message += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type} `;
    }
    message += "must be ";
    const types2 = [];
    const instances = [];
    const other = [];
    for (const value2 of expected) {
      (0, import_node_assert.default)(
        typeof value2 === "string",
        "All expected entries have to be of type string"
      );
      if (kTypes.has(value2)) {
        types2.push(value2.toLowerCase());
      } else if (classRegExp.exec(value2) === null) {
        (0, import_node_assert.default)(
          value2 !== "object",
          'The value "object" should be written as "Object"'
        );
        other.push(value2);
      } else {
        instances.push(value2);
      }
    }
    if (instances.length > 0) {
      const pos = types2.indexOf("object");
      if (pos !== -1) {
        types2.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types2.length > 0) {
      message += `${types2.length > 1 ? "one of type" : "of type"} ${formatList(
        types2,
        "or"
      )}`;
      if (instances.length > 0 || other.length > 0)
        message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0)
        message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0].toLowerCase() !== other[0])
          message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  },
  TypeError
);
codes.ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  },
  TypeError
);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path3, base, message) => {
    return `Invalid package config ${path3}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
codes.ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} pkgPath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      (0, import_node_assert.default)(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
codes.ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {string} [type]
   */
  (path3, base, type = "package") => {
    return `Cannot find ${type} '${path3}' imported from ${base}`;
  },
  Error
);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
  },
  TypeError
);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} pkgPath
   * @param {string} subpath
   * @param {string} [base]
   */
  (pkgPath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} ext
   * @param {string} path
   */
  (ext, path3) => {
    return `Unknown file extension "${ext}" for ${path3}`;
  },
  TypeError
);
codes.ERR_INVALID_ARG_VALUE = createError(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name, value2, reason = "is invalid") => {
    let inspected = (0, import_node_util.inspect)(value2);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError(
  "ERR_UNSUPPORTED_ESM_URL_SCHEME",
  /**
   * @param {URL} url
   * @param {Array<string>} supported
   */
  (url, supported) => {
    let message = `Only URLs with a scheme in: ${formatList(
      supported
    )} are supported by the default ESM loader`;
    if (isWindows && url.protocol.length === 2) {
      message += ". On Windows, absolute paths must be valid file:// URLs";
    }
    message += `. Received protocol '${url.protocol}'`;
    return message;
  },
  Error
);
function createError(sym, value2, def) {
  messages.set(sym, value2);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = limit;
    const message = getMessage(key, args, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}
var captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error);
    if (stackTraceLimitIsWritable)
      Error.stackTraceLimit = userStackTraceLimit;
    return error;
  }
);
function getMessage(key, args, self2) {
  const message = messages.get(key);
  (0, import_node_assert.default)(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert.default)(
      message.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, args);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null)
    expectedLength++;
  (0, import_node_assert.default)(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  );
  if (args.length === 0)
    return message;
  args.unshift(message);
  return Reflect.apply(import_node_util.format, null, args);
}
function determineSpecificType(value2) {
  if (value2 === null || value2 === void 0) {
    return String(value2);
  }
  if (typeof value2 === "function" && value2.name) {
    return `function ${value2.name}`;
  }
  if (typeof value2 === "object") {
    if (value2.constructor && value2.constructor.name) {
      return `an instance of ${value2.constructor.name}`;
    }
    return `${(0, import_node_util.inspect)(value2, { depth: -1 })}`;
  }
  let inspected = (0, import_node_util.inspect)(value2, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value2} (${inspected})`;
}
var reader = { read };
var packageJsonReader = reader;
function read(jsonPath) {
  try {
    const string = import_node_fs2.default.readFileSync(
      import_node_path.default.toNamespacedPath(import_node_path.default.join(import_node_path.default.dirname(jsonPath), "package.json")),
      "utf8"
    );
    return { string };
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    if (exception.code === "ENOENT") {
      return { string: void 0 };
    }
    throw exception;
  }
}
var { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes;
var packageJsonCache = /* @__PURE__ */ new Map();
function getPackageConfig(path3, specifier, base) {
  const existing = packageJsonCache.get(path3);
  if (existing !== void 0) {
    return existing;
  }
  const source = packageJsonReader.read(path3).string;
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path3,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJsonCache.set(path3, packageConfig2);
    return packageConfig2;
  }
  let packageJson;
  try {
    packageJson = JSON.parse(source);
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    throw new ERR_INVALID_PACKAGE_CONFIG$1(
      path3,
      (base ? `"${specifier}" from ` : "") + (0, import_node_url.fileURLToPath)(base || specifier),
      exception.message
    );
  }
  const { exports: exports2, imports, main, name, type } = packageJson;
  const packageConfig = {
    pjsonPath: path3,
    exists: true,
    main: typeof main === "string" ? main : void 0,
    name: typeof name === "string" ? name : void 0,
    type: type === "module" || type === "commonjs" ? type : "none",
    // @ts-expect-error Assume `Record<string, unknown>`.
    exports: exports2,
    // @ts-expect-error Assume `Record<string, unknown>`.
    imports: imports && typeof imports === "object" ? imports : void 0
  };
  packageJsonCache.set(path3, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved) {
  let packageJsonUrl = new import_node_url.URL("package.json", resolved);
  while (true) {
    const packageJsonPath2 = packageJsonUrl.pathname;
    if (packageJsonPath2.endsWith("node_modules/package.json"))
      break;
    const packageConfig2 = getPackageConfig(
      (0, import_node_url.fileURLToPath)(packageJsonUrl),
      resolved
    );
    if (packageConfig2.exists)
      return packageConfig2;
    const lastPackageJsonUrl = packageJsonUrl;
    packageJsonUrl = new import_node_url.URL("../package.json", packageJsonUrl);
    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname)
      break;
  }
  const packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  const packageConfig = {
    pjsonPath: packageJsonPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJsonCache.set(packageJsonPath, packageConfig);
  return packageConfig;
}
function getPackageType(url) {
  const packageConfig = getPackageScopeConfig(url);
  return packageConfig.type;
}
var { ERR_UNKNOWN_FILE_EXTENSION } = codes;
var hasOwnProperty2 = {}.hasOwnProperty;
var extensionFormatMap = {
  // @ts-expect-error: hush.
  __proto__: null,
  ".cjs": "commonjs",
  ".js": "module",
  ".json": "json",
  ".mjs": "module"
};
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json")
    return "json";
  return null;
}
var protocolHandlers = {
  // @ts-expect-error: hush.
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "http:": getHttpProtocolModuleFormat,
  "https:": getHttpProtocolModuleFormat,
  "node:"() {
    return "builtin";
  }
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname2(url) {
  const pathname = url.pathname;
  let index2 = pathname.length;
  while (index2--) {
    const code = pathname.codePointAt(index2);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index2 - 1) === 47 ? "" : pathname.slice(index2);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  const ext = extname2(url);
  if (ext === ".js") {
    return getPackageType(url) === "module" ? "module" : "commonjs";
  }
  const format2 = extensionFormatMap[ext];
  if (format2)
    return format2;
  if (ignoreErrors) {
    return void 0;
  }
  const filepath = (0, import_node_url.fileURLToPath)(url);
  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url, context) {
  if (!hasOwnProperty2.call(protocolHandlers, url.protocol)) {
    return null;
  }
  return protocolHandlers[url.protocol](url, context, true) || null;
}
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_ESM_URL_SCHEME
} = codes;
var own = {}.hasOwnProperty;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
var invalidPackageNameRegEx = /^\.|%|\\/;
var patternRegEx = /\*/g;
var encodedSepRegEx = /%2f|%5c/i;
var emittedPackageWarnings = /* @__PURE__ */ new Set();
var doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal2, base, isTarget) {
  const pjsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  import_node_process.default.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal2 ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url.fileURLToPath)(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  const format2 = defaultGetFormatWithoutErrors(url, { parentURL: base.href });
  if (format2 !== "module")
    return;
  const path3 = (0, import_node_url.fileURLToPath)(url.href);
  const pkgPath = (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl));
  const basePath = (0, import_node_url.fileURLToPath)(base);
  if (main)
    import_node_process.default.emitWarning(
      `Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path3.slice(
        pkgPath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  else
    import_node_process.default.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path3.slice(
        pkgPath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
}
function tryStatSync(path3) {
  try {
    return (0, import_node_fs2.statSync)(path3);
  } catch {
    return new import_node_fs2.Stats();
  }
}
function fileExists(url) {
  const stats = (0, import_node_fs2.statSync)(url, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new import_node_url.URL(packageConfig.main, packageJsonUrl);
    if (fileExists(guess))
      return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new import_node_url.URL(tries2[i2], packageJsonUrl);
      if (fileExists(guess))
        break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new import_node_url.URL(tries[i], packageJsonUrl);
    if (fileExists(guess))
      break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    (0, import_node_url.fileURLToPath)(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSepRegEx.exec(resolved.pathname) !== null)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      (0, import_node_url.fileURLToPath)(base)
    );
  const filePath = (0, import_node_url.fileURLToPath)(resolved);
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, import_node_url.fileURLToPath)(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats.isFile()) {
    throw new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && (0, import_node_url.fileURLToPath)(base),
      "module"
    );
  }
  if (!preserveSymlinks) {
    const real = (0, import_node_fs2.realpathSync)(filePath);
    const { search, hash: hash2 } = resolved;
    resolved = (0, import_node_url.pathToFileURL)(real + (filePath.endsWith(import_node_path.default.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash2;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    (0, import_node_url.fileURLToPath)(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    subpath,
    base && (0, import_node_url.fileURLToPath)(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal2, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal2 ? "imports" : "exports"}" resolution of ${(0, import_node_url.fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && (0, import_node_url.fileURLToPath)(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal2, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    subpath,
    target,
    internal2,
    base && (0, import_node_url.fileURLToPath)(base)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal2, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal2, base);
  if (!target.startsWith("./")) {
    if (internal2 && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new import_node_url.URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal2, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal2,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal2, base);
    }
  }
  const resolved = new import_node_url.URL(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new import_node_url.URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal2, base);
  if (subpath === "")
    return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal2,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal2, base);
    }
  }
  if (pattern) {
    return new import_node_url.URL(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new import_node_url.URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key)
    return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal2, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal2,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0)
      return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal2,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception = (
          /** @type {ErrnoException} */
          error
        );
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET")
          continue;
        throw error;
      }
      if (resolveResult === void 0)
        continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys2 = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys2.length) {
      const key = keys2[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          (0, import_node_url.fileURLToPath)(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys2.length) {
      const key = keys2[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal2,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal2,
    base
  );
}
function isConditionalExportsMainSugar(exports2, packageJsonUrl, base) {
  if (typeof exports2 === "string" || Array.isArray(exports2))
    return true;
  if (typeof exports2 !== "object" || exports2 === null)
    return false;
  const keys2 = Object.getOwnPropertyNames(exports2);
  let isConditionalSugar = false;
  let i = 0;
  let j = -1;
  while (++j < keys2.length) {
    const key = keys2[j];
    const curIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        (0, import_node_url.fileURLToPath)(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = (0, import_node_url.fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  import_node_process.default.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url.fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports2 = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base)) {
    exports2 = { ".": exports2 };
  }
  if (own.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports2[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys2 = Object.getOwnPropertyNames(exports2);
  let i = -1;
  while (++i < keys2.length) {
    const key = keys2[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports2[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB)
    return -1;
  if (baseLengthB > baseLengthA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, import_node_url.fileURLToPath)(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, import_node_url.pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys2 = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys2.length) {
          const key = keys2[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      (0, import_node_url.fileURLToPath)(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (import_node_module.builtinModules.includes(specifier)) {
    return new import_node_url.URL("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = (0, import_node_url.pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
    }
  }
  let packageJsonUrl = new import_node_url.URL(
    "./node_modules/" + packageName + "/package.json",
    base
  );
  let packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new import_node_url.URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig2 = getPackageConfig(packageJsonPath, specifier, base);
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new import_node_url.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, (0, import_node_url.fileURLToPath)(base));
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/")
      return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "")
    return false;
  if (specifier[0] === "/")
    return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isRemote = protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    resolved = new import_node_url.URL(specifier, base);
  } else if (!isRemote && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new import_node_url.URL(specifier);
    } catch {
      if (!isRemote) {
        resolved = packageResolve(specifier, base, conditions);
      }
    }
  }
  (0, import_node_assert.default)(resolved !== void 0, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function fileURLToPath(id) {
  if (typeof id === "string" && !id.startsWith("file://")) {
    return normalizeSlash(id);
  }
  return normalizeSlash((0, import_node_url.fileURLToPath)(id));
}
function normalizeid(id) {
  if (typeof id !== "string") {
    id = id.toString();
  }
  if (/(node|data|http|https|file):/.test(id)) {
    return id;
  }
  if (BUILTIN_MODULES.has(id)) {
    return "node:" + id;
  }
  return "file://" + encodeURI(normalizeSlash(id));
}
var DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
var DEFAULT_URL = (0, import_node_url.pathToFileURL)(process.cwd());
var DEFAULT_EXTENSIONS = [".mjs", ".cjs", ".js", ".json"];
var NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "ERR_MODULE_NOT_FOUND",
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "MODULE_NOT_FOUND",
  "ERR_PACKAGE_PATH_NOT_EXPORTED"
]);
function _tryModuleResolve(id, url, conditions) {
  try {
    return moduleResolve(id, url, conditions);
  } catch (error) {
    if (!NOT_FOUND_ERRORS.has(error.code)) {
      throw error;
    }
  }
}
function _resolve(id, options = {}) {
  if (/(node|data|http|https):/.test(id)) {
    return id;
  }
  if (BUILTIN_MODULES.has(id)) {
    return "node:" + id;
  }
  if (isAbsolute(id) && (0, import_node_fs2.existsSync)(id)) {
    const realPath2 = (0, import_node_fs2.realpathSync)(fileURLToPath(id));
    return (0, import_node_url.pathToFileURL)(realPath2).toString();
  }
  const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
  const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((u) => new URL(normalizeid(u.toString())));
  if (_urls.length === 0) {
    _urls.push(DEFAULT_URL);
  }
  const urls = [..._urls];
  for (const url of _urls) {
    if (url.protocol === "file:") {
      urls.push(
        new URL("./", url),
        // If url is directory
        new URL(joinURL(url.pathname, "_index.js"), url),
        // TODO: Remove in next major version?
        new URL("node_modules", url)
      );
    }
  }
  let resolved;
  for (const url of urls) {
    resolved = _tryModuleResolve(id, url, conditionsSet);
    if (resolved) {
      break;
    }
    for (const prefix of ["", "/index"]) {
      for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
        resolved = _tryModuleResolve(
          id + prefix + extension,
          url,
          conditionsSet
        );
        if (resolved) {
          break;
        }
      }
      if (resolved) {
        break;
      }
    }
    if (resolved) {
      break;
    }
  }
  if (!resolved) {
    const error = new Error(
      `Cannot find module ${id} imported from ${urls.join(", ")}`
    );
    error.code = "ERR_MODULE_NOT_FOUND";
    throw error;
  }
  const realPath = (0, import_node_fs2.realpathSync)(fileURLToPath(resolved));
  return (0, import_node_url.pathToFileURL)(realPath).toString();
}
function resolveSync(id, options) {
  return _resolve(id, options);
}
function resolvePathSync(id, options) {
  return fileURLToPath(resolveSync(id, options));
}
function resolvePath(id, options) {
  return pcall(resolvePathSync, id, options);
}
var ESM_STATIC_IMPORT_RE = new RegExp(`(?<=\\s|^|;)import\\s*([\\s"']*(?<imports>[\\p{L}\\p{M}\\w\\t\\n\\r $*,/{}@.]+)from\\s*)?["']\\s*(?<specifier>(?<="\\s*)[^"]*[^\\s"](?=\\s*")|(?<='\\s*)[^']*[^\\s'](?=\\s*'))\\s*["'][\\s;]*`, "gmu");
var IMPORT_NAMED_TYPE_RE = new RegExp(`(?<=\\s|^|;)import\\s*type\\s+([\\s"']*(?<imports>[\\w\\t\\n\\r $*,/{}]+)from\\s*)?["']\\s*(?<specifier>(?<="\\s*)[^"]*[^\\s"](?=\\s*")|(?<='\\s*)[^']*[^\\s'](?=\\s*'))\\s*["'][\\s;]*`, "gm");
var EXPORT_NAMED_RE = new RegExp(`\\bexport\\s+{(?<exports>[^}]+?)[\\s,]*}(\\s*from\\s*["']\\s*(?<specifier>(?<="\\s*)[^"]*[^\\s"](?=\\s*")|(?<='\\s*)[^']*[^\\s'](?=\\s*'))\\s*["'][^\\n;]*)?`, "g");
var EXPORT_NAMED_TYPE_RE = new RegExp(`\\bexport\\s+type\\s+{(?<exports>[^}]+?)[\\s,]*}(\\s*from\\s*["']\\s*(?<specifier>(?<="\\s*)[^"]*[^\\s"](?=\\s*")|(?<='\\s*)[^']*[^\\s'](?=\\s*'))\\s*["'][^\\n;]*)?`, "g");
var EXPORT_STAR_RE = new RegExp(`\\bexport\\s*(\\*)(\\s*as\\s+(?<name>[\\w$]+)\\s+)?\\s*(\\s*from\\s*["']\\s*(?<specifier>(?<="\\s*)[^"]*[^\\s"](?=\\s*")|(?<='\\s*)[^']*[^\\s'](?=\\s*'))\\s*["'][^\\n;]*)?`, "g");
var EVAL_ESM_IMPORT_RE = new RegExp(`(?<=import .* from ["'])([^"']+)(?=["'])|(?<=export .* from ["'])([^"']+)(?=["'])|(?<=import\\s*["'])([^"']+)(?=["'])|(?<=import\\s*\\(["'])([^"']+)(?=["']\\))`, "g");

// node_modules/@nuxt/kit/dist/index.mjs
var import_jiti2 = __toESM(require_lib(), 1);

// node_modules/globby/index.js
var import_node_fs4 = __toESM(require_node_fs());
var import_node_path3 = __toESM(require_node_path());
var import_merge2 = __toESM(require_merge2());
var import_fast_glob2 = __toESM(require_out4());
var import_dir_glob = __toESM(require_dir_glob());

// node_modules/globby/ignore.js
var import_node_process2 = __toESM(require_node_process(), 1);
var import_node_fs3 = __toESM(require_node_fs(), 1);
var import_node_path2 = __toESM(require_node_path(), 1);
var import_fast_glob = __toESM(require_out4(), 1);
var import_ignore = __toESM(require_ignore(), 1);

// node_modules/slash/index.js
function slash(path3) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(path3);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(path3);
  if (isExtendedLengthPath || hasNonAscii) {
    return path3;
  }
  return path3.replace(/\\/g, "/");
}

// node_modules/globby/utilities.js
var import_node_url2 = __toESM(require_node_url(), 1);
var import_node_stream = __toESM(require_node_stream(), 1);
var toPath = (urlOrPath) => urlOrPath instanceof URL ? (0, import_node_url2.fileURLToPath)(urlOrPath) : urlOrPath;
var FilterStream = class extends import_node_stream.Transform {
  constructor(filter) {
    super({
      objectMode: true,
      transform(data2, encoding, callback) {
        callback(void 0, filter(data2) ? data2 : void 0);
      }
    });
  }
};
var isNegativePattern = (pattern) => pattern[0] === "!";

// node_modules/globby/ignore.js
var ignoreFilesGlobOptions = {
  ignore: [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ],
  absolute: true,
  dot: true
};
var GITIGNORE_FILES_PATTERN = "**/.gitignore";
var applyBaseToPattern = (pattern, base) => isNegativePattern(pattern) ? "!" + import_node_path2.default.posix.join(base, pattern.slice(1)) : import_node_path2.default.posix.join(base, pattern);
var parseIgnoreFile = (file, cwd) => {
  const base = slash(import_node_path2.default.relative(cwd, import_node_path2.default.dirname(file.filePath)));
  return file.content.split(/\r?\n/).filter((line) => line && !line.startsWith("#")).map((pattern) => applyBaseToPattern(pattern, base));
};
var toRelativePath = (fileOrDirectory, cwd) => {
  cwd = slash(cwd);
  if (import_node_path2.default.isAbsolute(fileOrDirectory)) {
    if (slash(fileOrDirectory).startsWith(cwd)) {
      return import_node_path2.default.relative(cwd, fileOrDirectory);
    }
    throw new Error(`Path ${fileOrDirectory} is not in cwd ${cwd}`);
  }
  return fileOrDirectory;
};
var getIsIgnoredPredicate = (files, cwd) => {
  const patterns = files.flatMap((file) => parseIgnoreFile(file, cwd));
  const ignores = (0, import_ignore.default)().add(patterns);
  return (fileOrDirectory) => {
    fileOrDirectory = toPath(fileOrDirectory);
    fileOrDirectory = toRelativePath(fileOrDirectory, cwd);
    return fileOrDirectory ? ignores.ignores(slash(fileOrDirectory)) : false;
  };
};
var normalizeOptions = (options = {}) => ({
  cwd: toPath(options.cwd) || import_node_process2.default.cwd(),
  suppressErrors: Boolean(options.suppressErrors),
  deep: typeof options.deep === "number" ? options.deep : Number.POSITIVE_INFINITY
});
var isIgnoredByIgnoreFiles = async (patterns, options) => {
  const { cwd, suppressErrors, deep } = normalizeOptions(options);
  const paths = await (0, import_fast_glob.default)(patterns, { cwd, suppressErrors, deep, ...ignoreFilesGlobOptions });
  const files = await Promise.all(
    paths.map(async (filePath) => ({
      filePath,
      content: await import_node_fs3.default.promises.readFile(filePath, "utf8")
    }))
  );
  return getIsIgnoredPredicate(files, cwd);
};
var isIgnoredByIgnoreFilesSync = (patterns, options) => {
  const { cwd, suppressErrors, deep } = normalizeOptions(options);
  const paths = import_fast_glob.default.sync(patterns, { cwd, suppressErrors, deep, ...ignoreFilesGlobOptions });
  const files = paths.map((filePath) => ({
    filePath,
    content: import_node_fs3.default.readFileSync(filePath, "utf8")
  }));
  return getIsIgnoredPredicate(files, cwd);
};

// node_modules/globby/index.js
var assertPatternsInput = (patterns) => {
  if (patterns.some((pattern) => typeof pattern !== "string")) {
    throw new TypeError("Patterns must be a string or an array of strings");
  }
};
var toPatternsArray = (patterns) => {
  patterns = [...new Set([patterns].flat())];
  assertPatternsInput(patterns);
  return patterns;
};
var checkCwdOption = (options) => {
  if (!options.cwd) {
    return;
  }
  let stat;
  try {
    stat = import_node_fs4.default.statSync(options.cwd);
  } catch {
    return;
  }
  if (!stat.isDirectory()) {
    throw new Error("The `cwd` option must be a path to a directory");
  }
};
var normalizeOptions2 = (options = {}) => {
  options = {
    ...options,
    ignore: options.ignore || [],
    expandDirectories: options.expandDirectories === void 0 ? true : options.expandDirectories,
    cwd: toPath(options.cwd)
  };
  checkCwdOption(options);
  return options;
};
var normalizeArguments = (fn) => async (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions2(options));
var normalizeArgumentsSync = (fn) => (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions2(options));
var getIgnoreFilesPatterns = (options) => {
  const { ignoreFiles, gitignore } = options;
  const patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];
  if (gitignore) {
    patterns.push(GITIGNORE_FILES_PATTERN);
  }
  return patterns;
};
var getFilter = async (options) => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && await isIgnoredByIgnoreFiles(ignoreFilesPatterns, options)
  );
};
var getFilterSync = (options) => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, options)
  );
};
var createFilterFunction = (isIgnored) => {
  const seen = /* @__PURE__ */ new Set();
  return (fastGlobResult) => {
    const path3 = fastGlobResult.path || fastGlobResult;
    const pathKey = import_node_path3.default.normalize(path3);
    const seenOrIgnored = seen.has(pathKey) || isIgnored && isIgnored(path3);
    seen.add(pathKey);
    return !seenOrIgnored;
  };
};
var unionFastGlobResults = (results, filter) => results.flat().filter((fastGlobResult) => filter(fastGlobResult));
var unionFastGlobStreams = (streams, filter) => (0, import_merge2.default)(streams).pipe(new FilterStream((fastGlobResult) => filter(fastGlobResult)));
var convertNegativePatterns = (patterns, options) => {
  const tasks = [];
  while (patterns.length > 0) {
    const index2 = patterns.findIndex((pattern) => isNegativePattern(pattern));
    if (index2 === -1) {
      tasks.push({ patterns, options });
      break;
    }
    const ignorePattern = patterns[index2].slice(1);
    for (const task of tasks) {
      task.options.ignore.push(ignorePattern);
    }
    if (index2 !== 0) {
      tasks.push({
        patterns: patterns.slice(0, index2),
        options: {
          ...options,
          ignore: [
            ...options.ignore,
            ignorePattern
          ]
        }
      });
    }
    patterns = patterns.slice(index2 + 1);
  }
  return tasks;
};
var getDirGlobOptions = (options, cwd) => ({
  ...cwd ? { cwd } : {},
  ...Array.isArray(options) ? { files: options } : options
});
var generateTasks = async (patterns, options) => {
  const globTasks = convertNegativePatterns(patterns, options);
  const { cwd, expandDirectories } = options;
  if (!expandDirectories) {
    return globTasks;
  }
  const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
  const ignoreExpandOptions = cwd ? { cwd } : void 0;
  return Promise.all(
    globTasks.map(async (task) => {
      let { patterns: patterns2, options: options2 } = task;
      [
        patterns2,
        options2.ignore
      ] = await Promise.all([
        (0, import_dir_glob.default)(patterns2, patternExpandOptions),
        (0, import_dir_glob.default)(options2.ignore, ignoreExpandOptions)
      ]);
      return { patterns: patterns2, options: options2 };
    })
  );
};
var generateTasksSync = (patterns, options) => {
  const globTasks = convertNegativePatterns(patterns, options);
  const { cwd, expandDirectories } = options;
  if (!expandDirectories) {
    return globTasks;
  }
  const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
  const ignoreExpandOptions = cwd ? { cwd } : void 0;
  return globTasks.map((task) => {
    let { patterns: patterns2, options: options2 } = task;
    patterns2 = import_dir_glob.default.sync(patterns2, patternExpandOptions);
    options2.ignore = import_dir_glob.default.sync(options2.ignore, ignoreExpandOptions);
    return { patterns: patterns2, options: options2 };
  });
};
var globby = normalizeArguments(async (patterns, options) => {
  const [
    tasks,
    filter
  ] = await Promise.all([
    generateTasks(patterns, options),
    getFilter(options)
  ]);
  const results = await Promise.all(tasks.map((task) => (0, import_fast_glob2.default)(task.patterns, task.options)));
  return unionFastGlobResults(results, filter);
});
var globbySync = normalizeArgumentsSync((patterns, options) => {
  const tasks = generateTasksSync(patterns, options);
  const filter = getFilterSync(options);
  const results = tasks.map((task) => import_fast_glob2.default.sync(task.patterns, task.options));
  return unionFastGlobResults(results, filter);
});
var globbyStream = normalizeArgumentsSync((patterns, options) => {
  const tasks = generateTasksSync(patterns, options);
  const filter = getFilterSync(options);
  const streams = tasks.map((task) => import_fast_glob2.default.stream(task.patterns, task.options));
  return unionFastGlobStreams(streams, filter);
});
var isDynamicPattern = normalizeArgumentsSync(
  (patterns, options) => patterns.some((pattern) => import_fast_glob2.default.isDynamicPattern(pattern, options))
);
var generateGlobTasks = normalizeArguments(generateTasks);
var generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);

// node_modules/pathe/dist/utils.mjs
var pathSeparators = /* @__PURE__ */ new Set(["/", "\\", void 0]);
var normalizedAliasSymbol = Symbol.for("pathe:normalizedAlias");
function normalizeAliases(_aliases) {
  if (_aliases[normalizedAliasSymbol]) {
    return _aliases;
  }
  const aliases = Object.fromEntries(
    Object.entries(_aliases).sort(([a], [b]) => _compareAliases(a, b))
  );
  for (const key in aliases) {
    for (const alias in aliases) {
      if (alias === key || key.startsWith(alias)) {
        continue;
      }
      if (aliases[key].startsWith(alias) && pathSeparators.has(aliases[key][alias.length])) {
        aliases[key] = aliases[alias] + aliases[key].slice(alias.length);
      }
    }
  }
  Object.defineProperty(aliases, normalizedAliasSymbol, {
    value: true,
    enumerable: false
  });
  return aliases;
}
function resolveAlias(path3, aliases) {
  const _path = normalizeWindowsPath(path3);
  aliases = normalizeAliases(aliases);
  for (const alias in aliases) {
    if (_path.startsWith(alias) && pathSeparators.has(_path[alias.length])) {
      return join(aliases[alias], _path.slice(alias.length));
    }
  }
  return _path;
}
function _compareAliases(a, b) {
  return b.split("/").length - a.split("/").length;
}

// node_modules/@nuxt/kit/dist/index.mjs
var import_ignore4 = __toESM(require_ignore(), 1);

// node_modules/c12/dist/index.mjs
var import_node_fs6 = __toESM(require_node_fs(), 1);
var dotenv = __toESM(require_main(), 1);
var import_promises = __toESM(require_promises(), 1);
var import_node_os2 = __toESM(require_node_os(), 1);
var import_jiti = __toESM(require_lib(), 1);

// node_modules/rc9/dist/index.mjs
var import_node_fs5 = __toESM(require_node_fs(), 1);
var import_node_path4 = __toESM(require_node_path(), 1);
var import_node_os = __toESM(require_node_os(), 1);
var import_flat = __toESM(require_flat(), 1);
var defaults = {
  name: ".conf",
  dir: process.cwd(),
  flat: false
};

// node_modules/c12/dist/index.mjs
var import_chokidar = __toESM(require_chokidar(), 1);

// node_modules/ohash/dist/index.mjs
var defaults2 = Object.freeze({
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false,
  excludeKeys: void 0,
  excludeValues: void 0,
  replacer: void 0
});
var defaultPrototypesKeys = Object.freeze([
  "prototype",
  "__proto__",
  "constructor"
]);
var nativeFunc = "[native code] }";
var nativeFuncLength = nativeFunc.length;

// node_modules/std-env/dist/index.mjs
var providers = [
  ["APPVEYOR"],
  ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"],
  ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"],
  ["APPCIRCLE", "AC_APPCIRCLE"],
  ["BAMBOO", "bamboo_planKey"],
  ["BITBUCKET", "BITBUCKET_COMMIT"],
  ["BITRISE", "BITRISE_IO"],
  ["BUDDY", "BUDDY_WORKSPACE_ID"],
  ["BUILDKITE"],
  ["CIRCLE", "CIRCLECI"],
  ["CIRRUS", "CIRRUS_CI"],
  ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }],
  ["CODEBUILD", "CODEBUILD_BUILD_ARN"],
  ["CODEFRESH", "CF_BUILD_ID"],
  ["DRONE"],
  ["DRONE", "DRONE_BUILD_EVENT"],
  ["DSARI"],
  ["GITHUB_ACTIONS"],
  ["GITLAB", "GITLAB_CI"],
  ["GITLAB", "CI_MERGE_REQUEST_ID"],
  ["GOCD", "GO_PIPELINE_LABEL"],
  ["LAYERCI"],
  ["HUDSON", "HUDSON_URL"],
  ["JENKINS", "JENKINS_URL"],
  ["MAGNUM"],
  ["NETLIFY"],
  ["NETLIFY", "NETLIFY_LOCAL", { ci: false }],
  ["NEVERCODE"],
  ["RENDER"],
  ["SAIL", "SAILCI"],
  ["SEMAPHORE"],
  ["SCREWDRIVER"],
  ["SHIPPABLE"],
  ["SOLANO", "TDDIUM"],
  ["STRIDER"],
  ["TEAMCITY", "TEAMCITY_VERSION"],
  ["TRAVIS"],
  ["VERCEL", "NOW_BUILDER"],
  ["APPCENTER", "APPCENTER_BUILD_ID"],
  ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }],
  ["STACKBLITZ"],
  ["STORMKIT"],
  ["CLEAVR"]
];
function detectProvider(env) {
  for (const provider2 of providers) {
    const envName = provider2[1] || provider2[0];
    if (env[envName]) {
      return {
        name: provider2[0].toLowerCase(),
        ...provider2[2]
      };
    }
  }
  if (env.SHELL && env.SHELL === "/bin/jsh") {
    return {
      name: "stackblitz",
      ci: false
    };
  }
  return {
    name: "",
    ci: false
  };
}
var processShim = typeof process !== "undefined" ? process : {};
var envShim = processShim.env || {};
var providerInfo = detectProvider(envShim);
var nodeENV = typeof process !== "undefined" && process.env && "development" || "";
var platform = processShim.platform;
var provider = providerInfo.name;
var isCI = toBoolean(envShim.CI) || providerInfo.ci !== false;
var hasTTY = toBoolean(processShim.stdout && processShim.stdout.isTTY);
var isDebug = toBoolean(envShim.DEBUG);
var isTest = nodeENV === "test" || toBoolean(envShim.TEST);
var isDevelopment = nodeENV === "dev" || nodeENV === "development";
var isMinimal = toBoolean(envShim.MINIMAL) || isCI || isTest || !hasTTY;
var isWindows2 = /^win/i.test(platform);
var isLinux = /^linux/i.test(platform);
var isMacOS = /^darwin/i.test(platform);
function toBoolean(val) {
  return val ? val !== "false" : false;
}

// node_modules/@nuxt/schema/dist/index.mjs
var import_postcss_import_resolver = __toESM(require_postcss_import_resolver(), 1);
var adhoc = defineUntypedSchema({
  /**
   * Configure Nuxt component auto-registration.
   *
   * Any components in the directories configured here can be used throughout your
   * pages, layouts (and other components) without needing to explicitly import them.
   *
   * @see https://nuxt.com/docs/guide/directory-structure/components
   * @type {boolean | typeof import('../src/types/components').ComponentsOptions | typeof import('../src/types/components').ComponentsOptions['dirs']}
   */
  components: {
    $resolve: (val) => {
      if (Array.isArray(val)) {
        return { dirs: val };
      }
      if (val === void 0 || val === true) {
        return { dirs: [{ path: "~/components/global", global: true }, "~/components"] };
      }
      return val;
    }
  },
  /**
   * Configure how Nuxt auto-imports composables into your application.
   *
   * @see [Nuxt 3 documentation](https://nuxt.com/docs/guide/directory-structure/composables)
   * @type {typeof import('../src/types/imports').ImportsOptions}
   */
  imports: {
    global: false,
    /**
     * An array of custom directories that will be auto-imported.
     * Note that this option will not override the default directories (~/composables, ~/utils).
     * @example
     * ```js
     * imports: {
     *   // Auto-import pinia stores defined in `~/stores`
     *   dirs: ['stores']
     * }
     * ```
     */
    dirs: []
  },
  /**
   * Whether to use the vue-router integration in Nuxt 3. If you do not provide a value it will be
   * enabled if you have a `pages/` directory in your source folder.
   *
   * @type {boolean}
   */
  pages: void 0,
  /**
   * Manually disable nuxt telemetry.
   *
   * @see [Nuxt Telemetry](https://github.com/nuxt/telemetry) for more information.
   *
   * @type {boolean | Record<string, any>}
  */
  telemetry: void 0,
  /**
   * Enable Nuxt DevTools for development.
   *
   * This is an experimental feature.
   * Breaking changes for devtools might not reflect on the version of Nuxt.
   *
   * @see  [Nuxt DevTools](https://devtools.nuxtjs.org/) for more information.
   * @experimental
   * @type {boolean | { enabled: boolean, [key: string]: any }}
   */
  devtools: false
});
var app = defineUntypedSchema({
  /**
   * Vue.js config
   */
  vue: {
    /**
     * Options for the Vue compiler that will be passed at build time.
     * @see [documentation](https://vuejs.org/api/application.html#app-config-compileroptions)
     * @type {typeof import('@vue/compiler-core').CompilerOptions}
     */
    compilerOptions: {},
    /**
     * Include Vue compiler in runtime bundle.
     */
    runtimeCompiler: {
      $resolve: async (val, get) => val ?? await get("experimental.runtimeVueCompiler") ?? false
    },
    /**
     * Vue Experimental: Enable reactive destructure for `defineProps`
     * @see [Vue RFC#502](https://github.com/vuejs/rfcs/discussions/502)
     * @type {boolean}
     */
    propsDestructure: false,
    /**
     * Vue Experimental: Enable macro `defineModel`
     * @see [Vue RFC#503](https://github.com/vuejs/rfcs/discussions/503)
     * @type {boolean}
     */
    defineModel: false
  },
  /**
   * Nuxt App configuration.
   */
  app: {
    /**
     * The base path of your Nuxt application.
     *
     * This can be set at runtime by setting the NUXT_APP_BASE_URL environment variable.
     * @example
     * ```bash
     * NUXT_APP_BASE_URL=/prefix/ node .output/server/index.mjs
     * ```
     */
    baseURL: {
      $resolve: async (val) => val || process.env.NUXT_APP_BASE_URL || "/"
    },
    /** The folder name for the built site assets, relative to `baseURL` (or `cdnURL` if set). This is set at build time and should not be customized at runtime. */
    buildAssetsDir: {
      $resolve: async (val) => val || process.env.NUXT_APP_BUILD_ASSETS_DIR || "/_nuxt/"
    },
    /**
     * An absolute URL to serve the public folder from (production-only).
     *
     * This can be set to a different value at runtime by setting the `NUXT_APP_CDN_URL` environment variable.
     * @example
     * ```bash
     * NUXT_APP_CDN_URL=https://mycdn.org/ node .output/server/index.mjs
     * ```
     */
    cdnURL: {
      $resolve: async (val, get) => await get("dev") ? "" : (process.env.NUXT_APP_CDN_URL ?? val) || ""
    },
    /**
     * Set default configuration for `<head>` on every page.
     *
     * @example
     * ```js
     * app: {
     *   head: {
     *     meta: [
     *       // <meta name="viewport" content="width=device-width, initial-scale=1">
     *       { name: 'viewport', content: 'width=device-width, initial-scale=1' }
     *     ],
     *     script: [
     *       // <script src="https://myawesome-lib.js"><\/script>
     *       { src: 'https://awesome-lib.js' }
     *     ],
     *     link: [
     *       // <link rel="stylesheet" href="https://myawesome-lib.css">
     *       { rel: 'stylesheet', href: 'https://awesome-lib.css' }
     *     ],
     *     // please note that this is an area that is likely to change
     *     style: [
     *       // <style type="text/css">:root { color: red }</style>
     *       { children: ':root { color: red }', type: 'text/css' }
     *     ],
     *     noscript: [
     *       // <noscript>JavaScript is required</noscript>
     *       { children: 'JavaScript is required' }
     *     ]
     *   }
     * }
     * ```
     * @type {typeof import('../src/types/config').NuxtAppConfig['head']}
     */
    head: {
      $resolve: async (val, get) => {
        var _a, _b;
        const resolved = defu(val, await get("meta"), {
          meta: [],
          link: [],
          style: [],
          script: [],
          noscript: []
        });
        if (!((_a = resolved.meta.find((m2) => m2.charset)) == null ? void 0 : _a.charset)) {
          resolved.meta.unshift({ charset: resolved.charset || "utf-8" });
        }
        if (!((_b = resolved.meta.find((m2) => m2.name === "viewport")) == null ? void 0 : _b.content)) {
          resolved.meta.unshift({ name: "viewport", content: resolved.viewport || "width=device-width, initial-scale=1" });
        }
        resolved.meta = resolved.meta.filter(Boolean);
        resolved.link = resolved.link.filter(Boolean);
        resolved.style = resolved.style.filter(Boolean);
        resolved.script = resolved.script.filter(Boolean);
        resolved.noscript = resolved.noscript.filter(Boolean);
        return resolved;
      }
    },
    /**
     * Default values for layout transitions.
     *
     * This can be overridden with `definePageMeta` on an individual page.
     * Only JSON-serializable values are allowed.
     *
     * @see https://vuejs.org/api/built-in-components.html#transition
     * @type {typeof import('../src/types/config').NuxtAppConfig['layoutTransition']}
     */
    layoutTransition: false,
    /**
     * Default values for page transitions.
     *
     * This can be overridden with `definePageMeta` on an individual page.
     * Only JSON-serializable values are allowed.
     *
     * @see https://vuejs.org/api/built-in-components.html#transition
     * @type {typeof import('../src/types/config').NuxtAppConfig['pageTransition']}
     */
    pageTransition: false,
    /**
     * Default values for KeepAlive configuration between pages.
     *
     * This can be overridden with `definePageMeta` on an individual page.
     * Only JSON-serializable values are allowed.
     *
     * @see https://vuejs.org/api/built-in-components.html#keepalive
     * @type {typeof import('../src/types/config').NuxtAppConfig['keepalive']}
     */
    keepalive: false,
    /**
     * Customize Nuxt root element id.
     */
    rootId: "__nuxt",
    /**
     * Customize Nuxt root element tag.
     *
     */
    rootTag: "div"
  },
  /** A path to an HTML file, the contents of which will be inserted into any HTML page
   * rendered with `ssr: false`.
   *
   * By default Nuxt will look in `~/app/spa-loading-template.html` for this file.
   *
   * You can set this to `false` to disable any loading indicator.
   *
   * Some good sources for spinners are [SpinKit](https://github.com/tobiasahlin/SpinKit) or [SVG Spinners](https://icones.js.org/collection/svg-spinners).
   *
   * @example ~/app/spa-loading-template.html
   * ```html
   * <!-- https://github.com/barelyhuman/snips/blob/dev/pages/css-loader.md -->
   * <div class="loader"></div>
   * <style>
   * .loader {
   *   display: block;
   *   position: fixed;
   *   z-index: 1031;
   *   top: 50%;
   *   left: 50%;
   *   transform: translate(-50%, -50%);
   *   width: 18px;
   *   height: 18px;
   *   box-sizing: border-box;
   *   border: solid 2px transparent;
   *   border-top-color: #000;
   *   border-left-color: #000;
   *   border-bottom-color: #efefef;
   *   border-right-color: #efefef;
   *   border-radius: 50%;
   *   -webkit-animation: loader 400ms linear infinite;
   *   animation: loader 400ms linear infinite;
   * }
   *
   * \@-webkit-keyframes loader {
   *   0% {
   *     -webkit-transform: translate(-50%, -50%) rotate(0deg);
   *   }
   *   100% {
   *     -webkit-transform: translate(-50%, -50%) rotate(360deg);
   *   }
   * }
   * \@keyframes loader {
   *   0% {
   *     transform: translate(-50%, -50%) rotate(0deg);
   *   }
   *   100% {
   *     transform: translate(-50%, -50%) rotate(360deg);
   *   }
   * }
   * </style>
   * ```
   *
   * @type {string | false}
   */
  spaLoadingTemplate: {
    $resolve: async (val, get) => typeof val === "string" ? resolve(await get("srcDir"), val) : val ?? null
  },
  /**
   * An array of nuxt app plugins.
   *
   * Each plugin can be a string (which can be an absolute or relative path to a file).
   * If it ends with `.client` or `.server` then it will be automatically loaded only
   * in the appropriate context.
   *
   * It can also be an object with `src` and `mode` keys.
   *
   * @note Plugins are also auto-registered from the `~/plugins` directory
   * and these plugins do not need to be listed in `nuxt.config` unless you
   * need to customize their order. All plugins are deduplicated by their src path.
   *
   * @see https://nuxt.com/docs/guide/directory-structure/plugins
   *
   * @example
   * ```js
   * plugins: [
   *   '~/plugins/foo.client.js', // only in client side
   *   '~/plugins/bar.server.js', // only in server side
   *   '~/plugins/baz.js', // both client & server
   *   { src: '~/plugins/both-sides.js' },
   *   { src: '~/plugins/client-only.js', mode: 'client' }, // only on client side
   *   { src: '~/plugins/server-only.js', mode: 'server' } // only on server side
   * ]
   * ```
   * @type {(typeof import('../src/types/nuxt').NuxtPlugin | string)[]}
   */
  plugins: [],
  /**
   * You can define the CSS files/modules/libraries you want to set globally
   * (included in every page).
   *
   * Nuxt will automatically guess the file type by its extension and use the
   * appropriate pre-processor. You will still need to install the required
   * loader if you need to use them.
   *
   * @example
   * ```js
   * css: [
   *   // Load a Node.js module directly (here it's a Sass file).
   *   'bulma',
   *   // CSS file in the project
   *   '@/assets/css/main.css',
   *   // SCSS file in the project
   *   '@/assets/css/main.scss'
   * ]
   * ```
   * @type {string[]}
   */
  css: {
    $resolve: (val) => (val ?? []).map((c) => c.src || c)
  }
});
var build = defineUntypedSchema({
  /**
   * The builder to use for bundling the Vue part of your application.
   *
   * @type {'vite' | 'webpack' | { bundle: (nuxt: typeof import('../src/types/nuxt').Nuxt) => Promise<void> }}
   */
  builder: {
    $resolve: async (val, get) => {
      if (typeof val === "object") {
        return val;
      }
      const map = {
        vite: "@nuxt/vite-builder",
        webpack: "@nuxt/webpack-builder"
      };
      return map[val] || val || (await get("vite") === false ? map.webpack : map.vite);
    }
  },
  /**
   * Whether to generate sourcemaps.
   *
   * @type {boolean | { server?: boolean, client?: boolean }}
   */
  sourcemap: {
    $resolve: async (val, get) => {
      if (typeof val === "boolean") {
        return { server: val, client: val };
      }
      return defu(val, {
        server: true,
        client: await get("dev")
      });
    }
  },
  /**
   * Log level when building logs.
   *
   * Defaults to 'silent' when running in CI or when a TTY is not available.
   * This option is then used as 'silent' in Vite and 'none' in Webpack
   *
   * @type {'silent' | 'info' | 'verbose'}
   */
  logLevel: {
    $resolve: (val) => {
      if (val && !["silent", "info", "verbose"].includes(val)) {
        console.warn(`Invalid \`logLevel\` option: \`${val}\`. Must be one of: \`silent\`, \`info\`, \`verbose\`.`);
      }
      return val ?? (isTest ? "silent" : "info");
    }
  },
  /**
   * Shared build configuration.
   */
  build: {
    /**
     * If you want to transpile specific dependencies with Babel, you can add them here.
     * Each item in transpile can be a package name, a function, a string or regex object matching the
     * dependency's file name.
     *
     * You can also use a function to conditionally transpile. The function will receive an object ({ isDev, isServer, isClient, isModern, isLegacy }).
     *
     * @example
     * ```js
     transpile: [({ isLegacy }) => isLegacy && 'ky']
     * ```
     * @type {Array<string | RegExp | ((ctx: { isClient?: boolean; isServer?: boolean; isDev: boolean }) => string | RegExp | false)>}
     */
    transpile: {
      $resolve: (val) => [].concat(val).filter(Boolean)
    },
    /**
     * You can provide your own templates which will be rendered based
     * on Nuxt configuration. This feature is specially useful for using with modules.
     *
     * Templates are rendered using [`lodash/template`](https://lodash.com/docs/4.17.15#template).
     *
     * @example
     * ```js
     * templates: [
     *   {
     *     src: '~/modules/support/plugin.js', // `src` can be absolute or relative
     *     dst: 'support.js', // `dst` is relative to project `.nuxt` dir
     *     options: {
     *       // Options are provided to template as `options` key
     *       live_chat: false
     *     }
     *   }
     * ]
     * ```
     *
     * @type {typeof import('../src/types/nuxt').NuxtTemplate<any>[]}
     */
    templates: [],
    /**
     * Nuxt uses `webpack-bundle-analyzer` to visualize your bundles and how to optimize them.
     *
     * Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack-contrib/webpack-bundle-analyzer#options-for-plugin) or [for vite](https://github.com/btd/rollup-plugin-visualizer#options).
     *
     * @example
     * ```js
     * analyze: {
     *   analyzerMode: 'static'
     * }
     * ```
     * @type {boolean | typeof import('webpack-bundle-analyzer').BundleAnalyzerPlugin.Options | typeof import('rollup-plugin-visualizer').PluginVisualizerOptions}
     *
     */
    analyze: {
      $resolve: async (val, get) => {
        if (val !== true) {
          return val ?? false;
        }
        const rootDir = await get("rootDir");
        const analyzeDir = await get("analyzeDir");
        return {
          template: "treemap",
          projectRoot: rootDir,
          filename: join(analyzeDir, "{name}.html")
        };
      }
    }
  },
  /**
   * Build time optimization configuration.
   */
  optimization: {
    /**
     * Functions to inject a key for.
     *
     * As long as the number of arguments passed to the function is less than `argumentLength`, an
     * additional magic string will be injected that can be used to deduplicate requests between server
     * and client. You will need to take steps to handle this additional key.
     *
     * The key will be unique based on the location of the function being invoked within the file.
     *
     * @type {Array<{ name: string, source?: string | RegExp, argumentLength: number }>}
     */
    keyedComposables: {
      $resolve: (val) => [
        { name: "defineNuxtComponent", argumentLength: 2 },
        { name: "useState", argumentLength: 2 },
        { name: "useFetch", argumentLength: 3 },
        { name: "useAsyncData", argumentLength: 3 },
        { name: "useLazyAsyncData", argumentLength: 3 },
        { name: "useLazyFetch", argumentLength: 3 }
      ].concat(val).filter(Boolean)
    },
    /**
     * Tree shake code from specific builds.
     */
    treeShake: {
      /**
       * Tree shake composables from the server or client builds.
       *
       * @example
       * ```js
       * treeShake: { client: { myPackage: ['useServerOnlyComposable'] } }
       * ```
       */
      composables: {
        server: {
          $resolve: async (val, get) => defu(
            val || {},
            await get("dev") ? {} : {
              vue: ["onBeforeMount", "onMounted", "onBeforeUpdate", "onRenderTracked", "onRenderTriggered", "onActivated", "onDeactivated", "onBeforeUnmount"],
              "#app": ["definePayloadReviver", "definePageMeta"]
            }
          )
        },
        client: {
          $resolve: async (val, get) => defu(
            val || {},
            await get("dev") ? {} : {
              vue: ["onServerPrefetch", "onRenderTracked", "onRenderTriggered"],
              "#app": ["definePayloadReducer", "definePageMeta"]
            }
          )
        }
      }
    },
    /**
     * Options passed directly to the transformer from `unctx` that preserves async context
     * after `await`.
     *
     * @type {typeof import('unctx/transform').TransformerOptions}
     */
    asyncTransforms: {
      asyncFunctions: ["defineNuxtPlugin", "defineNuxtRouteMiddleware"],
      objectDefinitions: {
        defineNuxtComponent: ["asyncData", "setup"],
        defineNuxtPlugin: ["setup"],
        definePageMeta: ["middleware", "validate"]
      }
    }
  }
});
var common = defineUntypedSchema({
  /**
   * Extend project from multiple local or remote sources.
   *
   * Value should be either a string or array of strings pointing to source directories or config path relative to current config.
   *
   * You can use `github:`, `gitlab:`, `bitbucket:` or `https://` to extend from a remote git repository.
   *
   * @type {string|string[]}
   *
   */
  extends: null,
  /**
   * Extend project from a local or remote source.
   *
   * Value should be a string pointing to source directory or config path relative to current config.
   *
   * You can use `github:`, `gitlab:`, `bitbucket:` or `https://` to extend from a remote git repository.
   *
   * @type {string}
   *
   */
  theme: null,
  /**
   * Define the root directory of your application.
   *
   * This property can be overwritten (for example, running `nuxt ./my-app/`
   * will set the `rootDir` to the absolute path of `./my-app/` from the
   * current/working directory.
   *
   * It is normally not needed to configure this option.
   */
  rootDir: {
    $resolve: (val) => typeof val === "string" ? resolve(val) : process.cwd()
  },
  /**
   * Define the workspace directory of your application.
   *
   * Often this is used when in a monorepo setup. Nuxt will attempt to detect
   * your workspace directory automatically, but you can override it here.
   *
   * It is normally not needed to configure this option.
   */
  workspaceDir: {
    $resolve: async (val, get) => val ? resolve(await get("rootDir"), val) : await findWorkspaceDir(await get("rootDir")).catch(() => get("rootDir"))
  },
  /**
   * Define the source directory of your Nuxt application.
   *
   * If a relative path is specified, it will be relative to the `rootDir`.
   *
   * @example
   * ```js
   * export default {
   *   srcDir: 'src/'
   * }
   * ```
   * This would work with the following folder structure:
   * ```bash
   * -| app/
   * ---| node_modules/
   * ---| nuxt.config.js
   * ---| package.json
   * ---| src/
   * ------| assets/
   * ------| components/
   * ------| layouts/
   * ------| middleware/
   * ------| pages/
   * ------| plugins/
   * ------| static/
   * ------| store/
   * ------| server/
   * ```
   */
  srcDir: {
    $resolve: async (val, get) => resolve(await get("rootDir"), val || ".")
  },
  /**
   * Define the server directory of your Nuxt application, where Nitro
   * routes, middleware and plugins are kept.
   *
   * If a relative path is specified, it will be relative to your `rootDir`.
   *
   */
  serverDir: {
    $resolve: async (val, get) => resolve(await get("rootDir"), val || resolve(await get("srcDir"), "server"))
  },
  /**
   * Define the directory where your built Nuxt files will be placed.
   *
   * Many tools assume that `.nuxt` is a hidden directory (because it starts
   * with a `.`). If that is a problem, you can use this option to prevent that.
   *
   * @example
   * ```js
   * export default {
   *   buildDir: 'nuxt-build'
   * }
   * ```
   */
  buildDir: {
    $resolve: async (val, get) => resolve(await get("rootDir"), val || ".nuxt")
  },
  /**
   * Used to set the modules directories for path resolving (for example, webpack's
   * `resolveLoading`, `nodeExternals` and `postcss`).
   *
   * The configuration path is relative to `options.rootDir` (default is current working directory).
   *
   * Setting this field may be necessary if your project is organized as a yarn workspace-styled mono-repository.
   *
   * @example
   * ```js
   * export default {
   *   modulesDir: ['../../node_modules']
   * }
   * ```
   */
  modulesDir: {
    $default: ["node_modules"],
    $resolve: async (val, get) => [
      ...await Promise.all(val.map(async (dir) => resolve(await get("rootDir"), dir))),
      resolve(process.cwd(), "node_modules")
    ]
  },
  /**
   * The directory where Nuxt will store the generated files when running `nuxt analyze`.
   *
   * If a relative path is specified, it will be relative to your `rootDir`.
   */
  analyzeDir: {
    $resolve: async (val, get) => val ? resolve(await get("rootDir"), val) : resolve(await get("buildDir"), "analyze")
  },
  /**
   * Whether Nuxt is running in development mode.
   *
   * Normally, you should not need to set this.
   */
  dev: Boolean(isDevelopment),
  /**
   * Whether your app is being unit tested.
   */
  test: Boolean(isDevelopment),
  /**
   * Set to `true` to enable debug mode.
   *
   * At the moment, it prints out hook names and timings on the server, and
   * logs hook arguments as well in the browser.
   *
   */
  debug: {
    $resolve: async (val, get) => val ?? isDebug
  },
  /**
   * Whether to enable rendering of HTML - either dynamically (in server mode) or at generate time.
   * If set to `false` generated pages will have no content.
   */
  ssr: {
    $resolve: (val) => val ?? true
  },
  /**
   * Modules are Nuxt extensions which can extend its core functionality and add endless integrations.
   *
   * Each module is either a string (which can refer to a package, or be a path to a file), a
   * tuple with the module as first string and the options as a second object, or an inline module function.
   *
   * Nuxt tries to resolve each item in the modules array using node require path
   * (in `node_modules`) and then will be resolved from project `srcDir` if `~` alias is used.
   *
   * @note Modules are executed sequentially so the order is important.
   *
   * @example
   * ```js
   * modules: [
   *   // Using package name
   *   '@nuxtjs/axios',
   *   // Relative to your project srcDir
   *   '~/modules/awesome.js',
   *   // Providing options
   *   ['@nuxtjs/google-analytics', { ua: 'X1234567' }],
   *   // Inline definition
   *   function () {}
   * ]
   * ```
   * @type {(typeof import('../src/types/module').NuxtModule | string | [typeof import('../src/types/module').NuxtModule | string, Record<string, any>] | undefined | null | false)[]}
   */
  modules: {
    $resolve: (val) => [].concat(val).filter(Boolean)
  },
  /**
   * Customize default directory structure used by Nuxt.
   *
   * It is better to stick with defaults unless needed.
   */
  dir: {
    /**
     * The assets directory (aliased as `~assets` in your build).
     */
    assets: "assets",
    /**
     * The layouts directory, each file of which will be auto-registered as a Nuxt layout.
     */
    layouts: "layouts",
    /**
     * The middleware directory, each file of which will be auto-registered as a Nuxt middleware.
     */
    middleware: "middleware",
    /**
     * The modules directory, each file in which will be auto-registered as a Nuxt module.
     */
    modules: "modules",
    /**
     * The directory which will be processed to auto-generate your application page routes.
     */
    pages: "pages",
    /**
     * The plugins directory, each file of which will be auto-registered as a Nuxt plugin.
     */
    plugins: "plugins",
    /**
     * The directory containing your static files, which will be directly accessible via the Nuxt server
     * and copied across into your `dist` folder when your app is generated.
     */
    public: {
      $resolve: async (val, get) => val || await get("dir.static") || "public"
    },
    static: {
      $schema: { deprecated: "use `dir.public` option instead" },
      $resolve: async (val, get) => val || await get("dir.public") || "public"
    }
  },
  /**
   * The extensions that should be resolved by the Nuxt resolver.
   */
  extensions: {
    $resolve: (val) => [".js", ".jsx", ".mjs", ".ts", ".tsx", ".vue"].concat(val).filter(Boolean)
  },
  /**
   * You can improve your DX by defining additional aliases to access custom directories
   * within your JavaScript and CSS.
   *
   * @note Within a webpack context (image sources, CSS - but not JavaScript) you _must_ access
   * your alias by prefixing it with `~`.
   *
   * @note These aliases will be automatically added to the generated `.nuxt/tsconfig.json` so you can get full
   * type support and path auto-complete. In case you need to extend options provided by `./.nuxt/tsconfig.json`
   * further, make sure to add them here or within the `typescript.tsConfig` property in `nuxt.config`.
   *
   * @example
   * ```js
   * export default {
   *   alias: {
   *     'images': fileURLToPath(new URL('./assets/images', import.meta.url)),
   *     'style': fileURLToPath(new URL('./assets/style', import.meta.url)),
   *     'data': fileURLToPath(new URL('./assets/other/data', import.meta.url))
   *   }
   * }
   * ```
   *
   * ```html
   * <template>
   *   <img src="~images/main-bg.jpg">
   * </template>
   *
   * <script>
   * import data from 'data/test.json'
   * <\/script>
   *
   * <style>
   * // Uncomment the below
   * //@import '~style/variables.scss';
   * //@import '~style/utils.scss';
   * //@import '~style/base.scss';
   * body {
   *   background-image: url('~images/main-bg.jpg');
   * }
   * </style>
   * ```
   *
   * @type {Record<string, string>}
   */
  alias: {
    $resolve: async (val, get) => ({
      "~": await get("srcDir"),
      "@": await get("srcDir"),
      "~~": await get("rootDir"),
      "@@": await get("rootDir"),
      [await get("dir.assets")]: join(await get("srcDir"), await get("dir.assets")),
      [await get("dir.public")]: join(await get("srcDir"), await get("dir.public")),
      ...val
    })
  },
  /**
   * Pass options directly to `node-ignore` (which is used by Nuxt to ignore files).
   *
   * @see [node-ignore](https://github.com/kaelzhang/node-ignore)
   *
   * @example
   * ```js
   * ignoreOptions: {
   *   ignorecase: false
   * }
   * ```
   */
  ignoreOptions: void 0,
  /**
   * Any file in `pages/`, `layouts/`, `middleware/` or `store/` will be ignored during
   * building if its filename starts with the prefix specified by `ignorePrefix`.
   */
  ignorePrefix: {
    $resolve: (val) => val ?? "-"
  },
  /**
   * More customizable than `ignorePrefix`: all files matching glob patterns specified
   * inside the `ignore` array will be ignored in building.
   */
  ignore: {
    $resolve: async (val, get) => [
      "**/*.stories.{js,cts,mts,ts,jsx,tsx}",
      // ignore storybook files
      "**/*.{spec,test}.{js,cts,mts,ts,jsx,tsx}",
      // ignore tests
      "**/*.d.{cts,mts,ts}",
      // ignore type declarations
      "**/.{vercel,netlify,output,git,cache,data}",
      relative(await get("rootDir"), await get("analyzeDir")),
      relative(await get("rootDir"), await get("buildDir")),
      await get("ignorePrefix") && `**/${await get("ignorePrefix")}*.*`
    ].concat(val).filter(Boolean)
  },
  /**
   * The watch property lets you define patterns that will restart the Nuxt dev server when changed.
   *
   * It is an array of strings or regular expressions, which will be matched against the file path
   * relative to the project `srcDir`.
   *
   * @type {Array<string | RegExp>}
   */
  watch: {
    $resolve: (val) => [].concat(val).filter((b) => typeof b === "string" || b instanceof RegExp)
  },
  /**
   * The watchers property lets you overwrite watchers configuration in your `nuxt.config`.
   */
  watchers: {
    /** An array of event types, which, when received, will cause the watcher to restart. */
    rewatchOnRawEvents: void 0,
    /**
     * `watchOptions` to pass directly to webpack.
     *
     * @see [webpack@4 watch options](https://v4.webpack.js.org/configuration/watch/#watchoptions).
     *  */
    webpack: {
      aggregateTimeout: 1e3
    },
    /**
     * Options to pass directly to `chokidar`.
     *
     * @see [chokidar](https://github.com/paulmillr/chokidar#api)
     */
    chokidar: {
      ignoreInitial: true
    }
  },
  /**
   * Hooks are listeners to Nuxt events that are typically used in modules,
   * but are also available in `nuxt.config`.
   *
   * Internally, hooks follow a naming pattern using colons (e.g., build:done).
   *
   * For ease of configuration, you can also structure them as an hierarchical
   * object in `nuxt.config` (as below).
   *
   * @example
   * ```js'node:fs'
   * import fs from 'node:fs'
   * import path from 'node:path'
   * export default {
   *   hooks: {
   *     build: {
   *       done(builder) {
   *         const extraFilePath = path.join(
   *           builder.nuxt.options.buildDir,
   *           'extra-file'
   *         )
   *         fs.writeFileSync(extraFilePath, 'Something extra')
   *       }
   *     }
   *   }
   * }
   * ```
   * @type {typeof import('../src/types/hooks').NuxtHooks}
   */
  hooks: null,
  /**
   * Runtime config allows passing dynamic config and environment variables to the Nuxt app context.
   *
   * The value of this object is accessible from server only using `useRuntimeConfig`.
   *
   * It mainly should hold _private_ configuration which is not exposed on the frontend.
   * This could include a reference to your API secret tokens.
   *
   * Anything under `public` and `app` will be exposed to the frontend as well.
   *
   * Values are automatically replaced by matching env variables at runtime, e.g. setting an environment
   * variable `NUXT_API_KEY=my-api-key NUXT_PUBLIC_BASE_URL=/foo/` would overwrite the two values in the example below.
   *
   * @example
   * ```js
   * export default {
   *  runtimeConfig: {
   *     apiKey: '' // Default to an empty string, automatically set at runtime using process.env.NUXT_API_KEY
   *     public: {
   *        baseURL: '' // Exposed to the frontend as well.
   *     }
   *   }
   * }
   * ```
   * @type {typeof import('../src/types/config').RuntimeConfig}
   */
  runtimeConfig: {
    $resolve: async (val, get) => {
      provideFallbackValues(val);
      return defu(val, {
        public: {},
        app: {
          baseURL: (await get("app")).baseURL,
          buildAssetsDir: (await get("app")).buildAssetsDir,
          cdnURL: (await get("app")).cdnURL
        }
      });
    }
  },
  /**
   * Additional app configuration
   *
   * For programmatic usage and type support, you can directly provide app config with this option.
   * It will be merged with `app.config` file as default value.
   *
   * @type {typeof import('../src/types/config').AppConfig}
   */
  appConfig: {},
  $schema: {}
});
function provideFallbackValues(obj) {
  for (const key in obj) {
    if (typeof obj[key] === "undefined" || obj[key] === null) {
      obj[key] = "";
    } else if (typeof obj[key] === "object") {
      provideFallbackValues(obj[key]);
    }
  }
}
var dev = defineUntypedSchema({
  devServer: {
    /**
     * Whether to enable HTTPS.
     *
     * @example
     * ```
     * export default defineNuxtConfig({
     *   devServer: {
     *     https: {
     *       key: './server.key',
     *       cert: './server.crt'
     *     }
     *   }
     * })
     * ```
     *
     *
     * @type {boolean | { key: string; cert: string }}
     *
     */
    https: false,
    /** Dev server listening port */
    port: process.env.NUXT_PORT || process.env.NITRO_PORT || process.env.PORT || 3e3,
    /** Dev server listening host */
    host: process.env.NUXT_HOST || process.env.NITRO_HOST || process.env.HOST || "",
    /**
     * Listening dev server URL.
     *
     * This should not be set directly as it will always be overridden by the
     * dev server with the full URL (for module and internal use).
     */
    url: "http://localhost:3000"
  }
});
var experimental = defineUntypedSchema({
  experimental: {
    /**
     * Set to true to generate an async entry point for the Vue bundle (for module federation support).
     */
    asyncEntry: {
      $resolve: (val) => val ?? false
    },
    /**
     * Enable Vue's reactivity transform
     * @see https://vuejs.org/guide/extras/reactivity-transform.html
     *
     * Warning: Reactivity transform feature has been marked as deprecated in Vue 3.3 and is planned to be
     * removed from core in Vue 3.4.
     * @see https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028
     */
    reactivityTransform: false,
    // TODO: Remove in v3.6 when nitro has support for mocking traced dependencies
    // https://github.com/unjs/nitro/issues/1118
    /**
     * Externalize `vue`, `@vue/*` and `vue-router` when building.
     * @see https://github.com/nuxt/nuxt/issues/13632
     */
    externalVue: true,
    /**
     * Tree shakes contents of client-only components from server bundle.
     * @see https://github.com/nuxt/framework/pull/5750
     */
    treeshakeClientOnly: true,
    /**
     * Emit `app:chunkError` hook when there is an error loading vite/webpack
     * chunks.
     *
     * By default, Nuxt will also perform a hard reload of the new route
     * when a chunk fails to load when navigating to a new route.
     *
     * You can disable automatic handling by setting this to `false`, or handle
     * chunk errors manually by setting it to `manual`.
     *
     * @see https://github.com/nuxt/nuxt/pull/19038
     * @type {false | 'manual' | 'automatic'}
     */
    emitRouteChunkError: {
      $resolve: (val) => {
        if (val === true) {
          return "manual";
        }
        if (val === "reload") {
          return "automatic";
        }
        return val ?? "automatic";
      }
    },
    /**
     * Whether to restore Nuxt app state from `sessionStorage` when reloading the page
     * after a chunk error or manual `reloadNuxtApp()` call.
     *
     * To avoid hydration errors, it will be applied only after the Vue app has been mounted,
     * meaning there may be a flicker on initial load.
     *
     * Consider carefully before enabling this as it can cause unexpected behavior, and
     * consider providing explicit keys to `useState` as auto-generated keys may not match
     * across builds.
     *
     * @type {boolean}
     */
    restoreState: false,
    /**
     * Inline styles when rendering HTML (currently vite only).
     *
     * You can also pass a function that receives the path of a Vue component
     * and returns a boolean indicating whether to inline the styles for that component.
     *
     * @type {boolean | ((id?: string) => boolean)}
     */
    inlineSSRStyles: {
      async $resolve(val, get) {
        if (val === false || await get("dev") || await get("ssr") === false || await get("builder") === "@nuxt/webpack-builder") {
          return false;
        }
        return val ?? true;
      }
    },
    /**
     * Turn off rendering of Nuxt scripts and JS resource hints.
     * You can also disable scripts more granularly within `routeRules`.
     */
    noScripts: false,
    /** Render JSON payloads with support for revivifying complex types. */
    renderJsonPayloads: true,
    /**
     * Disable vue server renderer endpoint within nitro.
    */
    noVueServer: false,
    /**
     * When this option is enabled (by default) payload of pages generated with `nuxt generate` are extracted
     *
     * @type {boolean | undefined}
     */
    payloadExtraction: void 0,
    /**
     * Whether to enable the experimental `<NuxtClientFallback>` component for rendering content on the client
     * if there's an error in SSR.
     */
    clientFallback: false,
    /** Enable cross-origin prefetch using the Speculation Rules API. */
    crossOriginPrefetch: false,
    /**
     * Enable View Transition API integration with client-side router.
     *
     * @see https://developer.chrome.com/docs/web-platform/view-transitions
     */
    viewTransition: false,
    /**
     * Write early hints when using node server.
     *
     * @note nginx does not support 103 Early hints in the current version.
     */
    writeEarlyHints: false,
    /**
     * Experimental component islands support with <NuxtIsland> and .island.vue files.
     */
    componentIslands: false,
    /**
     * Config schema support
     *
     * @see https://github.com/nuxt/nuxt/issues/15592
     */
    configSchema: true,
    /**
     * This enables 'Bundler' module resolution mode for TypeScript, which is the recommended setting
     * for frameworks like Nuxt and Vite.
     *
     * It improves type support when using modern libraries with `exports`.
     *
     * This is only not enabled by default because it could be a breaking change for some projects.
     *
     * See https://github.com/microsoft/TypeScript/pull/51669
     */
    typescriptBundlerResolution: {
      async $resolve(val, get) {
        if (typeof val === "boolean") {
          return val;
        }
        const setting = await get("typescript.tsConfig.compilerOptions.moduleResolution");
        if (setting) {
          return setting.toLowerCase() === "bundler";
        }
        return false;
      }
    },
    /**
     * Whether or not to add a compatibility layer for modules, plugins or user code relying on the old
     * `@vueuse/head` API.
     *
     * This can be disabled for most Nuxt sites to reduce the client-side bundle by ~0.5kb.
     */
    polyfillVueUseHead: false,
    /** Allow disabling Nuxt SSR responses by setting the `x-nuxt-no-ssr` header. */
    respectNoSSRHeader: false,
    /** Resolve `~`, `~~`, `@` and `@@` aliases located within layers with respect to their layer source and root directories. */
    localLayerAliases: true,
    /** Enable the new experimental typed router using [unplugin-vue-router](https://github.com/posva/unplugin-vue-router). */
    typedPages: false,
    /**
     * Set an alternative watcher that will be used as the watching service for Nuxt.
     *
     * Nuxt uses 'chokidar-granular' by default, which will ignore top-level directories
     * (like `node_modules` and `.git`) that are excluded from watching.
     *
     * You can set this instead to `parcel` to use `@parcel/watcher`, which may improve
     * performance in large projects or on Windows platforms.
     *
     * You can also set this to `chokidar` to watch all files in your source directory.
     *
     * @see https://github.com/paulmillr/chokidar
     * @see https://github.com/parcel-bundler/watcher
     * @type {'chokidar' | 'parcel' | 'chokidar-granular'}
     */
    watcher: "chokidar-granular"
  }
});
var generate = defineUntypedSchema({
  generate: {
    /**
     * The routes to generate.
     *
     * If you are using the crawler, this will be only the starting point for route generation.
     * This is often necessary when using dynamic routes.
     *
     * It is preferred to use `nitro.prerender.routes`.
     *
     * @example
     * ```js
     * routes: ['/users/1', '/users/2', '/users/3']
     * ```
     * 
     * @type {string | string[]}
     */
    routes: [],
    /**
     * This option is no longer used. Instead, use `nitro.prerender.ignore`.
     * 
     * @deprecated
     */
    exclude: []
  }
});
var internal = defineUntypedSchema({
  /** @private */
  _majorVersion: 3,
  /** @private */
  _legacyGenerate: false,
  /** @private */
  _start: false,
  /** @private */
  _build: false,
  /** @private */
  _generate: false,
  /** @private */
  _prepare: false,
  /** @private */
  _cli: false,
  /** @private */
  _requiredModules: {},
  /** @private */
  _nuxtConfigFile: void 0,
  /** @private */
  _nuxtConfigFiles: [],
  /** @private */
  appDir: "",
  /** @private */
  _installedModules: [],
  /** @private */
  _modules: []
});
var nitro = defineUntypedSchema({
  /**
   * Configuration for Nitro.
   *
   * @see https://nitro.unjs.io/config/
   *
   * @type {typeof import('nitropack')['NitroConfig']}
   */
  nitro: {
    routeRules: {
      $resolve: async (val, get) => ({
        ...await get("routeRules") || {},
        ...val || {}
      })
    }
  },
  /**
   * Global route options applied to matching server routes.
   *
   * @experimental This is an experimental feature and API may change in the future.
   *
   * @see https://nitro.unjs.io/config/#routerules
   *
   * @type {typeof import('nitropack')['NitroConfig']['routeRules']}
   */
  routeRules: {},
  /**
   * Nitro server handlers.
   *
   * Each handler accepts the following options:
   * - handler: The path to the file defining the handler.
   * - route: The route under which the handler is available. This follows the conventions of https://github.com/unjs/radix3.
   * - method: The HTTP method of requests that should be handled.
   * - middleware: Specifies whether it is a middleware handler.
   * - lazy: Specifies whether to use lazy loading to import the handler.
   *
   * @see https://nuxt.com/docs/guide/directory-structure/server
   *
   * @note Files from `server/api`, `server/middleware` and `server/routes` will be automatically registered by Nuxt.
   *
   * @example
   * ```js
   * serverHandlers: [
   *   { route: '/path/foo/**:name', handler: '~/server/foohandler.ts' }
   * ]
   * ```
   *
   * @type {typeof import('nitropack')['NitroEventHandler'][]}
   */
  serverHandlers: [],
  /**
   * Nitro development-only server handlers.
   *
   * @see https://nitro.unjs.io/guide/routing
   *
   * @type {typeof import('nitropack')['NitroDevEventHandler'][]}
   */
  devServerHandlers: []
});
var postcss = defineUntypedSchema({
  postcss: {
    /**
     * Options for configuring PostCSS plugins.
     *
     * https://postcss.org/
     * @type {Record<string, any>}
     */
    plugins: {
      /**
       * https://github.com/postcss/postcss-import
       */
      "postcss-import": {
        $resolve: async (val, get) => val !== false ? defu(val || {}, {
          resolve: (0, import_postcss_import_resolver.default)({
            alias: { ...await get("alias") },
            modules: [
              await get("srcDir"),
              await get("rootDir"),
              ...await get("modulesDir")
            ]
          })
        }) : val
      },
      /**
       * https://github.com/postcss/postcss-url
       */
      "postcss-url": {},
      /**
       * https://github.com/postcss/autoprefixer
       */
      autoprefixer: {},
      cssnano: {
        $resolve: async (val, get) => val ?? !(await get("dev") && {
          preset: ["default", {
            // Keep quotes in font values to prevent from HEX conversion
            // https://github.com/nuxt/nuxt/issues/6306
            minifyFontValues: { removeQuotes: false }
          }]
        })
      }
    }
  }
});
var router = defineUntypedSchema({
  router: {
    /**
     * Additional options passed to `vue-router`.
     *
     * Note: Only JSON serializable options should be passed by nuxt config.
     *
     * For more control, you can use `app/router.options.ts` file.
     *
     * @see [documentation](https://router.vuejs.org/api/interfaces/routeroptions.html).
     * @type {typeof import('../src/types/router').RouterConfigSerializable}
     *
     */
    options: {}
  }
});
var typescript = defineUntypedSchema({
  /**
   * Configuration for Nuxt's TypeScript integration.
   *
   */
  typescript: {
    /**
     * TypeScript comes with certain checks to give you more safety and analysis of your program.
     * Once youve converted your codebase to TypeScript, you can start enabling these checks for greater safety.
     * [Read More](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks)
     */
    strict: true,
    /**
     * Which builder types to include for your project.
     *
     * By default Nuxt infers this based on your `builder` option (defaulting to 'vite') but you can either turn off
     * builder environment types (with `false`) to handle this fully yourself, or opt for a 'shared' option.
     *
     * The 'shared' option is advised for module authors, who will want to support multiple possible builders.
     *
     * @type {'vite' | 'webpack' | 'shared' | false | undefined}
     */
    builder: {
      $resolve: async (val, get) => val ?? null
    },
    /**
     * Include parent workspace in the Nuxt project. Mostly useful for themes and module authors.
     */
    includeWorkspace: false,
    /**
     * Enable build-time type checking.
     *
     * If set to true, this will type check in development. You can restrict this to build-time type checking by setting it to `build`.
     * Requires to install `typescript` and `vue-tsc` as dev dependencies.
     *
     * @see https://nuxt.com/docs/guide/concepts/typescript
     *
     * @type {boolean | 'build'}
     */
    typeCheck: false,
    /**
     * You can extend generated `.nuxt/tsconfig.json` using this option.
     * @type {typeof import('pkg-types')['TSConfig']}
     */
    tsConfig: {},
    /**
     * Generate a `*.vue` shim.
     *
     * We recommend instead either enabling [**Take Over Mode**](https://vuejs.org/guide/typescript/overview.html#volar-takeover-mode) or adding
     * TypeScript Vue Plugin (Volar)**  [[Download](https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin)].
     */
    shim: true
  }
});
var vite = defineUntypedSchema({
  /**
   * Configuration that will be passed directly to Vite.
   *
   * See https://vitejs.dev/config for more information.
   * Please note that not all vite options are supported in Nuxt.
   *
   * @type {typeof import('../src/types/config').ViteConfig}
   */
  vite: {
    root: {
      $resolve: async (val, get) => val ?? await get("srcDir")
    },
    mode: {
      $resolve: async (val, get) => val ?? (await get("dev") ? "development" : "production")
    },
    define: {
      $resolve: async (val, get) => ({
        "process.dev": await get("dev"),
        "process.test": isTest,
        ...val || {}
      })
    },
    resolve: {
      extensions: [".mjs", ".js", ".ts", ".jsx", ".tsx", ".json", ".vue"]
    },
    publicDir: {
      $resolve: async (val, get) => {
        if (val) {
          console.warn("Directly configuring the `vite.publicDir` option is not supported. Instead, set `dir.public`. You can read more in `https://nuxt.com/docs/api/configuration/nuxt-config#public`.");
        }
        return val ?? resolve(await get("srcDir"), (await get("dir")).public);
      }
    },
    vue: {
      isProduction: {
        $resolve: async (val, get) => val ?? !await get("dev")
      },
      template: {
        compilerOptions: {
          $resolve: async (val, get) => val ?? (await get("vue")).compilerOptions
        }
      },
      script: {
        propsDestructure: {
          $resolve: async (val, get) => val ?? Boolean((await get("vue")).propsDestructure)
        },
        defineModel: {
          $resolve: async (val, get) => val ?? Boolean((await get("vue")).defineModel)
        }
      }
    },
    vueJsx: {
      $resolve: async (val, get) => {
        var _a;
        return {
          isCustomElement: (_a = (await get("vue")).compilerOptions) == null ? void 0 : _a.isCustomElement,
          ...val || {}
        };
      }
    },
    optimizeDeps: {
      exclude: {
        $resolve: async (val, get) => [
          ...val || [],
          ...(await get("build.transpile")).filter((i) => typeof i === "string"),
          "vue-demi"
        ]
      }
    },
    esbuild: {
      jsxFactory: "h",
      jsxFragment: "Fragment",
      tsconfigRaw: "{}"
    },
    clearScreen: true,
    build: {
      assetsDir: {
        $resolve: async (val, get) => val ?? withoutLeadingSlash((await get("app")).buildAssetsDir)
      },
      emptyOutDir: false
    },
    server: {
      fs: {
        allow: {
          $resolve: async (val, get) => [
            await get("buildDir"),
            await get("srcDir"),
            await get("rootDir"),
            await get("workspaceDir"),
            ...await get("modulesDir"),
            ...val ?? []
          ]
        }
      }
    }
  }
});
var webpack = defineUntypedSchema({
  webpack: {
    /**
     * Nuxt uses `webpack-bundle-analyzer` to visualize your bundles and how to optimize them.
     *
     * Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack-contrib/webpack-bundle-analyzer#options-for-plugin) or [for vite](https://github.com/btd/rollup-plugin-visualizer#options).
     *
     * @example
     * ```js
     * analyze: {
     *   analyzerMode: 'static'
     * }
     * ```
     * @type {boolean | typeof import('webpack-bundle-analyzer').BundleAnalyzerPlugin.Options}
     */
    analyze: {
      $resolve: async (val, get) => {
        if (val !== true) {
          return val ?? false;
        }
        const rootDir = await get("rootDir");
        const analyzeDir = await get("analyzeDir");
        return {
          template: "treemap",
          projectRoot: rootDir,
          filename: join(analyzeDir, "{name}.html")
        };
      }
    },
    /**
     * Enable the profiler in webpackbar.
     *
     * It is normally enabled by CLI argument `--profile`.
     *
     * @see [webpackbar](https://github.com/unjs/webpackbar#profile).
     */
    profile: process.argv.includes("--profile"),
    /**
     * Enables Common CSS Extraction.
     *
     * Using [mini-css-extract-plugin](https://github.com/webpack-contrib/mini-css-extract-plugin) under the hood, your CSS will be extracted
     * into separate files, usually one per component. This allows caching your CSS and
     * JavaScript separately.
     *
     * @example
     * ```js
     * export default {
     *   webpack: {
     *     extractCSS: true,
     *     // or
     *     extractCSS: {
     *       ignoreOrder: true
     *     }
     *   }
     * }
     * ```
     *
     * If you want to extract all your CSS to a single file, there is a workaround for this.
     * However, note that it is not recommended to extract everything into a single file.
     * Extracting into multiple CSS files is better for caching and preload isolation. It
     * can also improve page performance by downloading and resolving only those resources
     * that are needed.
     *
     * @example
     * ```js
     * export default {
     *   webpack: {
     *     extractCSS: true,
     *     optimization: {
     *       splitChunks: {
     *         cacheGroups: {
     *           styles: {
     *             name: 'styles',
     *             test: /\.(css|vue)$/,
     *             chunks: 'all',
     *             enforce: true
     *           }
     *         }
     *       }
     *     }
     *   }
     * }
     * ```
     * @type {boolean | typeof import('mini-css-extract-plugin').PluginOptions}
     */
    extractCSS: true,
    /**
     * Enables CSS source map support (defaults to `true` in development).
     */
    cssSourceMap: {
      $resolve: async (val, get) => val ?? await get("dev")
    },
    /**
     * The polyfill library to load to provide URL and URLSearchParams.
     *
     * Defaults to `'url'` ([see package](https://www.npmjs.com/package/url)).
     */
    serverURLPolyfill: "url",
    /**
     * Customize bundle filenames.
     *
     * To understand a bit more about the use of manifests, take a look at [this webpack documentation](https://webpack.js.org/guides/code-splitting/).
     *
     * @note Be careful when using non-hashed based filenames in production
     * as most browsers will cache the asset and not detect the changes on first load.
     *
     * This example changes fancy chunk names to numerical ids:
     *
     * @example
     * ```js
     * filenames: {
     *   chunk: ({ isDev }) => (isDev ? '[name].js' : '[id].[contenthash].js')
     * }
     * ```
     * 
     * @type {
     *  Record<
     *    string,
     *    string |
     *    ((
     *      ctx: {
     *        nuxt: import('../src/types/nuxt').Nuxt,
     *        options: import('../src/types/nuxt').Nuxt['options'],
     *        name: string,
     *        isDev: boolean,
     *        isServer: boolean,
     *        isClient: boolean,
     *        alias: { [index: string]: string | false | string[] },
     *        transpile: RegExp[]
     *      }) => string)
     *  >
     * }
     */
    filenames: {
      app: ({ isDev }) => isDev ? `[name].js` : `[contenthash:7].js`,
      chunk: ({ isDev }) => isDev ? `[name].js` : `[contenthash:7].js`,
      css: ({ isDev }) => isDev ? "[name].css" : "css/[contenthash:7].css",
      img: ({ isDev }) => isDev ? "[path][name].[ext]" : "img/[name].[contenthash:7].[ext]",
      font: ({ isDev }) => isDev ? "[path][name].[ext]" : "fonts/[name].[contenthash:7].[ext]",
      video: ({ isDev }) => isDev ? "[path][name].[ext]" : "videos/[name].[contenthash:7].[ext]"
    },
    /**
     * Customize the options of Nuxt's integrated webpack loaders.
     */
    loaders: {
      $resolve: async (val, get) => {
        const styleLoaders = [
          "css",
          "cssModules",
          "less",
          "sass",
          "scss",
          "stylus",
          "vueStyle"
        ];
        for (const name of styleLoaders) {
          const loader = val[name];
          if (loader && loader.sourceMap === void 0) {
            loader.sourceMap = Boolean(await get("build.cssSourceMap"));
          }
        }
        return val;
      },
      /**
       * See https://github.com/esbuild-kit/esbuild-loader
       * @type {Omit<typeof import('esbuild-loader')['LoaderOptions'], 'loader'>}
      */
      esbuild: {},
      /**
       * See: https://github.com/webpack-contrib/file-loader#options
       * @type {Omit<typeof import('file-loader')['Options'], 'name'>}
       *
       * @default
       * ```ts
       * { esModule: false }
       * ```
       */
      file: { esModule: false },
      /**
       * See: https://github.com/webpack-contrib/file-loader#options
       * @type {Omit<typeof import('file-loader')['Options'], 'name'>}
       *
       * @default
       * ```ts
       * { esModule: false, limit: 1000  }
       * ```
       */
      fontUrl: { esModule: false, limit: 1e3 },
      /**
       * See: https://github.com/webpack-contrib/file-loader#options
       * @type {Omit<typeof import('file-loader')['Options'], 'name'>}
       *
       * @default
       * ```ts
       * { esModule: false, limit: 1000  }
       * ```
       */
      imgUrl: { esModule: false, limit: 1e3 },
      /**
       * See: https://pugjs.org/api/reference.html#options
       * @type {typeof import('pug')['Options']}
       */
      pugPlain: {},
      /**
       * See [vue-loader](https://github.com/vuejs/vue-loader) for available options.
       * @type {Partial<typeof import('vue-loader')['VueLoaderOptions']>}
       */
      vue: {
        transformAssetUrls: {
          video: "src",
          source: "src",
          object: "src",
          embed: "src"
        },
        compilerOptions: { $resolve: async (val, get) => val ?? await get("vue.compilerOptions") },
        propsDestructure: { $resolve: async (val, get) => val ?? Boolean(await get("vue.propsDestructure")) },
        defineModel: { $resolve: async (val, get) => val ?? Boolean(await get("vue.defineModel")) }
      },
      css: {
        importLoaders: 0,
        url: {
          filter: (url, resourcePath) => !url.startsWith("/")
        },
        esModule: false
      },
      cssModules: {
        importLoaders: 0,
        url: {
          filter: (url, resourcePath) => !url.startsWith("/")
        },
        esModule: false,
        modules: {
          localIdentName: "[local]_[hash:base64:5]"
        }
      },
      /**
       * See: https://github.com/webpack-contrib/less-loader#options
       */
      less: {},
      /**
       * See: https://github.com/webpack-contrib/sass-loader#options
       * @type {typeof import('sass-loader')['Options']}
       * 
       * @default
       * ```ts
       * {
       *   sassOptions: {
       *     indentedSyntax: true
       *   }
       * }
       * ```
       */
      sass: {
        sassOptions: {
          indentedSyntax: true
        }
      },
      /**
       * See: https://github.com/webpack-contrib/sass-loader#options
       * @type {typeof import('sass-loader')['Options']}
       */
      scss: {},
      /**
       * See: https://github.com/webpack-contrib/stylus-loader#options
       */
      stylus: {},
      vueStyle: {}
    },
    /**
     * Add webpack plugins.
     *
     * @example
     * ```js
     * import webpack from 'webpack'
     * import { version } from './package.json'
     * // ...
     * plugins: [
     *   new webpack.DefinePlugin({
     *     'process.VERSION': version
     *   })
     * ]
     * ```
     */
    plugins: [],
    /**
     * Hard-replaces `typeof process`, `typeof window` and `typeof document` to tree-shake bundle.
     */
    aggressiveCodeRemoval: false,
    /**
     * OptimizeCSSAssets plugin options.
     *
     * Defaults to true when `extractCSS` is enabled.
     *
     * @see [css-minimizer-webpack-plugin documentation](https://github.com/webpack-contrib/css-minimizer-webpack-plugin).
     *
     * @type {false | typeof import('css-minimizer-webpack-plugin').BasePluginOptions & typeof import('css-minimizer-webpack-plugin').DefinedDefaultMinimizerAndOptions<any>}
     */
    optimizeCSS: {
      $resolve: async (val, get) => val ?? (await get("build.extractCSS") ? {} : false)
    },
    /**
     * Configure [webpack optimization](https://webpack.js.org/configuration/optimization/).
     * @type {false | typeof import('webpack').Configuration['optimization']}
     */
    optimization: {
      runtimeChunk: "single",
      /** Set minimize to `false` to disable all minimizers. (It is disabled in development by default). */
      minimize: { $resolve: async (val, get) => val ?? !await get("dev") },
      /** You can set minimizer to a customized array of plugins. */
      minimizer: void 0,
      splitChunks: {
        chunks: "all",
        automaticNameDelimiter: "/",
        cacheGroups: {}
      }
    },
    /**
     * Customize PostCSS Loader.
     * Same options as https://github.com/webpack-contrib/postcss-loader#options
     *
     * @type {{ execute?: boolean, postcssOptions: typeof import('postcss').ProcessOptions, sourceMap?: boolean, implementation?: any }}
     */
    postcss: {
      postcssOptions: {
        config: {
          $resolve: async (val, get) => val ?? await get("postcss.config")
        },
        plugins: {
          $resolve: async (val, get) => val ?? await get("postcss.plugins")
        }
      }
    },
    /**
     * See [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware) for available options.
     * @type {typeof import('webpack-dev-middleware').Options<typeof import('http').IncomingMessage, typeof import('http').ServerResponse>}
     */
    devMiddleware: {
      stats: "none"
    },
    /**
     * See [webpack-hot-middleware](https://github.com/webpack-contrib/webpack-hot-middleware) for available options.
     * @type {typeof import('webpack-hot-middleware').MiddlewareOptions & { client?: typeof import('webpack-hot-middleware').ClientOptions }}
     */
    hotMiddleware: {},
    /**
     * Set to `false` to disable the overlay provided by [FriendlyErrorsWebpackPlugin](https://github.com/nuxt/friendly-errors-webpack-plugin).
     */
    friendlyErrors: true,
    /**
     * Filters to hide build warnings.
     * @type {Array<(warn: typeof import('webpack').WebpackError) => boolean>}
     */
    warningIgnoreFilters: [],
    /**
     * Configure [webpack experiments](https://webpack.js.org/configuration/experiments/)
     * @type {false | typeof import('webpack').Configuration['experiments']}
     */
    experiments: {}
  }
});
var index = {
  ...adhoc,
  ...app,
  ...build,
  ...common,
  ...dev,
  ...experimental,
  ...generate,
  ...internal,
  ...nitro,
  ...postcss,
  ...router,
  ...typescript,
  ...vite,
  ...webpack
};

// node_modules/@nuxt/kit/dist/index.mjs
var import_hash_sum = __toESM(require_hash_sum(), 1);
var logger = consola;
var nuxtCtx = getContext("nuxt");
function useNuxt() {
  const instance = nuxtCtx.tryUse();
  if (!instance) {
    throw new Error("Nuxt instance is unavailable!");
  }
  return instance;
}
function tryUseNuxt() {
  return nuxtCtx.tryUse();
}
function normalizeSemanticVersion(version2) {
  return version2.replace(/-[0-9]+\.[0-9a-f]+/, "");
}
async function checkNuxtCompatibility(constraints, nuxt = useNuxt()) {
  const issues = [];
  if (constraints.nuxt) {
    const nuxtVersion = getNuxtVersion(nuxt);
    if (!(0, import_satisfies.default)(normalizeSemanticVersion(nuxtVersion), constraints.nuxt, { includePrerelease: true })) {
      issues.push({
        name: "nuxt",
        message: `Nuxt version \`${constraints.nuxt}\` is required but currently using \`${nuxtVersion}\``
      });
    }
  }
  if (isNuxt2(nuxt)) {
    const bridgeRequirement = constraints.bridge;
    const hasBridge = !!nuxt.options.bridge;
    if (bridgeRequirement === true && !hasBridge) {
      issues.push({
        name: "bridge",
        message: "Nuxt bridge is required"
      });
    } else if (bridgeRequirement === false && hasBridge) {
      issues.push({
        name: "bridge",
        message: "Nuxt bridge is not supported"
      });
    }
  }
  await nuxt.callHook("kit:compatibility", constraints, issues);
  issues.toString = () => issues.map((issue) => ` - [${issue.name}] ${issue.message}`).join("\n");
  return issues;
}
async function assertNuxtCompatibility(constraints, nuxt = useNuxt()) {
  const issues = await checkNuxtCompatibility(constraints, nuxt);
  if (issues.length) {
    throw new Error("Nuxt compatibility issues found:\n" + issues.toString());
  }
  return true;
}
function isNuxt2(nuxt = useNuxt()) {
  return getNuxtVersion(nuxt).startsWith("2.");
}
function getNuxtVersion(nuxt = useNuxt()) {
  var _a;
  const version2 = ((nuxt == null ? void 0 : nuxt._version) || (nuxt == null ? void 0 : nuxt.version) || ((_a = nuxt == null ? void 0 : nuxt.constructor) == null ? void 0 : _a.version) || "").replace(/^v/g, "");
  if (!version2) {
    throw new Error("Cannot determine nuxt version! Is current instance passed?");
  }
  return version2;
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol2 = root$1.Symbol;
var Symbol$1 = Symbol2;
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$9.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var symbolTag = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray2 = Array.isArray;
var isArray$1 = isArray2;
var INFINITY = 1 / 0;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray$1(value2)) {
    return arrayMap(value2, baseToString) + "";
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
function isObject3(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
function identity(value2) {
  return value2;
}
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject3(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$9 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject3(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue2(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value2 = getValue2(object, key);
  return baseIsNative(value2) ? value2 : void 0;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value2) {
  return function() {
    return value2;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length) {
  var type = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function baseAssignValue(object, key, value2) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function assignValue(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty$7.call(object, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue(object, key, value2);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction(value2);
}
function isIterateeCall(value2, index2, object) {
  if (!isObject3(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value2);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var objectProto$7 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$7;
  return value2 === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$1 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$1;
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike(value2) && hasOwnProperty$6.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer2 = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag$1 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule && freeModule.require && freeModule.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray$1(value2), isArg = !isArr && isArguments$1(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$5.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject3(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});
var extendWith = assignInWith;
function toString2(value2) {
  return value2 == null ? "" : baseToString(value2);
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject2(value2) {
  if (!isObjectLike(value2) || baseGetTag(value2) != objectTag) {
    return false;
  }
  var proto = getPrototype$1(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var domExcTag = "[object DOMException]";
var errorTag = "[object Error]";
function isError(value2) {
  if (!isObjectLike(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == errorTag || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject2(value2);
}
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, void 0, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});
var attempt$1 = attempt;
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf(htmlEscapes);
var escapeHtmlChar$1 = escapeHtmlChar;
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape2(string) {
  string = toString2(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar$1) : string;
}
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq(objValue, objectProto$1[key]) && !hasOwnProperty$1.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate$1 = reInterpolate;
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape$1 = reEscape;
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate$1 = reEvaluate;
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape$1,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate$1,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate$1,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape2 }
  }
};
var templateSettings$1 = templateSettings;
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto = Object.prototype;
var hasOwnProperty3 = objectProto.hasOwnProperty;
function template(string, options, guard) {
  var settings = templateSettings$1.imports._.templateSettings || templateSettings$1;
  if (guard && isIterateeCall(string, options, guard)) {
    options = void 0;
  }
  string = toString2(string);
  options = extendWith({}, options, settings, customDefaultsAssignIn);
  var imports = extendWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
  var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate$1 ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty3.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index2 = offset2 + match.length;
    return match;
  });
  source += "';\n";
  var variable = hasOwnProperty3.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result = attempt$1(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}
async function compileTemplate(template$1, ctx) {
  const data2 = { ...ctx, options: template$1.options };
  if (template$1.src) {
    try {
      const srcContents = await import_node_fs7.promises.readFile(template$1.src, "utf-8");
      return template(srcContents, {})(data2);
    } catch (err) {
      console.error("Error compiling template: ", template$1);
      throw err;
    }
  }
  if (template$1.getContents) {
    return template$1.getContents(data2);
  }
  throw new Error("Invalid template: " + JSON.stringify(template$1));
}
var serialize = (data2) => JSON.stringify(data2, null, 2).replace(/"{(.+)}"(?=,?$)/gm, (r2) => JSON.parse(r2).replace(/^{(.*)}$/, "$1"));
var importSources = (sources, { lazy = false } = {}) => {
  if (!Array.isArray(sources)) {
    sources = [sources];
  }
  return sources.map((src) => {
    if (lazy) {
      return `const ${genSafeVariableName(src)} = ${genDynamicImport(src, { comment: `webpackChunkName: ${JSON.stringify(src)}` })}`;
    }
    return genImport(src, genSafeVariableName(src));
  }).join("\n");
};
var importName = genSafeVariableName;
var templateUtils = { serialize, importName, importSources };
function defineNuxtModule(definition) {
  if (typeof definition === "function") {
    return defineNuxtModule({ setup: definition });
  }
  const module3 = defu(definition, { meta: {} });
  if (module3.meta.configKey === void 0) {
    module3.meta.configKey = module3.meta.name;
  }
  async function getOptions2(inlineOptions, nuxt = useNuxt()) {
    const configKey = module3.meta.configKey || module3.meta.name;
    const _defaults = module3.defaults instanceof Function ? module3.defaults(nuxt) : module3.defaults;
    let _options = defu(inlineOptions, nuxt.options[configKey], _defaults);
    if (module3.schema) {
      _options = await applyDefaults(module3.schema, _options);
    }
    return Promise.resolve(_options);
  }
  async function normalizedModule(inlineOptions, nuxt) {
    var _a;
    if (!nuxt) {
      nuxt = tryUseNuxt() || this.nuxt;
    }
    const uniqueKey = module3.meta.name || module3.meta.configKey;
    if (uniqueKey) {
      nuxt.options._requiredModules = nuxt.options._requiredModules || {};
      if (nuxt.options._requiredModules[uniqueKey]) {
        return false;
      }
      nuxt.options._requiredModules[uniqueKey] = true;
    }
    if (module3.meta.compatibility) {
      const issues = await checkNuxtCompatibility(module3.meta.compatibility, nuxt);
      if (issues.length) {
        logger.warn(`Module \`${module3.meta.name}\` is disabled due to incompatibility issues:
${issues.toString()}`);
        return;
      }
    }
    nuxt2Shims(nuxt);
    const _options = await getOptions2(inlineOptions, nuxt);
    if (module3.hooks) {
      nuxt.hooks.addHooks(module3.hooks);
    }
    const key = `nuxt:module:${uniqueKey || Math.round(Math.random() * 1e4)}`;
    const mark = import_node_perf_hooks.performance.mark(key);
    const res = await ((_a = module3.setup) == null ? void 0 : _a.call(null, _options, nuxt)) ?? {};
    const perf = import_node_perf_hooks.performance.measure(key, mark == null ? void 0 : mark.name);
    const setupTime = perf ? Math.round(perf.duration * 100) / 100 : 0;
    if (setupTime > 5e3 && uniqueKey !== "@nuxt/telemetry") {
      logger.warn(`Slow module \`${uniqueKey || "<no name>"}\` took \`${setupTime}ms\` to setup.`);
    } else if (nuxt.options.debug) {
      logger.info(`Module \`${uniqueKey || "<no name>"}\` took \`${setupTime}ms\` to setup.`);
    }
    if (res === false) {
      return false;
    }
    return defu(res, {
      timings: {
        setup: setupTime
      }
    });
  }
  normalizedModule.getMeta = () => Promise.resolve(module3.meta);
  normalizedModule.getOptions = getOptions2;
  return normalizedModule;
}
var NUXT2_SHIMS_KEY = "__nuxt2_shims_key__";
function nuxt2Shims(nuxt) {
  if (!isNuxt2(nuxt) || nuxt[NUXT2_SHIMS_KEY]) {
    return;
  }
  nuxt[NUXT2_SHIMS_KEY] = true;
  nuxt.hooks = nuxt;
  if (!nuxtCtx.tryUse()) {
    nuxtCtx.set(nuxt);
    nuxt.hook("close", () => nuxtCtx.unset());
  }
  let virtualTemplates;
  nuxt.hook("builder:prepared", (_builder, buildOptions) => {
    virtualTemplates = buildOptions.templates.filter((t) => t.getContents);
    for (const template2 of virtualTemplates) {
      buildOptions.templates.splice(buildOptions.templates.indexOf(template2), 1);
    }
  });
  nuxt.hook("build:templates", async (templates) => {
    const context = {
      nuxt,
      utils: templateUtils,
      app: {
        dir: nuxt.options.srcDir,
        extensions: nuxt.options.extensions,
        plugins: nuxt.options.plugins,
        templates: [
          ...templates.templatesFiles,
          ...virtualTemplates
        ],
        templateVars: templates.templateVars
      }
    };
    for await (const template2 of virtualTemplates) {
      const contents = await compileTemplate({ ...template2, src: "" }, context);
      await import_node_fs7.promises.mkdir(dirname(template2.dst), { recursive: true });
      await import_node_fs7.promises.writeFile(template2.dst, contents);
    }
  });
}
var _require = (0, import_jiti2.default)(process.cwd(), { interopDefault: true, esmResolve: true });
async function resolvePath2(path3, opts = {}) {
  const _path = path3;
  path3 = normalize(path3);
  if (isAbsolute(path3) && (0, import_node_fs7.existsSync)(path3) && !await isDirectory(path3)) {
    return path3;
  }
  const nuxt = tryUseNuxt();
  const cwd = opts.cwd || (nuxt ? nuxt.options.rootDir : process.cwd());
  const extensions = opts.extensions || (nuxt ? nuxt.options.extensions : [".ts", ".mjs", ".cjs", ".json"]);
  const modulesDir = nuxt ? nuxt.options.modulesDir : [];
  path3 = resolveAlias2(path3);
  if (!isAbsolute(path3)) {
    path3 = resolve(cwd, path3);
  }
  let _isDir = false;
  if ((0, import_node_fs7.existsSync)(path3)) {
    _isDir = await isDirectory(path3);
    if (!_isDir) {
      return path3;
    }
  }
  for (const ext of extensions) {
    const pathWithExt = path3 + ext;
    if ((0, import_node_fs7.existsSync)(pathWithExt)) {
      return pathWithExt;
    }
    const pathWithIndex = join(path3, "index" + ext);
    if (_isDir && (0, import_node_fs7.existsSync)(pathWithIndex)) {
      return pathWithIndex;
    }
  }
  const resolveModulePath = await resolvePath(_path, { url: [cwd, ...modulesDir] }).catch(() => null);
  if (resolveModulePath) {
    return resolveModulePath;
  }
  return path3;
}
function resolveAlias2(path3, alias) {
  var _a;
  if (!alias) {
    alias = ((_a = tryUseNuxt()) == null ? void 0 : _a.options.alias) || {};
  }
  return resolveAlias(path3, alias);
}
function createResolver2(base) {
  if (!base) {
    throw new Error("`base` argument is missing for createResolver(base)!");
  }
  base = base.toString();
  if (base.startsWith("file://")) {
    base = dirname((0, import_node_url3.fileURLToPath)(base));
  }
  return {
    resolve: (...path3) => resolve(base, ...path3),
    resolvePath: (path3, opts) => resolvePath2(path3, { cwd: base, ...opts })
  };
}
async function isDirectory(path3) {
  return (await import_node_fs7.promises.lstat(path3)).isDirectory();
}
function addImports(imports) {
  assertNuxtCompatibility({ bridge: true });
  useNuxt().hook("imports:extend", (_imports) => {
    _imports.push(...Array.isArray(imports) ? imports : [imports]);
  });
}
function addImportsDir(dirs, opts = {}) {
  assertNuxtCompatibility({ bridge: true });
  useNuxt().hook("imports:dirs", (_dirs) => {
    for (const dir of Array.isArray(dirs) ? dirs : [dirs]) {
      _dirs[opts.prepend ? "unshift" : "push"](dir);
    }
  });
}
async function addComponentsDir(dir) {
  const nuxt = useNuxt();
  await assertNuxtCompatibility({ nuxt: ">=2.13" }, nuxt);
  nuxt.options.components = nuxt.options.components || [];
  nuxt.hook("components:dirs", (dirs) => {
    dirs.push(dir);
  });
}
function normalizePlugin(plugin) {
  if (typeof plugin === "string") {
    plugin = { src: plugin };
  } else {
    plugin = { ...plugin };
  }
  if (!plugin.src) {
    throw new Error("Invalid plugin. src option is required: " + JSON.stringify(plugin));
  }
  const nonTopLevelPlugin = plugin.src.match(/\/plugins\/[^/]+\/index\.[^/]+$/i);
  if (nonTopLevelPlugin && nonTopLevelPlugin.length > 0 && !useNuxt().options.plugins.find((i) => (typeof i === "string" ? i : i.src).endsWith(nonTopLevelPlugin[0]))) {
    console.warn(`[warn] [nuxt] [deprecation] You are using a plugin that is within a subfolder of your plugins directory without adding it to your config explicitly. You can move it to the top-level plugins directory, or include the file '~${nonTopLevelPlugin[0]}' in your plugins config (https://nuxt.com/docs/api/configuration/nuxt-config#plugins-1) to remove this warning.`);
  }
  plugin.src = normalize(resolveAlias2(plugin.src));
  if (plugin.ssr) {
    plugin.mode = "server";
  }
  if (!plugin.mode) {
    const [, mode = "all"] = plugin.src.match(/\.(server|client)(\.\w+)*$/) || [];
    plugin.mode = mode;
  }
  return plugin;
}
function addPlugin(_plugin, opts = {}) {
  const nuxt = useNuxt();
  const plugin = normalizePlugin(_plugin);
  nuxt.options.plugins = nuxt.options.plugins.filter((p) => normalizePlugin(p).src !== plugin.src);
  nuxt.options.plugins[opts.append ? "push" : "unshift"](plugin);
  return plugin;
}

// node_modules/@storyblok/nuxt/dist/module.mjs
var module2 = defineNuxtModule({
  meta: {
    name: "@storyblok/nuxt",
    configKey: "storyblok"
  },
  defaults: {
    accessToken: "",
    enableSudoMode: false,
    usePlugin: true,
    // legacy opt. for enableSudoMode
    bridge: true,
    devtools: false,
    globalDir: "~/storyblok",
    apiOptions: {}
  },
  setup(options, nuxt) {
    const resolver = createResolver2(import.meta.url);
    if (nuxt.options.vite.optimizeDeps) {
      nuxt.options.vite.optimizeDeps.include = nuxt.options.vite.optimizeDeps.include || [];
      nuxt.options.vite.optimizeDeps.include.push("@storyblok/nuxt");
      nuxt.options.vite.optimizeDeps.include.push("@storyblok/vue");
      nuxt.options.vite.optimizeDeps.exclude = nuxt.options.vite.optimizeDeps.exclude || [];
      nuxt.options.vite.optimizeDeps.exclude.push("fsevents");
    }
    if (options.globalDir) {
      addComponentsDir({ path: options.globalDir, global: true, pathPrefix: false });
    }
    nuxt.options.build.transpile.push(resolver.resolve("./runtime"));
    nuxt.options.build.transpile.push("@storyblok/nuxt");
    nuxt.options.build.transpile.push("@storyblok/vue");
    nuxt.options.runtimeConfig.public.storyblok = options;
    const enablePluginCondition = options.usePlugin === true && options.enableSudoMode === false;
    if (enablePluginCondition) {
      addPlugin(resolver.resolve("./runtime/plugin"));
    }
    const names = [
      "useStoryblok",
      "useStoryblokApi",
      "useStoryblokBridge",
      "renderRichText",
      "RichTextSchema"
    ];
    for (const name of names) {
      addImports({ name, as: name, from: "@storyblok/vue" });
    }
    addImportsDir(resolver.resolve("./runtime/composables"));
    if (options.devtools) {
      nuxt.hook("devtools:customTabs", (iframeTabs) => {
        iframeTabs.push({
          name: "storyblok",
          title: "Storyblok",
          icon: "i-logos-storyblok-icon",
          view: {
            type: "iframe",
            src: "https://app.storyblok.com/#!/me/spaces/"
          }
        });
      });
    }
  }
});
export {
  module2 as default
};
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@storyblok_nuxt.js.map
