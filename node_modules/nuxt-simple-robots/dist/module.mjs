import fsp from 'node:fs/promises';
import { useNuxt, createResolver, addTemplate, defineNuxtModule, useLogger, addImports, addComponent, addServerHandler } from '@nuxt/kit';
import { defu } from 'defu';
import { installNuxtSiteConfig, updateSiteConfig, requireSiteConfig } from 'nuxt-site-config-kit';
import { relative } from 'pathe';

function asArray(v) {
  return typeof v === "undefined" ? [] : Array.isArray(v) ? v : [v];
}

function extendTypes(module, template) {
  const nuxt = useNuxt();
  const { resolve } = createResolver(import.meta.url);
  addTemplate({
    filename: `module/${module}.d.ts`,
    getContents: async () => {
      const typesPath = relative(resolve(nuxt.options.rootDir, nuxt.options.buildDir, "module"), resolve("runtime/types"));
      const s = await template({ typesPath });
      return `// Generated by ${module}
${s}
export {}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, `module/${module}.d.ts`) });
  });
}

function parseRobotsTxt(s) {
  const groups = [];
  const sitemaps = [];
  let createNewGroup = false;
  let currentGroup = {
    comment: [],
    // comments are too hard to parse in a logical order, we'll just omit them
    disallow: [],
    allow: [],
    userAgent: []
  };
  for (const line of s.split("\n")) {
    const sepIndex = line.indexOf(":");
    if (sepIndex === -1)
      continue;
    const rule = line.substring(0, sepIndex).trim();
    const val = line.substring(sepIndex + 1).trim();
    switch (rule) {
      case "User-agent":
        if (createNewGroup) {
          groups.push({
            ...currentGroup
          });
          currentGroup = {
            comment: [],
            disallow: [],
            allow: [],
            userAgent: []
          };
          createNewGroup = false;
        }
        currentGroup.userAgent.push(val);
        break;
      case "Allow":
        currentGroup.allow.push(val);
        createNewGroup = true;
        break;
      case "Disallow":
        currentGroup.disallow.push(val);
        createNewGroup = true;
        break;
      case "Sitemap":
        sitemaps.push(val);
        break;
    }
  }
  groups.push({
    ...currentGroup
  });
  return {
    groups,
    sitemaps
  };
}

const NonHelpfulBots = [
  "Nuclei",
  "WikiDo",
  "Riddler",
  "PetalBot",
  "Zoominfobot",
  "Go-http-client",
  "Node/simplecrawler",
  "CazoodleBot",
  "dotbot/1.0",
  "Gigabot",
  "Barkrowler",
  "BLEXBot",
  "magpie-crawler"
];

const module = defineNuxtModule({
  meta: {
    name: "nuxt-simple-robots",
    compatibility: {
      nuxt: "^3.6.1",
      bridge: false
    },
    configKey: "robots"
  },
  defaults: {
    enabled: true,
    credits: true,
    debug: false,
    allow: [],
    disallow: [],
    sitemap: [],
    groups: [],
    blockNonSeoBots: false,
    mergeWithRobotsTxtPath: true,
    robotsEnabledValue: "index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1",
    robotsDisabledValue: "noindex, nofollow",
    disallowNonIndexableRoutes: true
  },
  async setup(config, nuxt) {
    const logger = useLogger("nuxt-simple-robots");
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    if (config.enabled === false) {
      logger.debug("The module is disabled, skipping setup.");
      return;
    }
    if (config.blockNonSeoBots) {
      config.groups.push({
        userAgent: NonHelpfulBots,
        comment: ["Block bots that don't benefit us."],
        disallow: ["/"]
      });
    }
    const { resolve } = createResolver(import.meta.url);
    await installNuxtSiteConfig();
    if (config.siteUrl || config.host) {
      await updateSiteConfig({
        _context: "nuxt-simple-robots:config",
        url: config.siteUrl,
        indexable: config.indexable
      });
    }
    if (config.mergeWithRobotsTxtPath !== false) {
      let usingRobotsTxtPath = "";
      let robotsTxt = false;
      const publicRobotsTxtPath = resolve(nuxt.options.rootDir, nuxt.options.dir.public, "robots.txt");
      const validPaths = [
        // public/robots.txt - This is the default, we need to move this to avoid issues
        publicRobotsTxtPath,
        // assets/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.assets, "robots.txt"),
        // public/_robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.public, "_robots.txt"),
        // public/_dir/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.public, "_dir", "robots.txt"),
        // pages/_dir/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.pages, "_dir", "robots.txt"),
        // pages/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.pages, "robots.txt"),
        // robots.txt
        resolve(nuxt.options.rootDir, "robots.txt")
      ];
      if (config.mergeWithRobotsTxtPath === true) {
        for (const path of validPaths) {
          robotsTxt = await fsp.readFile(path, { encoding: "utf-8" }).catch(() => false);
          if (robotsTxt) {
            usingRobotsTxtPath = path;
            break;
          }
        }
      } else {
        const customPath = resolve(nuxt.options.rootDir, config.mergeWithRobotsTxtPath);
        if (!await fsp.statfs(customPath).catch(() => false)) {
          logger.error(`You provided an invalid \`mergeWithRobotsTxtPath\`, the file does not exist: ${customPath}.`);
        } else {
          usingRobotsTxtPath = customPath;
          robotsTxt = await fsp.readFile(customPath, { encoding: "utf-8" });
        }
      }
      if (typeof robotsTxt === "string") {
        logger.debug(`A robots.txt file was found at \`./${relative(nuxt.options.rootDir, usingRobotsTxtPath)}\`, merging config.`);
        const { groups, sitemaps } = parseRobotsTxt(robotsTxt);
        config.groups.push(...groups);
        config.sitemap = [.../* @__PURE__ */ new Set([...asArray(config.sitemap), ...sitemaps])];
        if (usingRobotsTxtPath === publicRobotsTxtPath) {
          await fsp.rename(usingRobotsTxtPath, resolve(nuxt.options.rootDir, nuxt.options.dir.public, "_robots.txt"));
          logger.warn("Your robots.txt file was moved to `./public/_robots.txt` to avoid conflicts.");
          const extraPaths = [];
          for (const path of validPaths) {
            if (path !== usingRobotsTxtPath)
              extraPaths.push(` - ./${relative(nuxt.options.rootDir, path)}`);
          }
          logger.info(`The following paths are also valid for your robots.txt:
${extraPaths.join("\n")}
`);
        }
      }
    }
    nuxt.hook("modules:done", async () => {
      config.sitemap = asArray(config.sitemap);
      config.disallow = asArray(config.disallow);
      config.allow = asArray(config.allow);
      await nuxt.hooks.callHook("robots:config", config);
      nuxt.options.routeRules = nuxt.options.routeRules || {};
      Object.entries(nuxt.options.routeRules).forEach(([route, rules]) => {
        if (rules.index === false || rules.robots) {
          nuxt.options.routeRules[route] = defu({
            headers: {
              "X-Robots-Tag": rules.index === false ? config.robotsDisabledValue : rules.robots
            }
          }, nuxt.options.routeRules?.[route]);
        }
      });
      const disallow = config.disallow;
      if (config.disallowNonIndexableRoutes) {
        Object.entries(nuxt.options.routeRules || {}).forEach(([route, rules]) => {
          if (rules.index === false || rules.robots?.includes("noindex")) {
            disallow.push(route.replaceAll("**", "*"));
          }
        });
      }
      config.disallow = [...new Set(disallow)];
      config.groups = config.groups.map((group) => {
        group.userAgent = group.userAgent ? asArray(group.userAgent) : ["*"];
        group.disallow = asArray(group.disallow);
        group.allow = asArray(group.allow);
        return group;
      });
      const existingGroup = config.groups.find((stack) => stack.userAgent.length === 1 && stack.userAgent[0] === "*");
      if (existingGroup) {
        existingGroup.disallow = [.../* @__PURE__ */ new Set([...existingGroup.disallow || [], ...config.disallow])];
        if (existingGroup.disallow.length > 1) {
          existingGroup.disallow = existingGroup.disallow.filter((disallow2) => disallow2 !== "");
        }
        existingGroup.allow = [.../* @__PURE__ */ new Set([...existingGroup.allow || [], ...config.allow])];
      } else {
        config.groups.unshift({
          userAgent: ["*"],
          disallow: config.disallow.length > 0 ? config.disallow : [""],
          allow: config.allow
        });
      }
      const hasRelativeSitemaps = config.sitemap.some((sitemap) => !sitemap.startsWith("http"));
      if (hasRelativeSitemaps) {
        requireSiteConfig("nuxt-simple-robots", {
          url: "Required to render relative Sitemap paths as absolute URLs."
        }, { prerender: true });
      }
      nuxt.options.runtimeConfig["nuxt-simple-robots"] = {
        credits: config.credits,
        groups: config.groups,
        sitemap: config.sitemap,
        robotsEnabledValue: config.robotsEnabledValue,
        robotsDisabledValue: config.robotsDisabledValue
      };
    });
    extendTypes("nuxt-simple-robots", () => {
      return `
interface NuxtSimpleRobotsNitroRules {
  index?: boolean
  robots?: string
}
declare module 'nitropack' {
  interface NitroRouteRules extends NuxtSimpleRobotsNitroRules {}
  interface NitroRouteConfig extends NuxtSimpleRobotsNitroRules {}
}`;
    });
    nuxt.hooks.hook("nitro:init", async (nitro) => {
      if (nuxt.options._generate) {
        nitro.options.prerender.routes = nitro.options.prerender.routes || [];
        nitro.options.prerender.routes.push("/robots.txt");
      }
    });
    nuxt.options.optimization.treeShake.composables.client["nuxt-simple-robots"] = ["defineRobotMeta"];
    addImports({
      name: "defineRobotMeta",
      from: resolve("./runtime/composables/defineRobotMeta")
    });
    addComponent({
      name: "RobotMeta",
      filePath: resolve("./runtime/components/RobotMeta")
    });
    addServerHandler({
      route: "/robots.txt",
      handler: resolve("./runtime/server/robots-txt")
    });
    addServerHandler({
      handler: resolve("./runtime/server/middleware/xRobotsTagHeader")
    });
  }
});

export { module as default };
